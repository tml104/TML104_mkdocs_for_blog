{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home \u00b6 Hi, I am TML104. mkdocs gh-deploy","title":"Home"},{"location":"#home","text":"Hi, I am TML104. mkdocs gh-deploy","title":"Home"},{"location":"old/Git/","text":"Git\u5e38\u89c1\u64cd\u4f5c \u00b6 \u65b0\u5efa \u00b6 \u5728\u5f53\u524d\u76ee\u5f55\u65b0\u5efagit\u5e93 1 git init Add\u3001RM & Commit & \u72b6\u6001\u68c0\u67e5\u3001\u6bd4\u5bf9 \u00b6 \u5de5\u4f5c\u533a\u63a8\u9001\u5230\u6682\u5b58\u533a 1 git add a.txt b.txt ... \u5de5\u4f5c\u533a\u63a8\u9001\u5230\u6682\u5b58\u533a\uff08\u5220\u9664\u6587\u4ef6\uff09 *\u4e5f\u53ef\u4f7f\u7528 git add 1 git rm <file> \u6682\u5b58\u533a\u63a8\u9001\u5230\u4ed3\u5e93 1 git commit -m \"(description)\" \u68c0\u67e5\u72b6\u6001 1 git status \u6bd4\u5bf9\u4e0d\u540c 1 git diff a.txt Commit\u8bb0\u5f55 1 git log [--pretty=oneline] [--gtaph] [--abbrev-commit] Commit\u64cd\u4f5c\u65e5\u5fd7\uff08\u7528\u4e8e\u5bfb\u627eCommit ID\uff09 1 git reflog \u7248\u672c\u56de\u9000\u3001\u590d\u539f \u00b6 \u56de\u9000\u81f3\u4e4b\u524d\u7684Commit 1 git reset --hard <HEAD^|HEAD~1> \u4ee5Commit ID\u56de\u9000 1 git reset --hard <1094a...> \u5728\u6267\u884c git add \u4e4b\u524d\uff0c\u5de5\u4f5c\u533a!=\u6682\u5b58\u533a\uff08index\uff09==\u4ed3\u5e93 \u6267\u884c git add \u540e\uff0c\u5de5\u4f5c\u533a==\u6682\u5b58\u533a!=\u4ed3\u5e93 \u4ece\u4ed3\u5e93\u4e2d\u590d\u539f\u81f3\u6682\u5b58\u533a\uff08\u64a4\u9500\u6682\u5b58\u533a\u7684\u4fee\u6539\uff09 1 git reset HEAD <file> \u4ece\u6682\u5b58\u533a\u590d\u539f\u81f3\u5de5\u4f5c\u533a\uff08\u4e22\u5f03\u5de5\u4f5c\u533a\u4fee\u6539\uff09 1 git checkout -- <file> \u5206\u652f \u00b6 \u65b0\u5efa\u5206\u652f\u5e76\u5207\u6362\u81f3 1 2 3 4 5 6 git checkout -b <new branch name> (or) git branch <new branch name> git checkout <new branch name> (or) git switch -c <new branch name> \u67e5\u770b\u6240\u6709\u5206\u652f 1 git branch \u5207\u6362\u5206\u652f 1 2 3 git checkout <branch name> (or) git switch <branch name> \u5c06\u5176\u4ed6\u5206\u652f\u7684\u5185\u5bb9\uff08\u6700\u65b0\u7684Commit\uff09\u4e0e\u5f53\u524d\u5206\u652f\u7684\u5185\u5bb9\uff08\u6700\u65b0\u7684Commit\uff09\u5408\u5e76 1 2 \uff08\u5728\u5f53\u524d\u5206\u652f\u4e0b\u6267\u884c\uff09 git merge <other branch name> \u5220\u9664\u67d0\u5206\u652f 1 git branch -d <other branch name> \u5f3a\u5236\u5220\u9664\uff08\u5982\u679c\u6b64\u5206\u652f\u6ca1\u6709\u88ab\u5408\u5e76\u8fc7\uff09 1 git branch -D <other branch name> \u5408\u5e76\u65f6\u53ef\u80fd\u4f1a\u9047\u5230\u51b2\u7a81\u3002\u82e5\u9047\u5230\u51b2\u7a81\uff0c\u76f4\u63a5\u6253\u5f00\u6587\u4ef6\u4fee\u6539\u6700\u7ec8\u5408\u5e76\u540e\u7684\u6587\u4ef6\u7248\u672c\u3002\u4e4b\u540e\u518d\u63d0\u4ea4 1 2 3 4 5 git merge <branch name> git status ...(\u9047\u5230\u51b2\u7a81\u540e\u4fee\u6539\u6587\u4ef6) git add <file> git commit -m <description> \u7981\u7528 fast forward \u6a21\u5f0f\u5408\u5e76\u3002\u6b64\u65f6 merge \u4f1a\u751f\u6210\u65b0 Commit \uff08\u91c7\u53d6\u9ed8\u8ba4\u65b9\u5f0f\u7684 merge \u53ea\u4f1a\u5c06 HEAD \u6307\u9488\u79fb\u52a8\u5230\u65b0\u5206\u652f\u7684\u6700\u65b0 Commit \u4e0a\uff09 1 git merge --no-ff -m \"merge with no-fast-forward\" <other branch name> Stash \u4e34\u65f6\u4fdd\u85cf \u00b6 \u5728\u5207\u6362\u81f3\u5176\u4ed6\u5206\u652f\u524d\uff0c\u5982\u679c\u5de5\u4f5c\u533a\u6709\u672a Commit \u7684\u4fee\u6539\uff0c\u53ef\u4ee5\u5148\u4fdd\u5b58 1 git stash \u6062\u590d\uff08pop\u4f1a\u4ecestash\u5217\u8868\u4e2d\u53d6\u51fa\u6700\u540e\u4e00\u4e2a\u590d\u539f\uff0c\u7136\u540e\u5220\u9664\u4e4b\uff09 1 2 3 4 git stash apply git stash drop (or) git stash pop Cherry-pick \u590d\u7528 Commit \u00b6 \u590d\u7528\u67d0\u6b21\u7684 Commit \u4e8e\u5f53\u524d Commit\uff0c\u8fd9\u4e2a\u65f6\u5019\u4f1a\u65b0\u5efa\u4e00\u4e2a\u65b0\u7684 Commit 1 git cherry-pick <commit id> \u8fdc\u7a0b\u63a8\u9001\u3001\u6293\u53d6 \u00b6 \u67e5\u770b\u8fdc\u7a0b\u4ed3\u5e93\uff08\u82e5\u6ca1\u6709\u5219\u8fd4\u56de\u7a7a\uff09 1 git remote \u6dfb\u52a0\u8fdc\u7a0b\u4ed3\u5e93 1 git remote add origin git@github.com:tml104/<repository name> \u63a8\u9001\u672c\u5730 master \u5206\u652f\u81f3\u8fdc\u7a0b\u5e93 \u4f7f\u7528 -u \u53c2\u6570\u6765\u5c06\u672c\u5730\u5206\u652f\u4e0e\u8fdc\u7a0b\u5206\u652f\u5173\u8054 \uff08\u5206\u652f\u4e0d\u5b58\u5728\u65f6\u4f1a\u81ea\u52a8\u65b0\u5efa\uff09 1 2 3 4 git push [-u|--set-upstream] origin master git push origin dev git push \uff08\u81ea\u52a8\u5c06\u5f53\u524d\u6240\u5728\u672c\u5730\u5206\u652f\u63a8\u9001\u81f3\u5bf9\u5e94\u8fdc\u7a0b\u5206\u652f\uff0c\u5f53\u4e14\u4ec5\u5f53\u5f53\u524d\u6240\u5728\u672c\u5730\u5206\u652f\u5df2\u7ecf\u548c\u8fdc\u7a0b\u5206\u652f\u5173\u8054\u65f6\u53ef\u7528\uff09 git push origin <local branch name>:<remote branch name> Clone \u8fdc\u7a0b\u4ed3\u5e93 1 2 git clone git@github.com:<user name>/<repository name> cd <repository name> \u4f7f\u5f97\u672c\u5730\u5206\u652f\u4e0e\u8fdc\u7a0b\u5206\u652f\u5173\u8054 1 git branch --set-upstream-to=origin/<branch name> <local branch name> \u62c9\u53d6\u8fdc\u7a0b\u5206\u652f\u5e76\u4e0e\u672c\u5730\u5206\u652f\u5408\u5e76\uff08\u53ef\u80fd\u4f1a\u51b2\u7a81\uff0c\u4e5f\u53ef\u80fd\u5408\u5e76\u4e4b\u540e\u6ca1\u6709\u53d8\u5316\uff09 1 git pull [origin] [<local branch name>:<remote branch name>] \u8bbe\u7f6essh key \u00b6 https://www.liaoxuefeng.com/wiki/896043488029600/896954117292416 https://blog.csdn.net/lqlqlq007/article/details/78983879 \u5728\u8bbe\u7f6e\u524d\u8bbe\u7f6e\u90ae\u7bb1\u548c\u7528\u6237\u540d \u00b6 1 2 git config --global user.name \"\u8fd9\u91cc\u6362\u4e0a\u4f60\u7684\u7528\u6237\u540d\" git config --global user.email \"\u8fd9\u91cc\u6362\u4e0a\u4f60\u7684\u90ae\u7bb1\" \u672c\u5730\u4ea7\u751fssh\u5bc6\u94a5\uff0c\u5e76\u5c06\u516c\u94a5\u653e\u5230\u670d\u52a1\u5668\u4e0a \u00b6 1 2 ssh-keygen -t rsa -C \"1041159637@qq.com\" \u63a5\u7740\u5c06\"C:\\Users\\10411\\.ssh\\id_rsa.pub\"\u4e2d\u7684\u5185\u5bb9\u590d\u5236\u5230github\u4e2dnew sshkey\u4e2d","title":"Git\u5e38\u89c1\u64cd\u4f5c"},{"location":"old/Git/#git","text":"","title":"Git\u5e38\u89c1\u64cd\u4f5c"},{"location":"old/Git/#_1","text":"\u5728\u5f53\u524d\u76ee\u5f55\u65b0\u5efagit\u5e93 1 git init","title":"\u65b0\u5efa"},{"location":"old/Git/#addrm-commit","text":"\u5de5\u4f5c\u533a\u63a8\u9001\u5230\u6682\u5b58\u533a 1 git add a.txt b.txt ... \u5de5\u4f5c\u533a\u63a8\u9001\u5230\u6682\u5b58\u533a\uff08\u5220\u9664\u6587\u4ef6\uff09 *\u4e5f\u53ef\u4f7f\u7528 git add 1 git rm <file> \u6682\u5b58\u533a\u63a8\u9001\u5230\u4ed3\u5e93 1 git commit -m \"(description)\" \u68c0\u67e5\u72b6\u6001 1 git status \u6bd4\u5bf9\u4e0d\u540c 1 git diff a.txt Commit\u8bb0\u5f55 1 git log [--pretty=oneline] [--gtaph] [--abbrev-commit] Commit\u64cd\u4f5c\u65e5\u5fd7\uff08\u7528\u4e8e\u5bfb\u627eCommit ID\uff09 1 git reflog","title":"Add\u3001RM &amp; Commit &amp; \u72b6\u6001\u68c0\u67e5\u3001\u6bd4\u5bf9"},{"location":"old/Git/#_2","text":"\u56de\u9000\u81f3\u4e4b\u524d\u7684Commit 1 git reset --hard <HEAD^|HEAD~1> \u4ee5Commit ID\u56de\u9000 1 git reset --hard <1094a...> \u5728\u6267\u884c git add \u4e4b\u524d\uff0c\u5de5\u4f5c\u533a!=\u6682\u5b58\u533a\uff08index\uff09==\u4ed3\u5e93 \u6267\u884c git add \u540e\uff0c\u5de5\u4f5c\u533a==\u6682\u5b58\u533a!=\u4ed3\u5e93 \u4ece\u4ed3\u5e93\u4e2d\u590d\u539f\u81f3\u6682\u5b58\u533a\uff08\u64a4\u9500\u6682\u5b58\u533a\u7684\u4fee\u6539\uff09 1 git reset HEAD <file> \u4ece\u6682\u5b58\u533a\u590d\u539f\u81f3\u5de5\u4f5c\u533a\uff08\u4e22\u5f03\u5de5\u4f5c\u533a\u4fee\u6539\uff09 1 git checkout -- <file>","title":"\u7248\u672c\u56de\u9000\u3001\u590d\u539f"},{"location":"old/Git/#_3","text":"\u65b0\u5efa\u5206\u652f\u5e76\u5207\u6362\u81f3 1 2 3 4 5 6 git checkout -b <new branch name> (or) git branch <new branch name> git checkout <new branch name> (or) git switch -c <new branch name> \u67e5\u770b\u6240\u6709\u5206\u652f 1 git branch \u5207\u6362\u5206\u652f 1 2 3 git checkout <branch name> (or) git switch <branch name> \u5c06\u5176\u4ed6\u5206\u652f\u7684\u5185\u5bb9\uff08\u6700\u65b0\u7684Commit\uff09\u4e0e\u5f53\u524d\u5206\u652f\u7684\u5185\u5bb9\uff08\u6700\u65b0\u7684Commit\uff09\u5408\u5e76 1 2 \uff08\u5728\u5f53\u524d\u5206\u652f\u4e0b\u6267\u884c\uff09 git merge <other branch name> \u5220\u9664\u67d0\u5206\u652f 1 git branch -d <other branch name> \u5f3a\u5236\u5220\u9664\uff08\u5982\u679c\u6b64\u5206\u652f\u6ca1\u6709\u88ab\u5408\u5e76\u8fc7\uff09 1 git branch -D <other branch name> \u5408\u5e76\u65f6\u53ef\u80fd\u4f1a\u9047\u5230\u51b2\u7a81\u3002\u82e5\u9047\u5230\u51b2\u7a81\uff0c\u76f4\u63a5\u6253\u5f00\u6587\u4ef6\u4fee\u6539\u6700\u7ec8\u5408\u5e76\u540e\u7684\u6587\u4ef6\u7248\u672c\u3002\u4e4b\u540e\u518d\u63d0\u4ea4 1 2 3 4 5 git merge <branch name> git status ...(\u9047\u5230\u51b2\u7a81\u540e\u4fee\u6539\u6587\u4ef6) git add <file> git commit -m <description> \u7981\u7528 fast forward \u6a21\u5f0f\u5408\u5e76\u3002\u6b64\u65f6 merge \u4f1a\u751f\u6210\u65b0 Commit \uff08\u91c7\u53d6\u9ed8\u8ba4\u65b9\u5f0f\u7684 merge \u53ea\u4f1a\u5c06 HEAD \u6307\u9488\u79fb\u52a8\u5230\u65b0\u5206\u652f\u7684\u6700\u65b0 Commit \u4e0a\uff09 1 git merge --no-ff -m \"merge with no-fast-forward\" <other branch name>","title":"\u5206\u652f"},{"location":"old/Git/#stash","text":"\u5728\u5207\u6362\u81f3\u5176\u4ed6\u5206\u652f\u524d\uff0c\u5982\u679c\u5de5\u4f5c\u533a\u6709\u672a Commit \u7684\u4fee\u6539\uff0c\u53ef\u4ee5\u5148\u4fdd\u5b58 1 git stash \u6062\u590d\uff08pop\u4f1a\u4ecestash\u5217\u8868\u4e2d\u53d6\u51fa\u6700\u540e\u4e00\u4e2a\u590d\u539f\uff0c\u7136\u540e\u5220\u9664\u4e4b\uff09 1 2 3 4 git stash apply git stash drop (or) git stash pop","title":"Stash \u4e34\u65f6\u4fdd\u85cf"},{"location":"old/Git/#cherry-pick-commit","text":"\u590d\u7528\u67d0\u6b21\u7684 Commit \u4e8e\u5f53\u524d Commit\uff0c\u8fd9\u4e2a\u65f6\u5019\u4f1a\u65b0\u5efa\u4e00\u4e2a\u65b0\u7684 Commit 1 git cherry-pick <commit id>","title":"Cherry-pick \u590d\u7528 Commit"},{"location":"old/Git/#_4","text":"\u67e5\u770b\u8fdc\u7a0b\u4ed3\u5e93\uff08\u82e5\u6ca1\u6709\u5219\u8fd4\u56de\u7a7a\uff09 1 git remote \u6dfb\u52a0\u8fdc\u7a0b\u4ed3\u5e93 1 git remote add origin git@github.com:tml104/<repository name> \u63a8\u9001\u672c\u5730 master \u5206\u652f\u81f3\u8fdc\u7a0b\u5e93 \u4f7f\u7528 -u \u53c2\u6570\u6765\u5c06\u672c\u5730\u5206\u652f\u4e0e\u8fdc\u7a0b\u5206\u652f\u5173\u8054 \uff08\u5206\u652f\u4e0d\u5b58\u5728\u65f6\u4f1a\u81ea\u52a8\u65b0\u5efa\uff09 1 2 3 4 git push [-u|--set-upstream] origin master git push origin dev git push \uff08\u81ea\u52a8\u5c06\u5f53\u524d\u6240\u5728\u672c\u5730\u5206\u652f\u63a8\u9001\u81f3\u5bf9\u5e94\u8fdc\u7a0b\u5206\u652f\uff0c\u5f53\u4e14\u4ec5\u5f53\u5f53\u524d\u6240\u5728\u672c\u5730\u5206\u652f\u5df2\u7ecf\u548c\u8fdc\u7a0b\u5206\u652f\u5173\u8054\u65f6\u53ef\u7528\uff09 git push origin <local branch name>:<remote branch name> Clone \u8fdc\u7a0b\u4ed3\u5e93 1 2 git clone git@github.com:<user name>/<repository name> cd <repository name> \u4f7f\u5f97\u672c\u5730\u5206\u652f\u4e0e\u8fdc\u7a0b\u5206\u652f\u5173\u8054 1 git branch --set-upstream-to=origin/<branch name> <local branch name> \u62c9\u53d6\u8fdc\u7a0b\u5206\u652f\u5e76\u4e0e\u672c\u5730\u5206\u652f\u5408\u5e76\uff08\u53ef\u80fd\u4f1a\u51b2\u7a81\uff0c\u4e5f\u53ef\u80fd\u5408\u5e76\u4e4b\u540e\u6ca1\u6709\u53d8\u5316\uff09 1 git pull [origin] [<local branch name>:<remote branch name>]","title":"\u8fdc\u7a0b\u63a8\u9001\u3001\u6293\u53d6"},{"location":"old/Git/#ssh-key","text":"https://www.liaoxuefeng.com/wiki/896043488029600/896954117292416 https://blog.csdn.net/lqlqlq007/article/details/78983879","title":"\u8bbe\u7f6essh key"},{"location":"old/Git/#_5","text":"1 2 git config --global user.name \"\u8fd9\u91cc\u6362\u4e0a\u4f60\u7684\u7528\u6237\u540d\" git config --global user.email \"\u8fd9\u91cc\u6362\u4e0a\u4f60\u7684\u90ae\u7bb1\"","title":"\u5728\u8bbe\u7f6e\u524d\u8bbe\u7f6e\u90ae\u7bb1\u548c\u7528\u6237\u540d"},{"location":"old/Git/#ssh","text":"1 2 ssh-keygen -t rsa -C \"1041159637@qq.com\" \u63a5\u7740\u5c06\"C:\\Users\\10411\\.ssh\\id_rsa.pub\"\u4e2d\u7684\u5185\u5bb9\u590d\u5236\u5230github\u4e2dnew sshkey\u4e2d","title":"\u672c\u5730\u4ea7\u751fssh\u5bc6\u94a5\uff0c\u5e76\u5c06\u516c\u94a5\u653e\u5230\u670d\u52a1\u5668\u4e0a"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/","text":"\u5f85\u5b66\u4e60\u7b97\u6cd5\uff1a \u6811\u94fe\u5256\u5206 \u76f8\u5173 \u6811\u94fe\u5256\u5206 LCT \u5b57\u7b26\u4e32 \u76f8\u5173 \u6269\u5c55kmp \u540e\u7f00\u6570\u7ec4 ac\u81ea\u52a8\u673a \u540e\u7f00\u81ea\u52a8\u673a \u56fe\u8bba \u76f8\u5173\uff1a Tarjan 2-sat \u6570\u636e\u7ed3\u6784\u76f8\u5173 KDT\uff08\uff1f\uff09 \u4e3b\u5e2d\u6811 \u70b9\u5206\u6cbb \u7b1b\u5361\u5c14\u6811 \u6574\u4f53\u4e8c\u5206 \u6570\u5b66\uff1a Polya FFT (?) NTT FWT \u7ebf\u6027\u57fa \u72c4\u91cc\u514b\u96f7\u5377\u79ef \u535a\u5f08\u8bba\u76f8\u5173 \u6b63\u96be\u5219\u53cd \u6b63\u96be\u5219\u53cd \u6b63\u96be\u5219\u53cd \u8e29\u5751 \u00b6 \u4f7f\u7528FWT\u65f6\u4e0d\u628a\u6570\u7ec4\u957f\u5ea6\u5f00\u591f\u5bfc\u81f4wa\u534a\u5929\uff08HDU 6057 Kanade\u2019s convolution\uff09 \u6570\u636e\u91cf\u8fc7\u5927\u65f6\u5207\u8bb0\u4f7f\u7528printf\u548cscanf \u7528\u6d6e\u9ede\u6578\u8dd1\u6700\u77ed\u8def\u6216\u8005\u6700\u5927\u6d41\u7684\u6642\u5019\u8981\u6ce8\u610f\u9b06\u5f1b\u689d\u4ef6\u8981\u653e\u9b06\u4e00\u5b9a\u7cbe\u5ea6(\u4f8b\u5982dy>dx+edge+eps) \u52a8\u6001\u89c4\u5212 \u00b6 \u5355\u8c03\u961f\u5217\u4f18\u5316 \u00b6 P6563 \u4e00\u76f4\u5728\u4f60\u8eab\u8fb9 \u7535\u7ebf\u957f\u5ea6\u4e3a1\uff0c2\uff0c...\uff0cn\u4e2d\u67d0\u4e2a\u6570\uff0c\u82b1ai\u5143\u53ef\u4ee5\u5f97\u77e5\u957f\u5ea6\u662f\u5426\u5927\u4e8e\uff08\u6216\u5c0f\u4e8e\u7b49\u4e8e\uff09i\uff0c\u95ee\u5979\u81f3\u5c11\u8981\u82b1\u591a\u5c11\u94b1\u624d\u80fd\u4fdd\u8bc1\u77e5\u9053\u9700\u8981\u7535\u7ebf\u7684\u957f\u5ea6 \u5206\u6790\uff1a $$ f(L,R)=\\min_{1\\le k\\lt r}(\\max(f(L,k),f(k+1,R))+a_k) $$ R\u6269\u5c55\u65f6\uff0c\u6700\u4f18\u51b3\u7b56\u70b9p=k\u4e0d\u4e0b\u964d\uff08\u4e0a\u5347\u6216\u4e0d\u53d8\uff09\u3002 \u56e0\u6b64\u5206\u7c7b\u8ba8\u8bbaf(L,k)\u4e0ef(k+1,R)\u7684\u5927\u5c0f\uff0c\u5206\u522b\u7ef4\u62a4\u66f4\u65b0\u4e24\u79cd\u60c5\u51b5\u5373\u53ef\u3002 \u5177\u4f53\u5730\uff1a\u6b63\u5e8f\u5faa\u73afR:[1,N]\uff0c\u5012\u5e8f\u5faa\u73afL:[R,1]\uff0c\u5bf9\u4e8e\u6bcf\u4e2aL\u90fd\u540e\u9000\u66f4\u65b0\u6700\u4f18\u51b3\u7b56\u70b9k\uff0c\u7136\u540e\u66f4\u65b0f(L,k)>f(k+1,R)\u7684\u60c5\u51b5\u3002f(L,k)<=f(k+1,R)\u7684\u60c5\u51b5\uff0cf(L,R)=min f(k+1,R)+ak\uff0c\u4f7f\u7528\u5355\u8c03\u961f\u5217\u7ef4\u62a4\u3002 P2120 \u4ed3\u5e93\u5efa\u8bbe \u5206\u6790\uff1a $$ dp[i]=\\min_{0\\le j\\lt i}(dp_j+x_i(sump_i-sump_j)-\\(sumxp_i-sumxp_j))+c_i $$ \u76f4\u63a5\u5957\u7528\u659c\u7387\u4f18\u5316\u5373\u53ef SOSdp \u00b6 \u53ef\u4ee5\u5728O(m*2^m)\u7684\u65f6\u95f4\u91cc\u6c42\u89e3\u4e0b\u5217\u5f0f\u5b50\uff1a $$ f_{st}=\\sum_{i\\subset st} w_i $$ \u8bbe \\(dp(st,i)\\) \u8868\u793a\u4e8c\u8fdb\u5236\u8868\u793a\u96c6\u5408st\u7684\u6700\u540ei\u4f4d\uff08\u4ece0\u8ba1\u6570\uff09\u53d8\u5316\u7684\u6240\u6709\u5b50\u96c6\u8d21\u732e\u7684\u548c\u3002 \u5219\u6709\u8f6c\u79fb\uff1a $$ dp(st,i) = \\begin{cases} dp(st,i-1), & \\text{\u7b2ci\u4f4d\u4e3a0} \\ dp(st,i-1) + dp(st\\oplus(2^i),i-1), & \\text{\u7b2ci\u4f4d\u4e3a1} \\ \\end{cases} $$ 1 2 3 4 5 6 7 void sos (){ for ( int i = 0 ; i < ( 1 << N ); i ++ ) f [ i ] = w [ i ]; for ( int i = 0 ; i < N ; i ++ ) for ( int st = 0 ; st < ( 1 << N ); st ++ ) if ( st & ( 1 << i )) f [ st ] += f [ st ^ ( 1 << i )]; } \u6811\u4e0a\u80cc\u5305 \u00b6 P1064 [NOIP2006 \u63d0\u9ad8\u7ec4] \u91d1\u660e\u7684\u9884\u7b97\u65b9\u6848 \u9898\u610f\uff1a\u7ed9\u5b9a\u4e00\u7cfb\u5217\u7269\u54c1,\u6bcf\u4e2a\u7269\u54c1\u6709\u4e00\u4e2a\u4ef7\u683cv\u548c\u6743\u503cw,\u5e76\u4e14\u7269\u54c1\u95f4\u5b58\u5728\u4f9d\u8d56\u5173\u7cfb.\u6c42\u4e00\u79cd\u53ef\u884c\u65b9\u6848,\u4f7f\u5f97\u6ee1\u8db3\u4f9d\u8d56\u5173\u7cfb\u5e76\u4e14\\sum v \\leq m\u2211 v \u2264 m \u7684\u60c5\u51b5\u4e0b\\sum w\u2211 w \u5c3d\u91cf\u5927 \u89e3\u6cd5\uff1a \u6211\u4eec \u5bf9\u8fd9\u9897\u6811\u6c42\u4e00\u4e2a\u540e\u5e8f\u904d\u5386 ,\u8fd9\u6837\u4e00\u4e2a\u8282\u70b9\u7684\u513f\u5b50\u4ee5\u53ca\u5de6\u8fb9\u5144\u5f1f\u5728\u5e8f\u5217\u4e2d\u90fd\u5728\u5b83\u7684\u524d\u90e8.\u7136\u540e\u5462?\u6bcf\u4e00\u6b65\u6211\u4eec\u90fd\u6709\u4e24\u79cd\u51b3\u7b56. \u9009\u8fd9\u4e2a\u7269\u54c1,\u90a3\u4e48\u72b6\u6001i\u53ef\u4ee5\u76f4\u63a5\u7531\u72b6\u6001i - 1\u8f6c\u79fb\u800c\u6765 \u4e0d\u9009\u8fd9\u4e2a\u7269\u54c1,\u90a3\u4e48\u662f\u4e0d\u662f \u8fd9\u4e2a\u70b9\u7684\u513f\u5b50\u90fd\u4e0d\u53ef\u4ee5\u9009 ,\u90a3\u4e48\u72b6\u6001i\u5c31\u53ea\u80fd\u7531\u5b83\u7684\u5de6\u5144\u5f1f\u8f6c\u79fb\u800c\u6765 \u8bbepre[i]\u662f\u7f16\u53f7\u4e3ai\u7684\u8282\u70b9\u7684\u5de6\u5144\u5f1f $$ f[i,j]=\\max\\begin{cases} f[pre[i],j],\\ f[i-1,j-v]+w, & j\\ge v \\end{cases} $$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <cstdlib> #include <algorithm> #include <string> #include <vector> #include <map> #include <unordered_map> #include <set> #include <unordered_set> #include <queue> using namespace std ; typedef long long ll ; const int N = 200 ; int n , m ; struct E { int to , inext ; } edge [ N * 2 ]; int head [ N ], total ; struct Node { int val ; int weight ; int fa ; int dfn ; } s [ N ]; void adde ( int x , int y ) { edge [ ++ total ]. to = y ; edge [ total ]. inext = head [ x ]; head [ x ] = total ; } int dfn ; //\u6309\u7167dfs\u5e8f\u4f5c\u4e3a\u7d22\u5f15 struct Node_dfn { int val ; int weight ; int pre ; } ss [ N ]; int dp [ N ][ 50000 ]; void dfs ( int x , int fa ) { int p = dfn ; for ( int e = head [ x ]; e ; e = edge [ e ]. inext ) { int y = edge [ e ]. to ; if ( y == fa ) continue ; dfs ( y , x ); } s [ x ]. dfn =++ dfn ; ss [ dfn ]. val = s [ x ]. val ; ss [ dfn ]. weight = s [ x ]. weight ; ss [ dfn ]. pre = p ; } int dpdp () { memset ( dp , 0 , sizeof ( dp )); dp [ 0 ][ 0 ] = 0 ; for ( int i = 1 ; i <= n + 1 ; i ++ ) //dfn { // dp[i][0]=0; for ( int w = 0 ; w <= m ; w ++ ) { /*dp[i][w]=max( dp[ss[i].pre][w], dp[i-1][w-1]+ss[i].bb );*/ dp [ i ][ w ] = dp [ ss [ i ]. pre ][ w ]; if ( w - ss [ i ]. weight >= 0 ) dp [ i ][ w ] = max ( dp [ i ][ w ], dp [ i -1 ][ w - ss [ i ]. weight ] + ss [ i ]. val ); } } int ans = 0 ; for ( int w = 1 ; w <= m ; w ++ ) { ans = max ( ans , dp [ n ][ w ]); } return ans ; } int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ), cout . tie ( 0 ); while ( cin >> m >> n ) { if ( n == 0 && m == 0 ) return 0 ; total = 0 ; dfn = 0 ; for ( int i = 0 ; i <= n + 10 ; i ++ ) { head [ i ] = 0 ; ss [ i ] = ss [ 0 ]; s [ i ] = s [ 0 ]; } for ( int i = 1 ; i <= n ; i ++ ) { int a , b , c ; cin >> a >> b >> c ; s [ i ]. weight = a ; s [ i ]. val = a * b ; s [ i ]. fa = c ; s [ i ]. dfn = 0 ; adde ( i , c ); adde ( c , i ); } dfs ( 0 , 0 ); cout << dpdp () << endl ; } return 0 ; } \u6570\u8bba \u00b6 \u540c\u4f59\u6027\u8d28 \u00b6 \u6574\u9664\u6027 $$ a\\equiv b \\pmod m \\Rightarrow m|(a-b) $$ \u4f20\u9012\u6027 $$ \\begin{cases} a\\equiv b \\pmod m\\ c\\equiv d \\pmod m \\end{cases} \\Rightarrow a\\equiv c \\pmod m $$ \u4fdd\u6301\u57fa\u672c\u8fd0\u7b97 $$ \\left. \\begin{matrix} a \\equiv b \\pmod{m} \\ c \\equiv d\\pmod{m} \\end{matrix} \\right} \\Rightarrow \\left{ \\begin{matrix} a \\pm c \\equiv b \\pm d \\pmod{m} \\ ac \\equiv bd \\pmod{m} \\end{matrix} \\right. $$ $$ a \\equiv b \\pmod{m} \\Rightarrow \\begin{cases} an \\equiv bn \\pmod{m}, \\forall n \\in \\mathbb{Z} \\ a^n \\equiv b^n \\pmod{m}, \\forall n \\in \\mathbb{N}^0 \\end{cases} $$ \u5e95\u6570\u653e\u7f29 $$ (km \\pm a)^n \\equiv (\\pm a)^n \\pmod{m} $$ \u6a21\u6570\u653e\u7f29 $$ a \\equiv b \\pmod{m} \\Leftrightarrow ka \\equiv kb \\pmod{km} $$ \u9664\u6cd5\u539f\u7406\uff1a\u5f53k\u3001m\u4e92\u8d28\u65f6 $$ ka \\equiv kb \\pmod{m} \\Rightarrow a \\equiv b \\pmod{m} $$ \\[ \\begin{cases} a \\equiv b \\pmod m \\\\ n|m \\end{cases}\\Rightarrow a\\equiv b \\pmod n \\] \u5bf9\u82e5\u5e72\u540c\u4f59\u7684\u540c\u4f59\u65b9\u7a0b\uff1a $$ \\left. \\begin{matrix} a \\equiv b \\pmod{m_1} \\ a \\equiv b \\pmod{m_2} \\ \\vdots \\ a \\equiv b \\pmod{m_n} \\ (n \\ge 2) \\end{matrix} \\right} \\Rightarrow a \\equiv b \\pmod{ \\text{lcm}[m_1,m_2,\\cdots,m_n]} $$ \\[ \\frac{a}{b}\\mod c=\\frac{a\\mod (bc)}{b} \\] \u6269\u5c55\u5362\u5361\u65af\u5b9a\u7406 (exLucas) \u00b6 \u5f53\u6a21\u6570p\u4e0d\u662f\u8d28\u6570\u65f6 $$ p=p_1 {k_1}p_2 \\cdots p_s^{k_s} $$ \u5f53k1=k2=...=1\u65f6\uff0c\u6c42\u4e0b\u9762\u7684\u540c\u4f59\u65b9\u7a0b\u7684a1\uff0c\u7136\u540eCRT\u5408\u5e76\u7b54\u6848 $$ \\begin{cases} C_n^m\\equiv a_1 \\pmod {p_1^{k_1}} \\ C_n^m\\equiv a_2 \\pmod {p_2^{k_2}} \\ \\cdots\\ C_n^m\\equiv a_s \\pmod {p_s^{k_s}} \\end{cases} $$ \u5f53\u5206\u89e3\u540e\u8fd8\u4e0d\u662f\u8d28\u6570\u65f6 $$ C_n^m=\\frac{n!}{m!(n-m)!}\\mod p t\\=\\frac{\\frac{n!}{p }}{\\frac{m!}{p {a_2}}*\\frac{(n-m)!}{p }}*p^{a_1-a_2-a_3}\\mod p^t\\ $$ \u8ba1\u7b97n!\u3001m!\u3001(n-m)!\u5728mod p^t\u4e0b\u7684\u503c\uff08\u540e\u4e24\u8005\u518d\u6c42\u9006\u5143\uff09 \u5bf9\u4e8e\u9636\u4e58\u4e2d\u7684\u6bcf\u4e00\u4e2a\u6570\uff0c\u5206\u4e3a\u53ef\u88abp\u6574\u9664\u7684\u548c\u4e0d\u53ef\u88abp\u6574\u9664\u7684 $$ n!=\\lfloor\\frac{n}{p}\\rfloor! * p {\\lfloor\\frac{n}{p}\\rfloor} * (\\prod_{i=1\\p|i} {P t}i) {p t}\\rfloor}~*(\\prod_{i=1\\p\u2224i} }i) \\pmod {p^t} $$ (n/p)!\u9012\u5f52\u89e3\u51b3\uff0c\u540e\u4e24\u8005\u9884\u5904\u7406\u89e3\u51b3 \u53c2\u89c1luogu/4720_exLucas 2019-2020 ICPC Asia Taipei-Hsinchu Regional Contest M.DivModulo: \u9898\u610f \uff1a \u6c42C(N,M) dmod D\uff0c\u5176\u4e2d x dmod y \u6307\u7684\u662f\u53bb\u6389 x \u4e2d\u6240\u6709 y \u56e0\u5b50\u540e\u53d6\u4f59\u6570\u3002 \u5206\u6790\uff1a \u6211\u4eec\u8bd5\u56fe\u5c06\u9636\u4e58\u4e2d\u6240\u6709\u542b\u6709D\u7684\u9879\u63d0\u51fa\u6765\uff0c\u7136\u540e\u5229\u7528\u7c7b\u4f3c\u6269\u5c55\u5362\u5361\u65af\u8ba1\u7b97\u4f59\u4e0b\u7684\u90e8\u5206\u3002 $$ C M_N=\\frac{N!}{M!(N-M)!}=\\frac{N! div D}{M! div D (N-M)! div D} D K $$ \u8fd9\u4e2a\u65f6\u5019\u518d\u53d6\u6a21 $$ C_N^M dmod D=(N! div D) inv(M! div D) inv((N-M)! div D) \\mod D $$ \u5206\u6bcd\u4e0d\u4e00\u5b9a\u4e0eD\u4e92\u8d28\uff0c\u56e0\u6b64\u8003\u8651\u8d28\u56e0\u6570\u5206\u89e3D=D1...Ds\uff0c\u6700\u540e\u518d\u7528CRT\u5408\u5e76 $$ C_N M div D=\\frac{C_N M}{D K}=\\frac{(C_N M div p_i) p_i k}{D K}=\\frac{(C_N M div p_i)*p_i }{(D/D_i)^K}\\mod D_i $$ \u5176\u4e2dK\u662f\u4f7f\u5f97D^K\u9664C(N,M)\u540e\u4ecd\u662f\u6574\u6570\u7684\u6700\u5927\u7684K $$ K=\\min_{1\\le i\\le s}\\frac{k_i}{a_i} $$ \u81f3\u4e8e\u8ba1\u7b97C_N^M div D mod P\uff0c\u5219\u8fd0\u7528\u7c7b\u4f3c\u6269\u5c55\u5362\u5361\u65af\u7684\u65b9\u6cd5\u5373\u53ef $$ n!=\\lfloor\\frac{n}{D}\\rfloor! * D {\\lfloor\\frac{n}{D}\\rfloor} * (\\prod_{i=1\\D|i} i) {\\lfloor\\frac{n}{D}\\rfloor}~*(\\prod_{i=1\\D\u2224i} }i)\\ n! div D=\\lfloor\\frac{n}{D}\\rfloor! (\\prod_{i=1\\D|i} {P}i) {D}\\rfloor} *(\\prod_{i=1\\D\u2224i}^{N\\mod {D}}i) $$ \u9636\u548c\u539f\u6839 \u00b6 \u9636 \uff1a \\( \\((a,m)=1,a^l\\equiv1\\pmod{m}\\) \\) ,\u4f7f\u5f97\u5176\u6210\u7acb\u7684\u6700\u5c0f\u7684l\u79f0\u4e3aa\u5173\u4e8emod m\u7684\u9636\u3002\u8bb0\u4e3a \\( \\(\\text{ord}_ma=l\\) \\) \\[ \\text{ord}_ma=l\\Rightarrow \\text{ord}_ma^t=\\frac{l}{(t,l)} \\] \u8bc1\u660e\uff1a $$ \u8bbe\u540e\u8005\u539f\u6839\u662fx,\u5219\u663e\u7136l|tx\\Rightarrow tx=\\text{lcm}(t,l)=\\frac{tl}{(t,l)} $$ \\[ a^n\\equiv1\\pmod m\\Leftrightarrow l|n \\] \u7531\u4e8e\u6b27\u62c9\u5b9a\u7406 \\( \\(a^{\\phi(n)}\\equiv 1\\pmod m\\) \\) ,\u5219 \\( \\(l|\\phi(n)\\) \\) \\( \\(1,a,a^2,\\cdots,a^{l-1}\\) \\) \u5173\u4e8em\u4e24\u4e24\u4e0d\u540c\u4f59\uff08l\u662f\u6700\u5c0f\u5faa\u73af\u5468\u671f\uff09 p\u4e3a\u8d28\u6570\uff0c \\( \\(l|\\phi(p)\\) \\) \uff0c\u5219\u5b58\u5728 \\( \\(\\phi(l)\\) \\) \u4e2a\u5173\u4e8emod p\u9636\u4e3al\uff0c\u4e14\u4e24\u4e24\u4e92\u4e0d\u540c\u4f59\u7684\u6570 \u82e5 \\( \\(m=p_1^{a_1}\\cdots p_k^{a_k}\\) \\) ,\u5219 \\( \\(\\text{ord}_ma=[\\text{ord}_{p_1}^{a_1},\\cdots,\\text{ord}_{p_k}^{a_k}]\\) \\) \u539f\u6839 \uff1a \\( \\((g,m)=1\\) \\) \uff0c\u4e14 \\( \\(\\text{ord}_mg=\\phi(m)\\) \\) \uff0c\u5219g\u662fm\u7684\u539f\u6839\u3002 \\( \\(\\{g,g^2,\\cdots,g^{\\phi(m)}\\}\\) \\) \u662fmod m\u7684\u4e00\u4e2a\u7b80\u7ea6\u5269\u4f59\u7cfb\u3002 \u539f\u6839\u5f62\u5f0f\uff1a \\( \\(2,4,p^\\alpha,2p^\\alpha\\) \\) \u3002p\u4e3a\u5947\u6570\u8d28\u6570\uff08\u9664\u4e862\u5916\u7684\u8d28\u6570\uff09\uff0calpha\u4e3a\u6b63\u6574\u6570 \u6240\u6709\u539f\u6839\uff1ag\u4e3am\u7684\u4e00\u4e2a\u539f\u6839\uff0c\u5219\u4e0b\u9762\u7684\u96c6\u5408\u7ed9\u51fa\u6240\u6709\u539f\u6839\uff08\u539f\u6839g\u6784\u6210\u6574\u6570mod m\u4e58\u6cd5\u7fa4\u751f\u6210\u5143\uff09\uff0c\u56e0\u6b64\u82e5m\u5b58\u5728\u539f\u6839\uff0c\u5219\u539f\u6839\u6570\u91cf\u4e3a \\( \\(\\phi(\\phi(m))\\) \\) $$ {g^s|1\\le s\\le\\phi(m),(s,\\phi(m))=1} $$ \u6c42\u89e3\u4e00\u4e2a\uff08\u6700\u5c0f\uff09\u539f\u6839 \uff1a \\[(g,m)=1$$,\u8bbe$$p_1,p_2,\\cdots,p_k$$\u662f$$\\phi(m)$$\u7684\u6240\u6709\u4e0d\u540c\u8d28\u56e0\u6570\uff0c\u5219g\u662fm\u7684\u539f\u6839\uff0c\u5f53\u4e14\u4ec5\u5f53$$1\\le i\\le k,g^{\\frac{\\phi(m)}{p_i}}\\not\\equiv1\\pmod m\\] \u5148\u5206\u89e3 \\( \\(\\phi(m)\\) \\) \u7684\u8d28\u56e0\u6570\uff0c\u7136\u540e\u7a77\u4e3eg\uff0c\u5e76\u4f9d\u6b21\u9a8c\u8bc1\u6bcf\u4e2a\u8d28\u56e0\u6570\u662f\u5426\u6ee1\u8db3\u4e0a\u9762\u7684\u6761\u4ef6\u3002 https://zh.wikipedia.org/wiki/%E5%8E%9F%E6%A0%B9 m \u6a21m\u7684\u539f\u6839(\u6709*\u53f7\u7684\u6570\u6ca1\u6709\u539f\u6839\uff0c\u6b64\u65f6\u662f\u6709\u6700\u5927\u6a21m\u5468\u671f\u7684\u6570) \u5468\u671f ( \u200a A002322 ) 1 0 1 2 1 1 3 2 2 4 3 2 5 2, 3 4 6 5 2 7 3, 5 6 8* 3, 5, 7 2 9 2, 5 6 10 3, 7 4 11 2, 6, 7, 8 10 12* 5, 7, 11 2 13 2, 6, 7, 11 12 14 3, 5 6 15* 2, 7, 8, 13 4 16* 3, 5, 11, 13 4 17 3, 5, 6, 7, 10, 11, 12, 14 16 18 5, 11 6 19 2, 3, 10, 13, 14, 15 18 20* 3, 7, 13, 17 4 21* 2, 5, 10, 11, 17, 19 6 22 7, 13, 17, 19 10 23 5, 7, 10, 11, 14, 15, 17, 19, 20, 21 22 24* 5, 7, 11, 13, 17, 19, 23 2 25 2, 3, 8, 12, 13, 17, 22, 23 20 26 7, 11, 15, 19 12 27 2, 5, 11, 14, 20, 23 18 28* 3, 5, 11, 17, 19, 23 6 29 2, 3, 8, 10, 11, 14, 15, 18, 19, 21, 26, 27 28 30* 7, 13, 17, 23 4 31 3, 11, 12, 13, 17, 21, 22, 24 30 32* 3, 5, 11, 13, 19, 21, 27, 29 8 33* 2, 5, 7, 8, 13, 14, 17, 19, 20, 26, 28, 29 10 34 3, 5, 7, 11, 23, 27, 29, 31 16 35* 2, 3, 12, 17, 18, 23, 32, 33 12 36* 5, 7, 11, 23, 29, 31 6 \u8d39\u9a6c\u5c0f\u5b9a\u7406 \u00b6 p\u662f\u8d28\u6570\uff0c\u5219 $$ a^p\\equiv a \\pmod p $$ \u7279\u522b\u7684,\u5f53a\u4e0d\u662fp\u7684\u500d\u6570\u65f6(\u8fd9\u65f6a,p\u4e92\u8d28)\u6709 $$ a^{p-1}\\equiv 1 \\pmod p $$ Miller Rabin \u8d28\u6570\u5224\u522b\u6cd5 \u00b6 \u8d39\u9a6c\u7d20\u6027\u6d4b\u8bd5 \u00b6 \u5728[2\u5230n-1]\u91cc\u9762\u9009\u62e9\u4e00\u4e9b\u57faa,\u68c0\u67e5\u662f\u5426\u6ee1\u8db3\u8d39\u9a6c\u5c0f\u5b9a\u7406,\u4e0d\u6ee1\u8db3\u5c31\u8bf4\u660e\u4e0d\u662f\u8d28\u6570 \u5f53\u7136\u6ee1\u8db3\u4e86\u4e5f\u4e0d\u4e00\u5b9a\u662f\u8d28\u6570 \u4e8c\u6b21\u63a2\u6d4b\u5b9a\u7406 \u00b6 p\u662f\u5947\u8d28\u6570\uff0c\u5219\u65b9\u7a0b \\(x^2\\equiv1\\pmod p\\) \u7684\u89e3\u4e3a \\(x=1\\) \u6216\u8005 \\(x=p-1\\) \uff08\u4e5f\u5373 \\(x=-1\\) (\u540c\u4f59\u610f\u4e49\u4e0b\u7684)\uff09 \u8bc1\u660e\uff1a $$ x^2=1\\pmod1 \\Rightarrow (x+1)(x-1)=0\\pmod1\\Rightarrow\\ p|(x+1)(x-1) \\Rightarrow x=p-1\u62161 $$ \u5361\u8fc8\u514b\u5c14\u6570 \u00b6 \u5bf9\u8fd9\u7c7b\u6570,\u53d6\u4efb\u4f55\u57fa\u90fd\u80fd\u901a\u8fc7\u7d20\u6027\u6d4b\u8bd5,\u4f46\u5176\u672c\u8eab\u5374\u4e0d\u662f\u8d28\u6570. \u6700\u5c0f\u7684\u4e09\u4e2a\u6570\u662f561,1105,1729( OEIS:A002997 ) \u7b49\u4ef7\u5b9a\u4e49 :\u4e00\u4e2a\u6b63\u5408\u6210\u6570n\u662f\u5361\u8fc8\u514b\u5c14\u6570\uff0c\u5f53\u4e14\u4ec5\u5f53 n\u65e0\u5e73\u65b9\u6570\u7ea6\u6570\u4e14\u5bf9\u4e8e\u6240\u6709 n\u7684\u7d20\u56e0\u6570 p\uff0cp-1|n-1 \u7efc\u5408\u505a\u6cd5 \u00b6 \u5982\u679cn\u662f\u5927\u4e8e2\u7684\u8d28\u6570,\u5219\u7531\u4e8en-1\u662f\u5076\u6570,\u5bf9\u4e8e\u4efb\u610f\u7684\u57fa \\(a~(a\\in[2,n-1])\\) ,\u6709 $$ a {n-1}=a $$ \u7531\u8d39\u9a6c\u7d20\u6027\u6d4b\u8bd5,\u6211\u4eec\u63a5\u4e0b\u6765\u8981\u505a \\(a^{n-1}\\equiv 1 \\pmod n\\) ,\u7ed3\u5408\u4e0a\u5f0f\u53ef\u4ee5\u5f97\u5230 $$ a {2 sd}=(a {2 d})^2\\equiv 1\\pmod n $$ \u7531\u4e8c\u6b21\u63a2\u6d4b\u5b9a\u7406\u53ef\u77e5\uff0c \\(a^{2^{r-1}}\\equiv 1\u6216-1\\) . \u800c\u5982\u679c\u7b49\u4e8e1\u90a3\u4e48\u53ef\u4ee5\u7ee7\u7eed\u5f00\u6839\u53f7\u3002 \u73b0\u5728\u8003\u8651\u53cd\u8fc7\u6765\u7528\u8fd9\u4e2a\u5b9a\u7406\uff1a\u5982\u679c\u5b58\u5728\u8fd9\u4e48\u4e00\u4e2aa\u4f7f\u5f97\u4e0b\u9762\u4e24\u4e2a\u5f0f\u5b50\u90fd\u6ee1\u8db3\uff1a $$ a^d\\not\\equiv1 \\pmod n\\ a {{2 r}d}\\not\\equiv1 \\pmod n (0\\le r\\le s-1)\\ $$ \u90a3\u4e48n\u5c31\u4e00\u5b9a\u662f\u5408\u6570,a\u4fbf\u662fn\u662f\u5408\u6570\u7684\u4e00\u4e2a\u51ed\u636e. \u6ce8\uff1a\u8fd9\u91cc\u8981\u4e48 \\(a^d,a^{2^1d},\\cdots,a^{2^rd}\\) \u5168\u662f1\uff0c\u8981\u4e48\u4f1a\u5b58\u5728\u4e00\u4e2a\u6570\u662f-1\uff0c\u7136\u540e\u5c31\u90fd\u662f1 \u8fd9\u662f\u56e0\u4e3a\u5982\u679c\u5176\u4e2d\u67d0\u4e2a\u6570\u662f1\u90a3\u4e48\u53ef\u4ee5\u5f00\u6839\u53f7\uff0c\u5f97\u5230\u524d\u4e00\u4e2a\u6570\u662f1\u6216-1\u3002\u5982\u679c\u662f1\u90a3\u4e48\u53ef\u4ee5\u7ee7\u7eed\u5f00\u6839\u53f7\u76f4\u5230\u6240\u6709\u6570\u90fd\u662f1\u4e3a\u6b62\uff1b\u5982\u679c\u662f-1\u90a3\u4e48\u5c31\u6b64\u7ec8\u6b62\uff0c\u56e0\u6b64\u8fd9\u4e2a-1\u4e4b\u540e\u7684\u6570\u90fd\u662f1 Pollard's Rho \u8d28\u56e0\u6570\u5206\u89e3(\u5f85\u8865\u5145) \u00b6 \u72c4\u5229\u514b\u96f7\u5377\u79ef\uff0c\u83ab\u6bd4\u4e4c\u65af\u53cd\u6f14 \u00b6 \u5f15\u74061\uff1a \u5730\u677f\u9664\u6cd5\u5d4c\u5957\u53ef\u4e0b\u653e $$ \\forall a,b,c\\in \\mathbb{Z},\\lfloor\\frac{a}{bc}\\rfloor=\\lfloor\\frac{\\lfloor\\frac ab\\rfloor}{c}\\rfloor $$ \u5f15\u74062 \uff1a\u4e0d\u540c\u7684n/d\u4e2a\u6570\u4e0d\u4f1a\u8d85\u8fc7 \\(\\lfloor2\\sqrt n\\rfloor\\) \u6570\u8bba\u5206\u5757 \u00b6 \uff08\u5f85\u8865\u5145\uff09 \u79ef\u6027\u51fd\u6570 \u00b6 \\(f(n)\\) \u6ee1\u8db3 \\(f(1)=1 \\&\\& \\forall x,y\\in\\mathbb{N_+},\\gcd(x,y)=1\\) \u6709 \\(f(xy)=f(x)f(y)\\) ,\u5219f\u4e3a\u79ef\u6027\u51fd\u6570\u3002 \u5982\u679c\u6ca1\u6709gcd\u6761\u4ef6\u7684\u9650\u5236\uff0c\u4e5f\u5373\u4efb\u610f\u4e24\u4e2a\u6570\u90fd\u6ee1\u8db3\u79ef\u6027\u6761\u4ef6\uff0c\u5219f\u4e3a\u5b8c\u5168\u79ef\u6027\u51fd\u6570 \u6027\u8d28 \uff1a\uff08\u5f85\u8865\u5145\uff09 \u5e38\u89c1\u79ef\u6027\u51fd\u6570 \uff1a \u4e0b\u6587\u4e2d \\([condition]\\) \u8868\u793a\u5f53\u6761\u4ef6\u6210\u7acb\u65f6\u4e3a1\uff0c\u5426\u5219\u4e3a0 \u5355\u4f4d\u51fd\u6570\uff1a\uff08\u5b8c\u5168\u79ef\u6027\u51fd\u6570\uff09 $$ \\epsilon(n)=[n=1] $$ \u5e42\u51fd\u6570\u548c\u6052\u7b49\u51fd\u6570\uff1a(\u5b8c\u5168\u79ef\u6027\u51fd\u6570) $$ id_k(n)=n^k,id(n)=n $$ \u5e38\u6570\u51fd\u6570\uff1a\uff08\u5b8c\u5168\u79ef\u6027\u51fd\u6570\uff09 $$ 1(n)=1 $$ \u9664\u6570\u51fd\u6570\uff1a $$ \\sigma_k(n)=\\sum_{d|n}d^k\\sigma_0(n),\\sigma_1(n)=\\sigma(n) $$ \u6b27\u62c9\u51fd\u6570\uff1a \u83ab\u6bd4\u4e4c\u65af\u51fd\u6570\uff1a $$ \\mu(n)=\\begin{cases} 1 & n=1\\ 0 & \\exist d>1:d^2|n\\ (-1)^{\\omega(n)} & else\\ \\end{cases} $$ \u672c\u8d28\u4e0d\u540c\u8d28\u56e0\u5b50\u4e2a\u6570\u51fd\u6570\uff08\u4e5f\u662f\u79ef\u6027\u51fd\u6570\uff09\uff1a $$ \\omega({n})=|{p: (p|n \\&\\& \\text{p is a prime})}| $$ \u72c4\u5229\u514b\u96f7\u5377\u79ef\uff08Dirichlet \uff09 \u00b6 \u4e24\u4e2a\u6570\u8bba\u51fd\u6570fg\u7684\u5377\u79ef\uff0c\u662f\u6240\u6709\u6574\u9664n\u7684\u56e0\u5b50d\u7684f(d)\uff0c\u548c\u8be5\u56e0\u5b50\u5bf9\u5e94\u7684\u5546\u6570n\\d\u7684g(n\\d) \u4e4b\u79ef\u7684\u6c42\u548c \uff08\u7ed3\u679c\u662f\u4e00\u4e2a\u65b0\u7684\u6570\u8bba\u51fd\u6570\uff09 $$ (f g)(n)=\\sum_{d|n}f(d)g(\\frac nd) $$ \u6027\u8d28 *\uff08\u7fa4\u8bba\uff09\uff1a \u4ea4\u6362\u5f8b \u7ed3\u5408\u5f8b \u5206\u914d\u7387\uff1a \\(f*(g+h)=f*g+f*h\\) \u5355\u4f4d\u5143\uff1a \\(\\epsilon\\) ,\u4e5f\u5373\u5355\u4f4d\u51fd\u6570 \u83ab\u6bd4\u4e4c\u65af\u5bb9\u65a5 \u00b6 \u5982\u679c\u8981\u6c42\u67d0\u4e2a\u503c\uff0c\u8fd9\u4e2a\u503c\u8981\u6c42 \\(\\gcd(a_1,\\cdots,c_n)=1\\) \uff0c\u90a3\u4e48 $$ ans=\\sum_{d=1}^{n}\\mu(d)\\cdot D(a_1,a_2,\\cdots,a_n,d) $$ \u5176\u4e2d \\(D(a_1,a_2,\\cdots,a_n,d)\\) \u8868\u793a\u6ee1\u8db3 \\(d|\\gcd(a_1,a_2,\\cdots,a_n)\\) \u7ea6\u675f\u65f6\u7684\u51fd\u6570\u503c \u4f8b\u9898\uff1a 2019 \u94f6\u5dddD \u84dd\u4e66\u4e0a\u7684\u6c42sum of [gcd=1]\u9898 *RSA \u00b6 \u4ea7\u751f\u516c\u94a5\u548c\u79c1\u94a5\u7684\u8fc7\u7a0b \u00b6 \u9009\u62e9\u4e24\u4e2a\u8d28\u6570p\u3001q\uff0c\u4ee4N=pq \u6c42N\u7684\u6b27\u62c9\u51fd\u6570\u503cr\uff1a \\(r=\\phi(N)=\\phi(p)\\phi(q)=(p-1)(q-1)\\) \u9009\u62e9 \u5c0f\u4e8er \u7684\u6b63\u6570e\uff0c\u4f7f\u5f97 \\(\\gcd(e,r)=1\\) \u4f7f\u7528exgcd\u6c42\u5f97e\u5173\u4e8er\u7684\u9006\u5143\uff08\u7531\u4e8e\u5176\u4e0er\u4e92\u8d28\uff0c\u56e0\u6b64e\u7684\u9006\u5143\u5b58\u5728\uff09\uff0c\u8bb0\u4e3ad \u81f3\u6b64\uff0c \\((N,d)\\) \u4e3a\u79c1\u94a5\u3001 \\((N,e)\\) \u4e3a\u516c\u94a5\u3002 \u52a0\u5bc6 \u00b6 \u5047\u8bbe\u8981\u52a0\u5bc6\u7684\u5185\u5bb9\u4e3an\uff08n<N\uff09\uff0c\u5219\u52a0\u5bc6\u540e\u7684\u660e\u6587c\u4e3a\uff1a $$ c\\equiv n^e \\pmod N $$ \u89e3\u5bc6 \u00b6 \u62e5\u6709\u79c1\u94a5d\u548c\u660e\u6587c\uff0c\u5c31\u53ef\u4ee5\u7528\u4e0b\u9762\u7684\u5f0f\u5b50\u89e3\u5bc6\uff1a $$ n\\equiv c^{d} \\pmod N $$ \u539f\u7406\uff1a $$ c^d\\equiv n^{ed} \\pmod N $$ \u800c \\(ed\\equiv 1 \\pmod r\\) \uff0c\u5219 \\(ed=1+hr=1+h\\phi(N)\\) \uff0c\u4ece\u800c $$ n^{ed}\\equiv n\\cdot (n {\\phi(N)}) h \\pmod N $$ \u7531\u6b27\u62c9\u5b9a\u7406\u53ef\u77e5 \\(n^{\\phi(N)}\\equiv 1 \\pmod N\\) \uff08\u5982\u679cn\u548cN\u4e92\u8d28\uff09\uff0c\u90a3\u4e48\u53ef\u5f97 \\[ n^{ed}\\equiv n \\pmod N \\] \u5982\u679c\u4e0d\u4e92\u8d28\uff0c\u8bbe \\(n=kp<N,\\gcd(n,q)=1\\) \uff0c\u5219 $$ n^{ed}\\equiv (kp)^{ed}\\equiv 0\\equiv n \\pmod p\\ n^{ed}\\equiv n^{ed-1}\\cdot n=({n {\\phi(N)}}) hn\\equiv1^hn=n\\pmod q $$ \u6839\u636e\u540c\u4f59\u6027\u8d289\uff0c\u5f97\u5230 $$ n^{ed}=n \\pmod {pq} $$ Bertrand's postulate \u4f2f\u7279\u5170\u5207\u6bd4\u96ea\u592b\uff08\u5047\u8bbe\uff09\u5b9a\u7406 \u00b6 \u5bf9\u4e8e\u4efb\u610f\u6574\u6570 \\(n>3\\) \uff0c\u5b58\u5728\u8d28\u6570p\uff1a $$ n<p<2n-2 $$ \u5f31\u5316\u7248\u672c\uff1a $$ n<p<2n $$ \u5f3a\u5316\u7248\u672c\uff1a\u5bf9\u4e8e \\(n>25\\) \uff0c\u5b58\u5728\u8d28\u6570p\uff1a $$ n<p<(1+\\frac 15)n $$ \u535a\u5f08\u8bba \u00b6 Nim\u3001SG\u3001Multi-SG \u00b6 Nim \u5148\u624b\u5fc5\u80dc \uff1a\u5f02\u6216\u548c\u4e0d\u4e3a0 SG\uff1a \\(sg(x)=\\text{mex}(sg(y_1),\\cdots)\\) Multi-SG: \u82e5\u5e72\u4e2aICG\u7684\u548c\u7b49\u4e8e\u6bcf\u4e2aICG\u7684sg\u503c\u5f02\u6216\u548c Anti-SG\u3001Anti-Nim \u00b6 \u53d6\u5f97\u6700\u540e\u4e00\u4e2a\u77f3\u5934\u7684\u8f93\u3002 \u5148\u624b\u5fc5\u80dc \uff1a sg\u22600\uff0c\u4e14\u6709\u5355\u4e00\u6e38\u620fsg>1; sg=0\uff0c\u4e14\u65e0\u5355\u4e00\u6e38\u620fsg>1; \uff08\u4e5f\u5373\u6240\u6709\u6e38\u620fsg=1\uff09 Bash\u3001Anti-Bash \u00b6 \u4e00\u5806\uff08n\u4e2a\uff09\u77f3\u5934\uff0c\u80fd\u62ff1\u5230m\u4e2a\uff0c\u4e0d\u80fd\u62ff\u7684\u8f93\u3002 Bash\u5148\u624b\u5fc5\u80dc\uff1a \\(n\\%(m+1)\\neq0\\) \u53cdBash\u5148\u624b\u5fc5\u80dc\uff1a \\((n-1)\\%(m+1)\\neq0\\) Lasker's Nim \u00b6 n\u5806\u77f3\u5934\uff0c\u5bf9\u4e00\u5806\u77f3\u5934\u53ef\u4ee5\u7528nim\u7684\u53d6\u6cd5\u6216\u8005\u5206\u6210\u4e24\u5806\u3002 \u5355\u4e00\u6e38\u620f\u7684SG\u51fd\u6570\uff1a $$ sg(x)=\\begin{cases} x-1, & x\\%4==0\\ x, & x\\%4==1or2\\ x+1, & x\\%4==3 \\end{cases} $$ Every-SG \u00b6 \u672a\u7ed3\u675f\u7684\u5355\u4e00\u6e38\u620f\u5fc5\u987b\u52a8\u4e00\u6b65\u3002 \u67d0\u4e2a\u5355\u4e00\u6e38\u620f\u7684step\uff1a $$ step(x)=\\begin{cases} 0, & \\text{end}\\ \\max(step(y))+1, & sg(x)\\neq0 and sg(y)=0\\ \\min(step(y))+1, & sg(x)=0\\ \\end{cases} $$ \u5148\u624b\u5fc5\u80dc \uff1a \\(\\max(step(x))\\%2==1\\) \u9636\u68af\u535a\u5f08 \u00b6 \u9636\u68af\u4e0a\u6709\u82e5\u5e72\u77f3\u5934\uff0c\u6bcf\u6b21\u9009\u4e00\u4e2a\u9636\u68af\u4e0a\u7684\u81f3\u5c11\u4e00\u4e2a\u77f3\u5934\u79fb\u52a8\u5230\u4e0b\u4e00\u5c42\uff0c\u4e0d\u80fd\u79fb\u52a8\u7684\u8f93\u3002 \u65b9\u6cd5 \uff1a \u5947\u6570\u53f0\u9636\u770b\u505a\u5355\u4e2aNim\u6e38\u620f \u786c\u5e01\u53cd\u8f6c \u00b6 N\u679a\u786c\u5e01\u6392\u6210\u4e00\u6392\uff0c\u6709\u7684\u6b63\u9762\u671d\u4e0a\uff0c\u6709\u7684\u53cd\u9762\u671d\u4e0a\u3002\u6211\u4eec\u4ece\u5de6\u5f00 \u59cb\u5bf9\u786c\u5e01\u63091\u5230N\u7f16\u53f7\u3002 Alice\u548cBob\u8f6e\u6d41\u6839\u636e\u67d0\u4e9b\u7ea6\u675f\u7ffb\u786c\u5e01\uff08\u5982\uff1a\u6bcf\u6b21\u53ea\u80fd\u7ffb\u4e00\u6216\u4e24\u679a\uff0c\u6216\u8005\u6bcf \u6b21\u53ea\u80fd\u7ffb\u8fde\u7eed\u7684\u51e0\u679a\uff09\uff0c\u4f46\u4ed6\u6240\u7ffb\u52a8\u7684\u786c\u5e01\u4e2d\uff0c\u6700\u53f3\u8fb9\u7684\u5fc5\u987b\u662f \u4ece\u6b63\u9762\u7ffb\u5230\u53cd\u9762\u3002 \u8c01\u4e0d\u80fd\u7ffb\u8c01\u8f93\u3002 \u65b9\u6cd5 \uff1a \u5c40\u9762\u7684SG\u503c\u4e3a\u5c40\u9762\u4e2d\u6bcf\u4e2a\u6b63\u9762\u671d\u4e0a\u7684\u68cb\u5b50\u5355\u4e00\u5b58\u5728\u65f6\u7684SG\u503c\u7684\u5f02\u6216\u548c \u6811\u4e0a\u5220\u8fb9 \u00b6 \u53f6\u5b50\u8282\u70b9\u7684sg\u503c\u4e3a0\uff0c\u975e\u53f6\u5b50\u8282\u70b9\u7684sg\uff1a $$ sg(x)=\\sum_{\\oplus}(sg(y)+1) $$ \u5176\u4ed6\u7684\u5f85\u8865\u5145\u2026\u2026 \u5a01\u4f50\u592b\u535a\u5f08 \u00b6 \u4e24\u4eba\u8f6e\u6d41\u53d6\u4e24\u5806\u7b79\u7801\uff0c\u5176\u4e2d\u53d6\u6cd5\u6709\u4e24\u79cd\uff1a\u53d6\u8d70\u4e00\u5806\u4e2d\u4efb\u610f\u4e2a\u7b79\u7801\uff0c\u6216\u4ece\u4e24\u5806\u4e2d\u53d6\u8d70\u76f8\u540c\u6570\u76ee\u7684\u7b79\u7801\u3002\u53d6\u5b8c\u6240\u6709\u7b79\u7801\u7684\u4e00\u65b9\u83b7\u80dc\u3002 \u524d\u82e5\u5e72\u4e2a\u5947\u5f02\u5c40\u52bf\uff1a\uff080\uff0c0\uff09\u3001\uff081\uff0c2\uff09\u3001\uff083\uff0c5\uff09\u3001\uff084\uff0c7\uff09\u3001\uff086\uff0c10\uff09 \u4efb\u4f55\u4e00\u4e2a\u81ea\u7136\u6570\u90fd\u5305\u542b\u5728\u552f\u4e00\u4e00\u4e2a\u5947\u5f02\u5c40\u52bf\uff08\u5148\u8d25\uff09\u4e2d x\u4e3a\u524dk\u4e2a\u5947\u5f02\u5c40\u52bf\u4e2d\u672a\u51fa\u73b0\u7684\u6700\u5c0f\u6b63\u6574\u6570\uff0c\u5219\uff08x\uff0cy\uff09\u4e2d\u7684y=x+k \u5c40\u9762\uff08x\uff0cy\uff09\uff08x<y\uff09 \u5148\u624b\u5fc5\u8d25 \uff1a $$ (y-x)\\frac{\\sqrt5+1}{2}=x $$ \u6590\u6ce2\u90a3\u5951\u535a\u5f08 \u00b6 \u4e00\u5806\u77f3\u5b50\u6709n\u4e2a\uff0c\u4e24\u4eba\u8f6e\u6d41\u53d6\uff0c\u5148\u53d6\u8005\u7b2c1\u6b21\u53ef\u4ee5\u53d6\u4efb\u610f\u591a\u4e2a\uff0c\u4f46\u4e0d\u80fd\u5168\u90e8\u53d6\u5b8c\uff0c\u4ee5\u540e\u6bcf\u6b21\u53d6\u7684\u77f3\u5b50\u6570\u4e0d\u80fd\u8d85\u8fc7\u4e0a\u6b21\u53d6\u5b50\u6570\u76842\u500d\u3002\u53d6\u5b8c\u8005\u80dc\u3002 \u5148\u624b\u5fc5\u8d25 \uff1a\u77f3\u5934\u6570\u91cf\u662f\u6590\u6ce2\u90a3\u5951\u6570 \u4efb\u4f55\u6570\u53ef\u4ee5\u5206\u89e3\u6210\u82e5\u5e72\u4e0d\u8fde\u7eed\u6590\u6ce2\u90a3\u5951\u6570\u7684\u548c \u7ec4\u5408\u6570\u5b66 \u00b6 \u7ec4\u5408\u6570 \u00b6 \u6052\u7b49\u5f0f\uff1a \u659c\u7ebf\u52a0\u548c\u7b49\u4e8e\u659c\u7ebf\u672b\u7aef\u6b63\u4e0b\u65b9\u7684\u6570 \\[ \\sum_{r=0}^k \\binom {n+r-1}r = \\binom {n+k}k \\] \u540c\u884c\u52a0\u548c \\[ \\sum_{r=0}^n \\binom nr = 2^{n} \\] \u540c\u5217\u76f8\u52a0 $$ \\sum_{r=m}^{n} \\binom{r}{m}=\\binom{n+1}{m+1} $$ \u9694\u677f\u6cd5 \u00b6 n\u4e2a\u7403\u653e\u5165k\u4e2a\u76d2\u5b50\u4e2d\u3002\uff08\u6ce8\u610fk\u662f\u76d2\u5b50\u6570\u4e0d\u662f\u677f\u5b50\u6570\uff09 https://zh.wikipedia.org/wiki/%E9%9A%94%E6%9D%BF%E6%B3%95 \u4e0d\u5141\u8bb8\u7a7a\u76d2\uff1a \u8fd9\u79cd\u653e\u6cd5\u4e0d\u5141\u8bb8\u653e\u5c06\u677f\u5b50\u5728\u4e00\u5217\u7403\u7684\u6700\u5de6\u7aef\u548c\u6700\u53f3\u7aef $$ \\binom{n-1}{k-1} $$ \u5141\u8bb8\u7a7a\u76d2 \uff1a\u4e5f\u5373\u5141\u8bb8\u591a\u4e2a\u677f\u5b50\u63d2\u5728\u540c\u4e00\u4e2a\u7a7a\u9699\u4e4b\u95f4\uff08\u5305\u62ec\u6700\u5de6\u3001\u53f3\u7aef\uff09\u3002\u7b49\u4ef7\u4e8e\u5411n+k\u4e2a\u7403\u4e2d\u63d2k-1\u4e2a\u677f\u5b50\uff08k\u4e2a\u76d2\u5b50\uff09\uff08\u4e0d\u5141\u8bb8\u7a7a\u76d2\uff09\u3002 \u53ef\u4ee5\u8fd9\u4e48\u8003\u8651\uff1a\u5411n+k\u4e2a\u7403\u4e2d\u63d2k-1\u4e2a\u677f\u5b50\uff08\u4e0d\u5141\u8bb8\u7a7a\u76d2\uff09\u540e\u518d\u4ece\u6240\u6709\u76d2\u5b50\u4e2d\u5168\u90e8\u62ff\u6389\u4e00\u4e2a\u7403\uff0c\u5c31\u7b49\u4ef7\u4e8e\u73b0\u5728\u8fd9\u4e2a\u95ee\u9898\u4e86\u3002 $$ \\binom{n+k-1}{k-1} $$ \u4e0d\u76f8\u90bb\u7ec4\u5408\u6570 \u00b6 \u4ecen\u4e2a\u7403\u4e2d\u9009r\u4e2a\uff0c\u4f7f\u5f97\u5b83\u4eec\u4e92\u4e0d\u76f8\u90bb\uff0c\u95ee\u53d6\u6cd5\u603b\u6570\u3002 $$ C_{n-r+1}^r~(n\\ge2r-1) $$ \u8bc1\u660e\u65b9\u6cd5\uff1a{b1,...,br}\u662f\u4e00\u4e2a\u4e0d\u76f8\u90bb\u96c6\u5408\uff0c\u6784\u9020c1=b1,c2=b2-2,...,cr=br-r+1\uff0c\u5f97\u5230\u65b0\u7684\u96c6\u5408{c1,c2,...,cr}\uff0c\u7531\u4e8eb\u4e92\u4e0d\u76f8\u90bb\uff0c\u8fd9\u79cd\u6784\u9020\u65b9\u6cd5\u53ef\u4ee5\u4fdd\u8bc1c\u96c6\u5408\u6ca1\u6709\u91cd\u590d\u5143\u7d20\uff0c\u4e14\u5bf9\u4e8e\u4e0d\u540c\u7684b\u96c6\u5408\uff0cc\u96c6\u5408\u4e5f\u4e0d\u91cd\u590d\u3002\u8fd9\u5c31\u662f\u8bf4c\u548cb\u662f\u4e00\u4e00\u5bf9\u5e94\u5173\u7cfb\u3002\u800cc\u96c6\u5408\u7684\u610f\u4e49\u662f\u4ecen-r+1\u4e2a\u7403\u4e2d\u9009r\u4e2a\u3002 \u6590\u6ce2\u90a3\u5951\u6570\u5217\u7684\u7ec4\u5408\u6570\u8868\u793a \u00b6 \\[ F_n=C_{n-1}^{0}+C_{n-2}^{1}+\\dots+C_{n-i-1}^{i}\\\\ =\\sum_{i=0}^{(n+1)/2}C_{n-i-1}^{i} \\] \u8bc1\u660e\u65b9\u6cd5\uff1a\u8003\u8651\u4e0a\u697c\u68af\u65f6+2\u7684\u6b21\u6570\u3002\u6bcf\u67091\u4e2a+2\uff0c\u53ef\u9009\u62e9\u7684\u4f59\u5730\u5c31\u51cf\u5c111\u3002 $$ 1+1+1+1\\ 1+1+2\\ 1+2+1\\ 2+1+1\\ 2+2 $$ \u7b2c\u4e00\u7c7b\uff08\u65e0\u7b26\u53f7\uff09\u65af\u7279\u6797\u6570 \u00b6 n\u4e2a\uff08\u4e0d\u540c\uff09\u5143\u7d20\u5206\u6210k\u4e2a\u73af\u7684\u5206\u6cd5\u6570\u76ee $$ s(n,k)=\\begin{bmatrix} n\\k \\end{bmatrix}\\ s(0,0)=s(n,0)=s(0,n)=0\\ s(n+1,k)=ns(n,k)+s(n,k-1) $$ \u6027\u8d28 \uff1a $$ s(n,1)=(n-1)!\\ s(n,2)=(n-1)!\\sum_{i=1}^{n-1}\\frac 1i $$ \u7b2c\u4e8c\u7c7b\u65af\u7279\u6797\u6570 \u00b6 n\u4e2a\uff08\u4e0d\u540c\uff09\u5143\u7d20\u5206\u6210k\u4e2a\u975e\u7a7a\u5b50\u96c6\u7684\u65b9\u6cd5\u6570\u76ee $$ S(n,k)=\\begin{Bmatrix} n\\k \\end{Bmatrix}\\ \\begin{Bmatrix} 0\\0 \\end{Bmatrix}=1, \\begin{Bmatrix} 0\\n \\end{Bmatrix}= \\begin{Bmatrix} n\\0 \\end{Bmatrix}=0 \\ \\begin{Bmatrix} n\\k \\end{Bmatrix}=\\begin{Bmatrix} n-1\\k-1 \\end{Bmatrix}+k\\begin{Bmatrix} n-1\\k \\end{Bmatrix} $$ \u6027\u8d28 \uff1a\uff08\u6ca1\u4ec0\u4e48\u5375\u7528= =\uff09 $$ \\begin{Bmatrix} n\\k \\end{Bmatrix}=0~(k>n)\\ \\begin{Bmatrix} n\\n \\end{Bmatrix}=1\\ \\begin{Bmatrix} n\\2 \\end{Bmatrix}=2^{n-1}-1\\ \\begin{Bmatrix} n\\3 \\end{Bmatrix}=\\frac12(3 {n-1}+1)-2 $$ \u901a\u9879\u516c\u5f0f \uff1a $$ \\begin{Bmatrix} n\\k \\end{Bmatrix}=\\frac1{k!}\\sum_{i=0} k(-1) i{k\\choose i}(k-i)^n\\ =\\begin{align }\\left{\\begin{matrix}n\\m\\end{matrix}\\right}=\\sum\\limits_{k=0} m\\dfrac{(-1) k}{k!}\\dfrac{(m-k)^n}{(m-k)!}\\end{align } $$ \u548c\u9012\u51cf\u9636\u4e58\u7684\u5173\u7cfb\uff1a $$ \\begin{align }x n=\\sum\\limits_{k=1} n\\left{\\begin{matrix}n\\k\\end{matrix}\\right}x^\\underline k\\end{align } $$ \\[ x^{\\overline n}=x(x+1)\\cdots(x+n-1)\\\\ x^{\\underline n}=x(x-1)\\cdots(x-n+1)\\\\ \\] \u9519\u6392 \u00b6 \u7b80\u5316\u516c\u5f0f \uff1a $$ D_n=\\lfloor\\frac{n!}{e}+0.5\\rfloor $$ \u9012\u63a8\u516c\u5f0f \uff1a $$ D_n=nD_{n-1}+(-1)^n\\ D_n=(n-1)(D_{n-1}-D_{n-2})\\ (D_1=0,D_2=1) $$ Dilworth\u5b9a\u7406 \u00b6 \u5b9a\u7406 \uff1a\u5bf9\u4e8e\u4e00\u4e2a\u504f\u5e8f\u96c6\uff0c\u5176\u6700\u5c11\u94fe\u5212\u5206\u6570\u7b49\u4e8e\u5176\u6700\u957f\u53cd\u94fe\u7684\u957f\u5ea6\u3002 \u5bf9\u5076\u5b9a\u7406 \uff1a\u5bf9\u4e8e\u4e00\u4e2a\u504f\u5e8f\u96c6\uff0c\u5176\u6700\u5c11\u53cd\u94fe\u5212\u5206\u6570\u7b49\u4e8e\u5176\u6700\u957f\u94fe\u7684\u957f\u5ea6\u3002 \u6700\u5c11\u4e0a\u5347\u5b50\u5e8f\u5217\u5212\u5206\u6570=\u6700\u957f\u4e0d\u4e0a\u5347\u5b50\u5e8f\u5217\u957f\u5ea6 \u2b50\u653e\u7403\u95ee\u9898 \u00b6 1\u3001\u7403\u540c\uff0c\u76d2\u540c\uff0c\u76d2\u4e0d\u53ef\u4ee5\u4e3a\u7a7aPm\uff08N\uff09--\u8fd9\u7b26\u53f7\u8868\u793a\u90e8\u5206\u6570\u4e3am\u7684N-\u5206\u62c6\u7684\u4e2a\u6570\uff0cm\u662fP\u7684\u4e0b\u6807\uff0c\u4e3a\u4e86\u597d\u770b\u6211\u5c06\u5927\u5199\u7684M\u5f04\u6210\u5c0f\u5199 2\u3001\u7403\u540c\uff0c\u76d2\u540c\uff0c\u76d2\u53ef\u4ee5\u4e3a\u7a7a Pm\uff08N+M\uff09--\u4e3a\u4ec0\u4e48\u8981\u52a0M\uff0c\u4e0e4\u4e3a\u4ec0\u4e48\u8981\u57283\u7684\u57fa\u7840\u4e0a\u52a0M\u662f\u4e00\u6837\u7684\uff0c\u5c31\u662f\u4e3a\u4e86\u4fdd\u8bc1\u4e0d\u4e3a\u7a7a 3\u3001\u7403\u540c\uff0c\u76d2\u4e0d\u540c\uff0c\u76d2\u4e0d\u53ef\u4ee5\u4e3a\u7a7aC(N-1, M-1) 4\u3001\u7403\u540c\uff0c\u76d2\u4e0d\u540c\uff0c\u76d2\u53ef\u4ee5\u4e3a\u7a7a C(N+M-1, M-1) 5\u3001\u7403\u4e0d\u540c\uff0c\u76d2\u540c\uff0c\u76d2\u4e0d\u53ef\u4ee5\u4e3a\u7a7aS(N, M) --\u7b2c\u4e8c\u7c7b\u65af\u7279\u6797\u6570 6\u3001\u7403\u4e0d\u540c\uff0c\u76d2\u540c\uff0c\u76d2\u53ef\u4ee5\u4e3a\u7a7a S (N, 1) + S(N, 2) + S(N, 3) + ... + S(N, M) 7\u3001\u7403\u4e0d\u540c\uff0c\u76d2\u4e0d\u540c\uff0c\u76d2\u4e0d\u53ef\u4ee5\u4e3a\u7a7aM! * S(N, M) 8\u3001\u7403\u4e0d\u540c\uff0c\u76d2\u4e0d\u540c\uff0c\u76d2\u53ef\u4ee5\u4e3a\u7a7a M^N--\u8868\u793aM\u7684N\u6b21\u65b9 1\u30018\u4e2a\u76f8\u540c\u7684\u7403\u653e\u8fdb4\u4e2a\u76f8\u540c\u7684\u76d2\u5b50\u91cc\uff0c\u6bcf\u76d2\u81f3\u5c11\u4e00\u4e2a\uff0c\u6709\u51e0\u79cd\u65b9\u6cd5\uff1f \u516c\u5f0f\uff1a\u7403\u76f8\u540c\uff0c\u76d2\u76f8\u540c\uff0c\u62c6\u5206\u516c\u5f0f\u3002 P4(8)=P1(4)+P2(4)+P3(4)+P4(4) =1+2+1+1 =5 2\u30018\u4e2a\u76f8\u540c\u7684\u7403\u653e\u8fdb4\u4e2a\u4e0d\u540c\u7684\u76d2\u5b50\u91cc\uff0c\u6bcf\u76d2\u81f3\u5c11\u4e00\u4e2a\uff0c\u6709\u51e0\u79cd\u65b9\u6cd5\uff1f \u516c\u5f0f\uff1a\u7403\u76f8\u540c\uff0c\u76d2\u4e0d\u540c\uff0c\u63d2\u677f\u6cd5\u3002 C(8-1,4-1) =C(7,3) =7 6 \u215a =35 3\u30018\u4e2a\u4e0d\u540c\u7684\u7403\u653e\u8fdb4\u4e2a\u4e0d\u540c\u7684\u76d2\u5b50\u91cc\uff0c\u6bcf\u76d2\u81f3\u5c11\u4e00\u4e2a\uff0c\u6709\u51e0\u79cd\u65b9\u6cd5\uff1f \u516c\u5f0f\uff1a\u7403\u4e0d\u540c\uff0c\u76d2\u4e0d\u540c\uff0c\u4e0d\u4e3a\u7a7a\uff0c\u9636\u4e58\u548c\u4e8c\u7c7b\u65af\u7279\u6797\u6570\uff0c\u7403\u662f\u884c\u53f7\uff0c\u76d2\u5b50\u662f\u5217\u53f7\u3002 M! S(N,M) =4! * S(8,4) =24 1701 =40824 4\u30018\u4e2a\u4e0d\u540c\u7684\u7403\u653e\u8fdb4\u4e2a\u76f8\u540c\u7684\u76d2\u5b50\u91cc\uff0c\u6bcf\u76d2\u81f3\u5c11\u4e00\u4e2a\uff0c\u6709\u51e0\u79cd\u65b9\u6cd5 \uff1f \u516c\u5f0f\uff1a\u7403\u4e0d\u540c\uff0c\u76d2\u540c\uff0c\u4e8c\u7c7b\u65af\u7279\u6797\u6570\uff0c\u4e3a\u7a7a\u662f\u7d2f\u52a0\uff0c\u4e0d\u4e3a\u7a7a\u662f\u76f4\u63a5\u53d6\u6570\uff0c\u7403\u662f\u884c\u53f7\uff0c\u76d2\u5b50\u662f\u5217\u53f7\u3002 S(N,M) =S(8,4) =1701 5\u30018\u4e2a\u76f8\u540c\u7684\u7403\u653e\u8fdb4\u4e2a\u76f8\u540c\u7684\u76d2\u5b50\u91cc\uff0c\u6709\u51e0\u79cd\u65b9\u6cd5 \uff1f \u516c\u5f0f\uff1a\u7403\u540c\uff0c\u76d2\u540c\uff0c\u4e3a\u7a7a\uff0c\u62c6\u5206\u516c\u5f0f\u3002 P4(8+4)=P4(12) =P1(8)+P2(8)+P3(8)+P4(8) =1+4+(P1(5)+P2(5)+P3(5))+(P1(4)+P2(4)+P3(4)+P4(4)) =1+4+(1+2+(P1(2)+P2(2))+(1+2+1+1) =1+4+5+5 =15 6\u30018\u4e2a\u76f8\u540c\u7684\u7403\u653e\u8fdb4\u4e2a\u4e0d\u540c\u7684\u76d2\u5b50\u91cc\uff0c\u6709\u51e0\u79cd\u65b9\u6cd5\uff1f \u516c\u5f0f\uff1a\u7403\u540c\uff0c\u76d2\u4e0d\u540c\uff0c\u63d2\u677f\u6cd5\u3002 C(11,3) =11 10 9/6=15*11=165 7\u30018\u4e2a\u4e0d\u540c\u7684\u7403\u653e\u8fdb4\u4e2a\u4e0d\u540c\u7684\u76d2\u5b50\u91cc\uff0c\u6709\u51e0\u79cd\u65b9\u6cd5 \uff1f \u516c\u5f0f\uff1a\u7403\u4e0d\u540c\uff0c\u76d2\u4e0d\u540c\uff0c\u4e3a\u7a7a\uff0c\u76f4\u63a5\u662fM^N 4 8=4 4 4 4=2 8 2^8=256*256=65536 8\u30018\u4e2a\u4e0d\u540c\u7684\u7403\u653e\u8fdb4\u4e2a\u76f8\u540c\u7684\u76d2\u5b50\u91cc\uff0c\u6709\u51e0\u79cd\u65b9\u6cd5\uff1f \u516c\u5f0f\uff1a\u7403\u4e0d\u540c\uff0c\u76d2\u540c\uff0c\u4e8c\u7c7b\u65af\u7279\u6797\u6570\uff0c\u4e3a\u7a7a\uff0c\u662f\u7d2f\u52a0 S (N, 1) + S(N, 2) + S(N, 3) + ... + S(N, M) =S\uff088,1)+S\uff088,2)+S\uff088,3)+S\uff088,4) =1+127+966+1701 =2795 9\u30018\u4e2a\u4e0d\u540c\u7684\u7403\u5e73\u5747\u5206\u7ed94\u4e2a\u5c0f\u670b\u53cb\uff0c\u6709\u51e0\u79cd\u5206\u6cd5\uff1f \u4ece8\u4e2a\u7403\u4e2d\u53d62\u4e2a\u5206\u7ed9\u7b2c1\u4e2a\u5c0f\u670b\u53cb\uff0c\u4ece\u5269\u4e0b6\u4e2a\u4e2d\u53d62\u4e2a\u6765\u5206\u7ed9\u7b2c\u4e8c\u4e2a\u5c0f\u670b\u53cb\u3002\u3002\u3002 C(8,2) C(6,2) C(4,2)*C(2,2) = 2520 10\u30018\u4e2a\u4e0d\u540c\u7684\u7403\u5e73\u5747\u5206\u62104\u5806\uff0c\u6709\u51e0\u79cd\u5206\u6cd5\uff1f C(8,2) C(6,2) C(4,2)*C(2,2) / 4!= 2520/24 =105 \u7ebf\u6027\u4ee3\u6570 \u00b6 \u9ad8\u65af\u6d88\u5143 \u00b6 P2962 [USACO09NOV]Lights G \u9898\u610f\uff1a\u7ed9n\u4e2a\u70b9m\u6761\u8fb9\uff0cn\u4e2a\u70b9\u4e00\u5f00\u59cb\u5168\u662f0\uff0c\u6309\u4e0b\u4e00\u4e2a\u70b9\u4f7f\u5f97\u8be5\u70b9\u548c\u5176\u4ed6\u4e0e\u8be5\u70b9\u76f8\u8fde\u7684\u70b9\u7684\u72b6\u6001\u6539\u53d8\uff08\u5f02\u6216\uff09\uff0c\u6c42\u4f7f\u5f97\u6240\u6709\u70b9\u5168\u4e3a1\u7684\u6700\u5c0f\u6309\u4e0b\u6b21\u6570\u3002 \u89e3\uff1a\u6839\u636e\u70b9\u7684\u5173\u7cfb\u5217\u65b9\u7a0b\uff08\u53ea\u662f\u52a0\u6cd5\u6539\u4e3a\u4e58\u6cd5\uff09\uff0c\u7136\u540e\u505a\u9ad8\u65af\u6d88\u5143\uff0cdfs\u6c42\u51fa\u5404\u4e2ax\u4e3a1\u8fd8\u662f\u4e3a0\uff0c\u66f4\u65b0\u7b54\u6848 \u77e9\u9635\u4f18\u5316 \u00b6 P2044 [NOI2012]\u968f\u673a\u6570\u751f\u6210\u5668 \u9898\u610f\uff1a\u6c42 $$ X_n\\mod g $$ \u5176\u4e2d $$ X_{n+1}=(aX_n+c)\\mod m $$ \u89e3\uff1a\u8bbe $$ A=\\begin{bmatrix} X_n & a_{11}\\ a_{21} & a_{22} \\end{bmatrix}\\ B=\\begin{bmatrix} b_{11} & b_{11}\\ b_{21} & b_{22} \\end{bmatrix}\\ $$ AB\u4e58\u79ef\u5e94\u8be5\u4ecd\u662fA\u7684\u5f62\u5f0f\uff0c\u53ea\u4e0d\u8fc7X_n\u53d8\u4e3aX_{n+1}=aX_n+c\uff0c\u6839\u636e\u5173\u7cfb\u53ef\u4ee5\u6c42\u51fa\u77e9\u9635\u4e2d\u7684\u5f85\u5b9a\u7cfb\u6570\u4e3a $$ A=\\begin{bmatrix} X_0 & 1\\ 0 & 0 \\end{bmatrix}\\ B=\\begin{bmatrix} a & 0\\ c & 1 \\end{bmatrix}\\ $$ \u5957\u7528\u77e9\u9635\u5feb\u901f\u5e42\uff08\u5176\u4e2d\u4e58\u6cd5\u7528\u5feb\u901f\u4e58\u6cd5\u4ee5\u9632\u6b62\u7206longlong\uff09\u5373\u53ef \u5f02\u6216 \u00b6 \u5355\u4f4d\u5143\uff1a0 \u9006\u5143\uff1a \\(x^{-1}=x\\) \u96f6\u5143\uff1a\u4e0d\u5b58\u5728 \u8fd0\u7b97\u5f8b\uff1a\u4ea4\u6362\u5f8b\u3001\u7ed3\u5408\u5f8b \u6709\u5173\u516c\u5f0f\uff1a \\(a\\and b=a|b-a\\oplus b\\) \\(a+b=((a\\&b)<<1 )|(a\\oplus b)\\) \u7ebf\u6027\u57fa \u00b6 \u53ef\u5728\u5bf9\u6570\u65f6\u95f4\u5185\u5b8c\u6210\u63d2\u5165\u3001\u67e5\u8be2\u96c6\u5408\u6700\u5927\u503c\u548c\u6700\u5c0f\u5f02\u6216\u548c\u7684\u64cd\u4f5c\u3002 \u5b8c\u6210\u91cd\u6784\u64cd\u4f5c\u540e\uff08\u82b1\u8d39\u5bf9\u6570\u5e73\u65b9\u7684\u65f6\u95f4\uff09\u53ef\u8f6c\u6362\u4e3a\u5f62\u4f3c\u4e8e\u6700\u7b80\u884c\u9636\u68af\u578b\u77e9\u9635\u7684\u5f62\u5f0f\uff0c\u4e4b\u540e\u53ef\u5728\u5bf9\u6570\u65f6\u95f4\u5185\u67e5\u8be2\u96c6\u5408\u5185\u7b2ck\u5927\u5f02\u6216\u548c\u3002 \u6700\u5927\u503c \uff08restructure\u524d\uff09\u4ece\u5927\u5230\u5c0f\u679a\u4e3e\u6bcf\u4e2a\u6570\u5f02\u6216\u8fdb\u6765\u4f1a\u4e0d\u4f1a\u4f7f\u5f97\u7b54\u6848\u66f4\u5927\uff0c\u5982\u679c\u4f1a\u5c31\u5f02\u6216\u8fdb\u6765\u3002 \u5982\u679c\u9700\u8981\u5728\u5f02\u6216\u521d\u503c\u4e0d\u4e3a\u96f6\u7684\u60c5\u51b5\u4e0b\u53d6\u5f97\u6700\u5927\u503c\uff0c\u53ea\u9700\u8981\u66f4\u6539ans\u7684\u521d\u59cb\u503c\u5373\u53ef\u3002 \u6700\u5c0f\u503c \uff1a \u76f4\u63a5\u8d2a\u5fc3\u62ff\u7ebf\u6027\u57fa\u4e2d\u6700\u5c0f\u7684\u6570\uff08\u5f53\u7136\uff0c\u9700\u8981\u7279\u5224\u7ebf\u6027\u57fa\u662f\u5426\u53ef\u83b7\u5f970\uff09 - HDOJ 3949 \u7b2ck\u5927\u5f02\u6216\u548c \u6a21\u677f\u9898 P4151 \u6700\u5927xor\u8def\u5f84 \u7ed9\u5b9a\u65e0\u5411\u56fe\uff08\u53ef\u80fd\u6709\u91cd\u8fb9\u548c\u81ea\u73af\uff09\uff0c\u6c421\u5230n\u53f7\u70b9\u7684\u6700\u5927xor\u8def\u5f84\u548c\u3002 \u89e3\u6cd5\uff1a\u7531\u4e8e\u5f02\u6216\u7684\u6027\u8d28\uff0c\u6bcf\u6761\u8fb9\u6700\u591a\u8d70\u4e00\u6b21\uff0c\u4e14\u73af\u4e0a\u8f6c\u4e00\u5708\u80fd\u56de\u5230\u539f\u70b9\uff0c\u4ece\u539f\u70b9\u518d\u7ee7\u7eed\u8d70\u5c31\u76f8\u5f53\u4e8e\u767d\u5ad6\u4e86\u73af\u4e0a\u7684\u6743\u503c\u548c\u3002\u56e0\u6b64\u968f\u4fbf\u627e\u4e00\u6761\u4ece1\u5230n\u7684\u8def\u5f84\uff0c\u8fd9\u65f6\u9898\u76ee\u7b49\u4ef7\u4e8e\u9009\u51e0\u4e2a\u7b80\u5355\u73af\u548c\u73b0\u6709\u7b54\u6848\u5f02\u6216\u4f7f\u5f97\u7b54\u6848\u6700\u5927\uff0c\u518d\u7528dfs\u627e\u5230\u56fe\u4e2d\u6240\u6709\u7b80\u5355\u73af\u5e76\u628a\u7b80\u5355\u73af\u7684\u5f02\u6216\u548c\u6dfb\u52a0\u5230\u7ebf\u6027\u57fa\u4e2d\u5373\u53ef\u3002 P4301 \u65b0nim\u6e38\u620f \u5728\u7b2c\u4e00\u4e2a\u56de\u5408\u4e2d\uff0c\u7b2c\u4e00\u4e2a\u6e38\u620f\u8005\u53ef\u4ee5\u76f4\u63a5\u62ff\u8d70\u82e5\u5e72\u4e2a\u6574\u5806\u7684\u706b\u67f4\u3002\u53ef\u4ee5\u4e00\u5806\u90fd\u4e0d\u62ff\uff0c\u4f46\u4e0d\u53ef\u4ee5\u5168\u90e8\u62ff\u8d70\u3002\u7b2c\u4e8c\u56de\u5408\u4e5f\u4e00\u6837\uff0c\u7b2c\u4e8c\u4e2a\u6e38\u620f\u8005\u4e5f\u6709\u8fd9\u6837\u4e00\u6b21\u673a\u4f1a\u3002\u4ece\u7b2c\u4e09\u4e2a\u56de\u5408\uff08\u53c8\u8f6e\u5230\u7b2c\u4e00\u4e2a\u6e38\u620f\u8005\uff09\u5f00\u59cb\uff0c\u89c4\u5219\u548c Nim \u6e38\u620f\u4e00\u6837\u3002 \u5982\u679c\u4f60\u5148\u62ff\uff0c\u600e\u6837\u624d\u80fd\u4fdd\u8bc1\u83b7\u80dc\uff1f\u5982\u679c\u53ef\u4ee5\u83b7\u80dc\u7684\u8bdd\uff0c\u8fd8\u8981\u8ba9\u7b2c\u4e00\u56de\u5408\u62ff\u7684\u706b\u67f4\u603b\u6570\u5c3d\u91cf\u5c0f\u3002 \u89e3\u6cd5\uff1a\u6392\u5e8f\u7136\u540e\u5012\u7740\uff08\u4ece\u5927\u5230\u5c0f\uff09\u63d2\u5165\u7ebf\u6027\u57fa\uff0c\u5982\u679c\u63d2\u5165\u5931\u8d25\u5c31\u7d2f\u52a0\u5230\u7b54\u6848\u4e2d\u3002\uff08\u8fd9\u9898\u4e0d\u53ef\u80fd\u8f93\u51fa-1\uff09 P4869 albus\u5c31\u662f\u8981\u7b2c\u4e00\u4e2a\u51fa\u573a \u7ed9n\u4e2a\u6570ai\u548c\u4e00\u4e2a\u6570q\uff0cn\u4e2a\u6570\u7684\uff08\u591a\u91cd\u96c6\u7684\uff09\u5b50\u96c6\u5f02\u6216\u503c\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\u5f97\u5e8f\u5217b\uff0c\u6c42q\u5728b\u4e2d\u9996\u6b21\u51fa\u73b0\u7684\u4e0b\u6807\u3002 \u89e3\u6cd5\uff1a\u5c06a\u4e2d\u7684\u6570\u5168\u90e8\u63d2\u5165\u7ebf\u6027\u57fa\u5e76restructure\uff0c\u5229\u7528\u4e8c\u5206\u5728\u7ebf\u6027\u57fa\u4e2d\u6c42\u5f97q\u7684\u6392\u540d\uff0c\u663e\u7136q\u5c31\u662fa\u53bb\u91cd\u540e\u5f97\u5230\u7684b'\u7684\u4e0b\u6807\u3002 \u6839\u636e\u201c\u4e0d\u53bb\u91cd\u5f02\u6216\u96c6\u5408\u201d\u7684\u63a8\u8bba\uff0c\u4e0d\u53bb\u91cd\u5f02\u6216\u96c6\u5408\u5f97\u5230\u7684\u5e8f\u5217b'\uff0c\u5e94\u8be5\u662f\u53bb\u91cd\u5f02\u6216\u96c6\u5408b\u4e2d\u7684\u6bcf\u4e2a\u6570\u91cd\u590d \\(2^{n-lb.cnt}\\) \u6b21\u5f97\u5230\u7684\u3002\u56e0\u6b64\u5c06\u521a\u521a\u5f97\u5230\u7684\u4e0b\u6807\u51cf\u53bb1\uff0c\u4e58\u4e0a\u8fd9\u4e2a\u6570\uff0c\u518d\u52a01\uff0c\u5373\u53ef\u5f97\u5230\u7b54\u6848\u3002 \u751f\u6210\u51fd\u6570 \u00b6 \u666e\u901a\u751f\u6210\u51fd\u6570 \u00b6 \u5e42\u7ea7\u6570 \uff1a $$ F(x)=\\sum_{n=0}^\\infty a_nx^n $$ \u5982\u679c\u5e8f\u5217a\u6709\u901a\u9879\u516c\u5f0f\uff0c\u90a3\u4e48\u5b83\u7684\u666e\u901a\u751f\u6210\u51fd\u6570\u7684\u7cfb\u6570\u5c31\u662f\u901a\u9879\u516c\u5f0f\u3002\u4f8b\u5982 \\( \\(a=<1,2,4,8,16,...>\\) \\) \u7684\u751f\u6210\u51fd\u6570\u662f \\( \\(\\sum_{n\\ge 0} 2^nx^n\\) \\) \u52a0\u6cd5 \uff1a $$ F(x)\\pm G(x)=\\sum_n (a_n\\pm b_n)x^n $$ \u56e0\u6b64 \\( \\(F(x)\\pm G(x)\\) \\) \u662f\u5e8f\u5217 \\( \\(<a_n\\pm b_n>\\) \\) \u7684\u666e\u901a\u751f\u6210\u51fd\u6570\u3002 \u4e58\u6cd5\uff08\u5377\u79ef\uff09 \uff1a $$ F(x)G(x)=\\sum_n x^n \\sum_{i=0}^na_ib_{n-i} $$ \u56e0\u6b64 \\( \\(F(x)G(x)\\) \\) \u662f\u5e8f\u5217 \\( \\(<\\sum_{i=0}^na_ib_{n-i}>\\) \\) \u7684\u666e\u901a\u751f\u6210\u51fd\u6570\u3002 \u5e38\u7528\u5c55\u5f00 \uff1a \u7b49\u6bd4\u7ea7\u6570 $$ \\frac1{1-x}=\\sum_{n=0}^\\infty x^n\\ \\frac1{1-kx}=\\sum_{n=0}^\\infty k nx n $$ <0,1,1,1,....> $$ F(x)=\\frac x{1-x} $$ \u5076\u6570<1,0,1,0,1,..> $$ F(x)=\\frac 1{1-x^2} $$ \u7b49\u5dee<1,2,3,4,...> $$ F(x)=\\sum_{n\\ge1}nx {n-1}=(\\sum_{n\\ge1}x n)'=(\\frac{1}{1-x})'=\\frac1{(1-x)^2} $$ \u4e8c\u9879\u5f0f \\( \\(a_n=\\binom{m}{n}\\) \\) $$ F(x)=\\sum_{n\\ge0}\\binom{m}{n}x n=(1+x) m $$ \\( \\(a_n=\\binom{m+n}{n}\\) \\) $$ F(x)=\\frac{1}{(1-x)^{m+1}} $$ \u6590\u6ce2\u90a3\u5951\u6570\u5217 \u00b6 \u4e24\u79cd\u5c01\u95ed\u5f62\u5f0f\uff08\u7cfb\u6570\u5176\u5b9e\u5c31\u5bf9\u5e94\u901a\u9879\u516c\u5f0f\uff09\uff1a \u5f53 \\( \\(a_0=0,a_1=1\\) \\) \u65f6\uff08\u4f7f\u7528 \\( \\(\\frac{1}{1-kx}\\) \\) \u7684\u7ea7\u6570\u5c55\u5f00\uff09 $$ F(x)=xF(x)+x^2F(x)-a_0x+a_1x+a_0\\ \\Rightarrow F(x)=\\frac{x}{1-x-x^2}=\\frac{\\frac1{\\sqrt5}}{1-\\frac{1+\\sqrt5}{2}x}-\\frac{\\frac1{\\sqrt5}}{1-\\frac{1-\\sqrt5}{2}x}\\ =\\frac1{\\sqrt5}\\sum_{n=0}^\\infty x n((\\frac{1+\\sqrt5}{2}) n-(\\frac{1-\\sqrt5}{2})^n) $$ \u5f53 \\( \\(a_0=1,a_1=1\\) \\) \u65f6 $$ F(x)=\\frac{1}{1-x-x 2}=\\sum_{n\\ge0}x n\\sum_{i=0}^n\\binom{n-i}{i} $$ \u5361\u7279\u5170\u6570 \u00b6 \\[ H_n=\\sum_{i=0}^{n-1}H_iH_{n-i-1}~(n\\ge1)\\\\ H_0=H_1=1 \\] \u751f\u6210\u51fd\u6570 $$ H(x)=\\sum_{n\\ge0}H_nx n=1+x\\sum_{n\\ge1}\\sum_{i=0} H_ix iH_{n-i-1}x \\ =1+x\\sum_{i\\ge0}H_ix i\\sum_{n\\ge0}H_nx n=1+xH(x)^2 $$ \u5f97 $$ H(x)=\\frac{1\\pm\\sqrt{1-4x}}{2x}=\\frac2{1\\mp\\sqrt{1-4x}} $$ \u53c8 \\( \\(H(0)=1\\) \\) \uff0c\u56e0\u6b64\u53d6\u6b63\u6839\uff0c\u5219\u5229\u7528\u725b\u987f\u4e8c\u9879\u5f0f\u5b9a\u7406\u5c55\u5f00 \\( \\(\\sqrt{1-4x}\\) \\) \uff0c\u7136\u540e\u518d\u4ee3\u56de\u53bb\u7ecf\u8fc7\u4e00\u756a\u8fd0\u7b97\u53ef\u5f97 $$ H(x)=\\frac1{2x}\\sum_{n\\ge1}\\binom{2n-1}{n}\\frac1{(2n-1)}2x n=\\cdots=\\sum_{n\\ge0}\\binom{2n}{n}\\frac1{n+1}x n $$ BZOJ \u6709 n \u5806\u7cd6\u679c\u3002\u4e0d\u540c\u7684\u5806\u91cc\u7cd6\u679c\u7684\u79cd\u7c7b\u4e0d\u540c\uff08\u5373\u540c\u4e00\u4e2a\u5806\u91cc\u7684\u7cd6\u679c\u79cd\u7c7b\u662f\u76f8\u540c\u7684\uff0c\u4e0d\u540c\u7684\u5806\u91cc\u7684\u7cd6\u679c\u7684\u79cd\u7c7b\u662f\u4e0d\u540c\u7684\uff09\u3002\u7b2ci\u4e2a\u5806\u91cc\u6709 \u4e2a\u7cd6\u679c\u3002\u73b0\u5728\u8981\u5403\u6389\u81f3\u5c11a\u4e2a\u7cd6\u679c\uff0c\u4f46\u4e0d\u8d85\u8fc7b\u4e2a\u3002\u6c42\u6709\u591a\u5c11\u79cd\u65b9\u6848\u3002 \\[n\\le 10,0\\le a\\le b\\le 10^7,m_i\\le 10^6\\] i\u5806\u5403j\u4e2a\u7684\u751f\u6210\u51fd\u6570 $$ F_i(x)=\\sum_{j=0} {m_i}x j=\\frac{1-x^{m_i+1}}{1-x} $$ \u8003\u8651\u6240\u6709\u5806\u5c31\u662f\u4e58\u8d77\u6765\uff0c\u5bf9\u5e94\u751f\u6210\u51fd\u6570 $$ G(x)=\\prod_{i=1}^n F_i(x)=(1-x) {-n}\\prod_{i=1} n(1-x^{m_i+1}) $$ \u5176\u4e2d $$ \\begin{aligned} (1-x)^{-n} &=\\sum_{i\\ge 0}\\binom{-n}{i}(-x)^i\\ &=\\sum_{i\\ge 0}\\binom{n-1+i}{i}x^i \\end{aligned} $$ \u53f3\u4fa7\u5f0f\u5b50\u5728n\u8f83\u5c0f\u65f6\u80fd\u591f\u66b4\u529b\u5c55\u5f00\uff0c\u8bbe\u5176\u5c55\u5f00\u540e \\( \\(x^k\\) \\) \u5bf9\u5e94\u7cfb\u6570\u4e3a \\( \\(c_k\\) \\) \uff0c\u52191~b\u7684\u7b54\u6848\u4e3a $$ \\sum_{k=0} nc_k\\sum_{i=0} \\binom{n-1+i}{i}=\\sum_{k=0}^nc_k\\binom{n+b-k}{n} $$ \u6307\u6570\u751f\u6210\u51fd\u6570 \u00b6 \\[ \\hat F(x)=\\sum_{n}a_n\\frac{x^n}{n!} \\] \u52a0\u6cd5 \uff1a\u5bf9\u5e94\u9879\u7cfb\u6570\u76f8\u52a0 \u4e58\u6cd5\uff08\u5377\u79ef\uff09 \uff1a $$ \\hat F(x)\\hat G(x)=\\sum_{i\\ge0}a_i\\frac{x i}{i!}\\sum_{j\\ge0}b_j\\frac{x j}{j!}\\ =\\sum_{n\\ge0}x n\\sum_{i=0} na_ib_{n-i}\\frac1{i!(n-i)!}\\ =\\sum_{n\\ge0}\\frac{x n}{n!}\\sum_{i=0} na_ib_{n-i}\\binom{n}{i} $$ \u56e0\u6b64\u5176\u662f\u5e8f\u5217 \\( \\(<\\sum_{i=0}^n\\binom{n}{i}a_ib_{n-i}>\\) \\) \u7684\u6307\u6570\u751f\u6210\u51fd\u6570 \u5e38\u89c1\u5c55\u5f00 \uff1a \\[<1,1,\\cdots>$$ $$ \\hat F(x)=\\sum_{n\\ge0}\\frac{x^n}{n!}=e^x $$ \u7b49\u6bd4\u6570\u5217$$<1,p,p^2,\\cdots>$$ $$ \\hat F(x)=\\sum_{n\\ge0}p^n\\frac{x^n}{n!}=e^{xp} \\] \u5706\u6392\u5217 \u00b6 n\u4e2a\u9009r\u4e2a\u7684\u5706\u6392\u5217\uff1a\uff08\u5148\u7528\u666e\u901a\u7684\u6392\u5217\uff0c\u7136\u540e\u53bb\u9664\u8f6c1\u30012\u3001...\u3001r\u6b21\u7684\u60c5\u51b5\u5171r\u79cd\uff0c\u56e0\u6b64\u9664\u4ee5r\uff09 $$ Q(n,r)=\\frac{P(n,r)}{r}=\\frac{n!}{r(n-r)!} $$ \u7279\u522b\u5730\uff0cn\u4e2a\u6570\u7684\u5168\u5706\u6392\u5217\u662f(n-1)!\u79cd\u3002 \u751f\u6210\u51fd\u6570\uff08\u5176\u5173\u4e8ee\u7684\u6307\u6570\uff0c\u5c31\u662f\u4e00\u822c\u6392\u5217\u7684\u6307\u6570\u751f\u6210\u51fd\u6570\uff09 $$ \\hat Q(x)=\\sum_{n\\ge1}\\frac{(n-1)!x n}{n!}=\\sum_{n\\ge1}\\frac{x n}{n}=-\\ln(1-x)\\ \\Rightarrow e^{\\hat Q(x)}=\\hat P(x)=\\frac{1}{1-x} $$ \u4e8b\u5b9e\u4e0a\uff0c\u8bbe\u6392\u5217\u6570\u4e3ap(n)\uff0c\u5219\u5176\u53ef\u4ee5\u770b\u6210\u679a\u4e3e\u5176\u7531k\u4e2a\u6362\u6392\u5217\u6784\u6210\u5e76\u6c42\u548c\u5f97\u5230\uff0c\u8bbe \\( \\(q_k(n)\\) \\) \u8868\u793a\u6392\u5217\u7531k\u4e2a\u7f6e\u6362\u7ec4\u6210\u7684\uff0cc(n)\u8868\u793a\u5706\u6392\u5217\u4e2a\u6570 $$ p(n)=\\sum_{k=1}^nq_k(n)\\ \\hat P(x)=\\sum_{n\\ge1}\\sum_{k=1} nq_k(n)\\frac{x n}{n!}=\\sum_{k=1}^n\\hat q_k(x) $$ \\( \\(q_k(n)\\) \\) \u7684\u751f\u6210\u51fd\u6570\u548c \\( \\(c(n)\\) \\) \u7684\u751f\u6210\u51fd\u6570\u6709\u5982\u4e0b\u5173\u7cfb\uff1a \u53c2\u8003\u8bf7\u89c1\u6b64 $$ \\hat q_k(x)=\\frac1{k!}\\hat c(x)^k $$ \u5219 $$ \\hat P(x)=\\sum_{k=1}^n \\frac1{k!}\\hat c(x) k=e $$ \u9519\u6392\u6570 \u00b6 \u53ef\u4ee5\u770b\u6210\u6ca1\u6709\u957f\u5ea6\u4e3a1\u7684\u73af\u7684\u6392\u5217\uff0c\u56e0\u6b64\u5176\u751f\u6210\u51fd\u6570 $$ \\hat R(x)=\\sum_{n\\ge2}\\frac{x^n}{n}=-\\ln(1-x)-x $$ \u4e94\u8fb9\u5f62\u6570\u3001\u6574\u6570\u5206\u62c6 \u00b6 \u53c2\u8003\uff1a https://www.zhihu.com/question/364818496 \u9012\u63a8\u516c\u5f0f \uff1a $$ f_1=1,f_n=f_{n-1}+3n-2 $$ \u901a\u9879\u516c\u5f0f \uff1a $$ f_n=\\frac{n(3n-1)}{2} $$ \u7279\u522b\u5730\u3001\u5bf9\u4e8e\u5e7f\u4e49\u4e94\u8fb9\u5f62\u6570\uff0c\u4e0a\u5f0f\u7684n\uff1an=0,1,-1,2,-2,... $$ F_n=\\frac{n(3n\\pm 1)}{2} $$ \u6b27\u62c9\u51fd\u6570\uff08\u590d\u53d8\u51fd\u6570)\u7684\u5c55\u5f00\u5f0f \uff1a $$ \\phi(q)=\\prod_{k=1} \\infty(1-q k) $$ \u6574\u6570\u5206\u62c6\u7684\u751f\u6210\u51fd\u6570 \uff1a $$ G(x)=\\sum_{n=0}^\\infty p(n)x n=\\prod_{i=1} \\infty(\\frac{1}{1-x^i}) $$ \u4e5f\u5373\u6b27\u62c9\u51fd\u6570\u7684\u5012\u6570\u3002 \u7fa4\u8bba \u00b6 \u7fa4\u3001\u5b50\u7fa4 \u00b6 \u82e5\u96c6\u5408S\uff08\u975e\u7a7a\uff09 \u548cS \u4e0a\u7684\u8fd0\u7b97*\u6784\u6210\u7684\u4ee3\u6570\u7ed3\u6784(S,*)\u6ee1\u8db3\u4ee5\u4e0b\u6027\u8d28\uff1a \u5c01\u95ed\u6027\uff1a $$ \\forall a,b \\in S, a\\cdot b\\in S $$ \u7ed3\u5408\u5f8b\uff1a $$ \\forall a,b,c \\in S,(a\\cdot b)\\cdot c=a\\cdot(b\\cdot c) $$ \u5355\u4f4d\u5143\uff1a $$ \\exist e\\in S,\\forall a\\in S,e\\cdot a=a\\cdot e=a $$ \u9006\u5143\uff1a $$ \\forall a\\in S,\\exist b\\in S,a\\cdot b=b\\cdot a=e $$ \u79f0b\u4e3aa\u7684\u9006\u5143\uff0c\u8bb0\u4e3a(a)^(-1) \u5219\u79f0(S,*) \u4e3a\u4e00\u4e2a \u7fa4 \u3002\u4f8b\u5982\uff0c\u6574\u6570\u96c6\u548c\u6574\u6570\u95f4\u7684\u52a0\u6cd5 \u6784\u6210\u4e00\u4e2a\u7fa4\uff0c\u5355\u4f4d\u5143\u662f 0\uff0c\u4e00\u4e2a\u6574\u6570\u7684\u9006\u5143\u662f\u5b83\u7684\u76f8\u53cd\u6570\u3002 \u5b50\u7fa4\uff1a(T,*)\uff0cT\u662fS\u7684\u975e\u7a7a\u5b50\u96c6 \u7531\u4e8e\u6709\u7ed3\u5408\u5f8b\uff0c\u56e0\u6b64\u5bf9\u4e8e\u8be5\u8fd0\u7b97\u53ef\u4ee5\u4f7f\u7528\u5feb\u901f\u5e42 \u7f6e\u6362\u7fa4 \u00b6 \u628a\u96c6\u5408\u4e2d\u7684\u5143\u7d20\u6253\u4e71\u4f4d\u7f6e $$ f=\\begin{pmatrix} a_1,\\cdots,a_n\\ a_{p_1},\\cdots,a_{p_n}\\ \\end{pmatrix} $$ \u7f6e\u6362\u8fd0\u7b97\u4e5f\u6ee1\u8db3\u7fa4\u7684\u8fd0\u7b97\u7684\u6027\u8d28\uff1a\u5c01\u95ed\u6027\uff08\u7f6e\u6362\u540e\u5143\u7d20\u4ecd\u5728\u96c6\u5408\u5185\uff09\u3001\u7ed3\u5408\u5f8b\uff08\u7f6e\u6362\u4e58\u6cd5\uff09\u3001\u5355\u4f4d\u5143\uff08\u6052\u7b49\u7f6e\u6362\uff0c\u7f6e\u6362\u540e\u4f4d\u7f6e\u4e0d\u53d8\uff09\u3001\u9006\u5143\uff08\u7f6e\u6362\u7684\u53cd\u5411\u64cd\u4f5c\uff09 \u7f6e\u6362\u7684\u4e58\u6cd5\uff1a $$ f=\\begin{pmatrix} a_1,\\cdots,a_n\\ a_{p_1},\\cdots,a_{p_n}\\ \\end{pmatrix}\\ g=\\begin{pmatrix} a_{p_1},\\cdots,a_{p_n}\\ a_{q_1},\\cdots,a_{q_n}\\ \\end{pmatrix}\\ f\\circ g=\\begin{pmatrix} a_1,\\cdots,a_n\\ a_{q_1},\\cdots,a_{q_n}\\ \\end{pmatrix} $$ \u5faa\u73af\u7f6e\u6362 \u00b6 \\[ (a_1,\\cdots,a_m)=\\begin{pmatrix} a_1,a_2,\\cdots,a_n\\\\ a_n,a_1,\\cdots,a_{n-1} \\end{pmatrix} \\] \u4e24\u4e2a\u5faa\u73af\u7f6e\u6362\u4e0d\u542b\u6709\u76f8\u540c\u7684\u5143\u7d20\uff0c\u5219\u79f0\u5b83\u4eec\u662f \u4e0d\u76f8\u4ea4 \u7684\u3002 \u4efb\u610f\u4e00\u4e2a\u7f6e\u6362\u90fd\u53ef\u4ee5\u5206\u89e3\u4e3a\u82e5\u5e72\u4e0d\u76f8\u4ea4\u7684\u5faa\u73af\u7f6e\u6362\u7684\u4e58\u79ef\u3002 \uff08\u5982\u679c\u628a\u5143\u7d20\u89c6\u4e3a\u56fe\u7684\u8282\u70b9\uff0c\u6620\u5c04\u5173\u7cfb\u89c6\u4e3a\u6709\u5411\u8fb9\uff0c\u5219\u6bcf\u4e2a\u8282\u70b9\u7684\u5165\u5ea6\u548c\u51fa\u5ea6\u90fd\u4e3a 1\uff0c\u56e0\u6b64\u5f62\u6210\u7684\u56fe\u5f62\u5fc5\u5b9a\u662f\u82e5\u5e72\u4e2a\u73af\u7684\u96c6\u5408\uff0c\u800c\u4e00\u4e2a\u73af\u5373\u53ef\u7528\u4e00\u4e2a\u5faa\u73af\u7f6e\u6362\u8868\u793a\u3002\uff09 Burnside\u5f15\u7406 \u548c Polya\u5b9a\u7406 \u00b6 Burside\u5f15\u7406\uff1a $$ |X/G|=\\frac{1}{|G|}\\sum_{g\\in G}|X^g|\\ X^g={x|x\\in X,g(x)=x} $$ Polya\u5b9a\u7406\uff1a $$ |X/G|=\\frac{1}{|G|}\\sum_{g\\in G}|B|^{c(g)} $$ \u5176\u4e2d \\(c(g)\\) \u662f\u7f6e\u6362g\u80fd\u62c6\u5206\u6210\u7684\u4e0d\u76f8\u4ea4\u5faa\u73af\u7f6e\u6362\u6570\u91cf\u3002 \u5bf9\u4e8e\u65cb\u8f6c\uff1a\u5047\u8bbe\u65cb\u8f6c\u4e86k\u4e0b\uff0c\u5219\u5faa\u73af\u7f6e\u6362\u6570\u91cf\u662f $$ c(g)=\\gcd(n,k) $$ \u5bf9\u4e8e\u7ffb\u8f6c\uff1a $$ c(g)=\\frac{n}{2}+[n\\%2==1] $$ P4980 Polya\u5b9a\u7406\u6a21\u7248 $$ ans=\\frac{\\sum_{k=1}^n\\gcd(n,k)}{n}=\\sum_{d|n}\\phi(d)\\cdot n^{n/d-1} $$ \uff08\u7136\u800c\u8fd9\u9898\u7684\u6b27\u62c9\u51fd\u6570\u5c45\u7136\u80fd\u66b4\u529b\u6c42\u2026\u2026\u771f\u662f\u89c1\u9b3c\uff09 \u591a\u9879\u5f0f \u00b6 \u6b27\u62c9\u516c\u5f0f \uff1a $$ e^{\\theta i}=\\cos\\theta+i\\sin\\theta $$ \u7cfb\u6570\u8868\u793a\u6cd5\u3001\u70b9\u503c\u8868\u793a\u6cd5 \uff1a \u4f7f\u7528n+1\u4e2a\u70b9\u8868\u793a\u591a\u9879\u5f0f $$ f(x)={(x_0,f(x_0)),\\cdots,(x_n,f(x_n))} $$ \u5feb\u901f\u5085\u7acb\u53f6\u53d8\u6362\uff08FFT\uff09 \u00b6 \u79bb\u6563\u5085\u91cc\u53f6\u53d8\u6362 (Discrete Fourier Transform)\uff1a\u7cfb\u6570\u8868\u793a\u6cd5\u8f6c\u4e3a\u70b9\u503c\u8868\u793a\u6cd5\u3002 \u2026\u2026\u9006\u53d8\u6362 \uff1a\u70b9\u503c->\u7cfb\u6570 \u5377\u79ef \u00b6 \\[ \\vec c=\\vec a \\otimes \\vec b \\] \u5176\u4e2d\u5411\u91cf\u8868\u793a\u591a\u9879\u5f0f\uff0c\u4e14 $$ c_i=\\sum_{j=0}^ia_jb_{i-j} $$ \u5229\u7528\u70b9\u503c\u8868\u793a\u6cd5\u5c06\u70b9\u503c\u76f8\u4e58\u518d\u8f6c\u6362\u4e3a\u7cfb\u6570\u8868\u793a\u6cd5\u4e5f\u53ef\u4ee5\u8ba1\u7b97\u5377\u79ef\uff08On\u7684\u65f6\u95f4\u590d\u6742\u5ea6\uff09\u3002\u56e0\u6b64\u74f6\u9888\u5728\u4e8e\u70b9\u503c\u8868\u793a\u6cd5\u4e0e\u7cfb\u6570\u8868\u793a\u6cd5\u7684\u8f6c\u6362\u3002 \u5c06xi\u53d6\u7279\u5b9a\u7684\u503c\uff0c \\(x_i=\\omega_i^{[n]}=\\omega_n^i\\) \uff0c\u5219\u53ef\u6839\u636e\u67d0\u4e9b\u7279\u6b8a\u6027\u8d28\u5728nlogn\u65f6\u95f4\u5185\u8fdb\u884c\u5feb\u901f\u5085\u7acb\u53f6\u53d8\u6362\uff0c\u5bf9\u591a\u9879\u5f0f\u8fdb\u884c\u6c42\u503c\u548c\u5bf9\u70b9\u96c6\u8fdb\u884c\u63d2\u503c\u3002 \u5355\u4f4d\u590d\u6839 \u00b6 \u590d\u6570\u610f\u4e49\u4e0b\uff0c\u4e0b\u9762\u65b9\u7a0b\u7684\u89e3\u662fn\u6b21\u590d\u6839 $$ x^n=1 \\Rightarrow (\\omega_n)^n=1 $$ \uff08n\u6b21\uff09\u5355\u4f4d\u590d\u6839\uff1a\u628a\u590d\u5e73\u9762\u5355\u4f4d\u5143\u5206\u6210n\u4efd\uff0c\u7b2c\u4e00\u4e2a\u89d2\u5bf9\u5e94\u7684\u590d\u6570\u5411\u91cf $$ \\omega_n=e^{\\frac{2\\pi i}{n}}\\ {\\omega_n^k|k=0,1,\\cdots,n-1} $$ \\(w_n^0=1\\) \u6027\u8d28 \uff1a $$ w_n^n=1\\ w_n k=w_{2n} \\ w_{2n} {k+n}=-w_{2n} k $$ \u5b9a\u7406 1\uff1a \u5982\u679c \\(a=b\\pmod n\\) \uff0c\u5219 $$ w_n a=w_n b $$ \u8bc1\u660e\uff1a\u5728\u590d\u5e73\u9762\u4e0a\u770b\u5355\u4f4d\u590d\u6839\u5bb9\u6613\u770b\u51fa\u5b9a\u7406\u7684\u53d9\u8ff0\u662f\u6b63\u786e\u7684 \u5b9a\u74062 \uff1a\uff08\u76f8\u6d88\u5b9a\u7406\uff09 $$ \\omega_{dn} {dk}=\\omega_{n} k~(\\text{for }d>0) $$ \u5728\u590d\u5e73\u9762\u4e0a\u4e5f\u5bb9\u6613\u770b\u51fa\u5176\u6b63\u786e\u6027\u3002 \u5b9a\u74062\u7684\u63a8\u8bba \uff1a $$ \\omega_n {n/2}=\\omega_{2} 1=-1~(n>0,n\\text{ is even}) $$ \u5b9a\u74063 \uff1a\uff08\u6298\u534a\u5b9a\u7406\uff09 $$ \\omega_{n} {n/2+k}=-\\omega_n k $$ \u79bb\u6563\u5085\u7acb\u53f6\u53d8\u6362 \u00b6 \u5f53 \\(x_k=\\omega_n^k\\) \u65f6\uff08n\u662f\u591a\u9879\u5f0fA\u7684\u6b21\u6570\uff0ck=0~n-1\uff09\u5e26\u5165\u591a\u9879\u5f0fA\u5f97\u5230\u5404\u9879 \\(y_k=A(\\omega_n^k)=\\sum_{i=0}^{n-1}a_i(\\omega_n^k)^i\\) \uff0c\u591a\u9879\u5f0f\u503c\u5411\u91cf\uff08\u70b9\u503c\u8868\u793a\u6cd5\uff09 \\(\\vec y=(y_0,\\cdots,y_{n-1})\\) \u5c31\u88ab\u79f0\u4e3a\u7cfb\u6570\u5411\u91cfa\uff08\u7cfb\u6570\u8868\u793a\u6cd5\uff09\u7684\u79bb\u6563\u5085\u7acb\u53f6\u53d8\u6362\uff0c\u8bb0\u4e3a $$ \\vec y=\\text{DFT}_n(\\vec a) $$ \u79bb\u6563\u5085\u7acb\u53f6\u9006\u53d8\u6362 \u00b6 \u6839\u636e\u503c\u5411\u91cfy\u6c42\u51fa\u7cfb\u6570\u5411\u91cf\uff1a $$ \\vec a=\\text{DFT}^{-1}_n(\\vec y) $$ \u5377\u79ef\u5b9a\u7406 \u00b6 a\u3001b\u662f\u7cfb\u6570\u5411\u91cf\uff08\u957f\u5ea6\u4e3an\uff0c\u6700\u9ad8\u6b21\u4e3an\uff09\uff0c\u5219\u5377\u79efc\uff08\u4e5f\u662f\u7cfb\u6570\u5411\u91cf\uff09 $$ \\vec c=DFT_{2n}^{-1}(DFT_{2n}(\\vec a)\\cdot DFT_{2n}(\\vec b)) $$ \u5176\u4e2d\ud835\udc5b\u4e3a2\u7684\u5e42\u6b21\uff0c\u4e0d\u8db3\u7684\u75280\u8865\u3002\u4e2d\u95f4\u7684\u4e58\u53f7\u8868\u793a\u4e24\u4e2a\u5411\u91cf\u7684\u70b9\u4e58\u3002 \u5feb\u901f\u5085\u7acb\u53f6\u53d8\u6362 \u00b6 \u5feb\u901f\u5c06\u7cfb\u6570\u8868\u793a\u6cd5\u8f6c\u6362\u4e3a\u70b9\u503c\u8868\u793a\u6cd5\u3002 \u4e00\u4e2an\u9636\u591a\u9879\u5f0f\u53ef\u4ee5\u88ab\u62c6\u6210\u4e24\u90e8\u5206\uff08\u5076\u6570\u9879\u7cfb\u6570\u62ff\u51fa\u6765\uff0c\u642d\u914d\u65b0\u7684 \\(x^0\\text~x^{n-1}\\) \uff0c\u6210\u4e3a\u4e00\u4e2a\u65b0\u591a\u9879\u5f0f\uff1b\u5947\u6570\u9879\u7cfb\u6570\u62ff\u51fa\u6765\u6210\u4e3a\u53e6\u4e00\u4e2a\u65b0\u591a\u9879\u5f0f\uff09\uff1a $$ A(x)=A {[0]}(x 2)+xA {[1]}(x 2)\\ A {[0]}(x)=a_0+a_2x+\\cdots+a_{n-2}x \\ A {[1]}(x)=a_1+a_3x+\\cdots+a_{n-1}x \\ $$ \uff08\u6ce8\u610f\u8fd9\u91cc\u5f97\u5e26\u5165x^2\uff0c\u8fd9\u6837\u624d\u9f50\u6b21\uff09 \u7531\u8fd9\u4e24\u4e2a\u591a\u9879\u5f0f\u5f97\u5230\u7684\u79bb\u6563\u5085\u7acb\u53f6\u53d8\u6362\u7684\u7ed3\u679c\uff08\u70b9\u503c\u8868\u793a\u6cd5\u76f8\u91cf\uff09\u662f \\[ \\vec y^{[0]}=DFT_{n/2}(a_0,\\cdots,a_{n-2})\\\\ \\vec y^{[1]}=DFT_{n/2}(a_1,\\cdots,a_{n-1})\\\\ \\vec y=DFT_{n}(a_0,a_1,\\cdots,a_{n-1}) \\] \u5219\u8fd9\u4e24\u4e2a\u76f8\u91cf\u7684\u5404\u9879\u7cfb\u6570\u662f \\[ y_k^{[0]}=A^{[0]}(\\omega^k_{n/2})=A^{[0]}((\\omega^{k}_{n})^2)\\\\ y_k^{[1]}=A^{[1]}(\\omega^k_{n/2})=A^{[1]}((\\omega^{k}_{n})^2) \\] \u90a3\u4e48\u6700\u7ec8\u7ed3\u679c\uff08\u4e4b\u6240\u4ee5\u5206\u6210\u4e24\u90e8\u5206\u662f\u56e0\u4e3ay\u76f8\u91cf\u7684\u4e0b\u6807\u5927\u5c0f\u662f \\(y^{[0]},y^{[1]}\\) \u7684\u4e24\u500d\uff0c\u56e0\u6b64\u5728\u5206\u6cbb\u5b8c\u6210\u540e\u8f6c\u79fb\u65f6\u53ea\u9700\u8981\u679a\u4e3ek\uff1a0~n/2-1\u5373\u53ef\uff09\uff1a \\[ y_k=A(\\omega_n^k)=A^{[0]}((\\omega_n^k)^2)+A^{[1]}((\\omega_n^k)^2)\\omega^k_n=y^{[0]}_k+y^{[1]}_k\\omega_n^k\\\\ y_{k+n/2}=A(\\omega^{k+n/2}_n)=A^{[0]}((\\omega_n^{k+n/2})^2)+A^{[1]}((\\omega_n^{k+n/2})^2)\\omega^{k+n/2}_n\\\\ =A^{[0]}((\\omega_n^{k+n/2})^2)-A^{[1]}((\\omega_n^{k+n/2})^2)\\omega^{k}_n=y^{[0]}_k-y^{[1]}_k\\omega_n^k \\] \u5b9e\u9645\u5b9e\u73b0\u65f6\uff0c\u9700\u8981\u5148\u5c06\u591a\u9879\u5f0f\u957f\u5ea6\u8865\u5168\u52302\u7684\u5e42\u6b21\u3002 \u5feb\u901f\u5085\u7acb\u53f6\u9006\u53d8\u6362\uff08IFFT\uff09 \u00b6 \u53ef\u4ee5\u8bc1\u660e\uff1a $$ a_i=\\frac1n\\sum_{i=0} {n-1}y_i(\\omega_n )^i $$ \u5176\u4e2dai\u662f\u7cfb\u6570\u8868\u793a\u6cd5\u7684\u7cfb\u6570\uff0cyi\u662f\u70b9\u503c\u8868\u793a\u6cd5\u7684\u7cfb\u6570\u3002\u8fd9\u548c\u5904\u7406FFT\u662f\u4e00\u6837\u7684\u5f62\u5f0f\u3002\uff08\u4e5f\u5373\uff0c\u77e9\u9635 \\(Y=\\Omega A\\) \u4e2d\uff0cOmega\uff08\u7cfb\u6570\u77e9\u9635\uff09\u7684\u9006\u77e9\u9635\u662f\u6bcf\u4e00\u9879\u53d6\u5012\u6570\uff0c\u7136\u540e\u518d\u9664\u4ee5n\uff08\u4e5f\u5373\u591a\u9879\u5f0f\u957f\u5ea6\uff09\uff09 \u53c8\u56e0\u4e3a $$ \\frac{1}{\\omega_n}=\\omega_n^{-1} $$ \u5c06FFT\u8fc7\u7a0b\u4e2d\u7684pi\u6539\u4e3a-pi\u5c31\u662f\u5728\u505aIFFT\u4e86\u3002\u6700\u540e\u6c42\u5f97\u7684\u7cfb\u6570\u5168\u90e8\u9664\u4ee5n\uff08\u591a\u9879\u5f0f\u957f\u5ea6\uff09\u3002 \u8774\u8776\u53d8\u6362 \u00b6 \u5206\u6cbb\u8fc7\u7a0b\u4e2d\u7cfb\u6570\u7684\u4e0b\u6807\u53d8\u6362\u6709\u5982\u4e0b\u89c4\u5f8b\uff1a $$ 1:01234567\\ 2:02461357\\ 3:04261357\\ 4:04261537 $$ \u4e5f\u5373\u4e0b\u4e00\u6b65\u7684\u4e0b\u6807\u5728\u4e8c\u8fdb\u5236\u4e0b\u7684\u53cd\u8f6c\u503c\u4f1a\u6210\u4e3a\u8fd9\u4e00\u6b65\u7684\u4e0b\u6807\u3002 \u9012\u63a8\u5b9e\u73b0\uff1a( https://oi-wiki.org/math/poly/fft/#_8 ) $$ R(0)=0\\ R(x)=\\lfloor\\frac{R(\\lfloor\\frac{x}{2}\\rfloor)}{2}\\rfloor+(x\\mod 2)\\frac{len}{2} $$ 1 2 3 4 5 6 7 8 9 10 11 12 void pre_rev ( int len ) { rev [ 0 ] = 0 ; for ( int i = 1 ; i <= len ; i ++ ) { rev [ i ] = rev [ i >> 1 ] >> 1 ; if ( i & 1 ) { rev [ i ] |= len >> 1 ; } } } SP8372 TSUM - Triple Sums \u9898\u610f\uff1an\u4e2a\u6570\uff0c\u4efb\u53d6\u4e09\u4e2a\u52a0\u8d77\u6765\uff08\u8981\u6c42\u4e0b\u6807i<j<k\uff09\uff0c\u95ee\u6bcf\u4e2a\u53ef\u80fd\u7684\u7ed3\u679c\u7684\u65b9\u6848\u6570\uff08\u503c\u57df\u7edd\u5bf9\u503c20000\uff0cN\u572840000\u5185\uff09\u3002 https://www.cnblogs.com/SuuT/p/9584925.html \u89e3\u6cd5\uff1a\u8bbeA(x)\u662f\u4e0d\u8003\u8651\u987a\u5e8f\u7684\u9009\u6cd5\u7684\u9009\u4e00\u4e2a\u7684\u751f\u6210\u51fd\u6570\uff0c\u5219A(x 2)\u5c31\u662f\u9009\u4e24\u4e2a\u4e00\u6837\u7684\u751f\u6210\u51fd\u6570\uff0cA(x 3)\u5c31\u662f\u9009\u4e09\u4e2a\u4e00\u6837\u7684\u751f\u6210\u51fd\u6570\uff08\u5747\u662f\u4e0d\u8003\u8651\u987a\u5e8f\u7684\uff09 \u8003\u8651\u5bb9\u65a5\u539f\u7406\u628a\u9009\u5230\u76f8\u540c\u7684\u4e0b\u6807\u7684\u60c5\u51b5\u7ed9\u6392\u9664\u6389\uff0c\u5219\u4e0b\u9762\u7684\u5f0f\u5b50\u5c31\u662f\u7b5b\u6389\u4e4b\u540e\u7684\u751f\u6210\u51fd\u6570\uff1a\u51cf\u53bb\u6709\u4e24\u79cd\u76f8\u540c\u7684\u9009\u6cd5\u7684\u751f\u6210\u51fd\u6570\uff0c\u518d\u52a0\u56de\u591a\u51cf\u53bb\u7684\u4e09\u79cd\u76f8\u540c\u7684\u9009\u6cd5\u7684\u751f\u6210\u51fd\u6570 $$ A 3(x)-3A(x 2)A(x)+2A(x^3) $$ \u7531\u4e8ei<j<k\uff0c\u56e0\u6b64\u8fd8\u8981\u9664\u4ee56\u6765\u7b5b\u6389\u5176\u4ed6\u91cd\u590d\u7684\u60c5\u51b5\uff08\u663e\u7136\u67093*2*1\u79cd\u53ef\u80fd\uff09 \u5b9e\u73b0\u65f6\u7531\u4e8e\u6709\u8d1f\u6570\u5b58\u5728\uff0c\u9700\u8981\u6574\u4f53\u5c06\u8bfb\u5165\u7684\u5e8f\u5217\u79fb\u52a82e4\uff0c\u6700\u540e\u8981\u53cd\u5411\u79fb\u52a86e4\uff08\u56e0\u4e3a\u6700\u7ec8\u5f0f\u5b50\u662f3\u6b21\u5f0f\uff1f\uff09 UVA12633 Super Rooks on Chessboard \u9898\u76ee\u5927\u610f\uff1a\u7ed9\u4f60\u4e00\u5f20\u7f51\u683c\uff0c\u4e0a\u9762\u6709\u5f88\u591a\u9a91\u58eb\uff0c\u6bcf\u4e2a\u9a91\u58eb\u80fd\u6a2a\u7740\u7ad6\u7740\u659c\u7740\u653b\u51fb\u4e00\u6761\u76f4\u7ebf\u4e0a\u7684\u683c\u5b50\uff0c\u6c42\u6ca1\u88ab\u653b\u51fb\u7684\u683c\u5b50\u7684\u6570\u91cf\u603b\u548c\uff08R C D\u5c0f\u4e8e50000\uff09 https://blog.csdn.net/u013368721/article/details/45367249 \u89e3\u6cd5\uff1a\u5148\u8ba1\u7b97\u51fa\u4e0d\u8003\u8651\u659c\u65b9\u5411\u7684\u60c5\u51b5\uff0c\u8fd9\u65f6\u5019\u7b54\u6848\u5c31\u662f\u6ca1\u8f66\u7684\u884c\u4e58\u4ee5\u6ca1\u8f66\u7684\u5217\u7684\u6570\u91cf\u3002 \u8003\u8651\u659c\u65b9\u5411\uff0c\u6211\u4eec\u5c31\u8981\u5254\u9664\u6389\u4f1a\u88ab\u659c\u65b9\u5411\u5360\u636e\u7684\u60c5\u51b5\u3002\u8bbe\u591a\u9879\u5f0fR(x)\u8868\u793a\u6ca1\u88ab\u5360\u636e\u7684\u884c\u53f7\u7684\u751f\u6210\u51fd\u6570\uff0cC(x)\u8868\u793a\u6ca1\u88ab\u5360\u636e\u7684\u5217\u53f7\u7684\u751f\u6210\u51fd\u6570\u3002\uff08\u884c\u53f7\u4ece\u4e0a\u5230\u4e0b\u589e\u5927\uff0c\u5217\u53f7\u4ece\u5de6\u5230\u53f3\u589e\u5927\uff0c\u4ece0\u5f00\u59cb\u8ba1\u6570\uff09 $$ R(x)=\\sum_{i=1} {cnt}x \\ C(x)=\\sum_{i=1} {cnt2}x \\ $$ \u8fd9\u65f6\u5c31\u662f\u8981\u6570 \\(r_i-c_j=d_k\\) \u7684i\u3001j\u3001k\u6570\u91cf\uff0c\u4e5f\u5c31\u662f \\((R\\cdot C)(x)\\) \u4e2d \\(x^{d_k}\\) \u7684\u7cfb\u6570\u3002\uff08\u5176\u4e2dri\u3001cj\u3001dk\u662f\u6ca1\u6709\u8f66\u7684\u884c\u53f7\u4e0e\u5217\u53f7\u7684\u96c6\u5408\u4ee5\u53ca\u6709\u8f66\u7684\u5bf9\u89d2\u7ebf\u7684\u96c6\u5408\uff09 \u5177\u4f53\u5b9e\u73b0\u65f6\uff0c\u7531\u4e8e-ci\u662f\u8d1f\u6570\u4e0d\u597d\u5904\u7406\uff0c\u4e8e\u662f\u6574\u4f53\u504f\u79fbC\uff08\u9898\u76ee\u7ed9\u51fa\u7684\u5217\u6570\uff09\uff0cd\u8fd9\u4e2a\u96c6\u5408\u7684\u4e0b\u6807\u4e5f\u6574\u4f53\u504f\u79fbC\u90a3\u4e48\u591a\uff0c\u6700\u540e\u8ba1\u6570\u7684\u65f6\u5019\u76f4\u63a5\u51cf\u53bb\u7cfb\u6570\u4e58\u4ee5[\u90a3\u4e00\u5bf9\u89d2\u7ebf\u662f\u5426\u6709\u8f66]\u5373\u53ef\u3002 HDOJ4609 3-idiots \u9898\u610f\uff1a\u7ed9\u51fan\u4e2a\u6570\uff08\u53ef\u80fd\u76f8\u540c\uff0c\u503c\u57df1~1e5\uff09\uff0c\u4efb\u90093\u4e2a\uff0c\u95ee\u80fd\u591f\u6784\u6210\u4e09\u89d2\u5f62\u7684\u6982\u7387\u3002 https://blog.csdn.net/Maxwei_wzj/article/details/79329154 \u89e3\u6cd5\uff1a\u8bbeA(x)\u4e3a\u4efb\u610f\u90091\u4e2a\u5f97\u5230\u7684\u6570\u7684\u548c\u7684\u751f\u6210\u51fd\u6570\uff0c\u5219 $$ G(x)=\\frac{A(x) 2-A(x 2)}{2} $$ \u8fd9\u4e2a\u662f\u5728\u6392\u5e8f\u540e\u9009\u4e24\u4e2a\u6709\u5e8f\u6570\u5bf9\u6784\u6210\u7684\u548c\u7684\u9009\u6cd5\u6570\u91cf\u7684\u751f\u6210\u51fd\u6570\u3002 \u76f4\u63a5\u53bb\u8003\u8651\u80fd\u6709\u591a\u5c11\u4e2a\u6709\u5e8f\u6570\u5bf9i\u3001j\u3001k\u6ee1\u8db3 \\(A_i+A_j>A_k\\) \u4e14 \\(A_i\\le A_j\\le A_k\\) \u4f1a\u5b58\u5728\u56f0\u96be\uff08\u56e0\u4e3a\u76f4\u63a5\u5957\u7528\u4e0a\u9762\u7684\u751f\u6210\u51fd\u6570\u7684\u7ed3\u679c\u7684\u540e\u7f00\u548c\u662f\u4e0d\u80fd\u4fdd\u8bc1\u540e\u9762\u7684\u6761\u4ef6\u6ee1\u8db3\u7684\uff09\uff0c\u4e8e\u662f\u6211\u4eec\u53cd\u8fc7\u6765\u8003\u8651\u62a0\u6389 \\(A_i+A_j\\le A_k\\) \uff0c\u8fd9\u6837\u5728\u6392\u5e8f\u540e\uff0c\u540e\u8005\u7684\u6761\u4ef6\u81ea\u7136\u6ee1\u8db3\u3002 \u679a\u4e3eAk\u7684\u503c\uff0c\u7136\u540e\u5206\u4e09\u7c7b\u60c5\u51b5\u7edf\u8ba1\u7b54\u6848\uff08tempsum\u662f\u5c0f\u4e8eAk\u7684\u503c\u7684\u6570\u91cf\uff0ctempsum2\u662f\u5c0f\u4e8e\u7b49\u4e8eAk\u7684\u751f\u6210\u51fd\u6570\u7684\u503c\u7684\u7cfb\u6570\u548c\uff0ccnt_i\u662f\u7b49\u4e8ei\u7684\u6570\u7684\u6570\u91cf\uff09\uff1a \\(A_i\\le A_j \\lt A_k\\) \uff1a\u7b54\u6848\u7d2f\u52a0\u4e0a ans+=(tempsum*(tempsum-1)/2-tempsum2)*cnt[i]; \\(A_i\\lt A_j = A_k\\) \uff1a ans+=tempsum*cnt[i]*(cnt[i]-1)/2; \\(A_i\\lt A_j = A_k\\) \uff1a ans+=cnt[i]*(cnt[i]-1)*(cnt[i]-2)/6; \u5feb\u901f\u6570\u8bba\u53d8\u6362\uff08Number theoretic transform\uff09 \u00b6 FFT\u4e4b\u6240\u4ee5\u8981\u5f15\u5165\u590d\u6570\uff0c\u662f\u56e0\u4e3a\u5355\u4f4d\u5143\u6839\u6ee1\u8db3\u5faa\u73af\u7fa4\u7684\u6027\u8d28\uff1a $$ {1,\\omega,\\omega 2,\\cdots,\\omega } $$ \u8fd9\u4e2a\u7fa4\u662f \\(2^K\\) \u9636\u5faa\u73af\u7fa4\u3002\u800c\u5728\u5b9e\u6570\u8303\u56f4\u5185\u627e\u4e0d\u5230\u8fd9\u6837\u7684\u5faa\u73af\u7fa4\u3002 \u53c2\u8003\uff1a https://zhuanlan.zhihu.com/p/166197713 \u5728mod p\u610f\u4e49\u4e0b\uff0cp\u7684\u539f\u6839\u5c31\u6070\u597d\u548c\u521a\u521a\u7684\u5355\u4f4d\u5143\u6839\u4e00\u6837\u5177\u6709\u76f8\u540c\u7684\u6027\u8d28\u3002 \u4ee4g\u662fp\uff08\u8d28\u6570\uff09\u7684\u539f\u6839\uff0c\u4ee4 \\(g_N=g^{\\frac{p-1}{N}}~(N|p-1)\\) \uff0c\u5219\uff1a $$ g_N N=g =1 \\pmod p\\ g_{N} {N/2}=g \\frac{p-1}{2}=-1 \\pmod p $$ \\(g^{\\frac{p-1}{2}}\\) \u662f-1\u53ef\u7531\u539f\u6839\u7684\u6027\u8d28+\u4e8c\u6b21\u63a2\u6d4b\u5b9a\u7406\u8bc1\u660e\u5145\u5206\u5fc5\u8981\u6761\u4ef6\u3002 \u4ece\u8fd9\u91cc\u53ef\u4ee5\u77e5\u9053\uff0c\u4e0b\u9762\u7684\u7fa4\u7684\u9636\u6570\u5c31\u662fN-1\uff1a $$ {g,g 2,\\cdots,g =1} $$ \u5173\u952e\u95ee\u9898\u5c31\u5728\u4e8e \\(N|p-1\\) \uff0c\u800cp=998244353\u65f6 $$ p-1=998244353-1=2^{23}\\times17\\times7 $$ \u7531\u4e8e\u5728FFT\u4e2dN\uff08\u4e5f\u5c31\u662f\u6269\u5c55\u540e\u7684\u591a\u9879\u5f0f\u957f\u5ea6\uff09\u662f2\u7684\u5e42\uff0c\u56e0\u6b64\u5927\u591a\u6570\u65f6\u5019\uff08\u53ea\u8981N\u5c0f\u4e8e\u7b49\u4e8e2\u768423\u6b21\u5e42\uff09\u80fd\u591f\u6ee1\u8db3 \\(N|p-1\\) \u3002\u540c\u6837\u7c7b\u4f3c\u7684\u6570\u8fd8\u6709p=1004535809=479 2^{21}+1\u3002 \u8fd9\u4e24\u4e2a\u6570\u7684\u539f\u6839\u90fd\u662f3\u3002 * \u5feb\u901f\u6c83\u5c14\u4ec0\u53d8\u6362\uff08Fast Walsh Transform\uff09 \u00b6 https://oi-wiki.org/math/poly/fwt/#_3 \u7528\u4e8e\u89e3\u51b3\u4e0e\u4f4d\u8fd0\u7b97\u6709\u5173\u7684\u5377\u79ef\u95ee\u9898\uff1a \\(\\vec c=\\vec a \\oplus \\vec b\\) $$ C_i=\\sum_{i=j|k}A_j B_k $$ \u5bf9\u6216\u8fd0\u7b97\u6765\u8bf4\uff0c\u6784\u9020\uff1a $$ A'=FWT[A]:A' i=\\sum A_j $$ \u4e5f\u5373A' i\u8868\u793a\u4e8c\u8fdb\u5236\u4e0b\u76841\u662fi\u7684\u5b50\u96c6\u7684Aj\u7684\u603b\u548c\uff0c\u5982\u6b64\u6784\u9020\u5c31\u6709 $$ FWT[C]=FWT[A]\\cdot FWT[B]\\ \\sum C_i=\\sum_{i=i|j}A_i\\cdot \\sum_{i=i|j}B_i $$ \u7279\u522b\u5730\uff0c\u591a\u9879\u5f0f\u957f\u5ea6\u4e3a1\u65f6\uff0c\u663e\u7136\u6709 $$ A=FWT[A]=A' $$ \u56e0\u4e3a\u5728\u6216\u7684\u60c5\u51b5\u4e0bi\u81ea\u5df1\u5c31\u662fi\u7684\u5b50\u96c6\u3002\u5bf9\u4e8e\u4e0e\u6765\u8bf4\u4e5f\u540c\u7406\u3002 \u8003\u8651\u9012\u63a8\u516c\u5f0f\u7684\u65f6\u5019\uff0c\u4e3b\u8981\u8003\u8651\u591a\u51fa\u6765\u7684\u90a3\u4e00\u4f4d\u768401\u548c\u8fd0\u7b97\u5b50\u96c6\u6216\u8d85\u96c6\u7684\u5173\u7cfb \u6216\uff08OR\uff09 \u00b6 merge\u8868\u793a\u4e32\u63a5\uff0cA0\u8868\u793a\u5de6\u534a\u90e8\u5206\uff0cA1\u8868\u793a\u53f3\u534a\u90e8\u5206\u3002 $$ FWT[A]=merge(FWT[A_0],FWT[A_0]+FWT[A_1])\\ UFWT[A']=merge(UFWT[A'_0],UFWT[A'_1]-UFWT[A'_0]) $$ \u4e0e\uff08AND\uff09 \u00b6 \u4e0a\u6587\u4e2d\u5b50\u96c6\u53d8\u6210\u8d85\u96c6 $$ FWT[A]=merge(FWT[A_0]+FWT[A_1],FWT[A_1])\\ UFWT[A']=merge(UFWT[A'_0]-UFWT[A'_1],UFWT[A'_1]) $$ \u5f02\u6216\uff08XOR\uff09 \u00b6 \u8bbe $$ A' k=FWT[A][k]=\\sum {2 n-1}A_i(-1)^{|i\\and k|} $$ \u5176\u4e2d \\(|i\\and k|\\) \u8868\u793ai and k\u4e2d1\u7684\u6570\u76ee\u7684\u5947\u5076\u6027\u3002 \u5219\uff08\u56e0\u4e3a\u6307\u6570\u90a3\u4e2a\u5730\u65b9\u53ea\u662f\u8868\u793a\u5947\u5076\u6027\uff0c\u6240\u4ee5\u53ef\u4ee5\u76f4\u63a5\u4ece\u52a0\u53f7\u66ff\u6362\u6210\u5f02\u6216\u7b26\u53f7\uff09 $$ FWT[A][k]\\cdot FWT[B][k]\\= \\sum_{i=0} {2 n-1} A_i(-1)^{|i\\and k|}\\sum_{i=0} {2 n-1} B_i(-1)^{|i\\and k|}\\ =\\sum_{i=0} {2 n-1}\\sum_{j=0} {2 n-1}A_iB_j(-1)^{|i\\and k|\\oplus|j\\and k|}\\ =\\sum_{i=0} {2 n-1}\\sum_{j=0} {2 n-1}A_iB_j(-1)^{|(i\\oplus j)\\and k|}\\ =\\sum_{val=0} {2 n-1}(\\sum_{j=0} {2 n-1}A_{val}B_{val\\oplus j})(-1)^{|val\\and k|} $$ \u6ce8\u610f\uff1a\u6700\u540e\u4e00\u4e2a\u7b49\u5f0f\u540e\u6c42\u548c\u987a\u5e8f\u5df2\u7ecf\u53d8\u6362\u3002\u62ec\u53f7\u5185\u5c31\u662f \\(C_i\\) $$ FWT[A]=merge(FWT[A_0]+FWT[A_1],FWT[A_0]-FWT[A_1])\\ UFWT[A']=merge(\\frac{UFWT[A'_0]+UFWT[A'_1]}2,\\frac{UFWT[A'_0]-UFWT[A'_1]}2)\\ $$ \u5982\u679c\u662f\u540c\u6216\u5c31\u4ea4\u6362+-\u7b26\u53f7\u3002 \u7f51\u7edc\u6d41\u76f8\u5173 \u00b6 Hall's marriage theorem \u00b6 \u8bbe\u4e8c\u5206\u56fe\u4e2dG= \u4e2d\uff0c|V1|=m<=|V2|=n\uff0cG\u4e2d\u5b58\u5728V1\u5230V2\u7684\u5b8c\u5168\u5339\u914d\uff0c \u5f53\u4e14\u4ec5\u5f53 V1\u4e2d\u4efb\u610fk\u4e2a(k=1,2,..,m)\u4e2a\u9876\u70b9\u81f3\u5c11\u4e0eV2\u4e2dk\u4e2a\u9876\u70b9\u76f8\u90bb \uff08\u968f\u4fbf\u6311\u51fa\u4efb\u610f\u4e2a\u7537\u751f\uff0c\u5982\u679c\u4ed6\u4eec\u5fc3\u4eea\u7684\u5973\u751f\u7684\u6570\u91cf\uff08\u91cd\u590d\u4e0d\u7b97\uff09\u6bd4\u8fd9\u4e9b\u6311\u51fa\u7684\u7537\u751f\u6570\u8fd8\u5c11\uff0c\u90a3\u4e48\u5fc5\u7136\u4e0d\u80fd\u5b9e\u73b0\u5b8c\u7f8e\u914d\u5bf9\uff09 \u4e8c\u5206\u56fe\u6700\u5927\u5339\u914d\u6570\u91cf \u00b6 N(S)\u8868\u793a\u4e0eS\u76f8\u90bb\uff08\u8fde\u63a5\uff09\u7684\u9876\u70b9\u6570\u91cf $$ |M|=|V_1|-max_{S\\subset V_1}(|S|-|N(S)|) $$ \u6709n\u4e2a\u73ed\u7ea7\uff0c\u6bcf\u4e2a\u73ed\u7ea7\u6709ai\u4e2a\u4eba\uff0c\u4e00\u4e2a\u73ed\u7ea7\u53ef\u4ee5\u505a\u51fabi\u676f\u5976\u8336\uff0c\u4e00\u4e2a\u73ed\u7ea7\u7684\u4eba\u4e0d\u80fd\u559d\u672c\u73ed\u505a\u7684\u5976\u8336\uff0c\u53ef\u4ee5\u559d\u522b\u7684\u73ed\u505a\u7684\u5976\u8336\uff0c\u95ee\u6700\u591a\u6709\u591a\u5c11\u4eba\u559d\u5230\u5976\u8336 \u00b6 \u6211\u4eec\u601d\u8003\u4e09\u79cd\u60c5\u51b5\uff1a 1.\u5f53\u8fd9\u4e2aS\u5b50\u96c6\u662f\u4e2a\u7a7a\u5b50\u96c6\u7684\u65f6\u5019\uff0c\u90a3\u4e48|M|=|U| 2.\u5f53\u8fd9\u4e2aS\u5b50\u96c6\u5c31\u662fU\u7684\u672c\u8eab\u7684\u65f6\u5019\uff0c\u90a3\u4e48N(S)\u5c31\u7b49\u4e8eV\uff08\u5976\u8336\u7684\u6570\u91cf\uff09\uff0c\u5373|M|=|V| 3.\u5f53S\u662f|U|\u7684\u4e00\u4e2a\u5b50\u96c6\uff0c\u6211\u4eec\u4e00\u4e2a\u73ed\u4e00\u4e2a\u73ed\u7684\u8003\u8651\uff0c\u5f53S\u662f\u4e00\u4e2a\u73ed\u7684\u5b66\u751f\u7684\u65f6\u5019\uff0c\u90a3\u4e48\uff1a |M|=Sa-\uff08ai-\uff08Sb-bi\uff09\uff09\u5176\u4e2dSa\uff0cSb\u5206\u522b\u4ee3\u8868\u5b66\u751f\u603b\u6570\u91cf\u548c\u5976\u8336\u603b\u6570\u91cf\uff0cai\uff0cbi\u4ee3\u8868\u672c\u73ed\u5b66\u751f\u6570\u91cf\u548c\u672c\u73ed\u505a\u7684\u5976\u8336\u6570 \uff08\u4e3a\u4ec0\u4e48\u7b2c\u4e09\u4e2a\u60c5\u51b5\u4e0d\u4e00\u4e2a\u4e2a\u5b66\u751f\u8003\u8651\u706b\u6216\u8005\u4e24\u4e2a\u73ed\u4e09\u4e2a\u73ed\u7684\u8003\u8651\u5462\uff0c\u56e0\u4e3a\u6211\u4eec\u6c42\u7684\u662fmax\uff0c\u4e5f\u5c31\u662f\u6700\u5927\u503c\uff0c\u90a3\u4e48\u8fd9\u4e9b\u8003\u8651\u90fd\u662f\u65e0\u6548\u7684\uff0c\u5927\u5bb6\u753b\u4e00\u4e0b\u5c31\u77e5\u9053\u4e86\uff0c\u5f88\u5bb9\u6613\u7406\u89e3\uff09 \u4e09\u4e2a\u60c5\u51b5\u53d6\u6700\u5c0f\u503c\u8bb0\u4e3a\u7ed3\u679c \u4e3a\u4f55\u4e0d\u4e00\u4e2a\u4e2a\u8003\u8651\uff1a\u82e5\u5982\u6b64\u505a\uff0c|S|\u5c0f\u800c|N(S)|\u5927\uff0c\u5c06S\u6269\u5927\u5230\u540c\u73ed\u7ea7\uff0c\u7ed3\u679c\u4f1a\u66f4\u597d \u4e3a\u4f55\u4e0d\u6570\u4e2a\u73ed\u7ea7\u4e00\u8d77\u8003\u8651\uff1a\u82e5\u5982\u6b64\u505a\uff0c|N(S)|=|V2|\uff08\u4e5f\u5c31\u662f\u5976\u8336\u6570\u91cf\uff09\u4e3a\u5b9a\u503c\uff0c\u5219\u5c06S\u6269\u5927\u5230\u6240\u6709\u4eba\uff0c\u7ed3\u679c\u4f1a\u66f4\u597d\uff0c\u4f46\u8fd9\u548c\u60c5\u51b52\u662f\u91cd\u5408\u7684 \u4e09\u4e2a\u60c5\u51b5\u53d6\u6700\u5c0f\u503c\uff1a-max >>>> min \u539f\u6587\u94fe\u63a5\uff1a https://blog.csdn.net/qq_41925919/java/article/details/99689223 \u6700\u5927\u6743\u95ed\u5408\u5b50\u56fe \u00b6 \u5e26\u6743\u95ed\u5408\u5b50\u56fe\uff1a\u6743\u5728\u70b9\u4e0a\uff0c\u5b50\u56fe\u4e2d\u7684\u70b9\u7684\u51fa\u8fb9\u5747\u5728\u5b50\u56fe\u4e2d \u6700\u5927\u6743\u95ed\u5408\u5b50\u56fe\uff1a\u503c\u7b49\u4e8e \u201c\u6240\u6709\u6b63\u70b9\u6743\u503c\u7684\u548c\u201d\u51cf\u53bb\u201cs-t\u6700\u5c0f\u5272\u201d https://www.cnblogs.com/dilthey/p/7565206.html \u5c0fM\u7684\u4f5c\u7269 \uff08\u6b64\u9898\u7684\u53e6\u4e00\u4e2a\u505a\u6cd5\uff1aA\u3001B\u4f5c\u4e3a\u6e90\u70b9\u548c\u6c47\u70b9\uff0c\u4f5c\u7269\u4f5c\u4e3a\u4e2d\u95f4\u8282\u70b9\uff0c\u518d\u6784\u9020\u8fde\u7ed3\u6e90\u70b9\uff08\u6c47\u70b9\uff09\u548c\u4f5c\u7269\u8282\u70b9\u7684\u5956\u52b1\u8282\u70b9\uff0c\u7136\u540e\u6c42\u6700\u5c0f\u5272\uff09 https://blog.csdn.net/clover_hxy/article/details/55043578 \u6700\u5c0f\u5272\u7684\u4e00\u4e2a\u95ee\u9898\u6a21\u578b \u00b6 \u00b6 \u6709 \u4e2a\u7269\u54c1\u548c\u4e24\u4e2a\u96c6\u5408 \uff0c\u5982\u679c\u5c06\u4e00\u4e2a\u7269\u54c1\u653e\u5165 \u96c6\u5408\u4f1a\u82b1\u8d39 \uff0c\u653e\u5165 \u96c6\u5408\u4f1a\u82b1\u8d39 \uff1b\u8fd8\u6709\u82e5\u5e72\u4e2a\u5f62\u5982 \u9650\u5236\u6761\u4ef6\uff0c\u8868\u793a\u5982\u679c \u548c \u540c\u65f6\u4e0d\u5728\u4e00\u4e2a\u96c6\u5408\u4f1a\u82b1\u8d39 \u3002\u6bcf\u4e2a\u7269\u54c1\u5fc5\u987b\u4e14\u53ea\u80fd\u5c5e\u4e8e\u4e00\u4e2a\u96c6\u5408\uff0c\u6c42\u6700\u5c0f\u7684\u4ee3\u4ef7\u3002 \u8fd9\u662f\u4e00\u4e2a\u7ecf\u5178\u7684 \u4e8c\u8005\u9009\u5176\u4e00 \u7684\u6700\u5c0f\u5272\u9898\u76ee\u3002\u6211\u4eec\u5bf9\u4e8e\u6bcf\u4e2a\u96c6\u5408\u8bbe\u7f6e\u6e90\u70b9 \u548c\u6c47\u70b9 \uff0c\u7b2c \u4e2a\u70b9\u7531 \u8fde\u4e00\u6761\u5bb9\u91cf\u4e3a \u7684\u8fb9\u3001\u5411 \u8fde\u4e00\u6761\u5bb9\u91cf\u4e3a \u7684\u8fb9\u3002\u5bf9\u4e8e\u9650\u5236\u6761\u4ef6 \uff0c\u6211\u4eec\u5728 \u4e4b\u95f4\u8fde\u5bb9\u91cf\u4e3a \u7684\u53cc\u5411\u8fb9\u3002 \u6ce8\u610f\u5230\u5f53\u6e90\u70b9\u548c\u6c47\u70b9\u4e0d\u76f8\u8fde\u65f6\uff0c\u4ee3\u8868\u8fd9\u4e9b\u70b9\u90fd\u9009\u62e9\u4e86\u5176\u4e2d\u4e00\u4e2a\u96c6\u5408\u3002\u5982\u679c\u5c06\u8fde\u5411 \u6216 \u7684\u8fb9\u5272\u5f00\uff0c\u8868\u793a\u4e0d\u653e\u5728 \u6216 \u96c6\u5408\uff0c\u5982\u679c\u628a\u7269\u54c1\u4e4b\u95f4\u7684\u8fb9\u5272\u5f00\uff0c\u8868\u793a\u8fd9\u4e24\u4e2a\u7269\u54c1\u4e0d\u653e\u5728\u540c\u4e00\u4e2a\u96c6\u5408\u3002 \u6700\u5c0f\u5272\u5c31\u662f\u6700\u5c0f\u82b1\u8d39\u3002 \u8ba1\u7b97\u51e0\u4f55(Computational Geometry) \u00b6 \u8ba1\u7b97\u51e0\u4f55\u5168\u5bb6\u6876\uff1a https://www.cnblogs.com/Xing-Ling/p/12102489.html kuangbin\u7684\u677f\u5b50\uff1a https://kuangbin.github.io/2019/04/28/20190428/#more Pecco\u7684\u677f\u5b50\uff1a https://zhuanlan.zhihu.com/p/338057154 \u8fd9\u91cc\u4e3b\u8981\u7528kuangbin\u7684\u677f\u5b50\u3002 \u5e38\u8bc6 \u00b6 \u5411\u91cfa\u7684\u5de6\u624b\u8fb9\u662f\u6b63\u533a\u57df\uff08\u5305\u62ec180\u5ea6\u7ebf\uff09\uff0c\u53f3\u624b\u8fb9\u662f\u8d1f\u533a\u57df\u3002\u56e0\u6b64\u4e24\u4e2a\u76f8\u91cfa\u3001b\u7684\u5939\u89d2\u662f\u6b63\u65f6\uff0cb\u5728a\u5de6\u4fa7\uff0c\u5426\u5219\u5728\u53f3\u4fa7\u3002\uff08\u8fd9\u4e2a\u7ea6\u5b9a\u5728\u53c9\u4e58\u3001\u534a\u5e73\u9762\u4ea4\u4e2d\u90fd\u6709\u7528\uff09 \\[ |\\vec a\\times\\vec b|=|\\vec a||\\vec b|\\sin<\\vec a,\\vec b>\\\\ |\\vec a\\cdot \\vec b|=|\\vec a||\\vec b|\\cos<\\vec a,\\vec b> \\] \u539f\u5219 \u00b6 \u70b9\u548c\u5411\u91cf\u4f7f\u7528\u540c\u4e00\u5957\u7ed3\u6784Point\uff0c\u4f46\u662f\u5141\u8bb8\u5411\u91cf\u62e5\u6709\u522b\u540dVec\u3002\u70b9\u548c\u5411\u91cf\u7279\u6709\u7684\u65b9\u6cd5\u5728\u5b9a\u4e49\u65f6\u52a0\u4ee5\u533a\u5206 \u70b9\u5728\u4efb\u610f\u591a\u8fb9\u5f62\u5185 \u00b6 HDU1756 cupids arrow 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 #include <iostream> #include <cmath> #include <algorithm> using namespace std ; const double eps = 1e-8 ; inline int dcmp ( double a ){ return a <- eps ? -1 : ( a > eps ? 1 : 0 );} //\u5904\u7406\u7cbe\u5ea6 inline double Abs ( double a ){ return a * dcmp ( a );} //\u53d6\u7edd\u5bf9\u503c struct Point { double x , y ; Point ( double X = 0 , double Y = 0 ) { x = X , y = Y ; } }; typedef Point Vector ; double Dot ( Vector a , Vector b ) { return a . x * b . x + a . y * b . y ;} double Cro ( Vector a , Vector b ) { return a . x * b . y - a . y * b . x ;} double Len ( Vector a ) { return sqrt ( Dot ( a , a ));} Vector operator + ( Vector a , Vector b ){ return Vector ( a . x + b . x , a . y + b . y );} Vector operator - ( Vector a , Vector b ){ return Vector ( a . x - b . x , a . y - b . y );} Vector operator * ( Vector a , double b ){ return Vector ( a . x * b , a . y * b );} bool operator == ( Point a , Point b ){ return ! dcmp ( a . x - b . x ) &&! dcmp ( a . y - b . y );} //\u4e24\u70b9\u5750\u6807\u91cd\u5408\u5219\u76f8\u7b49 int n ; Point a [ 110 ]; bool check_PL ( Point p , Point a , Point b ) { return ! dcmp ( Cro ( p - a , b - a )) && dcmp ( Dot ( p - a , p - b )) <= 0 ; //\u53c9\u4e58\u4e3a0\u8868\u4e09\u70b9\u5171\u7ebf\uff0c\u70b9\u79ef\u5c0f\u4e8e0\u8868\u793aPA\u3001PB\u53cd\u5411 } int PIP ( Point * P , int n , Point a ) { int cnt = 0 ; double temp = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int j = i == n ? 1 : i + 1 ; if ( check_PL ( a , P [ i ], P [ j ])) return 2 ; //\u70b9\u5728\u8fb9\u4e0a if ( a . y >= min ( P [ i ]. y , P [ j ]. y ) && a . y < max ( P [ i ]. y , P [ j ]. y )) //\u7eb5\u5750\u6807\u5728\u8be5\u7ebf\u6bb5\u4e24\u7aef\u70b9\u4e4b\u95f4 { //temp:\u76f8\u4f3c\u4e09\u89d2\u5f62\u786e\u5b9a\u4ea4\u70b9\u7684x\u5750\u6807 temp = P [ i ]. x + ( a . y - P [ i ]. y ) / ( P [ j ]. y - P [ i ]. y ) * ( P [ j ]. x - P [ i ]. x ); cnt += dcmp ( temp - a . x ) > 0 ; //\u4ea4\u70b9\u5728A\u53f3\u65b9 } } return cnt & 1 ; } int main () { ios :: sync_with_stdio ( false ); while ( cin >> n ) { for ( int i = 1 ; i <= n ; i ++ ) { int x , y ; cin >> x >> y ; a [ i ]. x = x , a [ i ]. y = y ; } int m ; cin >> m ; for ( int i = 1 ; i <= m ; i ++ ) { int x , y ; cin >> x >> y ; Point b ( x , y ); if ( PIP ( a , n , b )) cout << \"Yes\" << endl ; else cout << \"No\" << endl ; } } return 0 ; } \u70b9\u5728\u51f8\u591a\u8fb9\u5f62\u5185 \u00b6 \u53ef\u4ee5\u4f7f\u7528\u4e8c\u5206\u6cd5\u5224\u65ad HRBUST 1429 \u51f8\u591a\u8fb9\u5f62 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 #include <iostream> #include <cmath> #include <algorithm> using namespace std ; const double eps = 1e-8 ; inline int dcmp ( double a ){ return a <- eps ? -1 : ( a > eps ? 1 : 0 );} //\u5904\u7406\u7cbe\u5ea6 inline double Abs ( double a ){ return a * dcmp ( a );} //\u53d6\u7edd\u5bf9\u503c struct Point { double x , y ; Point ( double X = 0 , double Y = 0 ) { x = X , y = Y ; } }; typedef Point Vector ; double Dot ( Vector a , Vector b ) { return a . x * b . x + a . y * b . y ;} double Cro ( Vector a , Vector b ) { return a . x * b . y - a . y * b . x ;} double Len ( Vector a ) { return sqrt ( Dot ( a , a ));} Vector operator + ( Vector a , Vector b ){ return Vector ( a . x + b . x , a . y + b . y );} Vector operator - ( Vector a , Vector b ){ return Vector ( a . x - b . x , a . y - b . y );} Vector operator * ( Vector a , double b ){ return Vector ( a . x * b , a . y * b );} bool operator == ( Point a , Point b ){ return ! dcmp ( a . x - b . x ) &&! dcmp ( a . y - b . y );} //\u4e24\u70b9\u5750\u6807\u91cd\u5408\u5219\u76f8\u7b49 const int N = 1e5 + 10 ; int n ; Point a [ N ], b [ N ]; bool check_PL ( Point p , Point a , Point b ) { return ! dcmp ( Cro ( p - a , b - a )) && dcmp ( Dot ( p - a , p - b )) <= 0 ; //\u53c9\u4e58\u4e3a0\u8868\u4e09\u70b9\u5171\u7ebf\uff0c\u70b9\u79ef\u5c0f\u4e8e0\u8868\u793aPA\u3001PB\u53cd\u5411 } bool judge ( Point a , Point L , Point R ) //\u5224\u65adAL\u662f\u5426\u5728AR\u53f3\u8fb9 { return dcmp ( Cro ( L - a , R - a )) > 0 ; } int PIP_of_convex ( Point * P , int n , Point a ) { if ( judge ( P [ 1 ], a , P [ 2 ]) || judge ( P [ 1 ], P [ n ], a )) return 0 ; if ( check_PL ( a , P [ 1 ], P [ 2 ]) || check_PL ( a , P [ 1 ], P [ n ])) return 2 ; int L = 2 , R = n -1 ; while ( L < R ) { int mid = ( L + R + 1 ) / 2 ; //OOO)XX if ( judge ( P [ 1 ], P [ mid ], a )) L = mid ; else R = mid -1 ; } if ( judge ( P [ L ], a , P [ L + 1 ])) return 0 ; //\u4e25\u683c\u5728\u5916\u4fa7 if ( check_PL ( a , P [ L ], P [ L + 1 ])) return 2 ; return 1 ; } int main () { ios :: sync_with_stdio ( false ); while ( cin >> n ) { for ( int i = n ; i >= 1 ; i -- ) { int x , y ; cin >> x >> y ; a [ i ]. x = x , a [ i ]. y = y ; } int m ; cin >> m ; bool flag = true ; for ( int i = 1 ; i <= m ; i ++ ) { int x , y ; cin >> x >> y ; b [ i ]. x = x , b [ i ]. y = y ; } for ( int i = 1 ; i <= m ; i ++ ) { if ( PIP_of_convex ( a , n , b [ i ]) != 1 ) { flag = false ; break ;} } if ( flag ) cout << \"YES\" << endl ; else cout << \"NO\" << endl ; } return 0 ; } //http://acm.hrbust.edu.cn/vj/index.php?c=problem-problem&id=55043 \u51f8\u5305(Convex Hull) \u00b6 Graham\u626b\u63cf\u6cd5 \u00b6 \u9700\u8981\u6781\u89d2\u6392\u5e8f https://blog.csdn.net/qq_39826163/article/details/83861353 Andrew \u7b97\u6cd5 \u00b6 \u9700\u8981\u6309\u7167\u5750\u6807x\u3001y\u4f9d\u6b21\u6392\u5e8f\u5e76\u6b63\u53cd\u8dd1\u5171\u4e24\u6b21 https://oi-wiki.org/geometry/convex-hull/ https://www.cnblogs.com/yjbjingcha/p/7255457.html P1452 \u65cb\u8f6c\u5361\u58f3\u6a21\u7248 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 #include <cstdio> #include <cmath> #include <algorithm> using namespace std ; const double eps = 1e-8 ; inline int dcmp ( double a ){ return a <- eps ? -1 : ( a > eps ? 1 : 0 );} //\u5904\u7406\u7cbe\u5ea6 inline double Abs ( double a ){ return a * dcmp ( a );} //\u53d6\u7edd\u5bf9\u503c struct Point { double x , y ; Point ( double X = 0 , double Y = 0 ) { x = X , y = Y ; } }; typedef Point Vector ; double Dot ( Vector a , Vector b ) { return a . x * b . x + a . y * b . y ;} double Cro ( Vector a , Vector b ) { return a . x * b . y - a . y * b . x ;} double Len ( Vector a ) { return sqrt ( Dot ( a , a ));} Vector operator + ( Vector a , Vector b ){ return Vector ( a . x + b . x , a . y + b . y );} Vector operator - ( Vector a , Vector b ){ return Vector ( a . x - b . x , a . y - b . y );} Vector operator * ( Vector a , double b ){ return Vector ( a . x * b , a . y * b );} bool operator == ( Point a , Point b ){ return ! dcmp ( a . x - b . x ) &&! dcmp ( a . y - b . y );} //\u4e24\u70b9\u5750\u6807\u91cd\u5408\u5219\u76f8\u7b49 bool cmp1 ( Vector a , Vector b ) { if ( a . x == b . x ) return a . y < b . y ; return a . x < b . x ; } int n , conv_p ; Point a [ 50010 ], conv [ 50010 ]; int Convex_Hull ( Point * P , int n , Point * st ) { int t = 0 ; if ( n == 1 ) { st [ 1 ] = st [ 2 ] = P [ 1 ]; return t = 1 ; } if ( n == 2 ) { st [ 1 ] = P [ 1 ]; st [ 2 ] = st [ 3 ] = P [ 2 ]; return t = 2 ; } sort ( P + 1 , P + 1 + n , cmp1 ); for ( int i = 1 ; i <= n ; i ++ ) { while ( t > 1 && dcmp ( Cro ( st [ t ] - st [ t -1 ], P [ i ] - st [ t -1 ]) <= 0 )) { t -- ; } st [ ++ t ] = P [ i ]; } int temp = t ; for ( int i = n -1 ; i >= 1 ; i -- ) { while ( t > temp && dcmp ( Cro ( st [ t ] - st [ t -1 ], P [ i ] - st [ t -1 ]) <= 0 )) { t -- ; } st [ ++ t ] = P [ i ]; } return -- t ; } int dis2 ( Vector a , Vector b ) { return ( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y ); } int Rotating_calipers ( Point * conv , int t ) { int ans = 0 , j = 2 ; for ( int i = 1 ; i <= t ; i ++ ) { while ( fabs ( Cro ( conv [ i ] - conv [ j ], conv [ i + 1 ] - conv [ j ])) < fabs ( Cro ( conv [ i ] - conv [ j + 1 ], conv [ i + 1 ] - conv [ j + 1 ]))) { j ++ ; if ( j > t ) j = 1 ; } ans = max ( ans , dis2 ( conv [ i ], conv [ j ])); } return ans ; } int main () { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; i ++ ) { int x , y ; scanf ( \"%d %d\" , & x , & y ); a [ i ]. x = x , a [ i ]. y = y ; } conv_p = Convex_Hull ( a , n , conv ); printf ( \"%d\" , Rotating_calipers ( conv , conv_p )); return 0 ; } \u65cb\u8f6c\u5361\u58f3(Rotating calipers) \u00b6 https://www.jvruo.com/archives/79/ \u7528\u4e8e\u6c42\u5e73\u9762\u6700\u8fdc\u70b9\u5bf9 \u534a\u5e73\u9762\u4ea4 \u00b6 https://www.jvruo.com/archives/67/ \u8fd9\u73a9\u610f\u4e5f\u592a\u590d\u6742\u4e86\u2026\u2026 \u56fe\u8bba \u00b6 \u6811\u94fe\u5256\u5206(HLD) \u00b6 \u7528\u4e8e\u89e3\u51b3\u6811\u4e0a\u8def\u5f84\u4fee\u6539\u3001\u67e5\u8be2\u7b49\u95ee\u9898\u3002\u5c06\u6811\u5212\u5206\u6210\u82e5\u5e72\u91cd\u94fe\u540e\uff0c\u91c7\u7528\u91cd\u94fedfs\u4f18\u5148\u65b9\u5f0f\u83b7\u5f97dfn\uff0c\u8fd9\u6837\u4e00\u6765\u6811\u4e0a\u8282\u70b9\u7684dfn\u662f\u8fde\u7eed\u7684\u3002\u7ef4\u62a4dfn\u548c\u70b9\u7684\u5173\u7cfb\uff0c\u540c\u65f6\u4f7f\u7528\u6570\u636e\u7ed3\u6784\uff08\u7ebf\u6bb5\u6811\u7b49\uff09\u7ef4\u62a4\u8fde\u7eeddfn\u4e0a\u7684\u8282\u70b9\u4fe1\u606f\u4ee5\u505a\u5230\u5feb\u901f\u6811\u94fe\u4e0a\u67e5\u8be2\u548c\u4fee\u6539\u3002 \u91cd\u94fe\u5256\u5206 \u00b6 \u91cd\u5b50\u8282\u70b9 \uff1a\u5b50\u8282\u70b9\u4e2d \u5b50\u6811\u6700\u5927 \uff08\u5b50\u6811\u4e2d\u8282\u70b9\u6700\u591a\uff0c\u5305\u542b\u6811\u6839\uff09\u7684\u4e00\u4e2a\u5b50\u8282\u70b9\u3002 \u8f7b\u5b50\u8282\u70b9 \uff1a\u9664\u4e86\u91cd\u5b50\u8282\u70b9\u5916\u7684\u5b50\u8282\u70b9 \u91cd\u8fb9 \uff1a\u6839\u5230\u91cd\u5b50\u8282\u70b9\u7684\u8fb9 \u8f7b\u8fb9 \uff1a\u9664\u4e86\u6839\u5230\u91cd\u5b50\u8282\u70b9\u7684\u8fb9\u5916\u7684\u5176\u4ed6\u5230\u5b50\u8282\u70b9\u7684\u8fb9 \u91cd\u94fe \uff1a\u82e5\u5e72\u7531\u91cd\u8fb9\u8fde\u6210\u7684\u94fe\uff08\u5176\u4f59\u843d\u5355\u8282\u70b9\u4e5f\u89c6\u4e3a\u4e00\u6761\u91cd\u94fe\uff09 \u901a\u8fc7\u4e24\u6b21dfs\u5b9e\u73b0\uff0c\u7b2c\u4e00\u6b21dfs\u6807\u8bb0\u91cd\u5b50\u8282\u70b9\u3001\u6df1\u5ea6\u3001\u7236\u4eb2\u3001\u5b50\u6811\u5927\u5c0f\uff1b\u7b2c\u4e8c\u6b21\u6807\u8bb0dfn\uff08\u91cd\u8fb9\u4f18\u5148\u904d\u5386\uff09\u3001rnk\uff08dfn\u7684\u53cd\u51fd\u6570\uff0c\u4e5f\u5373\u901a\u8fc7dfn\u83b7\u5f97\u8282\u70b9\u539f\u6807\u53f7\uff09\u3001top\uff08\u6240\u5728\u91cd\u94fe\u94fe\u9876\uff09\u3002 \u6027\u8d28 \uff1a \u6811\u4e0a\u6bcf\u4e2a\u8282\u70b9\u90fd\u5c5e\u4e8e\u4e14\u4ec5\u5c5e\u4e8e\u4e00\u6761\u91cd\u94fe\uff0c\u6240\u6709\u7684\u91cd\u94fe\u5c06\u6574\u68f5\u6811 \u5b8c\u5168\u5256\u5206\u3002 \u91cd\u8fb9\u4f18\u5148\u904d\u5386\uff0c\u5219\u6700\u540e\u6bcf\u6761\u91cd\u94fe\u7684dfn\uff08top\u7684dfn\uff09\u662f\u4e0a\u5347\u7684\uff0c\u6bcf\u4e2a\u8282\u70b9\u6309\u7167dfn\u6392\u5e8f\u5373\u53ef\u5f97\u5230\u8fde\u7eed\u7684\u5256\u5206\u94fe\u3002 \u5b50\u6811\u5185\u3001\u94fe\u5185\u7684dfn\u90fd\u662f\u8fde\u7eed\u7684\u3002 \u5411\u4e0b\u7ecf\u8fc7\u8f7b\u8fb9\uff0c\u5219\u5b50\u6811\u5927\u5c0f\u81f3\u5c11\u9664\u4ee52\u3002 \u91cd\u94fe\u6570\u91cf\u4e0d\u8d85\u8fc7 \\( \\(O(\\log n)\\) \\) \u8def\u5f84\u4e0a\u7ef4\u62a4 \uff1a\u6bcf\u6b21\u9009\u62e9\u6df1\u5ea6\u8f83\u5927\u7684\u94fe\u5f80\u4e0a\u8df3\uff0c\u76f4\u5230\u4e24\u70b9\u5728\u540c\u4e00\u6761\u94fe\u4e0a\u3002 \u5b50\u6811\u7ef4\u62a4 \uff1a\u8bb0\u5f55\u6240\u5728\u5b50\u6811\u8fde\u7eed\u533a\u95f4\u672b\u7aef\u7684\u7ed3\u70b9\uff08\u4ed6\u55b5\u7684\u4e0d\u662f\u76f4\u63a5\u8bb0\u5f55\u5b50\u6811dfn\u6700\u5927\u662f\u8c01\u5c31\u884c\u4e86\u5417\uff08\uff09\uff09 LCA \uff1a\u548c\u8def\u5f84\u4e0a\u7ef4\u62a4\u76f8\u4f3c\uff0c\u4e0d\u8fc7\u5f53\u4e24\u4e2a\u8282\u70b9\u8df3\u5230\u540c\u4e00\u94fe\u65f6\uff0c\u53d6\u6df1\u5ea6\u8f83\u5c0f\u8282\u70b9\u4f5c\u4e3aLCA [P2590 ZJOI2008]\u6811\u7684\u7edf\u8ba1 \u57fa\u672c\u4e0a\u4e5f\u662f\u6a21\u677f\u9898\u4e86 P3379 \u3010\u6a21\u677f\u3011\u6700\u8fd1\u516c\u5171\u7956\u5148\uff08LCA\uff09 \u4f20\u7edf\u5e94\u7528 P3384 \u3010\u6a21\u677f\u3011\u8f7b\u91cd\u94fe\u5256\u5206 \u6a21\u677f\u9898 [P3976 TJOI2015]\u65c5\u6e38 \u4ecea\u8d70\u5230b\uff0c\u8def\u5f84\u4e0a\u627e\u4e24\u4e2a\u70b9\u4e70\u5356\uff08\u4e70\u70b9\u548c\u5356\u70b9\u8981\u4e00\u4e2a\u5728\u524d\u4e00\u4e2a\u5728\u540e\uff09\uff08\u4e8f\u94b1\u5219\u8f93\u51fa0\uff09\uff0c\u5b8c\u4e8b\u540e\u4fee\u6539\u8def\u5f84\u4e0a\u7684\u70b9\u6743\u503c\u3002 \u89e3\u6cd5\uff1a\u6811\u5256\u540e\uff0c\u7ebf\u6bb5\u6811\u7ef4\u62a4\u8def\u5f84\u6743\u503c\u6700\u5927\u503c\u3001\u6700\u5c0f\u503c\u3001\u4ece\u6839\u5230\u53f6\u5b50\u7684\u6700\u5927\u6700\u5c0f\u503c\u5dee(RTL)\u3001\u4ece\u53f6\u5b50\u5230\u6839\u7684\u6700\u5927\u6700\u5c0f\u503c\u5dee(LTR)\u3002\u7ef4\u62a4\u8fd9\u51e0\u4e2a\u503c\u5373\u53ef\u3002 \u6811\u4e0a\u542f\u53d1\u5f0f\u5408\u5e76\uff08DSU on Tree\uff09 \u00b6 \u53c2\u8003\uff1a https://www.cnblogs.com/zwfymqz/p/9683124.html#_label1_4 \u7528\u4e8e\u89e3\u51b3\u4e00\u7c7b\u7b26\u5408\u4e0b\u8ff0\u7279\u5f81\u7684\u9898\uff1a \u5bf9\u4efb\u610f\u7684\u5b50\u6811\u8be2\u95ee\uff08\u4e5f\u5373\u7edf\u8ba1\u7b54\u6848\u901a\u5e38\u53ea\u548c\u5b50\u6811\u6709\u5173\uff09 \u65e0\u4fee\u6539 \u6d41\u7a0b \uff1a \u5bf9\u4e8e\u6bcf\u4e2a\u8282\u70b9x \u9012\u5f52\u89e3\u51b3\u6240\u6709\u8f7b\u5b50\u6811\uff0c\u4e0d\u4fdd\u7559\u5f71\u54cd \u9012\u5f52\u89e3\u51b3\u91cd\u5b50\u6811\uff0c\u4fdd\u7559\u5f71\u54cd \uff08\u901a\u8fc7\u4f20\u9012\u53c2\u6570\u8868\u660e\uff09 \u518d\u626b\u63cf\u4e00\u904d\u8f7b\u5b50\u6811\uff0c\u540c\u65f6\u7edf\u8ba1\u7b54\u6848 \u5c06\u7b54\u6848\u4fdd\u5b58\u5230ans[x] \u6839\u636e\u53c2\u6570\uff0c\u5982\u679c\u9700\u8981\u5220\u9664\u5b50\u6811\u7684\u5f71\u54cd\uff0c\u5c31\u5c3d\u6570\u5220\u9664\u4e4b\uff08\u518d\u904d\u5386\u4e00\u904d\u6574\u4e2a\u5b50\u6811\uff09\uff08\u6ce8\u610f\u8fd9\u91cc\u533a\u5206\u7b54\u6848\u548c\u5f71\u54cd\uff01\uff09 \u8fd9\u91cc\u7684\u5f71\u54cd\u662f\u7528\u6765\u8f85\u52a9\u7edf\u8ba1\u5f53\u524d\u5b50\u6811\u6839\u8282\u70b9\u7b54\u6848\u7684\u4e1c\u897f\u3002\u4f8b\u5982\u5982\u679c\u8981\u6570\u5b50\u6811\u6709\u591a\u5c11\u79cd\u989c\u8272\uff0c\u90a3\u4e48cnt\u6570\u7ec4\u8868\u793a\u7b2ci\u79cd\u989c\u8272\u51fa\u73b0\u4e86\u591a\u5c11\u6b21\uff0c\u8fd9\u5c31\u662f\u9700\u8981\u5728\u626b\u63cf\u5b50\u6811\u7684\u65f6\u5019\u9700\u8981\u7edf\u8ba1\u7684\u5f71\u54cd\uff0c\u7b54\u6848\u66f4\u65b0\u4f9d\u8d56\u4e8e\u6b64\u3002 \u590d\u6742\u5ea6 \uff1a\uff08\u6765\u6e90\u4e8e\u9a6c\u524d\u5352\uff09 \u4e00\u4e2a\u70b9\u88ab\u8bbf\u95ee\u5230\uff0c\u53ea\u6709\u4e24\u79cd\u60c5\u51b5 1\u3001\u5728\u66b4\u529b\u7edf\u8ba1\u8f7b\u8fb9\u7684\u65f6\u5019\u8bbf\u95ee\u5230\u3002 \u6839\u636e\u524d\u9762\u7684\u6027\u8d28\uff0c\u8be5\u6b21\u6570<logn 2\u3001\u901a\u8fc7\u91cd\u8fb9 / \u5728\u904d\u5386\u7684\u65f6\u5019\u88ab\u8bbf\u95ee\u5230 \u663e\u7136\u53ea\u6709\u4e00\u6b21 cf600E. Lomsat gelral \u9898\u610f\uff1a\u7ed9\u51fa\u4e00\u4e2a\u6811\uff0c\u6c42\u51fa\u6bcf\u4e2a\u8282\u70b9\u7684\u5b50\u6811\u4e2d\u51fa\u73b0\u6b21\u6570\u6700\u591a\u7684\u989c\u8272\u7684\u7f16\u53f7\u548c\uff08\u53ef\u80fd\u6709\u591a\u79cd\u989c\u8272\u51fa\u73b0\u6b21\u6570\u90fd\u662f\u6700\u591a\u7684\uff09 \u89e3\u6cd5\uff1a\u5f71\u54cd\u5c31\u662f\u4e0a\u6587\u4e2d\u8bf4\u7684cnt\uff08\u5b50\u6811\u4e2d\u67d0\u79cd\u989c\u8272\u51fa\u73b0\u4e86\u591a\u5c11\u6b21\uff09\uff0c\u540c\u65f6\u5f00\u4e00\u4e2a\u8f85\u52a9\u53d8\u91cfmaxval\u6765\u8bb0\u5f55\u51fa\u73b0\u6b21\u6570\u6700\u591a\u7684\u989c\u8272\u7684\u51fa\u73b0\u6b21\u6570\u662f\u591a\u5c11\u3002 \u6709\u5411\u56feTarjan \uff08\u5f85\u8865\u5145\uff09 \u00b6 (\u53ef\u80fd\u662f)\u8fb9\u5206\u6cbb \u00b6 HDU2376 Average Distance \u5206\u6210 \u5b50\u6811 \u4e58\u4ee5 \u5b50\u6811\u5916\u7684\u70b9\uff0c\u518d\u4e58\u4ee5\u8fb9\u7684\u6743\u503c\uff0c\u5373\u53ef\u5f97\u5230\u8fb9\u7684\u8d21\u732e\u3002 \u4e25\u683c\u6765\u8bf4\u5e94\u8be5\u662f\u8d2a\u5fc3\u800c\u4e0d\u662f\u8fb9\u5206\u6cbb\u2026\u2026 \u5b57\u7b26\u4e32 \u00b6 \u6269\u5c55kmp \u00b6 (by hqh 20201018) https://oi-wiki.org/string/z-func/ \u4e0b\u6587\u4e2d\u5b57\u7b26\u4e32\u4ece1\u5f00\u59cb\u8ba1\u6570\u3002 LCP \uff1a\u6700\u957f\u516c\u5171\u524d\u7f00 \u5b9a\u4e49\u5b57\u7b26\u4e32a(\u957f\u4e3am)\u5173\u4e8e\u6a21\u5f0f\u4e32b\u7684 extend\u6570\u7ec4 \uff1aextend[i]\u8868\u793aa\u7684\u5b50\u4e32a[i~m]\u548cb\u7684LCP\u957f\u5ea6\u3002\u5982a='abcde'\uff0cb='bcd', \u5219a\u7684extend[2]=3\uff08\u6700\u957f\u516c\u5171\u524d\u7f00\u4e3abcd\uff09 \u5b9a\u4e49\u5b57\u7b26\u4e32b(\u957f\u4e3an)\u7684 z\u51fd\u6570 \uff1az[i]\u8868\u793ab[i~n]\u4e0eb\u81ea\u8eab\u7684LCP\u957f\u5ea6\u3002\u5982b='ababc'\uff0cz\u51fd\u6570\u4e3a[5 0 2 0 0]\u3002z[1]\u5b9e\u9645\u4e0a\u662f\u65e0\u610f\u4e49\u7684\uff0c\u4e00\u822c\u5b9a\u4e49\u5176\u4e3ab\u7684\u957f\u5ea6\u3002 \u6c42z\u51fd\u6570\u7684\u7b97\u6cd5 \uff1a \u6838\u5fc3\u601d\u60f3\u662f\u5728\u91c7\u7528\u66b4\u529b\u5339\u914d\u7684\u57fa\u7840\u4e0a\uff0c\u6c42z[i]\u524d\u5148\u521d\u59cb\u5316z[i]\u4e3a\u4e4b\u524d\u67d0\u4e2a\u5df2\u7ecf\u6c42\u51fa\u7684\u503c\uff0c\u7136\u540e\u518d\u66b4\u529b\u5339\u914d\u3002 \u5047\u8bbe\u73b0\u5728\u6c42\u5230\u67d0\u4e2a\u4f4d\u7f6ei\uff0c\u8bb0\u5f55\u4e4b\u524d\u80fd\u8bbf\u95ee\u5230\u7684\u6700\u53f3\u4f4d\u7f6e\u4e3ar\uff0c\u5bf9\u5e94\u8bbf\u95ee\u5230\u8fd9\u4e2a\u4f4d\u7f6e\u7684\u4e0b\u6807\u4e3al\u3002\u5219b\u4e2d\uff0cl~r\u4e0e1~r-l+1\u5bf9\u5e94\u5b50\u4e32\u76f8\u7b49\u3002\u8fd9\u610f\u5473\u7740i\u5f00\u59cb\u5904\u67d0\u4e00\u90e8\u5206\u548c1~r-l+1\u662f\u4e00\u6837\u7684\uff0c \u89c1\u4e0b\u56fe \u3002\u56e0\u6b64\u81f3\u5c11\u53ef\u4ee5\u4fdd\u8bc1z[i]\u6709z[i-l+1]\u90a3\u4e48\u591a\u3002\u5f53\u7136\u4e5f\u6709\u53ef\u80fdz[i-l+1]\u4f5c\u4e3ai\u5904\u7684\u521d\u59cb\u957f\u5ea6\u4f1a\u8d85\u51fa\u76ee\u524d\u5df2\u7ecf\u77e5\u9053\u7684\u6700\u53f3\u4f4d\u7f6e\uff0c\u56e0\u6b64\u5e94\u8be5\u9650\u5236\u5176\u4e0d\u80fd\u8d85\u8fc7r\uff08\u56e0\u4e3ar\u7684\u53f3\u8fb9\u6211\u4eec\u662f\u4e0d\u77e5\u9053\u7684\uff0c\u9700\u8981\u66b4\u529b\u5339\u914d\u5f97\u77e5\uff09\u3002 \u521d\u59cb\u5316\u4e4b\u540e\u76f4\u63a5\u66b4\u529b\u5339\u914d\u5373\u53ef\u3002\u53ef\u4ee5\u8bc1\u660e\u6b64\u79cd\u505a\u6cd5\u590d\u6742\u5ea6\u662fOn\u7684\u3002\uff08\u8bc1\u660e\u53c2\u89c1\u94fe\u63a5\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void get_z ( int n = b_l ) { int l = 1 , r = 1 ; z [ 1 ] = b_l ; //undefined for ( int i = 2 ; i <= n ; i ++ ) { if ( i <= r ) z [ i ] = min ( z [ i - l + 1 ], r - i + 1 ); //init while ( i + z [ i ] <= n && b [ z [ i ] + 1 ] == b [ i + z [ i ]]) //i+z[i] is next position, so accessible pos is i+z[i]-1 z [ i ] ++ ; if ( i + z [ i ] -1 > r ) l = i , r = i + z [ i ] -1 ; } } \u6c42extend\u7684\u7b97\u6cd5\uff1a \u548cz\u51fd\u6570\u5dee\u4e0d\u591a 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void exkmp ( int m = a_l , int n = b_l ) //get extend array { while ( extend [ 1 ] <= m && a [ 1 + extend [ 1 ]] == b [ 1 + extend [ 1 ]]) extend [ 1 ] ++ ; int l = 1 , r = 1 ; for ( int i = 2 ; i <= m ; i ++ ) { if ( i <= r ) extend [ i ] = min ( z [ i - l + 1 ], r - i + 1 ); while ( i + extend [ i ] <= m && b [ extend [ i ] + 1 ] == a [ i + extend [ i ]]) extend [ i ] ++ ; if ( i + extend [ i ] -1 > r ) l = i , r = i + extend [ i ] -1 ; } } \u6a21\u5f0f\u5339\u914d \uff1a\u663e\u7136\u6c42\u51faextend\u6570\u7ec4\u540e\uff0cextend[i]=n\u5904\u610f\u5473\u7740\u5339\u914d\u6210\u529f\uff08\u4ecei\u5f00\u59cb\u7684\u4e00\u6bb5\u5b50\u4e32\u4e0eb\u5b8c\u5168\u91cd\u5408\uff09\u3002 \u672c\u8d28\u4e0d\u540c\u5b50\u4e32\u6570\u76ee \uff1a\u5047\u8bbe\u5bf9\u4e8e\u5b57\u7b26\u4e32a\uff08\u957f\u4e3an\uff09\uff0c\u540ei+1\u5b57\u7b26\u6784\u6210\u7684\u5b50\u4e32\u4e2d\u672c\u8d28\u4e0d\u540c\u5b50\u4e32\u6570\u76ee\u5df2\u7ecf\u6c42\u51fa\uff08\u8bbe\u4e3aans\uff09\uff0c\u73b0\u5728\u6211\u4eec\u6765\u6c42\u540ei\u4e2a\u5b57\u7b26\u4e2d\u672c\u8d28\u4e0d\u540c\u5b50\u4e32\u6570\u76ee\u3002\u8fd9\u4e2a\u95ee\u9898\u76f8\u5f53\u4e8e\u5728\u5b57\u7b26\u4e32\u5934\u6dfb\u52a0\u4e86\u4e00\u4e2a\u5b57\u7b26c,\u4f7f\u5f97a:=c+a\u3002\u518d\u7528On\u7684\u65f6\u95f4\u6c42\u51fa\u65b0\u5b57\u7b26\u4e32\u7684z\u51fd\u6570\uff0c\u7136\u540e\u904d\u5386z[2~n]\uff0c\u8fd9\u4e4b\u4e2d\u6700\u5927\u7684\u503cz[j]\u5373\u4e3a\u65b0\u5b57\u7b26\u4e32\u7684\u6700\u957f\u91cd\u5408\u524d\u7f00\uff0c\u663e\u7136\u5c0f\u4e8e\u6b64\u957f\u5ea6\u7684\u65b0\u5b57\u7b26\u4e32\u524d\u7f00\u4e5f\u4f1a\u91cd\u5408\uff0c\u56e0\u6b64ans+=n-max(z[2~n]) \u5b57\u7b26\u4e32\u538b\u7f29 \uff1a\uff08\u5f85\u8865\u5145\uff09 P5410 \u3010\u6a21\u677f\u3011\u6269\u5c55 KMP\uff08Z \u51fd\u6570\uff09 \u6a21\u677f\u9898 [P2375 NOI2014]\u52a8\u7269\u56ed \u9898\u610f\uff1a\u6c42\u5b57\u7b26\u4e32a\u7684num\u6570\u7ec4\uff0cnum[i]\u8868\u793a\u5b50\u4e32a[1~i]\u540e\u7f00\u4e0e\u524d\u7f00\u76f8\u540c\u4e14\u524d\u540e\u7f00\u4e92\u4e0d\u91cd\u53e0\u7684\u6570\u76ee\u3002\u5982\"abababa\",num[7]=2\uff0c\u56e0\u4e3a\"a\", \"aba\"\u4e3a\u76f8\u540c\u524d\u540e\u7f00\uff0c\u4f46\"ababa\"\u4e0d\u662f\uff0c\u56e0\u4e3a\u91cd\u53e0\u4e86\u3002 \u89e3\u6cd5\uff1a\u8003\u8651\u5230a\u7684z\u51fd\u6570\u7684\u610f\u4e49\u4e3ai\u5f00\u59cb\u7684\u5b50\u4e32\u4e0e\u81ea\u8eab\u7684LCP\u957f\u5ea6\uff0c\u90a3\u4e48\u5bf9\u4e8e\u66f4\u77ed\u7684\u957f\u5ea6\uff08\u8bbe\u6b64\u65f6\u7ec8\u70b9\u4e3aj\uff09\uff0ca[i~j]\u4e5f\u662fa\u7684\u524d\u7f00\u3002\u6bd4\u5982a=\"bbbbb\",z[3]=3\uff0c\u4e5f\u5373a[1~3]\u4e0ea[3~5]\u76f8\u540c\uff0c\u90a3\u4e48a[1~2]\u4e0ea[3~4], a[1]\u4e0ea[3]\u4e5f\u76f8\u540c\u3002 \u56e0\u6b64\u5047\u5982\u6ca1\u6709\u4e0d\u80fd\u91cd\u53e0\u7684\u9650\u5236\uff0c\u90a3\u4e48\u5bf9\u4e8e\u4f4d\u7f6ei\uff0c\u5176z[i]\u4f1a\u5bf9i~i+z[i]-1\u5904\u7684num\u90fd\u67091\u7684\u8d21\u732e\u3002\u8003\u8651\u4e0a\u4e0d\u80fd\u91cd\u53e0\u7684\u9650\u5236\uff0c\u56e0\u4e3az[i]\u53ef\u80fd\u5f88\u5927\u800c\u5bfc\u81f4\u516c\u5171\u524d\u7f00\u91cd\u53e0\uff0c\u56e0\u6b64\u5bf9\u4e8ez[i]>=i\u7684\u90e8\u5206\u7684\u8d21\u732e\u4e0d\u4e88\u8003\u8651\u5373\u53ef\u3002\u4e5f\u5373z[i]\u5bf9i~min(i+z[i]-1,i+(i-1)-1)\u7684numm\u6709\u8d21\u732e\u3002 \u6700\u540e\u5dee\u5206\u4e00\u4e0b\u518d\u7d2f\u52a0\u5dee\u5206\u8d21\u732e\u5373\u53ef\u3002\uff08\u5f53\u7136\u8fd9\u9898\u4f60\u4e5f\u53ef\u4ee5\u7528\u4e00\u822ckmp\u505a\uff09 CF1051E Vasya and Big Integers \u00b6 \u9898\u610f\uff1a\u7ed9\u4e09\u4e2a\u5927\u6570a,L,R, \u6c42\u5c06a\u5212\u5206\u6210\u6bcf\u6bb5\u6784\u6210\u7684\u6570\u65e0\u524d\u5bfc\u96f6\u4e14\u5927\u5c0f\u4ecb\u4e8e[L,R]\u4e4b\u95f4\u7684\u65b9\u6848\u6570\uff08Mod 998244353\uff09 \\(1\\le a\\le 1e(1e6), 0\\le L\\le R\\le 1e(1e6)\\) \uff0c\u4e5f\u5373\u4e0a\u9650\u6709\u5341\u4e07\u4f4d\u3002 \u89e3\u6cd5\uff1a\u8bbe \\(dp[j]\\) \u8868\u793a\u4ee5j~j+1\u4e4b\u95f4\u4f5c\u4e3a\u4e00\u6bb5\u7684\u8fb9\u754c\uff0c\u5212\u5206\u7684\u65b9\u6848\u6570\u3002\u5219 $$ dp[j]=\\sum(dp[i]) $$ \u5176\u4e2di\u4e3a\u540c\u65f6\u6ee1\u8db3\u4e0b\u97623\u4e2a\u6761\u4ef6\u7684\u6240\u6709\u6b63\u6574\u6570\uff1a \\(0\\le i \\le j-1\\) \\(a[i+1]\\neq 0\\) \uff08\u9664\u975eL\u4ec5\u6709\u4e00\u4f4d\uff0c\u53c2\u89c1\u4e0b\u6587\u8ba8\u8bba\uff09 \\(a[i+1 \\text{~} j]\\) \u6784\u6210\u7684\u6570\u5728[L,R]\u4e4b\u5185 \u6761\u4ef62\u662f\u4e3a\u4e86\u9650\u5236\u6709\u524d\u5bfc\u96f6\u7684\u5212\u5206\u4e0d\u80fd\u88ab\u8f6c\u79fb\u3002\u53ea\u6709\u4e00\u79cd\u60c5\u51b5\u4e0b\u8fd9\u6bb5\u80fd\u4ee50\u5f00\u5934\uff0c\u5c31\u662f\u8fd9\u6bb5\u6784\u6210\u7684\u6570\u672c\u8eab\u5c31\u662f0\u3002\u8fd9\u79cd\u60c5\u51b5\u4e0bL=0\uff0c\u56e0\u6b64i=j-1\u8fd9\u79cd\u60c5\u51b5\u7684\u5212\u5206\u9700\u8981\u505a\u7279\u5224\u3002 \u9664\u6b64\u4e4b\u5916\uff0c\u6613\u53d1\u73b0\u6ee1\u8db3\u6761\u4ef6\u7684i\u662f\u8fde\u7eed\u7684\u3002\u8bbea[i+1~j]\u6784\u6210\u7684\u6570\u4f4dM\uff0c|M|\u4e3a\u4e00\u4e2a\u6570\u7684\u6570\u4f4d\u957f\u5ea6\uff0c\u5219\u663e\u7136|L|<|M|<|R|\u7684\u60c5\u51b5\u90fd\u6ee1\u8db3\u6761\u4ef63\uff0c\u552f\u72ec\u53d6\u7b49\u53f7\u5904\u9700\u8981\u6bd4\u8f83L\u6216\u8005R\u4e0eM\u7684\u5927\u5c0f\u65b9\u80fd\u786e\u5b9a\u5bf9\u5e94\u4f4d\u7f6e\u7684i\u662f\u5426\u6ee1\u8db3\u6761\u4ef63\u3002\u800c\u6570\u7684\u6bd4\u8f83\u53ef\u901a\u8fc7\u6bd4\u8f83\u4e24\u6570\u7684LCP\u540e\u4e00\u4f4d\u89e3\u51b3\u3002\u6c42\u51faL\u3001R\u7684z\u51fd\u6570\uff0c\u518d\u6c42\u51faa\u5173\u4e8eL\u3001R\u7684extend\u6570\u7ec4\u5373\u53ef\u3002\u5f53\u7136\u6700\u540e\u8981\u4fdd\u8bc1i\u6ee1\u8db3\u6761\u4ef61. \u8fde\u7eed\u7684\u4e00\u6bb5i\u7684\u8f6c\u79fb\u53ef\u901a\u8fc7\u4fdd\u5b58dp\u7684\u524d\u7f00\u548cdpsum\u5b9e\u73b0\uff0c\u4f46\u5f53a[j+1]=0\u65f6,\u5176\u4e0d\u5e94\u8be5\u88ab\u8ba1\u5165dpsum\u4e2d\uff0c\u4ee5\u514d\u7834\u574f\u6761\u4ef62. \u5177\u4f53\u5b9e\u73b0\u53c2\u89c1\u4ee3\u7801\u3002 AC\u81ea\u52a8\u673a \u00b6 \uff08By hqh 20201031\uff09 https://oi-wiki.org/string/ac-automaton/ \u81ea\u52a8\u673a\u662f\u4e00\u79cd\u6709\u5411\u56fe\uff0c\u56fe\u4e0a\u7684\u7ed3\u70b9\u8868\u793a\u5904\u4e8e\u67d0\u79cd\u72b6\u6001\uff0c\u800c\u8fb9\u8868\u793a\u72b6\u6001\u7684\u8f6c\u79fb\u3002 AC\u81ea\u52a8\u673a\u7684\u4e3b\u8981\u7528\u9014\u662f\u201c\u591a\u6a21\u5f0f\u5339\u914d\u201d\uff0c\u4e5f\u5373\u7ed9\u5b9a\u82e5\u5e72\u4e2a\u6a21\u5f0f\u4e32\uff0c\u518d\u7ed9\u5b9a\u4e00\u4e2a\u4e3b\u4e32\uff0c\u8981\u6c42\u51fa\u6bcf\u4e2a\u6a21\u5f0f\u4e32\u5728\u4e3b\u4e32\u4e2d\u7684\u51fa\u73b0\u6b21\u6570\u3002 \u4e3b\u8981\u7684\u601d\u60f3\u662f\u5c06\u591a\u4e2a\u6a21\u5f0f\u4e32\u6784\u5efatrie\u6811\uff0c\u7136\u540e\u901a\u8fc7\u4fee\u6539trie\u6811\u7684\u4e00\u4e9b\u8fb9\uff0c\u6765\u5b9e\u73b0\u591a\u6a21\u5f0f\u5feb\u901f\u5339\u914d\u3002\u56e0\u6b64\u4f60\u53ef\u4ee5\u7406\u89e3\u4e3a\u5728trie\u6811\u4e0a\u8dd1kmp\u3002 \u5bf9AC\u81ea\u52a8\u673a\u800c\u8a00\uff0c\u6bcf\u4e2a\u7ed3\u70b9\u7684\u72b6\u6001\u8868\u793a\u5f53\u524d\u591a\u6a21\u5f0f\u5339\u914d\u7684\u8fdb\u5ea6\uff08\u5728\u5339\u914d\u7ed3\u675f\u5904\uff0c\u5bf9\u5e94\u7ed3\u70b9\u62e5\u6709\u4e00\u4e2a\u5339\u914d\u5b8c\u6210\u6807\u8bc6\u7b26end[u]\u8868\u793a\u6210\u529f\u5339\u914d\u4e00\u4e2a\u6a21\u5f0f\u4e32\uff09\uff1b\u8fb9\u662f\u5b57\u7b26\uff0c\u5f15\u5bfc\u8f6c\u79fb\u5230\u4e0b\u4e00\u4e2a\u72b6\u6001\u3002 ### fail\u6307\u9488 \u6784\u5efa\u81ea\u52a8\u673a\u7684\u5173\u952e\u5728\u4e8efail\u6307\u9488\u3002\u6784\u5efa\u5b8c\u6210trie\u6811\u540e\uff0c\u6211\u4eec\u5229\u7528bfs\u6784\u5efafail\u6307\u9488\u3002 fail\u6307\u9488\u4ee3\u8868\u7684\u610f\u4e49\u662f\u6307\u5411trie\u6811\u4e2d\u7684\u53e6\u4e00\u4e2a\u7ed3\u70b9\uff0c\u8fd9\u4e2a\u7ed3\u70b9\u6ee1\u8db3\u4ece\u6839\u8d70\u5230\u5bf9\u5e94\u7ed3\u70b9\u6240\u5bf9\u5e94\u7684\u5b57\u7b26\u4e32\uff0c\u662f\u5f53\u524d\u7ed3\u70b9\u5bf9\u5e94\u7684\u5b57\u7b26\u4e32\u7684 \u6700\u957f\u540e\u7f00 \u3002\u6bd4\u5982\u5f53\u524d\u7ed3\u70b9\u5bf9\u5e94\u5b57\u7b26\u4e32\u662fabaaa\uff0ctrie\u6811\u4e0a\u8fd8\u6709\u53e6\u4e00\u6761\u8def\u5f84\u8868\u793aaaa\uff0c\u5219\u5176fail\u6307\u5411\u6b64\u7ed3\u70b9\u3002 \u5f53\u6211\u4eec\u5339\u914d\u8fc7\u7a0b\u4e2d\u5931\u914d\u65f6\uff08\u8d70\u5230\u67d0\u4e00\u4e2a\u7ed3\u70b9\u540e\uff0ctrie\u6811\u4e0a\u5bf9\u5e94\u4e0b\u4e00\u4e2a\u5b57\u7b26\u7684\u7ed3\u70b9\u4e0d\u5b58\u5728\uff09\uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u8df3\u5230fail\uff0c\u518d\u7ee7\u7eed\u5c1d\u8bd5\u5339\u914d\u3002\u8fd9\u76f8\u5f53\u4e8e\u629b\u5f03\u4e00\u90e8\u5206\u5f53\u524d\u6a21\u5f0f\u4e32\u524d\u7f00\u4f7f\u5f97\u5339\u914d\u80fd\u591f\u7ee7\u7eed\u8fdb\u884c\u3002 \u5177\u4f53\u6784\u5efa\u65b9\u5f0f\u662f\u7528bfs\uff0c\u53d6\u51fa\u961f\u5934\u7ed3\u70b9u\uff0c\u7136\u540e\u904d\u5386\u6b64\u8282\u70b9\u7684\u63a5\u4e0b\u6765\u7684\u6240\u6709\u53ef\u80fd\u5b57\u7b26i\uff080~25\uff09\uff0c\u6309\u7167\u5982\u4e0b\u4ee3\u7801\u9012\u63a8\u5730\u66f4\u65b0\u4e0b\u4e00\u4e2a\u7ed3\u70b9\u7684fail\u6307\u9488\uff1a 1 fail[trie[u][i]]=trie[fail[u]][i]; \u4e5f\u5373\u8ba9\u4e0b\u4e00\u4e2a\u7ed3\u70b9\u7684fail\u6307\u9488\uff0c\u6307\u5411\u5f53\u524d\u7ed3\u70b9fail\u6307\u9488\u7684\u4e0b\u4e00\u4e2a\u5b57\u7b26i\u5bf9\u5e94\u7684\u7ed3\u70b9\u3002\u56e0\u4e3a\u662f\u7528bfs\uff0c\u53ef\u4ee5\u4fdd\u8bc1\u4e0b\u4e00\u4e2a\u7ed3\u70b9\u66f4\u6d45\u7684\u7ed3\u70b9\u5df2\u7ecf\u88ab\u66f4\u65b0\uff0c\u6240\u4ee5\u53ef\u4ee5\u8fd9\u4e48\u505a\u3002 \u5176\u4ed6\u8be6\u7ec6\u4fe1\u606f\u8bf7\u53c2\u89c1\u6587\u5934\u6240\u7ed9\u94fe\u63a5\u3002 \u5b57\u5178\u56fe \u00b6 \u4f7f\u7528fail\u6307\u9488\u5728\u5931\u914d\u65f6\u8df3\u8dc3\u5f88\u86cb\u75bc\uff0c\u56e0\u4e3a\u5982\u679c\u8df3\u4e86\u4e4b\u540e\u8fd8\u662f\u5931\u914d\u90a3\u4e48\u4f60\u8fd8\u662f\u5f97\u7ee7\u7eed\u4ecefail[u]\u7ee7\u7eed\u8df3\u5230fail[fail[u]]\uff0c\u90a3\u4e48\u6709\u6ca1\u6709\u66f4\u597d\u7684\u65b9\u6cd5\u5462\uff1f \u6ce8\u610f\u5230\u5982\u679c\u5728u\u5904\u524d\u5f80i\u5b57\u7b26\u65f6\u5931\u914d\uff0c\u90a3\u4e48trie[u][i] \u5fc5\u7136\u672a\u5b9a\u4e49\uff0c\u6211\u4eec\u901a\u8fc7\u6539\u5199trie[u][i] \u4f7f\u5f97\u5176\u76f4\u63a5\u6307\u5411\u4e0b\u4e00\u4e2a\u4e0d\u5931\u914d\u7684fail\u5373\u53ef\u3002 \u6bd4\u5982\uff1a 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u3002\u3002\u3002 \uff08\u524d\u9762\u662fBFS\u53d6\u51fa\u961f\u5934u\u7ed3\u70b9\uff09 for(int i=0;i<26;i++) { if(trie[u][i]) { fail[trie[u][i]]=trie[fail[u]][i]; q.push(trie[u][i]); } else { trie[u][i]=trie[fail[u]][i]; } } \u3002\u3002\u3002 \u4f7f\u7528 trie[u][i]=trie[fail[u]][i]; \u5728\u6c42fail\u7684\u540c\u65f6\u6539\u5199\u672a\u5b9a\u4e49trie\u6307\u9488\u5373\u53ef\u3002\u8fd9\u6837\uff0c\u5728\u5339\u914d\u65f6\u53ef\u4ee5\u76f4\u63a5\u4ee4 u=trie[u][i] \uff08\u4e0d\u8bba\u662f\u5426\u5931\u914d\uff09\u3002 \u8fd9\u6837\u4e4b\u540etrie\u5176\u5b9e\u5df2\u7ecf\u4e0d\u518d\u662f\u4e00\u68f5\u6811\uff0c\u800c\u662f\u4e00\u4e2a\u4f1a\u81ea\u6307\u7684\u56fe\uff0c\u6211\u4eec\u79f0\u4e4b\u4e3a\u5b57\u5178\u56fe\u3002 last\u4f18\u5316 \u00b6 \u4e8b\u5b9e\u4e0a\uff0c\u6c42\u6bcf\u4e2a\u6a21\u5f0f\u4e32\u5728\u4e3b\u4e32\u4e2d\u7684\u51fa\u73b0\u6b21\u6570\uff0c\u4e0d\u4ec5\u9700\u8981\u5728\u5b57\u5178\u56fe\u4e0a\u904d\u5386\uff0c\u800c\u4e14\u6bcf\u904d\u5386\u4e00\u4e2a\u7ed3\u70b9\u8fd8\u5f97\u8df3fail\uff08\u4e0d\u8bba\u5931\u914d\u4e0e\u5426\uff09\uff0c\u56e0\u4e3a\u4f60\u5e76\u4e0d\u77e5\u9053\u5f53\u524d\u5339\u914d\u4f4d\u7f6e\u6709\u591a\u5c11\u4e2a\u6a21\u5f0f\u4e32\u80fd\u5339\u914d\u3002 \u6bd4\u5982\uff1a\u4e3b\u4e32abaaa\uff0c\u6a21\u5f0f\u4e32aaa\u3001baaa\uff1b\u5339\u914d\u5230\u4e3b\u4e32\u7684\u6700\u540e\u4e00\u4e2aa\u65f6\uff0c\u4f1a\u5728trie\u56fe\u4e0a\u7684baaa\u5904\uff0c\u4f46\u8fd8\u662f\u5f97\u8df3fail\uff0c\u8df3\u5230trie\u56fe\u4e0a\u7684aaa\u4e0a\uff0c\u624d\u80fd\u77e5\u9053\u8fd9\u4e2a\u5b57\u7b26\u4e32\u4e5f\u5728\u4e3b\u4e32\u6700\u540e\u4e00\u4e2aa\u5904\u6210\u529f\u5339\u914d\u3002 \u8fd9\u4e2a\u505a\u6cd5\u5e26\u6765\u7684\u4ee3\u4ef7\u5176\u5b9e\u53ef\u4ee5\u6362\u6210\u53e6\u4e00\u79cd\u505a\u6cd5\u4ee5\u5f7b\u5e95\u6539\u5584\uff08\u89c1\u4e0b\u6587fail\u6811\uff09\uff0c\u4f46\u8fd9\u91cc\u5148\u8bf4\u660e\u53e6\u4e00\u79cd\u4f18\u5316\u65b9\u6cd5\u3002 \u5728\u8df3fail\u7684\u8fc7\u7a0b\u4e2d\uff0c\u5e76\u4e0d\u662f\u6bcf\u4e00\u4e2a\u7ed3\u70b9\u90fd\u662f\u67d0\u4e00\u6a21\u5f0f\u4e32\u7684\u7ec8\u70b9\u3002\u800c\u5728\u5b57\u5178\u56fe\u6784\u5efa\u5b8c\u6bd5\u540e\uff0cfail\u6811\u5176\u5b9e\u5bf9\u5339\u914d\u800c\u8a00\u610f\u4e49\u5c31\u4e0d\u5927\u4e86\uff0c\u56e0\u6b64\u6211\u4eec\u5e0c\u671bfail\u80fd\u76f4\u63a5\u8df3\u5230\u201c\u67d0\u4e2a\u6a21\u5f0f\u4e32\u201d\u7684\u7ed3\u5c3e\u3002\u6211\u4eec\u5f15\u5165last\u6570\u7ec4\uff0c\u5176\u53ef\u4ee5\u76f4\u63a5\u8df3\u5230\u201c\u67d0\u4e2a\u6a21\u5f0f\u4e32\u201d\u7684\u7ed3\u5c3e\u3002 \u6211\u4eec\u5728\u6784\u5efafail\u6307\u9488\u65f6\u6dfb\u52a0\u8fd9\u4e48\u4e00\u53e5\u8bdd\uff1a 1 2 3 4 5 6 ... fail[trie[u][i]]=trie[fail[u]][i]; last[trie[u][i]]=(id[fail[trie[u][i]]]==0)?(last[fail[trie[u][i]]]):(fail[trie[u][i]]); //\u6709\u6548\u5b57\u7b26\u4e32\u7ed3\u5c3e q.push(trie[u][i]); ... id[u] \u8868\u793a\u7ed3\u70b9u\u4f5c\u4e3a\u67d0\u4e00\u6a21\u5f0f\u4e32\u7684\u7ed3\u5c3e\uff0c\u5bf9\u5e94\u7684\u5b57\u7b26\u4e32\u7f16\u53f7\uff08\u5982\u679cu\u4e0d\u662f\u67d0\u4e00\u4e32\u7684\u7ed3\u5c3e\u8282\u70b9\uff0c\u90a3\u4e48\u5176\u4e3a0\uff09\u3002\u901a\u8fc7last\u7684\u9012\u63a8\u5373\u53ef\u6c42\u5f97last\u6570\u7ec4\u3002\u5728\u5339\u914d\u6c42\u89e3\u6bcf\u4e2a\u6a21\u5f0f\u4e32\u5728\u4e3b\u4e32\u4e2d\u7684\u51fa\u73b0\u6b21\u6570\u7684\u8fc7\u7a0b\u4e2d\uff0c\u6539\u8df3last\u800c\u975efail\u5373\u53ef\u3002 \u4f46\u8fd9\u4e48\u505a\u7684\u4f18\u5316\u4ec5\u4ec5\u53ea\u662f\u5e38\u6570\u4e0a\u7684\uff0c\u5982\u679c\u7ed9\u82e5\u5e72\u4e2a\u6a21\u5f0f\u4e32a\u3001aa\u3001aaa\u3001aaaa\u2026\u2026\uff0c\u90a3\u8fd8\u662f\u4f1a\u88ab\u5361\uff0c\u56e0\u6b64\u6211\u4eec\u5f15\u5165fail\u6811\u3002 fail\u6811 \u00b6 \u5c06\u6240\u6709\u7ed3\u70b9\u7684fail\u6307\u9488\u53cd\u8fc7\u6765\u63a5\uff0c\u5c06\u6784\u6210\u4e00\u4e2a\u4ee5trie\u56fe0\u7ed3\u70b9\u4e3a\u6839\u7684\u6811\uff0c\u6210\u4e3afail\u6811\u3002\u4ecefail\u6811\u5411\u4e0b\u8d70\uff0c\u76f8\u5f53\u4e8e\u5728\u5f53\u524d\u5b57\u7b26\u4e32\u524d\u6dfb\u52a0\u524d\u7f00\u3002\u6bd4\u5982abb\uff0c\u4ecefail\u6811\u5411\u4e0b\u8d70\u5230fuabb\uff08\u5f53\u7136\u53ef\u80fd\u4f1a\u6709\u597d\u51e0\u4e2a\u5b69\u5b50\uff0c\u8fd9\u91cc\u53ea\u662f\u4e3e\u4e2a\u4f8b\u5b50\uff09\u3002 \u6784\u5efa\u6b64\u6811\u4e5f\u5f88\u7b80\u5355\uff0c\u5728fail\u6307\u9488\u6784\u5efa\u5b8c\u6210\u540e\uff1a 1 2 3 4 for(int i=1;i<=total;i++) { adde(fail[i],i); } \u56de\u5230\u4e0a\u9762\u7684\u95ee\u9898\uff0c\u4e4b\u524d\u6211\u4eec\u901a\u8fc7last\u6570\u7ec4\u8fdb\u884c\u4e86\u4f18\u5316\u3002\u73b0\u5728\u5229\u7528fail\u6811\uff0c\u6211\u4eec\u53ef\u4ee5\u5229\u7528\u6811\u4e0a\u5dee\u5206\u7684\u65b9\u6cd5\uff0c\u6307\u5728\u5f53\u524d\u7ed3\u70b9u\u5904\u6dfb\u52a0\u4e00\u4e2a\u6807\u8bb01\uff0c\u8868\u793a\u81eau\u5230\u6839\u7684\u8def\u5f84\u90fd\u4f1a\u53d7\u6b64\u6807\u8bb0\u5f71\u54cd\u3002\u5339\u914d\u7ed3\u675f\u4e4b\u540e\u5bf9fail\u6811\u505adfs\u4ee5\u6c42\u51fa\u5dee\u5206\u7684\u76f8\u52a0\u503c\uff0c\u6700\u540e\u770b\u6bcf\u4e00\u4e2a\u7ed3\u70b9\u7684\u503c\uff0c\u6b64\u503c\u5c31\u662f\u5bf9\u5e94\u7684\u5b57\u7b26\u4e32\u7684\u51fa\u73b0\u6b21\u6570\u3002 \u5f53\u7136fail\u6811\u8fd8\u6709\u5f88\u591a\u7528\u9014\uff0c\u9664\u4e86\u5dee\u5206\u4e4b\u5916\uff0c\u8fd8\u53ef\u4ee5\u5bf9\u5176dfn+\u7ebf\u6bb5\u6811\u3001\u6811\u72b6\u6570\u7ec4\u3001\u6811\u94fe\u5256\u5206\u2026\u2026\u55ef\u3002 P3808 \u3010\u6a21\u677f\u3011AC\u81ea\u52a8\u673a\uff08\u7b80\u5355\u7248\uff09 \u677f\u5b50\u9898\uff0c\u53ea\u7528\u6c42\u51fa\u51fa\u73b0\u7684\u6a21\u5f0f\u4e32\u800c\u4e0d\u9700\u8981\u7edf\u8ba1\u4e2a\u6570\uff0c\u76f4\u63a5\u8df3fail\u6307\u9488\u5b8c\u6210\u5339\u914d\u3002 P3796 \u3010\u6a21\u677f\u3011AC\u81ea\u52a8\u673a\uff08\u52a0\u5f3a\u7248\uff09 \u540c\u6837\u662f\u677f\u5b50\u9898\uff0c\u6c42\u51fa\u51fa\u73b0\u7684\u6a21\u5f0f\u4e32\u7684\u6b21\u6570\uff0c\u6539\u7528last\u6307\u9488\u8df3\u8dc3\u5373\u53ef\u3002 P5357 \u3010\u6a21\u677f\u3011AC\u81ea\u52a8\u673a\uff08\u4e8c\u6b21\u52a0\u5f3a\u7248\uff09 \u9898\u610f\u548c\u52a0\u5f3a\u7248\u76f8\u540c\uff0c\u4f46\u9700\u8981\u7528fail\u6811+\u5dee\u5206\u624d\u80fd\u8fc7\uff08\u89c4\u907f\u6389\u5339\u914d\u65f6\u8df3\u4efb\u4f55\u6307\u9488\uff09\uff0c\u5177\u4f53\u505a\u6cd5\u4e0a\u6587\u5df2\u6709\u63cf\u8ff0 Educational Codeforces Round 97 (Rated for Div. 2) G\uff1aDeath DBMS \u9898\u610f\uff1a\u7ed9\u4e00\u5806\u6a21\u5f0f\u4e32\uff08\u53ef\u80fd\u672c\u8d28\u76f8\u540c\uff0c\u4f46\u4ed6\u4eec\u7684\u7f16\u53f7\u4e0d\u540c\uff09\uff0c\u6bcf\u4e2a\u7f16\u53f7\u5bf9\u5e94\u7684\u5b57\u7b26\u4e32\u521d\u59cb\u6743\u503c\u4e3a0\uff0c\u7136\u540e\u7ed9\u51fa\u4e24\u79cd\u64cd\u4f5c\uff1a\u7b2c\u4e00\u79cd\u64cd\u4f5c\u7ed9\u51fa\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u6c42\u51fa\u5176\u4e2d\u51fa\u73b0\u7684\u6a21\u5f0f\u4e32\u7684\u6700\u5927\u6743\u503c\uff1b\u7b2c\u4e8c\u79cd\u64cd\u4f5c\u7ed9\u51fa\u4e24\u4e2a\u6570x y\uff0c\u8981\u5c06\u7b2cx\u4e2a\u6a21\u5f0f\u4e32\u7684\u6743\u503c\u6539\u4e3ay \u89e3\u6cd5\uff1a\u6ce8\u610f\u6b64\u9898\u4e2d\uff0c\u4e24\u4e2a\u672c\u8d28\u76f8\u540c\u7684\u5b57\u7b26\u4e32\u53ef\u80fd\u4f1a\u6709\u4e0d\u540c\u7684\u6743\u503c\u3002 \u4f7f\u7528ac\u81ea\u52a8\u673a\u6784\u5efa\u5b57\u5178\u56fe\uff0c\u90a3\u4e48\u201c\u4e24\u4e2a\u672c\u8d28\u76f8\u540c\u7684\u5b57\u7b26\u4e32\u53ef\u80fd\u4f1a\u6709\u4e0d\u540c\u7684\u6743\u503c\u201d\u5c31\u76f8\u5f53\u4e8e\u5728\u5b57\u5178\u56fe\u7684\u7ed3\u70b9\u4e0a\u7ef4\u62a4\u591a\u4e2a\u6743\u503c\uff08\u4fee\u6539\u548c\u67e5\u8be2\u6700\u5927\u503c\uff09\u3002 \u53ef\u4ee5\u5728\u6bcf\u4e2a\u7ed3\u70b9\u4e0a\u5f00\u4e2a\u52a8\u6001\u5f00\u70b9\u7684\u7ebf\u6bb5\u6811\u3002\u4f46\u4e3a\u4e86\u5b9e\u73b0\u65b9\u4fbf\uff0c\u8fd9\u91cc\u4f7f\u7528N\u4e2a\uff08N\u4e3a\u5b57\u5178\u56fe\u4e2d\u7ed3\u70b9\u4e2a\u6570\uff09multiset\u6765\u7ef4\u62a4\u6bcf\u4e2a\u7ed3\u70b9\u4e0a\u7684\u591a\u4e2a\u6743\u503c\u3002 \u5269\u4e0b\u7684\u5c31\u7b80\u5355\u4e86\u3002\u5bf9\u4e8e\u64cd\u4f5c\u4e00\uff0c\u7528ac\u81ea\u52a8\u673a\u5339\u914d\uff0c\u6bcf\u8d70\u5230\u4e00\u4e2a\u7ed3\u70b9\u8df3last\uff08\u8fd9\u9898\u7684\u6570\u636e\u8df3fail\u4f1at\uff09\uff0c\u7136\u540e\u6c42\u5bf9\u5e94\u7ed3\u70b9multiset\u4e2d\u503c\u7684\u6700\u5927\u503c\u3002\u5bf9\u4e8e\u64cd\u4f5c2\uff0c\u5728\u5b57\u5178\u56fe\u4e0a\u627e\u5230\u5bf9\u5e94\u4e32\u540e\u4fee\u6539\u5bf9\u5e94multiset\uff08\u5220\u9664\u65e7\u7684\u6743\u503c\u5e76\u63d2\u5165\u65b0\u6743\u503c\uff09\u5373\u53ef \u540e\u7f00\u6570\u7ec4 \u00b6 \u540e\u7f00\u6570\u7ec4SA \uff1a\u5b57\u7b26\u4e32\u5404\u4e2a\u540e\u7f00\u7684\u6392\u540d\u5230\u4e0b\u6807\u7684\u6620\u5c04\u3002\u5982aabab\uff0c\u6309\u5b57\u5178\u5e8f\u4ece\u5c0f\u5230\u5927\u6392\uff0c\u540e\u7f00\u5206\u522b\u4e3aaabab\u3001ab\u3001abab\u3001b\u3001bab\uff0csa[1~5 ] =1 4 2 5 3 \u6392\u540d\u6570\u7ec4RK \uff1a\u4ece\u67d0\u4e00\u4f4d\u7f6ei\u5f00\u59cb\u5230\u5b57\u7b26\u4e32\u672b\u5c3e\u6240\u6784\u6210\u7684\u540e\u7f00\uff0c\u5728\u6240\u6709\u540e\u7f00\u4e2d\u7684\u6392\u540d\u3002\u76f8\u5f53\u4e8eSA\u7684\u9006\u6620\u5c04\u3002 \u6c42\u6cd5 \uff1a\u500d\u589e\u6cd5\u3002\u6bcf\u6b21\u8003\u8651\u957f\u5ea6w\u4e3a1\u30012\u30014\u30018\u2026\u2026\uff08\u5230\u5c0f\u4e8e\u7b49\u4e8en\u7684\u6700\u59272\u7684\u5e42\u6b21\u4e3a\u6b62\uff09\u7684\u5b50\u4e32\uff0c\u5bf9\u4e8e\u67d0\u4e2a\u4f4d\u7f6ei\uff0c\u7528\u5176\u4f4d\u7f6ei\u7684sa\u5bf9\u5e94\u503c\u4f5c\u4e3a\u7b2c\u4e00\u5173\u952e\u5b57\uff0c\u4f4d\u7f6e\u4e3ai+w\u7684sa\u5bf9\u5e94\u503c\u4f5c\u4e3a\u7b2c\u4e8c\u5173\u952e\u5b57\uff08\u5982\u679ci+w\u5927\u4e8en\u5c31\u770b\u6210\u65e0\u7a77\u5c0f\uff09\uff0c\u8fdb\u884c\u6392\u5e8f\u3002\u7531\u4e8e\u53ea\u6709\u4e24\u4e2a\u5173\u952e\u5b57\uff0c\u56e0\u6b64\u6392\u5e8f\u4f7f\u7528\u7ebf\u6027\u6392\u5e8f\u6cd5 \uff08\u6bd4\u5982\u8ba1\u6570\u6392\u5e8f\u6216\u8005\u57fa\u6570\u6392\u5e8f\uff0c\u4e0b\u6587\u4e2d\u4e3b\u8981\u91c7\u7528\u8ba1\u6570\u6392\u5e8f\uff0c\u56e0\u5176\u590d\u6742\u5ea6\u53ea\u548c\u503c\u57df\u6709\u5173\uff09\uff0c\u53ef\u5c06\u6c42SA\u7684\u6574\u4f53\u65f6\u95f4\u590d\u6742\u5ea6\u4e0b\u964d\u81f3O\uff08nlogn\uff09\u3002\u5177\u4f53\u53c2\u89c1\u4ee3\u7801\u3002 \u53e6\u4e00\u79cd\u6c42\u6cd5\u662f\u7528\u540e\u7f00\u81ea\u52a8\u673a\u3002\u53c2\u89c1\u201c\u540e\u7f00\u81ea\u52a8\u673a\u201d\u4e00\u8282\u3002 Height \u6570\u7ec4 \u00b6 \u542b\u4e49\uff1a\u7b2ci\u540d\u548c\u7b2ci-1\u540d(\u6ce8\u610f\u662f\u6392\u540d)\u7684\u6700\u957f\u516c\u5171\u524d\u7f00\u957f\u5ea6 1 height[i]=lcp(sa[i],sa[i-1]) \u5f15\u7406\uff1a\u7b2ci\u4e2a\u4f4d\u7f6e\u7684\u540e\u7f00\u5bf9\u5e94\u7684height\u503c\uff0c\u5927\u4e8e\u7b49\u4e8e\u4e0a\u4e00\u4e2a\u4f4d\u7f6e\uff08i-1\uff09\u7684height\u503c-1 1 height[rk[i]]>=height[rk[i-1]]-1 \u6c42\u89e3\uff1a\u501f\u52a9\u4e0a\u9762\u7684\u5f15\u7406\u53ef\u5728On\u65f6\u95f4\u5185\u6c42\u51faheight\u6570\u7ec4\u3002 1 2 3 4 5 for ( i = 1 , k = 0 ; i <= n ; ++ i ) { if ( k ) -- k ; while ( s [ i + k ] == s [ sa [ rk [ i ] - 1 ] + k ]) ++ k ; ht [ rk [ i ]] = k ; // height\u592a\u957f\u4e86\u7f29\u5199\u4e3aht } Height \u6570\u7ec4\u7684\u5e94\u7528 \u00b6 \u540e\u7f00\u81ea\u52a8\u673a\uff08Suffix Automator\uff0cSAM\uff09 \u00b6 \u540e\u7f00\u81ea\u52a8\u673a\u662f\u80fd\u591f\u5339\u914d\u67d0\u4e2a\u5b57\u7b26\u4e32S\u7684\u6240\u6709\u540e\u7f00\u7684\u81ea\u52a8\u673a\u3002\u5c31\u662f\u8bf4\u53d6S\u7684\u4efb\u4f55\u4e00\u4e2a\u540e\u7f00\uff08\u5305\u62ecS\u81ea\u8eab\uff09\uff0c\u5728SAM\u4e2d\u4ece\u5f00\u59cb\u8282\u70b9t0\u8d70\uff0c\u80af\u5b9a\u90fd\u80fd\u8d70\u5230\u67d0\u4e00\u4e2a\u7ec8\u6b62\u72b6\u6001\u3002 \u7b26\u5408\u8fd9\u4e2a\u6027\u8d28\u7684\u56fe\u662f\u6709\u5411\u65e0\u73af\u56fe\uff0c\u5e76\u4e14\u6709\u5f88\u591a\u56fe\u90fd\u7b26\u5408\u4e0a\u9762\u7684\u8981\u6c42\u3002\u4f46SAM\u662f\u5176\u4e2d\u8282\u70b9\u6570\u91cf\u6700\u5c11\u7684\u4e00\u4e2a\uff08 \u6781\u5c0f\u6027 \uff09\u3002 endpos\u7b49\u4ef7\u7c7b\u3001SAM\u4e2d\u7684\u8282\u70b9\u610f\u4e49 \u00b6 \u5b57\u7b26\u4e32S=abcbc\u3002\u8003\u8651\u5b50\u4e32bc\u5728S\u7684\u7ec8\u6b62\u4f4d\u7f6e\uff08endpos\u96c6\u5408\uff09\uff0c\u4e3a3\u30015\u3002\u5b50\u4e32c\u5728S\u4e2d\u7684\u7ec8\u6b62\u4f4d\u7f6e\u4e5f\u4e3a3\u30015\u3002\u50cf\u8fd9\u6837\u7ec8\u6b62\u4f4d\u7f6e\u96c6\u5408\u5b8c\u5168\u76f8\u540c\u7684S\u7684\u5b50\u4e32\u79f0\u4e3aendpos\u7b49\u4ef7\u7c7b\u3002 \u5728SAM\u4e2d\uff0c SAM\u7684\u4e00\u4e2a\u8282\u70b9\u5c31\u4ee3\u8868\u4e00\u4e2aendpos\u7b49\u4ef7\u7c7b \u3002\u56e0\u6b64\u5982\u679c\u6709\u4e00\u4e2a\u8282\u70b9\u4ee3\u8868\u5b50\u4e32bc\uff0c\u5219\u8fd9\u4e2a\u8282\u70b9\u4e5f\u4ee3\u8868\u5b50\u4e32c\uff0c\u53cd\u4e4b\u4ea6\u7136\u3002 \u8282\u70b9\u7684\u6700\u957f\u4e32\u3001\u8282\u70b9\u7684len \u00b6 \u663e\u7136\u4e00\u4e2a\u7b49\u4ef7\u7c7b\u4e2d\u53ef\u80fd\u5305\u542b\u591a\u4e2aS\u7684\u5b50\u4e32\uff0c\u6211\u4eec\u53d6\u5176\u4e2d\u6700\u957f\u7684\u4e00\u4e2a\uff0c\u4f5c\u4e3a\u8fd9\u4e2a\u7b49\u4ef7\u7c7b\u5bf9\u5e94\u8282\u70b9v\u7684\u6700\u957f\u4e32\uff0c\u5e76\u8bb0len\uff08v\uff09\u4e3a\u8fd9\u4e2a\u6700\u957f\u4e32\u7684\u957f\u5ea6\u3002 \u8282\u70b9\u7684link\uff08father\uff09 \u00b6 \u8282\u70b9\u7684\u6700\u957f\u4e32\u7684\u524d\u51e0\u4e2a\uff08\u6309\u7167\u957f\u5ea6\u9012\u51cf\u6765\u6570\uff09\u540e\u7f00\u90fd\u4f1a\u5728\u8fd9\u4e2a\u8282\u70b9\u6240\u5728\u7b49\u4ef7\u7c7b\u4e2d\u3002\u4f46\u53ef\u80fd\u4ece\u4e4b\u540e\u67d0\u4e2a\u4f4d\u7f6e\u5f00\u59cb\u7684\u540e\u7f00\u5c31\u90fd\u4e0d\u5728\u8fd9\u4e2a\u7b49\u4ef7\u7c7b\u4e2d\u4e86\u3002\u6211\u4eec\u8bb0\u4e0d\u5728\u5f53\u524d\u8282\u70b9\u7b49\u4ef7\u7c7b\u4e2d\u6700\u957f\u7684\u4e32\u4e3aB\uff0c\u5219B\u5bf9\u5e94\u53e6\u4e00\u4e2a\u7b49\u4ef7\u7c7bu\uff08\u5982\u679cB\u4e0d\u5b58\u5728\uff0c\u5c31\u4ee4u\u4e3aSAM\u7684\u8d77\u59cb\u8282\u70b9\uff09\u3002\u6211\u4eec\u4ee4link\uff08v\uff09=u\uff0c\u79f0\u4e3a \u540e\u7f00\u94fe\u63a5 \u3002 \u6240\u6709SAM\u4e2d\u7684\u8282\u70b9\uff08\u9664\u4e86\u8d77\u59cb\u8282\u70b9\uff09\u90fd\u6709\u540e\u7f00\u8fde\u63a5\u3002\u8fd9\u4e9b\u540e\u7f00\u8fde\u63a5\u6784\u6210\u4e00\u9897\uff08\u6709\u5411\uff09\u6811\uff0c\u4ece\u53f6\u5b50\u6307\u5230\u6811\u6839\u3002\u79f0\u4e4b\u4e3a \u540e\u7f00\u94fe\u63a5\u6811 \u3002 \u540e\u7f00\u94fe\u63a5\u6811\u3001\u7ec8\u70b9\u8282\u70b9 \u00b6 \u5de6\u56fe\u662f\u5b57\u7b26\u4e32S=abcbc\u7684\u540e\u7f00\u81ea\u52a8\u673a\uff08SAM\uff09\uff0c\u53f3\u56fe\u4e3a\u5176\u540e\u7f00\u94fe\u63a5\u6811\u3002 \u5b57\u7b26\u4e32S\u7684\u6240\u6709\u524d\u7f00\u5728\u81ea\u52a8\u673a\u4e2d\u4e5f\u5bf9\u5e94\u7740\u4e0d\u540c\u7684\u8282\u70b9\u3002\u4ece\u521d\u59cb\u72b6\u6001t0\u5f00\u59cb\u6309\u7167\u5b57\u7b26\u4e32S\u8d70\uff0c\u6240\u7ecf\u8fc7\u7684\u8282\u70b9\u88ab\u79f0\u4e3a \u7ec8\u70b9\u8282\u70b9 \u3002\u5982\u53f3\u56fe\u4e2d\u7684a\u3001ab\u3001abc\u3001abcb\u3001abcbc\u3002\uff08\u6ce8\u610f\u548c\u7ec8\u6b62\u72b6\u6001\u533a\u5206\uff09 \u5b9a\u4e49\u6bcf\u4e2a\u8282\u70b9\u7684 \u7ec8\u70b9\u96c6\u5408 \uff1a\u6bcf\u4e2a\u8282\u70b9\u7684\u7ec8\u70b9\u96c6\u5408\u7b49\u4e8e\u5176 \u5b50\u6811 \u5185\u6240\u6709\u7ec8\u70b9\u8282\u70b9\u5bf9\u5e94\u7684\u7ec8\u70b9\u7684\u96c6\u5408\u3002\u6bd4\u5982b\u8282\u70b9\u7684\u5b50\u6811\u4e2d\u6709ab\u3001abcb\u8282\u70b9\uff0cb\u7684\u7ec8\u70b9\u96c6\u5408\u5c31\u662fab\u3001abcb\u8282\u70b9\u3002 \u5982\u679c\u8282\u70b9 A \u662f B \u7684\u7956\u5148\uff0c\u5219\u8282\u70b9 A \u5bf9\u5e94\u7684\u5b57\u7b26\u4e32\u662f\u8282\u70b9 B \u5bf9\u5e94\u7684\u5b57\u7b26\u4e32\u7684 \u540e\u7f00 \u3002 S\u7684\u524d\u7f00\u5b50\u4e32s1(1,p) s2(1,q)\u5bf9\u5e94\u7684\u6700\u957f\u516c\u5171\u540e\u7f00\uff0c\u662f\u4e24\u4e32\u5bf9\u5e94\u8282\u70b9u\u3001v\u7684LCA\u5bf9\u5e94\u5b57\u7b26\u4e32\u3002 \u8282\u70b9len\u7684\u5927\u5c0f\u968f\u7740\u6df1\u5ea6\u9012\u589e\u800c\u4e0d\u4e0b\u964d\u3002 \u540e\u7f00\u94fe\u63a5\u6811\u4e2d\u7684\u975e\u53f6\u5b50\u8282\u70b9\u5bf9\u5e94\u7684\u6700\u957f\u4e32\uff0c\u8fd9\u4e2a\u6700\u957f\u4e32\u76f8\u5f53\u4e8e\u4ece\u5176\u7ec8\u70b9\u96c6\u5408\u4e2d\u7684\u4efb\u610f\u4e00\u4e2a\u7ec8\u70b9\u7684\u4e0b\u6807\u5f80\u524d\u53d6\u8fd9\u4e2a\u975e\u53f6\u5b50\u8282\u70b9\u7684len\u4e2a\u957f\u5ea6\uff08\u5305\u542b\u8fd9\u4e2a\u5f00\u59cb\u53d6\u7684\u4f4d\u7f6e\uff09\u7684\u5b57\u7b26\u7ec4\u6210\u3002 \u540e\u7f00\u94fe\u63a5\u6811\u4e2d\u7684\u53f6\u5b50\u8282\u70b9\u5c31\u662f\u7ec8\u70b9\u8282\u70b9\u3002\u4f46\u53cd\u8fc7\u6765\u4e0d\u4e00\u5b9a\u6210\u7acb\uff08\u5982S=ababa\uff0caba\u662f\u524d\u7f00\uff0c\u4f46aba\u51fa\u73b0\u4e86\u4e24\u6b21\uff0c\u6709\u66f4\u957f\u7684ababa\u4f5c\u4e3a\u5176\u513f\u5b50\uff09\u3002\u8fd9\u662f\u7531\u4e8e\u5176\u4ed6\u51fa\u73b0\u53ea\u6709\u4e00\u6b21\u7684\u975e\u524d\u7f00\u4e32\u90fd\u88ab\u5305\u542b\u5728\u67d0\u4e00\u53ea\u51fa\u73b0\u4e00\u6b21\u7684\u524d\u7f00\u4e32\u4e2d\u4e86\u3002\u6362\u53e5\u8bdd\u8bf4\u5982\u679cbab\u53ea\u51fa\u73b0\u4e86\u4e00\u6b21\uff0c\u90a3\u4e48\uff08\u4ece\u5934\u5230\uff09...bab\u4e5f\u80af\u5b9a\u53ea\u51fa\u73b0\u4e00\u6b21\u3002 \u8bbe\u6240\u6709\u7ec8\u70b9\u8282\u70b9\u7684siz\u4e3a1\u3002\u4ece\u53f6\u5b50\u8282\u70b9\u5f00\u59cbbfs\uff0c\u7d2f\u52a0siz\uff0c\u975e\u53f6\u5b50\u8282\u70b9\u7684siz\u503c\u5c31\u662f\u8fd9\u4e2a\u8282\u70b9\u7684\u7ec8\u70b9\u96c6\u5408\u5927\u5c0f\uff0c\u4e5f\u5373\u8fd9\u4e2a\u8282\u70b9\u5bf9\u5e94\u6700\u957f\u4e32\u51fa\u73b0\u7684\u6b21\u6570\u3002\uff08\u540e\u9762\u6a21\u677f\u9898\u4f1a\u7528\u5230\uff09 \u6784\u5efa\u65b9\u6cd5 \u00b6 \u6b65\u9aa4\u6709\u70b9\u9ebb\u70e6\uff08\u5176\u5b9e\u8fd8\u597d\uff09\uff0c\u53c2\u89c1https://oi-wiki.org/string/sam/ \u72b6\u6001\u6570\u4e0d\u4f1a\u8d85\u8fc72n-1 \u8f6c\u79fb\u6570\u4e0d\u4f1a\u8d85\u8fc73n-4 \u6784\u5efa\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a\u7ebf\u6027\u7ea7\u522b \u5e94\u7528 \u00b6 \u7ed9\u5b9a\u7684\u5b57\u7b26\u4e32P\u662f\u5426\u5728S\u4e2d\u51fa\u73b0\uff1a \u76f4\u63a5\u4ece\u8d77\u70b9\u8d70\uff0c\u4e2d\u9014\u9047\u5230\u67d0\u4e2a\u5b57\u6bcd\u8d70\u4e0d\u4e0b\u53bb\u4e86\u5c31\u8bf4\u660e\u6ca1\u51fa\u73b0 \u4e0d\u540c\u5b50\u4e32\u4e2a\u6570\uff1a \u6709\u5411\u65e0\u73af\u56fe\u52a8\u6001\u89c4\u5212\u3002\u6216\u8005\u7528len\uff08i\uff09-len\uff08link\uff08i\uff09\uff09\u5bf9\u6bcf\u4e2a\u7ed3\u70b9\u6c42\u548c\u3002\uff08\u8fd9\u4e2a\u5f0f\u5b50\u662f\u76f8\u5f53\u4e8e\u8fd9\u4e2a\u72b6\u6001\u5bf9\u6574\u4e2a\u4e32S\u7684\u4e0d\u91cd\u590d\u5b50\u4e32\u8d21\u732e\uff09 \u6c42\u6240\u6709\u4e0d\u540c\u5b50\u4e32\u603b\u957f\u5ea6 \u6742\u9879\u3001\u5947\u6280\u6deb\u5de7 \u00b6 vector\u3001set\u7684\u5408\u5e76 \u00b6 1\uff09\u5728a\u540e\u9762\u63d2\u5165b\uff0c\u65b9\u6cd5\u4e3a a.insert(a.end(),b,begin(),b.end()); 2\uff09\u5728a\u7684\u524d\u9762\u63d2\u5165b\uff0c\u65b9\u6cd5\u4e3a a.insert(a.begin(),b,begin(),b.end()); \u5408\u5e76set: a.insert(b,begin(),b.end()); \u4ea4\u4e92\u9898 \u00b6 CF Global Round 9 F. Integer Game 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include <iostream> using namespace std ; long long a [ 4 ], p1 , p2 ; int main () { ios :: sync_with_stdio ( false ); for ( int i = 1 ; i <= 3 ; i ++ ) cin >> a [ i ]; cout << \"First\" << endl ; cout << ( long long ) 1e11 << endl ; cout . flush (); cin >> p1 ; a [ p1 ] += ( long long ) 1e11 ; long long temp = 2 * a [ p1 ]; for ( int i = 1 ; i <= 3 ; i ++ ) { if ( i != p1 ) temp -= a [ i ]; } cout << temp << endl ; cout . flush (); cin >> p2 ; a [ p2 ] += temp ; cout << a [ p2 ] - a [ p1 ] << endl ; //d=c-a=(2c-a)-c=a[p2]-a[p1] cout . flush (); return 0 ; } CF 669 1407C \u2014 Chocolate Bunny 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include <iostream> #include <cstdio> using namespace std ; int n , a [ 10100 ]; int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); cin >> n ; int pos = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { int x , y ; cout << \"? \" << pos << \" \" << i << endl ; cout . flush (); cin >> x ; cout << \"? \" << i << \" \" << pos << endl ; cout . flush (); cin >> y ; if ( x < y ) { a [ i ] = y ; } else { a [ pos ] = x ; pos = i ; } } a [ pos ] = n ; cout << \"! \" ; for ( int i = 1 ; i <= n ; i ++ ) { cout << a [ i ] << \" \" ; } cout << endl ; cout . flush (); return 0 ; } priority_queue \u00b6 \u5f53\u7136\u4e5f\u80fd\u91cd\u8f7d\u8fd0\u7b97\u7b26\u641e\u5b9a 1 2 3 4 5 6 //\u5347\u5e8f\u961f\u5217\uff0c\u5c0f\u9876\u5806 priority_queue <int,vector<int>,greater<int> > q; //\u964d\u5e8f\u961f\u5217\uff0c\u5927\u9876\u5806 priority_queue <int,vector<int>,less<int> >q; //\u5bf9\u4e8elonglong greater<long long>() \u52a8\u6001\u5206\u914d\u4e8c\u7ef4\u6570\u7ec4\u5185\u5b58 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include <stdio.h> #include <stdlib.h> int allsum ( int * a , int n , int m ) { int ( * b )[ m ] = ( int ( * )[ m ]) a ; //\u8f6c\u6362\u4e3a\u6570\u7ec4\u6307\u9488 int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) sum += b [ i ][ j ]; //\u7edf\u8ba1\u7b54\u6848 return sum ; } int n , m ; int main () { scanf ( \"%d%d\" , & n , & m ); int ( * a )[ m ] = ( int ( * )[ m ]) calloc ( n * m , sizeof ( int )); //\u6309\u7167\u5927\u5c0f\u5206\u914d\u6570\u7ec4\u5185\u5b58 for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) scanf ( \"%d\" , & a [ i ][ j ]); //\u8f93\u5165 printf ( \"%d\" , allsum ( & a [ 0 ][ 0 ], n , m )); free ( a ); return 0 ; } \u81ea\u7136\u6570\u5e42\u548c \u00b6 https://zh.wikipedia.org/wiki/%E7%AD%89%E5%B9%82%E6%B1%82%E5%92%8C $$ \\sum_{i=1}^{n} i^{0} =n\\ \\sum_{i=1}^{n} i^{1} = \\frac{n(n+1)}{2} = \\frac{1}{2}n^2 +\\frac{1}{2} n \\ \\sum_{i=1}^{n} i^{2} = \\frac{n(n+1)(2n+1)}{6} = \\frac{1}{3}n^3 + \\frac{1}{2}n^2 + \\frac{1}{6}n\\ \\sum_{i=1}^{n} i^{3} = \\left[\\frac{n(n+1)}{2}\\right]^{2} = \\frac{1}{4}n^4 + \\frac{1}{2}n^3 + \\frac{1}{4}n^2\\ \\sum_{i=1}^{n} i^{4} = \\frac{n(n+1)(2n+1)(3n^2+3n-1)}{30} = \\frac{1}{5}n^5 + \\frac{1}{2}n^4 + \\frac{1}{3}n^3 - \\frac{1}{30}n\\ \\sum_{i=1}^{n} i^{5} = \\frac{n {2}(n+1) (2n^2+2n-1)}{12} = \\frac{1}{6}n^6 + \\frac{1}{2}n^5 + \\frac{5}{12}n^4 - \\frac{1}{12}n^2\\ \\sum_{i=1}^{n} i^{6} = \\frac{n(n+1)(2n+1)(3n 4+6n 3-3n+1)}{42} = \\frac{1}{7}n^7 + \\frac{1}{2}n^6 + \\frac{1}{2}n^5 - \\frac{1}{6}n^3 + \\frac{1}{42}n\\ \\sum_{i=1}^{n} i^{7} = \\frac{n 2(n+1) 2(3n 4+6n 3-n^2-4n+2)}{24} = \\frac{1}{8}n^8 + \\frac{1}{2}n^7 + \\frac{7}{12}n^6 - \\frac{7}{24}n^4 + \\frac{1}{12}n^2\\ \\sum_{i=1}^{n} i^{8} = \\frac{n(n+1)(2n+1)(5n 6+15n 5+5n 4-15n 3-n 2+9n-3)}{90}=\\frac{1}{9}n 9 + \\frac{1}{2}n^8 + \\frac{2}{3}n^7 - \\frac{7}{15}n^5 + \\frac{2}{9}n^3 - \\frac{1}{30}n\\ \\sum_{i=1}^{n} i^{9} = \\frac{n 2(n+1) 2(n 2+n-1)(2n 4+4n 3-n 2-3n+3)}{20}=\\frac{1}{10}n {10}+\\frac{1}{2}n 9+\\frac{3}{4}n 8-\\frac{7}{10}n 6+\\frac{1}{2}n 4-\\frac{3}{20}n 2\\ \\sum_{i=1}^{n} i^{10} = \\frac{n(n+1)(2n+1)(n 2+n-1)(3n 6+9n 5+2n 4-11n 3+3n 2+10n-5)}{66}=\\frac{1}{11}n {11}+\\frac{1}{2}n +\\frac{5}{6}n 9-n 7+n 5-\\frac{1}{2}n 3+\\frac{5}{66}n\\ \\sum_{i=0}^{n} i^{m-1} = \\sum_{k=0}^m S_k^m n k\uff0c\u5176\u4e2dS_0 m = 0\uff0cS_m^m = \\frac{1}{m}\uff0c\u7576m\u2212k\u70ba\u5927\u65bc1\u7684\u5947\u6578\u6642\uff0cS_k^m = 0\\ \\sum_{i=0}^{n} i^m = {1\\over{m+1}}\\sum_{i=0}^m{m+1\\choose{i}} B_i (n+1)^{m+1-i},(B_i\u4e3a\u4f2f\u52aa\u5229\u6570)\\ \\displaystyle \\sum_{i=1}^n i^{m+1} = \\sum_{k=0}^m L_k^m \\binom{n+k+1}{m+2},\\left(L_k^m = \\sum_{r=0}^k (-1)^r \\binom{m+2}{r} (k+1-r)^{m+1}\\right)\\ $$ Python \u91cd\u5b9a\u5411\u8f93\u51fa\u8f93\u5165 \u00b6 1 2 3 import sys sys . stdin = open ( \"l_in.txt\" , \"r\" ) sys . stdout = open ( \"l_out2.txt\" , \"w\" ) atan2(y,x) \u00b6 \u8fd9\u4e2a\u51fd\u6570\u5b9a\u4e49\u5728cmath\u91cc\uff0c\u8fd4\u56de\u4e00\u4e2a\u70b9(x,y)\u7684\u6781\u89d2\uff0c\u503c\u57df\u5728 \\((-\\pi,\\pi]\\) \u4e4b\u95f4\u3002 \u4e3b\u8981\u7528\u4e8e\u6781\u89d2\u6392\u5e8f\u7b49\u3002 \u8f93\u5165\u4e00\u884c \u00b6 cin.getline(char *m, int size) \u00b6 \u8f93\u5165\u6700\u591am\u4e2a\u5b57\u7b26\u5230\u5730\u5740m\u5904\u5f00\u59cb\u7684\u5b57\u7b26\u4e32\u3002\u6ce8\u610f\u5982\u679c\u4e4b\u524d\u7528cin\u8bfb\u5165\u7684\u8bdd\u8981\u901a\u8fc7\u7279\u6b8a\u624b\u6bb5\u6d88\u9664\u4e4b\u524d\u7684\u6362\u884c\u7b26\uff0c\u4e0b\u540c\u3002 getline(cin,*str) \u00b6 \u4ece\u6d41\u4e2d\u8bfb\u5165\u5230str\u4e2d char fgets(char str, int cnt, std::FILE* stream) \u00b6 \u4ece\u6d41\u4e2d\uff08\u6587\u4ef6\u6d41\uff0c\u6216stdin\uff09\u8bfb\u5165\u6700\u591acnt\u4e2a\u5b57\u7b26\u7684\u5b57\u7b26\u4e32\u5230str\u4e2d\u3002 ps\uff1a\u4e0b\u9762\u7684\u64cd\u4f5c\u53ef\u4ee5\u79fb\u9664\u591a\u4f59\u7684\u7a7a\u767d\u7b26 1 cin >> ws \u5feb\u901f\u8ba1\u7b97\u4e8c\u8fdb\u5236\u4e2d1\u7684\u4e2a\u6570 \u00b6 \uff08 https://www.cnblogs.com/graphics/archive/2010/06/21/1752421.html \uff09 1 2 3 4 5 int BitCount5 ( unsigned int n ) { unsigned int tmp = n - (( n >> 1 ) & 033333333333 ) - (( n >> 2 ) & 011111111111 ); return (( tmp + ( tmp >> 3 )) & 030707070707 ) % 63 ; }","title":"OI\u6742\u7b14\u8bb0"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_1","text":"\u4f7f\u7528FWT\u65f6\u4e0d\u628a\u6570\u7ec4\u957f\u5ea6\u5f00\u591f\u5bfc\u81f4wa\u534a\u5929\uff08HDU 6057 Kanade\u2019s convolution\uff09 \u6570\u636e\u91cf\u8fc7\u5927\u65f6\u5207\u8bb0\u4f7f\u7528printf\u548cscanf \u7528\u6d6e\u9ede\u6578\u8dd1\u6700\u77ed\u8def\u6216\u8005\u6700\u5927\u6d41\u7684\u6642\u5019\u8981\u6ce8\u610f\u9b06\u5f1b\u689d\u4ef6\u8981\u653e\u9b06\u4e00\u5b9a\u7cbe\u5ea6(\u4f8b\u5982dy>dx+edge+eps)","title":"\u8e29\u5751"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_2","text":"","title":"\u52a8\u6001\u89c4\u5212"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_3","text":"P6563 \u4e00\u76f4\u5728\u4f60\u8eab\u8fb9 \u7535\u7ebf\u957f\u5ea6\u4e3a1\uff0c2\uff0c...\uff0cn\u4e2d\u67d0\u4e2a\u6570\uff0c\u82b1ai\u5143\u53ef\u4ee5\u5f97\u77e5\u957f\u5ea6\u662f\u5426\u5927\u4e8e\uff08\u6216\u5c0f\u4e8e\u7b49\u4e8e\uff09i\uff0c\u95ee\u5979\u81f3\u5c11\u8981\u82b1\u591a\u5c11\u94b1\u624d\u80fd\u4fdd\u8bc1\u77e5\u9053\u9700\u8981\u7535\u7ebf\u7684\u957f\u5ea6 \u5206\u6790\uff1a $$ f(L,R)=\\min_{1\\le k\\lt r}(\\max(f(L,k),f(k+1,R))+a_k) $$ R\u6269\u5c55\u65f6\uff0c\u6700\u4f18\u51b3\u7b56\u70b9p=k\u4e0d\u4e0b\u964d\uff08\u4e0a\u5347\u6216\u4e0d\u53d8\uff09\u3002 \u56e0\u6b64\u5206\u7c7b\u8ba8\u8bbaf(L,k)\u4e0ef(k+1,R)\u7684\u5927\u5c0f\uff0c\u5206\u522b\u7ef4\u62a4\u66f4\u65b0\u4e24\u79cd\u60c5\u51b5\u5373\u53ef\u3002 \u5177\u4f53\u5730\uff1a\u6b63\u5e8f\u5faa\u73afR:[1,N]\uff0c\u5012\u5e8f\u5faa\u73afL:[R,1]\uff0c\u5bf9\u4e8e\u6bcf\u4e2aL\u90fd\u540e\u9000\u66f4\u65b0\u6700\u4f18\u51b3\u7b56\u70b9k\uff0c\u7136\u540e\u66f4\u65b0f(L,k)>f(k+1,R)\u7684\u60c5\u51b5\u3002f(L,k)<=f(k+1,R)\u7684\u60c5\u51b5\uff0cf(L,R)=min f(k+1,R)+ak\uff0c\u4f7f\u7528\u5355\u8c03\u961f\u5217\u7ef4\u62a4\u3002 P2120 \u4ed3\u5e93\u5efa\u8bbe \u5206\u6790\uff1a $$ dp[i]=\\min_{0\\le j\\lt i}(dp_j+x_i(sump_i-sump_j)-\\(sumxp_i-sumxp_j))+c_i $$ \u76f4\u63a5\u5957\u7528\u659c\u7387\u4f18\u5316\u5373\u53ef","title":"\u5355\u8c03\u961f\u5217\u4f18\u5316"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#sosdp","text":"\u53ef\u4ee5\u5728O(m*2^m)\u7684\u65f6\u95f4\u91cc\u6c42\u89e3\u4e0b\u5217\u5f0f\u5b50\uff1a $$ f_{st}=\\sum_{i\\subset st} w_i $$ \u8bbe \\(dp(st,i)\\) \u8868\u793a\u4e8c\u8fdb\u5236\u8868\u793a\u96c6\u5408st\u7684\u6700\u540ei\u4f4d\uff08\u4ece0\u8ba1\u6570\uff09\u53d8\u5316\u7684\u6240\u6709\u5b50\u96c6\u8d21\u732e\u7684\u548c\u3002 \u5219\u6709\u8f6c\u79fb\uff1a $$ dp(st,i) = \\begin{cases} dp(st,i-1), & \\text{\u7b2ci\u4f4d\u4e3a0} \\ dp(st,i-1) + dp(st\\oplus(2^i),i-1), & \\text{\u7b2ci\u4f4d\u4e3a1} \\ \\end{cases} $$ 1 2 3 4 5 6 7 void sos (){ for ( int i = 0 ; i < ( 1 << N ); i ++ ) f [ i ] = w [ i ]; for ( int i = 0 ; i < N ; i ++ ) for ( int st = 0 ; st < ( 1 << N ); st ++ ) if ( st & ( 1 << i )) f [ st ] += f [ st ^ ( 1 << i )]; }","title":"SOSdp"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_4","text":"P1064 [NOIP2006 \u63d0\u9ad8\u7ec4] \u91d1\u660e\u7684\u9884\u7b97\u65b9\u6848 \u9898\u610f\uff1a\u7ed9\u5b9a\u4e00\u7cfb\u5217\u7269\u54c1,\u6bcf\u4e2a\u7269\u54c1\u6709\u4e00\u4e2a\u4ef7\u683cv\u548c\u6743\u503cw,\u5e76\u4e14\u7269\u54c1\u95f4\u5b58\u5728\u4f9d\u8d56\u5173\u7cfb.\u6c42\u4e00\u79cd\u53ef\u884c\u65b9\u6848,\u4f7f\u5f97\u6ee1\u8db3\u4f9d\u8d56\u5173\u7cfb\u5e76\u4e14\\sum v \\leq m\u2211 v \u2264 m \u7684\u60c5\u51b5\u4e0b\\sum w\u2211 w \u5c3d\u91cf\u5927 \u89e3\u6cd5\uff1a \u6211\u4eec \u5bf9\u8fd9\u9897\u6811\u6c42\u4e00\u4e2a\u540e\u5e8f\u904d\u5386 ,\u8fd9\u6837\u4e00\u4e2a\u8282\u70b9\u7684\u513f\u5b50\u4ee5\u53ca\u5de6\u8fb9\u5144\u5f1f\u5728\u5e8f\u5217\u4e2d\u90fd\u5728\u5b83\u7684\u524d\u90e8.\u7136\u540e\u5462?\u6bcf\u4e00\u6b65\u6211\u4eec\u90fd\u6709\u4e24\u79cd\u51b3\u7b56. \u9009\u8fd9\u4e2a\u7269\u54c1,\u90a3\u4e48\u72b6\u6001i\u53ef\u4ee5\u76f4\u63a5\u7531\u72b6\u6001i - 1\u8f6c\u79fb\u800c\u6765 \u4e0d\u9009\u8fd9\u4e2a\u7269\u54c1,\u90a3\u4e48\u662f\u4e0d\u662f \u8fd9\u4e2a\u70b9\u7684\u513f\u5b50\u90fd\u4e0d\u53ef\u4ee5\u9009 ,\u90a3\u4e48\u72b6\u6001i\u5c31\u53ea\u80fd\u7531\u5b83\u7684\u5de6\u5144\u5f1f\u8f6c\u79fb\u800c\u6765 \u8bbepre[i]\u662f\u7f16\u53f7\u4e3ai\u7684\u8282\u70b9\u7684\u5de6\u5144\u5f1f $$ f[i,j]=\\max\\begin{cases} f[pre[i],j],\\ f[i-1,j-v]+w, & j\\ge v \\end{cases} $$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <cstdlib> #include <algorithm> #include <string> #include <vector> #include <map> #include <unordered_map> #include <set> #include <unordered_set> #include <queue> using namespace std ; typedef long long ll ; const int N = 200 ; int n , m ; struct E { int to , inext ; } edge [ N * 2 ]; int head [ N ], total ; struct Node { int val ; int weight ; int fa ; int dfn ; } s [ N ]; void adde ( int x , int y ) { edge [ ++ total ]. to = y ; edge [ total ]. inext = head [ x ]; head [ x ] = total ; } int dfn ; //\u6309\u7167dfs\u5e8f\u4f5c\u4e3a\u7d22\u5f15 struct Node_dfn { int val ; int weight ; int pre ; } ss [ N ]; int dp [ N ][ 50000 ]; void dfs ( int x , int fa ) { int p = dfn ; for ( int e = head [ x ]; e ; e = edge [ e ]. inext ) { int y = edge [ e ]. to ; if ( y == fa ) continue ; dfs ( y , x ); } s [ x ]. dfn =++ dfn ; ss [ dfn ]. val = s [ x ]. val ; ss [ dfn ]. weight = s [ x ]. weight ; ss [ dfn ]. pre = p ; } int dpdp () { memset ( dp , 0 , sizeof ( dp )); dp [ 0 ][ 0 ] = 0 ; for ( int i = 1 ; i <= n + 1 ; i ++ ) //dfn { // dp[i][0]=0; for ( int w = 0 ; w <= m ; w ++ ) { /*dp[i][w]=max( dp[ss[i].pre][w], dp[i-1][w-1]+ss[i].bb );*/ dp [ i ][ w ] = dp [ ss [ i ]. pre ][ w ]; if ( w - ss [ i ]. weight >= 0 ) dp [ i ][ w ] = max ( dp [ i ][ w ], dp [ i -1 ][ w - ss [ i ]. weight ] + ss [ i ]. val ); } } int ans = 0 ; for ( int w = 1 ; w <= m ; w ++ ) { ans = max ( ans , dp [ n ][ w ]); } return ans ; } int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ), cout . tie ( 0 ); while ( cin >> m >> n ) { if ( n == 0 && m == 0 ) return 0 ; total = 0 ; dfn = 0 ; for ( int i = 0 ; i <= n + 10 ; i ++ ) { head [ i ] = 0 ; ss [ i ] = ss [ 0 ]; s [ i ] = s [ 0 ]; } for ( int i = 1 ; i <= n ; i ++ ) { int a , b , c ; cin >> a >> b >> c ; s [ i ]. weight = a ; s [ i ]. val = a * b ; s [ i ]. fa = c ; s [ i ]. dfn = 0 ; adde ( i , c ); adde ( c , i ); } dfs ( 0 , 0 ); cout << dpdp () << endl ; } return 0 ; }","title":"\u6811\u4e0a\u80cc\u5305"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_5","text":"","title":"\u6570\u8bba"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_6","text":"\u6574\u9664\u6027 $$ a\\equiv b \\pmod m \\Rightarrow m|(a-b) $$ \u4f20\u9012\u6027 $$ \\begin{cases} a\\equiv b \\pmod m\\ c\\equiv d \\pmod m \\end{cases} \\Rightarrow a\\equiv c \\pmod m $$ \u4fdd\u6301\u57fa\u672c\u8fd0\u7b97 $$ \\left. \\begin{matrix} a \\equiv b \\pmod{m} \\ c \\equiv d\\pmod{m} \\end{matrix} \\right} \\Rightarrow \\left{ \\begin{matrix} a \\pm c \\equiv b \\pm d \\pmod{m} \\ ac \\equiv bd \\pmod{m} \\end{matrix} \\right. $$ $$ a \\equiv b \\pmod{m} \\Rightarrow \\begin{cases} an \\equiv bn \\pmod{m}, \\forall n \\in \\mathbb{Z} \\ a^n \\equiv b^n \\pmod{m}, \\forall n \\in \\mathbb{N}^0 \\end{cases} $$ \u5e95\u6570\u653e\u7f29 $$ (km \\pm a)^n \\equiv (\\pm a)^n \\pmod{m} $$ \u6a21\u6570\u653e\u7f29 $$ a \\equiv b \\pmod{m} \\Leftrightarrow ka \\equiv kb \\pmod{km} $$ \u9664\u6cd5\u539f\u7406\uff1a\u5f53k\u3001m\u4e92\u8d28\u65f6 $$ ka \\equiv kb \\pmod{m} \\Rightarrow a \\equiv b \\pmod{m} $$ \\[ \\begin{cases} a \\equiv b \\pmod m \\\\ n|m \\end{cases}\\Rightarrow a\\equiv b \\pmod n \\] \u5bf9\u82e5\u5e72\u540c\u4f59\u7684\u540c\u4f59\u65b9\u7a0b\uff1a $$ \\left. \\begin{matrix} a \\equiv b \\pmod{m_1} \\ a \\equiv b \\pmod{m_2} \\ \\vdots \\ a \\equiv b \\pmod{m_n} \\ (n \\ge 2) \\end{matrix} \\right} \\Rightarrow a \\equiv b \\pmod{ \\text{lcm}[m_1,m_2,\\cdots,m_n]} $$ \\[ \\frac{a}{b}\\mod c=\\frac{a\\mod (bc)}{b} \\]","title":"\u540c\u4f59\u6027\u8d28"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#exlucas","text":"\u5f53\u6a21\u6570p\u4e0d\u662f\u8d28\u6570\u65f6 $$ p=p_1 {k_1}p_2 \\cdots p_s^{k_s} $$ \u5f53k1=k2=...=1\u65f6\uff0c\u6c42\u4e0b\u9762\u7684\u540c\u4f59\u65b9\u7a0b\u7684a1\uff0c\u7136\u540eCRT\u5408\u5e76\u7b54\u6848 $$ \\begin{cases} C_n^m\\equiv a_1 \\pmod {p_1^{k_1}} \\ C_n^m\\equiv a_2 \\pmod {p_2^{k_2}} \\ \\cdots\\ C_n^m\\equiv a_s \\pmod {p_s^{k_s}} \\end{cases} $$ \u5f53\u5206\u89e3\u540e\u8fd8\u4e0d\u662f\u8d28\u6570\u65f6 $$ C_n^m=\\frac{n!}{m!(n-m)!}\\mod p t\\=\\frac{\\frac{n!}{p }}{\\frac{m!}{p {a_2}}*\\frac{(n-m)!}{p }}*p^{a_1-a_2-a_3}\\mod p^t\\ $$ \u8ba1\u7b97n!\u3001m!\u3001(n-m)!\u5728mod p^t\u4e0b\u7684\u503c\uff08\u540e\u4e24\u8005\u518d\u6c42\u9006\u5143\uff09 \u5bf9\u4e8e\u9636\u4e58\u4e2d\u7684\u6bcf\u4e00\u4e2a\u6570\uff0c\u5206\u4e3a\u53ef\u88abp\u6574\u9664\u7684\u548c\u4e0d\u53ef\u88abp\u6574\u9664\u7684 $$ n!=\\lfloor\\frac{n}{p}\\rfloor! * p {\\lfloor\\frac{n}{p}\\rfloor} * (\\prod_{i=1\\p|i} {P t}i) {p t}\\rfloor}~*(\\prod_{i=1\\p\u2224i} }i) \\pmod {p^t} $$ (n/p)!\u9012\u5f52\u89e3\u51b3\uff0c\u540e\u4e24\u8005\u9884\u5904\u7406\u89e3\u51b3 \u53c2\u89c1luogu/4720_exLucas 2019-2020 ICPC Asia Taipei-Hsinchu Regional Contest M.DivModulo: \u9898\u610f \uff1a \u6c42C(N,M) dmod D\uff0c\u5176\u4e2d x dmod y \u6307\u7684\u662f\u53bb\u6389 x \u4e2d\u6240\u6709 y \u56e0\u5b50\u540e\u53d6\u4f59\u6570\u3002 \u5206\u6790\uff1a \u6211\u4eec\u8bd5\u56fe\u5c06\u9636\u4e58\u4e2d\u6240\u6709\u542b\u6709D\u7684\u9879\u63d0\u51fa\u6765\uff0c\u7136\u540e\u5229\u7528\u7c7b\u4f3c\u6269\u5c55\u5362\u5361\u65af\u8ba1\u7b97\u4f59\u4e0b\u7684\u90e8\u5206\u3002 $$ C M_N=\\frac{N!}{M!(N-M)!}=\\frac{N! div D}{M! div D (N-M)! div D} D K $$ \u8fd9\u4e2a\u65f6\u5019\u518d\u53d6\u6a21 $$ C_N^M dmod D=(N! div D) inv(M! div D) inv((N-M)! div D) \\mod D $$ \u5206\u6bcd\u4e0d\u4e00\u5b9a\u4e0eD\u4e92\u8d28\uff0c\u56e0\u6b64\u8003\u8651\u8d28\u56e0\u6570\u5206\u89e3D=D1...Ds\uff0c\u6700\u540e\u518d\u7528CRT\u5408\u5e76 $$ C_N M div D=\\frac{C_N M}{D K}=\\frac{(C_N M div p_i) p_i k}{D K}=\\frac{(C_N M div p_i)*p_i }{(D/D_i)^K}\\mod D_i $$ \u5176\u4e2dK\u662f\u4f7f\u5f97D^K\u9664C(N,M)\u540e\u4ecd\u662f\u6574\u6570\u7684\u6700\u5927\u7684K $$ K=\\min_{1\\le i\\le s}\\frac{k_i}{a_i} $$ \u81f3\u4e8e\u8ba1\u7b97C_N^M div D mod P\uff0c\u5219\u8fd0\u7528\u7c7b\u4f3c\u6269\u5c55\u5362\u5361\u65af\u7684\u65b9\u6cd5\u5373\u53ef $$ n!=\\lfloor\\frac{n}{D}\\rfloor! * D {\\lfloor\\frac{n}{D}\\rfloor} * (\\prod_{i=1\\D|i} i) {\\lfloor\\frac{n}{D}\\rfloor}~*(\\prod_{i=1\\D\u2224i} }i)\\ n! div D=\\lfloor\\frac{n}{D}\\rfloor! (\\prod_{i=1\\D|i} {P}i) {D}\\rfloor} *(\\prod_{i=1\\D\u2224i}^{N\\mod {D}}i) $$","title":"\u6269\u5c55\u5362\u5361\u65af\u5b9a\u7406 (exLucas)"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_7","text":"\u9636 \uff1a \\( \\((a,m)=1,a^l\\equiv1\\pmod{m}\\) \\) ,\u4f7f\u5f97\u5176\u6210\u7acb\u7684\u6700\u5c0f\u7684l\u79f0\u4e3aa\u5173\u4e8emod m\u7684\u9636\u3002\u8bb0\u4e3a \\( \\(\\text{ord}_ma=l\\) \\) \\[ \\text{ord}_ma=l\\Rightarrow \\text{ord}_ma^t=\\frac{l}{(t,l)} \\] \u8bc1\u660e\uff1a $$ \u8bbe\u540e\u8005\u539f\u6839\u662fx,\u5219\u663e\u7136l|tx\\Rightarrow tx=\\text{lcm}(t,l)=\\frac{tl}{(t,l)} $$ \\[ a^n\\equiv1\\pmod m\\Leftrightarrow l|n \\] \u7531\u4e8e\u6b27\u62c9\u5b9a\u7406 \\( \\(a^{\\phi(n)}\\equiv 1\\pmod m\\) \\) ,\u5219 \\( \\(l|\\phi(n)\\) \\) \\( \\(1,a,a^2,\\cdots,a^{l-1}\\) \\) \u5173\u4e8em\u4e24\u4e24\u4e0d\u540c\u4f59\uff08l\u662f\u6700\u5c0f\u5faa\u73af\u5468\u671f\uff09 p\u4e3a\u8d28\u6570\uff0c \\( \\(l|\\phi(p)\\) \\) \uff0c\u5219\u5b58\u5728 \\( \\(\\phi(l)\\) \\) \u4e2a\u5173\u4e8emod p\u9636\u4e3al\uff0c\u4e14\u4e24\u4e24\u4e92\u4e0d\u540c\u4f59\u7684\u6570 \u82e5 \\( \\(m=p_1^{a_1}\\cdots p_k^{a_k}\\) \\) ,\u5219 \\( \\(\\text{ord}_ma=[\\text{ord}_{p_1}^{a_1},\\cdots,\\text{ord}_{p_k}^{a_k}]\\) \\) \u539f\u6839 \uff1a \\( \\((g,m)=1\\) \\) \uff0c\u4e14 \\( \\(\\text{ord}_mg=\\phi(m)\\) \\) \uff0c\u5219g\u662fm\u7684\u539f\u6839\u3002 \\( \\(\\{g,g^2,\\cdots,g^{\\phi(m)}\\}\\) \\) \u662fmod m\u7684\u4e00\u4e2a\u7b80\u7ea6\u5269\u4f59\u7cfb\u3002 \u539f\u6839\u5f62\u5f0f\uff1a \\( \\(2,4,p^\\alpha,2p^\\alpha\\) \\) \u3002p\u4e3a\u5947\u6570\u8d28\u6570\uff08\u9664\u4e862\u5916\u7684\u8d28\u6570\uff09\uff0calpha\u4e3a\u6b63\u6574\u6570 \u6240\u6709\u539f\u6839\uff1ag\u4e3am\u7684\u4e00\u4e2a\u539f\u6839\uff0c\u5219\u4e0b\u9762\u7684\u96c6\u5408\u7ed9\u51fa\u6240\u6709\u539f\u6839\uff08\u539f\u6839g\u6784\u6210\u6574\u6570mod m\u4e58\u6cd5\u7fa4\u751f\u6210\u5143\uff09\uff0c\u56e0\u6b64\u82e5m\u5b58\u5728\u539f\u6839\uff0c\u5219\u539f\u6839\u6570\u91cf\u4e3a \\( \\(\\phi(\\phi(m))\\) \\) $$ {g^s|1\\le s\\le\\phi(m),(s,\\phi(m))=1} $$ \u6c42\u89e3\u4e00\u4e2a\uff08\u6700\u5c0f\uff09\u539f\u6839 \uff1a \\[(g,m)=1$$,\u8bbe$$p_1,p_2,\\cdots,p_k$$\u662f$$\\phi(m)$$\u7684\u6240\u6709\u4e0d\u540c\u8d28\u56e0\u6570\uff0c\u5219g\u662fm\u7684\u539f\u6839\uff0c\u5f53\u4e14\u4ec5\u5f53$$1\\le i\\le k,g^{\\frac{\\phi(m)}{p_i}}\\not\\equiv1\\pmod m\\] \u5148\u5206\u89e3 \\( \\(\\phi(m)\\) \\) \u7684\u8d28\u56e0\u6570\uff0c\u7136\u540e\u7a77\u4e3eg\uff0c\u5e76\u4f9d\u6b21\u9a8c\u8bc1\u6bcf\u4e2a\u8d28\u56e0\u6570\u662f\u5426\u6ee1\u8db3\u4e0a\u9762\u7684\u6761\u4ef6\u3002 https://zh.wikipedia.org/wiki/%E5%8E%9F%E6%A0%B9 m \u6a21m\u7684\u539f\u6839(\u6709*\u53f7\u7684\u6570\u6ca1\u6709\u539f\u6839\uff0c\u6b64\u65f6\u662f\u6709\u6700\u5927\u6a21m\u5468\u671f\u7684\u6570) \u5468\u671f ( \u200a A002322 ) 1 0 1 2 1 1 3 2 2 4 3 2 5 2, 3 4 6 5 2 7 3, 5 6 8* 3, 5, 7 2 9 2, 5 6 10 3, 7 4 11 2, 6, 7, 8 10 12* 5, 7, 11 2 13 2, 6, 7, 11 12 14 3, 5 6 15* 2, 7, 8, 13 4 16* 3, 5, 11, 13 4 17 3, 5, 6, 7, 10, 11, 12, 14 16 18 5, 11 6 19 2, 3, 10, 13, 14, 15 18 20* 3, 7, 13, 17 4 21* 2, 5, 10, 11, 17, 19 6 22 7, 13, 17, 19 10 23 5, 7, 10, 11, 14, 15, 17, 19, 20, 21 22 24* 5, 7, 11, 13, 17, 19, 23 2 25 2, 3, 8, 12, 13, 17, 22, 23 20 26 7, 11, 15, 19 12 27 2, 5, 11, 14, 20, 23 18 28* 3, 5, 11, 17, 19, 23 6 29 2, 3, 8, 10, 11, 14, 15, 18, 19, 21, 26, 27 28 30* 7, 13, 17, 23 4 31 3, 11, 12, 13, 17, 21, 22, 24 30 32* 3, 5, 11, 13, 19, 21, 27, 29 8 33* 2, 5, 7, 8, 13, 14, 17, 19, 20, 26, 28, 29 10 34 3, 5, 7, 11, 23, 27, 29, 31 16 35* 2, 3, 12, 17, 18, 23, 32, 33 12 36* 5, 7, 11, 23, 29, 31 6","title":"\u9636\u548c\u539f\u6839"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_8","text":"p\u662f\u8d28\u6570\uff0c\u5219 $$ a^p\\equiv a \\pmod p $$ \u7279\u522b\u7684,\u5f53a\u4e0d\u662fp\u7684\u500d\u6570\u65f6(\u8fd9\u65f6a,p\u4e92\u8d28)\u6709 $$ a^{p-1}\\equiv 1 \\pmod p $$","title":"\u8d39\u9a6c\u5c0f\u5b9a\u7406"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#miller-rabin","text":"","title":"Miller Rabin \u8d28\u6570\u5224\u522b\u6cd5"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_9","text":"\u5728[2\u5230n-1]\u91cc\u9762\u9009\u62e9\u4e00\u4e9b\u57faa,\u68c0\u67e5\u662f\u5426\u6ee1\u8db3\u8d39\u9a6c\u5c0f\u5b9a\u7406,\u4e0d\u6ee1\u8db3\u5c31\u8bf4\u660e\u4e0d\u662f\u8d28\u6570 \u5f53\u7136\u6ee1\u8db3\u4e86\u4e5f\u4e0d\u4e00\u5b9a\u662f\u8d28\u6570","title":"\u8d39\u9a6c\u7d20\u6027\u6d4b\u8bd5"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_10","text":"p\u662f\u5947\u8d28\u6570\uff0c\u5219\u65b9\u7a0b \\(x^2\\equiv1\\pmod p\\) \u7684\u89e3\u4e3a \\(x=1\\) \u6216\u8005 \\(x=p-1\\) \uff08\u4e5f\u5373 \\(x=-1\\) (\u540c\u4f59\u610f\u4e49\u4e0b\u7684)\uff09 \u8bc1\u660e\uff1a $$ x^2=1\\pmod1 \\Rightarrow (x+1)(x-1)=0\\pmod1\\Rightarrow\\ p|(x+1)(x-1) \\Rightarrow x=p-1\u62161 $$","title":"\u4e8c\u6b21\u63a2\u6d4b\u5b9a\u7406"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_11","text":"\u5bf9\u8fd9\u7c7b\u6570,\u53d6\u4efb\u4f55\u57fa\u90fd\u80fd\u901a\u8fc7\u7d20\u6027\u6d4b\u8bd5,\u4f46\u5176\u672c\u8eab\u5374\u4e0d\u662f\u8d28\u6570. \u6700\u5c0f\u7684\u4e09\u4e2a\u6570\u662f561,1105,1729( OEIS:A002997 ) \u7b49\u4ef7\u5b9a\u4e49 :\u4e00\u4e2a\u6b63\u5408\u6210\u6570n\u662f\u5361\u8fc8\u514b\u5c14\u6570\uff0c\u5f53\u4e14\u4ec5\u5f53 n\u65e0\u5e73\u65b9\u6570\u7ea6\u6570\u4e14\u5bf9\u4e8e\u6240\u6709 n\u7684\u7d20\u56e0\u6570 p\uff0cp-1|n-1","title":"\u5361\u8fc8\u514b\u5c14\u6570"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_12","text":"\u5982\u679cn\u662f\u5927\u4e8e2\u7684\u8d28\u6570,\u5219\u7531\u4e8en-1\u662f\u5076\u6570,\u5bf9\u4e8e\u4efb\u610f\u7684\u57fa \\(a~(a\\in[2,n-1])\\) ,\u6709 $$ a {n-1}=a $$ \u7531\u8d39\u9a6c\u7d20\u6027\u6d4b\u8bd5,\u6211\u4eec\u63a5\u4e0b\u6765\u8981\u505a \\(a^{n-1}\\equiv 1 \\pmod n\\) ,\u7ed3\u5408\u4e0a\u5f0f\u53ef\u4ee5\u5f97\u5230 $$ a {2 sd}=(a {2 d})^2\\equiv 1\\pmod n $$ \u7531\u4e8c\u6b21\u63a2\u6d4b\u5b9a\u7406\u53ef\u77e5\uff0c \\(a^{2^{r-1}}\\equiv 1\u6216-1\\) . \u800c\u5982\u679c\u7b49\u4e8e1\u90a3\u4e48\u53ef\u4ee5\u7ee7\u7eed\u5f00\u6839\u53f7\u3002 \u73b0\u5728\u8003\u8651\u53cd\u8fc7\u6765\u7528\u8fd9\u4e2a\u5b9a\u7406\uff1a\u5982\u679c\u5b58\u5728\u8fd9\u4e48\u4e00\u4e2aa\u4f7f\u5f97\u4e0b\u9762\u4e24\u4e2a\u5f0f\u5b50\u90fd\u6ee1\u8db3\uff1a $$ a^d\\not\\equiv1 \\pmod n\\ a {{2 r}d}\\not\\equiv1 \\pmod n (0\\le r\\le s-1)\\ $$ \u90a3\u4e48n\u5c31\u4e00\u5b9a\u662f\u5408\u6570,a\u4fbf\u662fn\u662f\u5408\u6570\u7684\u4e00\u4e2a\u51ed\u636e. \u6ce8\uff1a\u8fd9\u91cc\u8981\u4e48 \\(a^d,a^{2^1d},\\cdots,a^{2^rd}\\) \u5168\u662f1\uff0c\u8981\u4e48\u4f1a\u5b58\u5728\u4e00\u4e2a\u6570\u662f-1\uff0c\u7136\u540e\u5c31\u90fd\u662f1 \u8fd9\u662f\u56e0\u4e3a\u5982\u679c\u5176\u4e2d\u67d0\u4e2a\u6570\u662f1\u90a3\u4e48\u53ef\u4ee5\u5f00\u6839\u53f7\uff0c\u5f97\u5230\u524d\u4e00\u4e2a\u6570\u662f1\u6216-1\u3002\u5982\u679c\u662f1\u90a3\u4e48\u53ef\u4ee5\u7ee7\u7eed\u5f00\u6839\u53f7\u76f4\u5230\u6240\u6709\u6570\u90fd\u662f1\u4e3a\u6b62\uff1b\u5982\u679c\u662f-1\u90a3\u4e48\u5c31\u6b64\u7ec8\u6b62\uff0c\u56e0\u6b64\u8fd9\u4e2a-1\u4e4b\u540e\u7684\u6570\u90fd\u662f1","title":"\u7efc\u5408\u505a\u6cd5"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#pollards-rho","text":"","title":"Pollard's Rho \u8d28\u56e0\u6570\u5206\u89e3(\u5f85\u8865\u5145)"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_13","text":"\u5f15\u74061\uff1a \u5730\u677f\u9664\u6cd5\u5d4c\u5957\u53ef\u4e0b\u653e $$ \\forall a,b,c\\in \\mathbb{Z},\\lfloor\\frac{a}{bc}\\rfloor=\\lfloor\\frac{\\lfloor\\frac ab\\rfloor}{c}\\rfloor $$ \u5f15\u74062 \uff1a\u4e0d\u540c\u7684n/d\u4e2a\u6570\u4e0d\u4f1a\u8d85\u8fc7 \\(\\lfloor2\\sqrt n\\rfloor\\)","title":"\u72c4\u5229\u514b\u96f7\u5377\u79ef\uff0c\u83ab\u6bd4\u4e4c\u65af\u53cd\u6f14"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_14","text":"\uff08\u5f85\u8865\u5145\uff09","title":"\u6570\u8bba\u5206\u5757"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_15","text":"\\(f(n)\\) \u6ee1\u8db3 \\(f(1)=1 \\&\\& \\forall x,y\\in\\mathbb{N_+},\\gcd(x,y)=1\\) \u6709 \\(f(xy)=f(x)f(y)\\) ,\u5219f\u4e3a\u79ef\u6027\u51fd\u6570\u3002 \u5982\u679c\u6ca1\u6709gcd\u6761\u4ef6\u7684\u9650\u5236\uff0c\u4e5f\u5373\u4efb\u610f\u4e24\u4e2a\u6570\u90fd\u6ee1\u8db3\u79ef\u6027\u6761\u4ef6\uff0c\u5219f\u4e3a\u5b8c\u5168\u79ef\u6027\u51fd\u6570 \u6027\u8d28 \uff1a\uff08\u5f85\u8865\u5145\uff09 \u5e38\u89c1\u79ef\u6027\u51fd\u6570 \uff1a \u4e0b\u6587\u4e2d \\([condition]\\) \u8868\u793a\u5f53\u6761\u4ef6\u6210\u7acb\u65f6\u4e3a1\uff0c\u5426\u5219\u4e3a0 \u5355\u4f4d\u51fd\u6570\uff1a\uff08\u5b8c\u5168\u79ef\u6027\u51fd\u6570\uff09 $$ \\epsilon(n)=[n=1] $$ \u5e42\u51fd\u6570\u548c\u6052\u7b49\u51fd\u6570\uff1a(\u5b8c\u5168\u79ef\u6027\u51fd\u6570) $$ id_k(n)=n^k,id(n)=n $$ \u5e38\u6570\u51fd\u6570\uff1a\uff08\u5b8c\u5168\u79ef\u6027\u51fd\u6570\uff09 $$ 1(n)=1 $$ \u9664\u6570\u51fd\u6570\uff1a $$ \\sigma_k(n)=\\sum_{d|n}d^k\\sigma_0(n),\\sigma_1(n)=\\sigma(n) $$ \u6b27\u62c9\u51fd\u6570\uff1a \u83ab\u6bd4\u4e4c\u65af\u51fd\u6570\uff1a $$ \\mu(n)=\\begin{cases} 1 & n=1\\ 0 & \\exist d>1:d^2|n\\ (-1)^{\\omega(n)} & else\\ \\end{cases} $$ \u672c\u8d28\u4e0d\u540c\u8d28\u56e0\u5b50\u4e2a\u6570\u51fd\u6570\uff08\u4e5f\u662f\u79ef\u6027\u51fd\u6570\uff09\uff1a $$ \\omega({n})=|{p: (p|n \\&\\& \\text{p is a prime})}| $$","title":"\u79ef\u6027\u51fd\u6570"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#dirichlet","text":"\u4e24\u4e2a\u6570\u8bba\u51fd\u6570fg\u7684\u5377\u79ef\uff0c\u662f\u6240\u6709\u6574\u9664n\u7684\u56e0\u5b50d\u7684f(d)\uff0c\u548c\u8be5\u56e0\u5b50\u5bf9\u5e94\u7684\u5546\u6570n\\d\u7684g(n\\d) \u4e4b\u79ef\u7684\u6c42\u548c \uff08\u7ed3\u679c\u662f\u4e00\u4e2a\u65b0\u7684\u6570\u8bba\u51fd\u6570\uff09 $$ (f g)(n)=\\sum_{d|n}f(d)g(\\frac nd) $$ \u6027\u8d28 *\uff08\u7fa4\u8bba\uff09\uff1a \u4ea4\u6362\u5f8b \u7ed3\u5408\u5f8b \u5206\u914d\u7387\uff1a \\(f*(g+h)=f*g+f*h\\) \u5355\u4f4d\u5143\uff1a \\(\\epsilon\\) ,\u4e5f\u5373\u5355\u4f4d\u51fd\u6570","title":"\u72c4\u5229\u514b\u96f7\u5377\u79ef\uff08Dirichlet \uff09"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_16","text":"\u5982\u679c\u8981\u6c42\u67d0\u4e2a\u503c\uff0c\u8fd9\u4e2a\u503c\u8981\u6c42 \\(\\gcd(a_1,\\cdots,c_n)=1\\) \uff0c\u90a3\u4e48 $$ ans=\\sum_{d=1}^{n}\\mu(d)\\cdot D(a_1,a_2,\\cdots,a_n,d) $$ \u5176\u4e2d \\(D(a_1,a_2,\\cdots,a_n,d)\\) \u8868\u793a\u6ee1\u8db3 \\(d|\\gcd(a_1,a_2,\\cdots,a_n)\\) \u7ea6\u675f\u65f6\u7684\u51fd\u6570\u503c \u4f8b\u9898\uff1a 2019 \u94f6\u5dddD \u84dd\u4e66\u4e0a\u7684\u6c42sum of [gcd=1]\u9898","title":"\u83ab\u6bd4\u4e4c\u65af\u5bb9\u65a5"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#rsa","text":"","title":"*RSA"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_17","text":"\u9009\u62e9\u4e24\u4e2a\u8d28\u6570p\u3001q\uff0c\u4ee4N=pq \u6c42N\u7684\u6b27\u62c9\u51fd\u6570\u503cr\uff1a \\(r=\\phi(N)=\\phi(p)\\phi(q)=(p-1)(q-1)\\) \u9009\u62e9 \u5c0f\u4e8er \u7684\u6b63\u6570e\uff0c\u4f7f\u5f97 \\(\\gcd(e,r)=1\\) \u4f7f\u7528exgcd\u6c42\u5f97e\u5173\u4e8er\u7684\u9006\u5143\uff08\u7531\u4e8e\u5176\u4e0er\u4e92\u8d28\uff0c\u56e0\u6b64e\u7684\u9006\u5143\u5b58\u5728\uff09\uff0c\u8bb0\u4e3ad \u81f3\u6b64\uff0c \\((N,d)\\) \u4e3a\u79c1\u94a5\u3001 \\((N,e)\\) \u4e3a\u516c\u94a5\u3002","title":"\u4ea7\u751f\u516c\u94a5\u548c\u79c1\u94a5\u7684\u8fc7\u7a0b"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_18","text":"\u5047\u8bbe\u8981\u52a0\u5bc6\u7684\u5185\u5bb9\u4e3an\uff08n<N\uff09\uff0c\u5219\u52a0\u5bc6\u540e\u7684\u660e\u6587c\u4e3a\uff1a $$ c\\equiv n^e \\pmod N $$","title":"\u52a0\u5bc6"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_19","text":"\u62e5\u6709\u79c1\u94a5d\u548c\u660e\u6587c\uff0c\u5c31\u53ef\u4ee5\u7528\u4e0b\u9762\u7684\u5f0f\u5b50\u89e3\u5bc6\uff1a $$ n\\equiv c^{d} \\pmod N $$ \u539f\u7406\uff1a $$ c^d\\equiv n^{ed} \\pmod N $$ \u800c \\(ed\\equiv 1 \\pmod r\\) \uff0c\u5219 \\(ed=1+hr=1+h\\phi(N)\\) \uff0c\u4ece\u800c $$ n^{ed}\\equiv n\\cdot (n {\\phi(N)}) h \\pmod N $$ \u7531\u6b27\u62c9\u5b9a\u7406\u53ef\u77e5 \\(n^{\\phi(N)}\\equiv 1 \\pmod N\\) \uff08\u5982\u679cn\u548cN\u4e92\u8d28\uff09\uff0c\u90a3\u4e48\u53ef\u5f97 \\[ n^{ed}\\equiv n \\pmod N \\] \u5982\u679c\u4e0d\u4e92\u8d28\uff0c\u8bbe \\(n=kp<N,\\gcd(n,q)=1\\) \uff0c\u5219 $$ n^{ed}\\equiv (kp)^{ed}\\equiv 0\\equiv n \\pmod p\\ n^{ed}\\equiv n^{ed-1}\\cdot n=({n {\\phi(N)}}) hn\\equiv1^hn=n\\pmod q $$ \u6839\u636e\u540c\u4f59\u6027\u8d289\uff0c\u5f97\u5230 $$ n^{ed}=n \\pmod {pq} $$","title":"\u89e3\u5bc6"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#bertrands-postulate","text":"\u5bf9\u4e8e\u4efb\u610f\u6574\u6570 \\(n>3\\) \uff0c\u5b58\u5728\u8d28\u6570p\uff1a $$ n<p<2n-2 $$ \u5f31\u5316\u7248\u672c\uff1a $$ n<p<2n $$ \u5f3a\u5316\u7248\u672c\uff1a\u5bf9\u4e8e \\(n>25\\) \uff0c\u5b58\u5728\u8d28\u6570p\uff1a $$ n<p<(1+\\frac 15)n $$","title":"Bertrand's postulate \u4f2f\u7279\u5170\u5207\u6bd4\u96ea\u592b\uff08\u5047\u8bbe\uff09\u5b9a\u7406"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_20","text":"","title":"\u535a\u5f08\u8bba"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#nimsgmulti-sg","text":"Nim \u5148\u624b\u5fc5\u80dc \uff1a\u5f02\u6216\u548c\u4e0d\u4e3a0 SG\uff1a \\(sg(x)=\\text{mex}(sg(y_1),\\cdots)\\) Multi-SG: \u82e5\u5e72\u4e2aICG\u7684\u548c\u7b49\u4e8e\u6bcf\u4e2aICG\u7684sg\u503c\u5f02\u6216\u548c","title":"Nim\u3001SG\u3001Multi-SG"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#anti-sganti-nim","text":"\u53d6\u5f97\u6700\u540e\u4e00\u4e2a\u77f3\u5934\u7684\u8f93\u3002 \u5148\u624b\u5fc5\u80dc \uff1a sg\u22600\uff0c\u4e14\u6709\u5355\u4e00\u6e38\u620fsg>1; sg=0\uff0c\u4e14\u65e0\u5355\u4e00\u6e38\u620fsg>1; \uff08\u4e5f\u5373\u6240\u6709\u6e38\u620fsg=1\uff09","title":"Anti-SG\u3001Anti-Nim"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#bashanti-bash","text":"\u4e00\u5806\uff08n\u4e2a\uff09\u77f3\u5934\uff0c\u80fd\u62ff1\u5230m\u4e2a\uff0c\u4e0d\u80fd\u62ff\u7684\u8f93\u3002 Bash\u5148\u624b\u5fc5\u80dc\uff1a \\(n\\%(m+1)\\neq0\\) \u53cdBash\u5148\u624b\u5fc5\u80dc\uff1a \\((n-1)\\%(m+1)\\neq0\\)","title":"Bash\u3001Anti-Bash"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#laskers-nim","text":"n\u5806\u77f3\u5934\uff0c\u5bf9\u4e00\u5806\u77f3\u5934\u53ef\u4ee5\u7528nim\u7684\u53d6\u6cd5\u6216\u8005\u5206\u6210\u4e24\u5806\u3002 \u5355\u4e00\u6e38\u620f\u7684SG\u51fd\u6570\uff1a $$ sg(x)=\\begin{cases} x-1, & x\\%4==0\\ x, & x\\%4==1or2\\ x+1, & x\\%4==3 \\end{cases} $$","title":"Lasker's Nim"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#every-sg","text":"\u672a\u7ed3\u675f\u7684\u5355\u4e00\u6e38\u620f\u5fc5\u987b\u52a8\u4e00\u6b65\u3002 \u67d0\u4e2a\u5355\u4e00\u6e38\u620f\u7684step\uff1a $$ step(x)=\\begin{cases} 0, & \\text{end}\\ \\max(step(y))+1, & sg(x)\\neq0 and sg(y)=0\\ \\min(step(y))+1, & sg(x)=0\\ \\end{cases} $$ \u5148\u624b\u5fc5\u80dc \uff1a \\(\\max(step(x))\\%2==1\\)","title":"Every-SG"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_21","text":"\u9636\u68af\u4e0a\u6709\u82e5\u5e72\u77f3\u5934\uff0c\u6bcf\u6b21\u9009\u4e00\u4e2a\u9636\u68af\u4e0a\u7684\u81f3\u5c11\u4e00\u4e2a\u77f3\u5934\u79fb\u52a8\u5230\u4e0b\u4e00\u5c42\uff0c\u4e0d\u80fd\u79fb\u52a8\u7684\u8f93\u3002 \u65b9\u6cd5 \uff1a \u5947\u6570\u53f0\u9636\u770b\u505a\u5355\u4e2aNim\u6e38\u620f","title":"\u9636\u68af\u535a\u5f08"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_22","text":"N\u679a\u786c\u5e01\u6392\u6210\u4e00\u6392\uff0c\u6709\u7684\u6b63\u9762\u671d\u4e0a\uff0c\u6709\u7684\u53cd\u9762\u671d\u4e0a\u3002\u6211\u4eec\u4ece\u5de6\u5f00 \u59cb\u5bf9\u786c\u5e01\u63091\u5230N\u7f16\u53f7\u3002 Alice\u548cBob\u8f6e\u6d41\u6839\u636e\u67d0\u4e9b\u7ea6\u675f\u7ffb\u786c\u5e01\uff08\u5982\uff1a\u6bcf\u6b21\u53ea\u80fd\u7ffb\u4e00\u6216\u4e24\u679a\uff0c\u6216\u8005\u6bcf \u6b21\u53ea\u80fd\u7ffb\u8fde\u7eed\u7684\u51e0\u679a\uff09\uff0c\u4f46\u4ed6\u6240\u7ffb\u52a8\u7684\u786c\u5e01\u4e2d\uff0c\u6700\u53f3\u8fb9\u7684\u5fc5\u987b\u662f \u4ece\u6b63\u9762\u7ffb\u5230\u53cd\u9762\u3002 \u8c01\u4e0d\u80fd\u7ffb\u8c01\u8f93\u3002 \u65b9\u6cd5 \uff1a \u5c40\u9762\u7684SG\u503c\u4e3a\u5c40\u9762\u4e2d\u6bcf\u4e2a\u6b63\u9762\u671d\u4e0a\u7684\u68cb\u5b50\u5355\u4e00\u5b58\u5728\u65f6\u7684SG\u503c\u7684\u5f02\u6216\u548c","title":"\u786c\u5e01\u53cd\u8f6c"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_23","text":"\u53f6\u5b50\u8282\u70b9\u7684sg\u503c\u4e3a0\uff0c\u975e\u53f6\u5b50\u8282\u70b9\u7684sg\uff1a $$ sg(x)=\\sum_{\\oplus}(sg(y)+1) $$ \u5176\u4ed6\u7684\u5f85\u8865\u5145\u2026\u2026","title":"\u6811\u4e0a\u5220\u8fb9"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_24","text":"\u4e24\u4eba\u8f6e\u6d41\u53d6\u4e24\u5806\u7b79\u7801\uff0c\u5176\u4e2d\u53d6\u6cd5\u6709\u4e24\u79cd\uff1a\u53d6\u8d70\u4e00\u5806\u4e2d\u4efb\u610f\u4e2a\u7b79\u7801\uff0c\u6216\u4ece\u4e24\u5806\u4e2d\u53d6\u8d70\u76f8\u540c\u6570\u76ee\u7684\u7b79\u7801\u3002\u53d6\u5b8c\u6240\u6709\u7b79\u7801\u7684\u4e00\u65b9\u83b7\u80dc\u3002 \u524d\u82e5\u5e72\u4e2a\u5947\u5f02\u5c40\u52bf\uff1a\uff080\uff0c0\uff09\u3001\uff081\uff0c2\uff09\u3001\uff083\uff0c5\uff09\u3001\uff084\uff0c7\uff09\u3001\uff086\uff0c10\uff09 \u4efb\u4f55\u4e00\u4e2a\u81ea\u7136\u6570\u90fd\u5305\u542b\u5728\u552f\u4e00\u4e00\u4e2a\u5947\u5f02\u5c40\u52bf\uff08\u5148\u8d25\uff09\u4e2d x\u4e3a\u524dk\u4e2a\u5947\u5f02\u5c40\u52bf\u4e2d\u672a\u51fa\u73b0\u7684\u6700\u5c0f\u6b63\u6574\u6570\uff0c\u5219\uff08x\uff0cy\uff09\u4e2d\u7684y=x+k \u5c40\u9762\uff08x\uff0cy\uff09\uff08x<y\uff09 \u5148\u624b\u5fc5\u8d25 \uff1a $$ (y-x)\\frac{\\sqrt5+1}{2}=x $$","title":"\u5a01\u4f50\u592b\u535a\u5f08"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_25","text":"\u4e00\u5806\u77f3\u5b50\u6709n\u4e2a\uff0c\u4e24\u4eba\u8f6e\u6d41\u53d6\uff0c\u5148\u53d6\u8005\u7b2c1\u6b21\u53ef\u4ee5\u53d6\u4efb\u610f\u591a\u4e2a\uff0c\u4f46\u4e0d\u80fd\u5168\u90e8\u53d6\u5b8c\uff0c\u4ee5\u540e\u6bcf\u6b21\u53d6\u7684\u77f3\u5b50\u6570\u4e0d\u80fd\u8d85\u8fc7\u4e0a\u6b21\u53d6\u5b50\u6570\u76842\u500d\u3002\u53d6\u5b8c\u8005\u80dc\u3002 \u5148\u624b\u5fc5\u8d25 \uff1a\u77f3\u5934\u6570\u91cf\u662f\u6590\u6ce2\u90a3\u5951\u6570 \u4efb\u4f55\u6570\u53ef\u4ee5\u5206\u89e3\u6210\u82e5\u5e72\u4e0d\u8fde\u7eed\u6590\u6ce2\u90a3\u5951\u6570\u7684\u548c","title":"\u6590\u6ce2\u90a3\u5951\u535a\u5f08"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_26","text":"","title":"\u7ec4\u5408\u6570\u5b66"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_27","text":"\u6052\u7b49\u5f0f\uff1a \u659c\u7ebf\u52a0\u548c\u7b49\u4e8e\u659c\u7ebf\u672b\u7aef\u6b63\u4e0b\u65b9\u7684\u6570 \\[ \\sum_{r=0}^k \\binom {n+r-1}r = \\binom {n+k}k \\] \u540c\u884c\u52a0\u548c \\[ \\sum_{r=0}^n \\binom nr = 2^{n} \\] \u540c\u5217\u76f8\u52a0 $$ \\sum_{r=m}^{n} \\binom{r}{m}=\\binom{n+1}{m+1} $$","title":"\u7ec4\u5408\u6570"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_28","text":"n\u4e2a\u7403\u653e\u5165k\u4e2a\u76d2\u5b50\u4e2d\u3002\uff08\u6ce8\u610fk\u662f\u76d2\u5b50\u6570\u4e0d\u662f\u677f\u5b50\u6570\uff09 https://zh.wikipedia.org/wiki/%E9%9A%94%E6%9D%BF%E6%B3%95 \u4e0d\u5141\u8bb8\u7a7a\u76d2\uff1a \u8fd9\u79cd\u653e\u6cd5\u4e0d\u5141\u8bb8\u653e\u5c06\u677f\u5b50\u5728\u4e00\u5217\u7403\u7684\u6700\u5de6\u7aef\u548c\u6700\u53f3\u7aef $$ \\binom{n-1}{k-1} $$ \u5141\u8bb8\u7a7a\u76d2 \uff1a\u4e5f\u5373\u5141\u8bb8\u591a\u4e2a\u677f\u5b50\u63d2\u5728\u540c\u4e00\u4e2a\u7a7a\u9699\u4e4b\u95f4\uff08\u5305\u62ec\u6700\u5de6\u3001\u53f3\u7aef\uff09\u3002\u7b49\u4ef7\u4e8e\u5411n+k\u4e2a\u7403\u4e2d\u63d2k-1\u4e2a\u677f\u5b50\uff08k\u4e2a\u76d2\u5b50\uff09\uff08\u4e0d\u5141\u8bb8\u7a7a\u76d2\uff09\u3002 \u53ef\u4ee5\u8fd9\u4e48\u8003\u8651\uff1a\u5411n+k\u4e2a\u7403\u4e2d\u63d2k-1\u4e2a\u677f\u5b50\uff08\u4e0d\u5141\u8bb8\u7a7a\u76d2\uff09\u540e\u518d\u4ece\u6240\u6709\u76d2\u5b50\u4e2d\u5168\u90e8\u62ff\u6389\u4e00\u4e2a\u7403\uff0c\u5c31\u7b49\u4ef7\u4e8e\u73b0\u5728\u8fd9\u4e2a\u95ee\u9898\u4e86\u3002 $$ \\binom{n+k-1}{k-1} $$","title":"\u9694\u677f\u6cd5"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_29","text":"\u4ecen\u4e2a\u7403\u4e2d\u9009r\u4e2a\uff0c\u4f7f\u5f97\u5b83\u4eec\u4e92\u4e0d\u76f8\u90bb\uff0c\u95ee\u53d6\u6cd5\u603b\u6570\u3002 $$ C_{n-r+1}^r~(n\\ge2r-1) $$ \u8bc1\u660e\u65b9\u6cd5\uff1a{b1,...,br}\u662f\u4e00\u4e2a\u4e0d\u76f8\u90bb\u96c6\u5408\uff0c\u6784\u9020c1=b1,c2=b2-2,...,cr=br-r+1\uff0c\u5f97\u5230\u65b0\u7684\u96c6\u5408{c1,c2,...,cr}\uff0c\u7531\u4e8eb\u4e92\u4e0d\u76f8\u90bb\uff0c\u8fd9\u79cd\u6784\u9020\u65b9\u6cd5\u53ef\u4ee5\u4fdd\u8bc1c\u96c6\u5408\u6ca1\u6709\u91cd\u590d\u5143\u7d20\uff0c\u4e14\u5bf9\u4e8e\u4e0d\u540c\u7684b\u96c6\u5408\uff0cc\u96c6\u5408\u4e5f\u4e0d\u91cd\u590d\u3002\u8fd9\u5c31\u662f\u8bf4c\u548cb\u662f\u4e00\u4e00\u5bf9\u5e94\u5173\u7cfb\u3002\u800cc\u96c6\u5408\u7684\u610f\u4e49\u662f\u4ecen-r+1\u4e2a\u7403\u4e2d\u9009r\u4e2a\u3002","title":"\u4e0d\u76f8\u90bb\u7ec4\u5408\u6570"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_30","text":"\\[ F_n=C_{n-1}^{0}+C_{n-2}^{1}+\\dots+C_{n-i-1}^{i}\\\\ =\\sum_{i=0}^{(n+1)/2}C_{n-i-1}^{i} \\] \u8bc1\u660e\u65b9\u6cd5\uff1a\u8003\u8651\u4e0a\u697c\u68af\u65f6+2\u7684\u6b21\u6570\u3002\u6bcf\u67091\u4e2a+2\uff0c\u53ef\u9009\u62e9\u7684\u4f59\u5730\u5c31\u51cf\u5c111\u3002 $$ 1+1+1+1\\ 1+1+2\\ 1+2+1\\ 2+1+1\\ 2+2 $$","title":"\u6590\u6ce2\u90a3\u5951\u6570\u5217\u7684\u7ec4\u5408\u6570\u8868\u793a"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_31","text":"n\u4e2a\uff08\u4e0d\u540c\uff09\u5143\u7d20\u5206\u6210k\u4e2a\u73af\u7684\u5206\u6cd5\u6570\u76ee $$ s(n,k)=\\begin{bmatrix} n\\k \\end{bmatrix}\\ s(0,0)=s(n,0)=s(0,n)=0\\ s(n+1,k)=ns(n,k)+s(n,k-1) $$ \u6027\u8d28 \uff1a $$ s(n,1)=(n-1)!\\ s(n,2)=(n-1)!\\sum_{i=1}^{n-1}\\frac 1i $$","title":"\u7b2c\u4e00\u7c7b\uff08\u65e0\u7b26\u53f7\uff09\u65af\u7279\u6797\u6570"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_32","text":"n\u4e2a\uff08\u4e0d\u540c\uff09\u5143\u7d20\u5206\u6210k\u4e2a\u975e\u7a7a\u5b50\u96c6\u7684\u65b9\u6cd5\u6570\u76ee $$ S(n,k)=\\begin{Bmatrix} n\\k \\end{Bmatrix}\\ \\begin{Bmatrix} 0\\0 \\end{Bmatrix}=1, \\begin{Bmatrix} 0\\n \\end{Bmatrix}= \\begin{Bmatrix} n\\0 \\end{Bmatrix}=0 \\ \\begin{Bmatrix} n\\k \\end{Bmatrix}=\\begin{Bmatrix} n-1\\k-1 \\end{Bmatrix}+k\\begin{Bmatrix} n-1\\k \\end{Bmatrix} $$ \u6027\u8d28 \uff1a\uff08\u6ca1\u4ec0\u4e48\u5375\u7528= =\uff09 $$ \\begin{Bmatrix} n\\k \\end{Bmatrix}=0~(k>n)\\ \\begin{Bmatrix} n\\n \\end{Bmatrix}=1\\ \\begin{Bmatrix} n\\2 \\end{Bmatrix}=2^{n-1}-1\\ \\begin{Bmatrix} n\\3 \\end{Bmatrix}=\\frac12(3 {n-1}+1)-2 $$ \u901a\u9879\u516c\u5f0f \uff1a $$ \\begin{Bmatrix} n\\k \\end{Bmatrix}=\\frac1{k!}\\sum_{i=0} k(-1) i{k\\choose i}(k-i)^n\\ =\\begin{align }\\left{\\begin{matrix}n\\m\\end{matrix}\\right}=\\sum\\limits_{k=0} m\\dfrac{(-1) k}{k!}\\dfrac{(m-k)^n}{(m-k)!}\\end{align } $$ \u548c\u9012\u51cf\u9636\u4e58\u7684\u5173\u7cfb\uff1a $$ \\begin{align }x n=\\sum\\limits_{k=1} n\\left{\\begin{matrix}n\\k\\end{matrix}\\right}x^\\underline k\\end{align } $$ \\[ x^{\\overline n}=x(x+1)\\cdots(x+n-1)\\\\ x^{\\underline n}=x(x-1)\\cdots(x-n+1)\\\\ \\]","title":"\u7b2c\u4e8c\u7c7b\u65af\u7279\u6797\u6570"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_33","text":"\u7b80\u5316\u516c\u5f0f \uff1a $$ D_n=\\lfloor\\frac{n!}{e}+0.5\\rfloor $$ \u9012\u63a8\u516c\u5f0f \uff1a $$ D_n=nD_{n-1}+(-1)^n\\ D_n=(n-1)(D_{n-1}-D_{n-2})\\ (D_1=0,D_2=1) $$","title":"\u9519\u6392"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#dilworth","text":"\u5b9a\u7406 \uff1a\u5bf9\u4e8e\u4e00\u4e2a\u504f\u5e8f\u96c6\uff0c\u5176\u6700\u5c11\u94fe\u5212\u5206\u6570\u7b49\u4e8e\u5176\u6700\u957f\u53cd\u94fe\u7684\u957f\u5ea6\u3002 \u5bf9\u5076\u5b9a\u7406 \uff1a\u5bf9\u4e8e\u4e00\u4e2a\u504f\u5e8f\u96c6\uff0c\u5176\u6700\u5c11\u53cd\u94fe\u5212\u5206\u6570\u7b49\u4e8e\u5176\u6700\u957f\u94fe\u7684\u957f\u5ea6\u3002 \u6700\u5c11\u4e0a\u5347\u5b50\u5e8f\u5217\u5212\u5206\u6570=\u6700\u957f\u4e0d\u4e0a\u5347\u5b50\u5e8f\u5217\u957f\u5ea6","title":"Dilworth\u5b9a\u7406"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_34","text":"1\u3001\u7403\u540c\uff0c\u76d2\u540c\uff0c\u76d2\u4e0d\u53ef\u4ee5\u4e3a\u7a7aPm\uff08N\uff09--\u8fd9\u7b26\u53f7\u8868\u793a\u90e8\u5206\u6570\u4e3am\u7684N-\u5206\u62c6\u7684\u4e2a\u6570\uff0cm\u662fP\u7684\u4e0b\u6807\uff0c\u4e3a\u4e86\u597d\u770b\u6211\u5c06\u5927\u5199\u7684M\u5f04\u6210\u5c0f\u5199 2\u3001\u7403\u540c\uff0c\u76d2\u540c\uff0c\u76d2\u53ef\u4ee5\u4e3a\u7a7a Pm\uff08N+M\uff09--\u4e3a\u4ec0\u4e48\u8981\u52a0M\uff0c\u4e0e4\u4e3a\u4ec0\u4e48\u8981\u57283\u7684\u57fa\u7840\u4e0a\u52a0M\u662f\u4e00\u6837\u7684\uff0c\u5c31\u662f\u4e3a\u4e86\u4fdd\u8bc1\u4e0d\u4e3a\u7a7a 3\u3001\u7403\u540c\uff0c\u76d2\u4e0d\u540c\uff0c\u76d2\u4e0d\u53ef\u4ee5\u4e3a\u7a7aC(N-1, M-1) 4\u3001\u7403\u540c\uff0c\u76d2\u4e0d\u540c\uff0c\u76d2\u53ef\u4ee5\u4e3a\u7a7a C(N+M-1, M-1) 5\u3001\u7403\u4e0d\u540c\uff0c\u76d2\u540c\uff0c\u76d2\u4e0d\u53ef\u4ee5\u4e3a\u7a7aS(N, M) --\u7b2c\u4e8c\u7c7b\u65af\u7279\u6797\u6570 6\u3001\u7403\u4e0d\u540c\uff0c\u76d2\u540c\uff0c\u76d2\u53ef\u4ee5\u4e3a\u7a7a S (N, 1) + S(N, 2) + S(N, 3) + ... + S(N, M) 7\u3001\u7403\u4e0d\u540c\uff0c\u76d2\u4e0d\u540c\uff0c\u76d2\u4e0d\u53ef\u4ee5\u4e3a\u7a7aM! * S(N, M) 8\u3001\u7403\u4e0d\u540c\uff0c\u76d2\u4e0d\u540c\uff0c\u76d2\u53ef\u4ee5\u4e3a\u7a7a M^N--\u8868\u793aM\u7684N\u6b21\u65b9 1\u30018\u4e2a\u76f8\u540c\u7684\u7403\u653e\u8fdb4\u4e2a\u76f8\u540c\u7684\u76d2\u5b50\u91cc\uff0c\u6bcf\u76d2\u81f3\u5c11\u4e00\u4e2a\uff0c\u6709\u51e0\u79cd\u65b9\u6cd5\uff1f \u516c\u5f0f\uff1a\u7403\u76f8\u540c\uff0c\u76d2\u76f8\u540c\uff0c\u62c6\u5206\u516c\u5f0f\u3002 P4(8)=P1(4)+P2(4)+P3(4)+P4(4) =1+2+1+1 =5 2\u30018\u4e2a\u76f8\u540c\u7684\u7403\u653e\u8fdb4\u4e2a\u4e0d\u540c\u7684\u76d2\u5b50\u91cc\uff0c\u6bcf\u76d2\u81f3\u5c11\u4e00\u4e2a\uff0c\u6709\u51e0\u79cd\u65b9\u6cd5\uff1f \u516c\u5f0f\uff1a\u7403\u76f8\u540c\uff0c\u76d2\u4e0d\u540c\uff0c\u63d2\u677f\u6cd5\u3002 C(8-1,4-1) =C(7,3) =7 6 \u215a =35 3\u30018\u4e2a\u4e0d\u540c\u7684\u7403\u653e\u8fdb4\u4e2a\u4e0d\u540c\u7684\u76d2\u5b50\u91cc\uff0c\u6bcf\u76d2\u81f3\u5c11\u4e00\u4e2a\uff0c\u6709\u51e0\u79cd\u65b9\u6cd5\uff1f \u516c\u5f0f\uff1a\u7403\u4e0d\u540c\uff0c\u76d2\u4e0d\u540c\uff0c\u4e0d\u4e3a\u7a7a\uff0c\u9636\u4e58\u548c\u4e8c\u7c7b\u65af\u7279\u6797\u6570\uff0c\u7403\u662f\u884c\u53f7\uff0c\u76d2\u5b50\u662f\u5217\u53f7\u3002 M! S(N,M) =4! * S(8,4) =24 1701 =40824 4\u30018\u4e2a\u4e0d\u540c\u7684\u7403\u653e\u8fdb4\u4e2a\u76f8\u540c\u7684\u76d2\u5b50\u91cc\uff0c\u6bcf\u76d2\u81f3\u5c11\u4e00\u4e2a\uff0c\u6709\u51e0\u79cd\u65b9\u6cd5 \uff1f \u516c\u5f0f\uff1a\u7403\u4e0d\u540c\uff0c\u76d2\u540c\uff0c\u4e8c\u7c7b\u65af\u7279\u6797\u6570\uff0c\u4e3a\u7a7a\u662f\u7d2f\u52a0\uff0c\u4e0d\u4e3a\u7a7a\u662f\u76f4\u63a5\u53d6\u6570\uff0c\u7403\u662f\u884c\u53f7\uff0c\u76d2\u5b50\u662f\u5217\u53f7\u3002 S(N,M) =S(8,4) =1701 5\u30018\u4e2a\u76f8\u540c\u7684\u7403\u653e\u8fdb4\u4e2a\u76f8\u540c\u7684\u76d2\u5b50\u91cc\uff0c\u6709\u51e0\u79cd\u65b9\u6cd5 \uff1f \u516c\u5f0f\uff1a\u7403\u540c\uff0c\u76d2\u540c\uff0c\u4e3a\u7a7a\uff0c\u62c6\u5206\u516c\u5f0f\u3002 P4(8+4)=P4(12) =P1(8)+P2(8)+P3(8)+P4(8) =1+4+(P1(5)+P2(5)+P3(5))+(P1(4)+P2(4)+P3(4)+P4(4)) =1+4+(1+2+(P1(2)+P2(2))+(1+2+1+1) =1+4+5+5 =15 6\u30018\u4e2a\u76f8\u540c\u7684\u7403\u653e\u8fdb4\u4e2a\u4e0d\u540c\u7684\u76d2\u5b50\u91cc\uff0c\u6709\u51e0\u79cd\u65b9\u6cd5\uff1f \u516c\u5f0f\uff1a\u7403\u540c\uff0c\u76d2\u4e0d\u540c\uff0c\u63d2\u677f\u6cd5\u3002 C(11,3) =11 10 9/6=15*11=165 7\u30018\u4e2a\u4e0d\u540c\u7684\u7403\u653e\u8fdb4\u4e2a\u4e0d\u540c\u7684\u76d2\u5b50\u91cc\uff0c\u6709\u51e0\u79cd\u65b9\u6cd5 \uff1f \u516c\u5f0f\uff1a\u7403\u4e0d\u540c\uff0c\u76d2\u4e0d\u540c\uff0c\u4e3a\u7a7a\uff0c\u76f4\u63a5\u662fM^N 4 8=4 4 4 4=2 8 2^8=256*256=65536 8\u30018\u4e2a\u4e0d\u540c\u7684\u7403\u653e\u8fdb4\u4e2a\u76f8\u540c\u7684\u76d2\u5b50\u91cc\uff0c\u6709\u51e0\u79cd\u65b9\u6cd5\uff1f \u516c\u5f0f\uff1a\u7403\u4e0d\u540c\uff0c\u76d2\u540c\uff0c\u4e8c\u7c7b\u65af\u7279\u6797\u6570\uff0c\u4e3a\u7a7a\uff0c\u662f\u7d2f\u52a0 S (N, 1) + S(N, 2) + S(N, 3) + ... + S(N, M) =S\uff088,1)+S\uff088,2)+S\uff088,3)+S\uff088,4) =1+127+966+1701 =2795 9\u30018\u4e2a\u4e0d\u540c\u7684\u7403\u5e73\u5747\u5206\u7ed94\u4e2a\u5c0f\u670b\u53cb\uff0c\u6709\u51e0\u79cd\u5206\u6cd5\uff1f \u4ece8\u4e2a\u7403\u4e2d\u53d62\u4e2a\u5206\u7ed9\u7b2c1\u4e2a\u5c0f\u670b\u53cb\uff0c\u4ece\u5269\u4e0b6\u4e2a\u4e2d\u53d62\u4e2a\u6765\u5206\u7ed9\u7b2c\u4e8c\u4e2a\u5c0f\u670b\u53cb\u3002\u3002\u3002 C(8,2) C(6,2) C(4,2)*C(2,2) = 2520 10\u30018\u4e2a\u4e0d\u540c\u7684\u7403\u5e73\u5747\u5206\u62104\u5806\uff0c\u6709\u51e0\u79cd\u5206\u6cd5\uff1f C(8,2) C(6,2) C(4,2)*C(2,2) / 4!= 2520/24 =105","title":"\u2b50\u653e\u7403\u95ee\u9898"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_35","text":"","title":"\u7ebf\u6027\u4ee3\u6570"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_36","text":"P2962 [USACO09NOV]Lights G \u9898\u610f\uff1a\u7ed9n\u4e2a\u70b9m\u6761\u8fb9\uff0cn\u4e2a\u70b9\u4e00\u5f00\u59cb\u5168\u662f0\uff0c\u6309\u4e0b\u4e00\u4e2a\u70b9\u4f7f\u5f97\u8be5\u70b9\u548c\u5176\u4ed6\u4e0e\u8be5\u70b9\u76f8\u8fde\u7684\u70b9\u7684\u72b6\u6001\u6539\u53d8\uff08\u5f02\u6216\uff09\uff0c\u6c42\u4f7f\u5f97\u6240\u6709\u70b9\u5168\u4e3a1\u7684\u6700\u5c0f\u6309\u4e0b\u6b21\u6570\u3002 \u89e3\uff1a\u6839\u636e\u70b9\u7684\u5173\u7cfb\u5217\u65b9\u7a0b\uff08\u53ea\u662f\u52a0\u6cd5\u6539\u4e3a\u4e58\u6cd5\uff09\uff0c\u7136\u540e\u505a\u9ad8\u65af\u6d88\u5143\uff0cdfs\u6c42\u51fa\u5404\u4e2ax\u4e3a1\u8fd8\u662f\u4e3a0\uff0c\u66f4\u65b0\u7b54\u6848","title":"\u9ad8\u65af\u6d88\u5143"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_37","text":"P2044 [NOI2012]\u968f\u673a\u6570\u751f\u6210\u5668 \u9898\u610f\uff1a\u6c42 $$ X_n\\mod g $$ \u5176\u4e2d $$ X_{n+1}=(aX_n+c)\\mod m $$ \u89e3\uff1a\u8bbe $$ A=\\begin{bmatrix} X_n & a_{11}\\ a_{21} & a_{22} \\end{bmatrix}\\ B=\\begin{bmatrix} b_{11} & b_{11}\\ b_{21} & b_{22} \\end{bmatrix}\\ $$ AB\u4e58\u79ef\u5e94\u8be5\u4ecd\u662fA\u7684\u5f62\u5f0f\uff0c\u53ea\u4e0d\u8fc7X_n\u53d8\u4e3aX_{n+1}=aX_n+c\uff0c\u6839\u636e\u5173\u7cfb\u53ef\u4ee5\u6c42\u51fa\u77e9\u9635\u4e2d\u7684\u5f85\u5b9a\u7cfb\u6570\u4e3a $$ A=\\begin{bmatrix} X_0 & 1\\ 0 & 0 \\end{bmatrix}\\ B=\\begin{bmatrix} a & 0\\ c & 1 \\end{bmatrix}\\ $$ \u5957\u7528\u77e9\u9635\u5feb\u901f\u5e42\uff08\u5176\u4e2d\u4e58\u6cd5\u7528\u5feb\u901f\u4e58\u6cd5\u4ee5\u9632\u6b62\u7206longlong\uff09\u5373\u53ef","title":"\u77e9\u9635\u4f18\u5316"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_38","text":"\u5355\u4f4d\u5143\uff1a0 \u9006\u5143\uff1a \\(x^{-1}=x\\) \u96f6\u5143\uff1a\u4e0d\u5b58\u5728 \u8fd0\u7b97\u5f8b\uff1a\u4ea4\u6362\u5f8b\u3001\u7ed3\u5408\u5f8b \u6709\u5173\u516c\u5f0f\uff1a \\(a\\and b=a|b-a\\oplus b\\) \\(a+b=((a\\&b)<<1 )|(a\\oplus b)\\)","title":"\u5f02\u6216"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_39","text":"\u53ef\u5728\u5bf9\u6570\u65f6\u95f4\u5185\u5b8c\u6210\u63d2\u5165\u3001\u67e5\u8be2\u96c6\u5408\u6700\u5927\u503c\u548c\u6700\u5c0f\u5f02\u6216\u548c\u7684\u64cd\u4f5c\u3002 \u5b8c\u6210\u91cd\u6784\u64cd\u4f5c\u540e\uff08\u82b1\u8d39\u5bf9\u6570\u5e73\u65b9\u7684\u65f6\u95f4\uff09\u53ef\u8f6c\u6362\u4e3a\u5f62\u4f3c\u4e8e\u6700\u7b80\u884c\u9636\u68af\u578b\u77e9\u9635\u7684\u5f62\u5f0f\uff0c\u4e4b\u540e\u53ef\u5728\u5bf9\u6570\u65f6\u95f4\u5185\u67e5\u8be2\u96c6\u5408\u5185\u7b2ck\u5927\u5f02\u6216\u548c\u3002 \u6700\u5927\u503c \uff08restructure\u524d\uff09\u4ece\u5927\u5230\u5c0f\u679a\u4e3e\u6bcf\u4e2a\u6570\u5f02\u6216\u8fdb\u6765\u4f1a\u4e0d\u4f1a\u4f7f\u5f97\u7b54\u6848\u66f4\u5927\uff0c\u5982\u679c\u4f1a\u5c31\u5f02\u6216\u8fdb\u6765\u3002 \u5982\u679c\u9700\u8981\u5728\u5f02\u6216\u521d\u503c\u4e0d\u4e3a\u96f6\u7684\u60c5\u51b5\u4e0b\u53d6\u5f97\u6700\u5927\u503c\uff0c\u53ea\u9700\u8981\u66f4\u6539ans\u7684\u521d\u59cb\u503c\u5373\u53ef\u3002 \u6700\u5c0f\u503c \uff1a \u76f4\u63a5\u8d2a\u5fc3\u62ff\u7ebf\u6027\u57fa\u4e2d\u6700\u5c0f\u7684\u6570\uff08\u5f53\u7136\uff0c\u9700\u8981\u7279\u5224\u7ebf\u6027\u57fa\u662f\u5426\u53ef\u83b7\u5f970\uff09 - HDOJ 3949 \u7b2ck\u5927\u5f02\u6216\u548c \u6a21\u677f\u9898 P4151 \u6700\u5927xor\u8def\u5f84 \u7ed9\u5b9a\u65e0\u5411\u56fe\uff08\u53ef\u80fd\u6709\u91cd\u8fb9\u548c\u81ea\u73af\uff09\uff0c\u6c421\u5230n\u53f7\u70b9\u7684\u6700\u5927xor\u8def\u5f84\u548c\u3002 \u89e3\u6cd5\uff1a\u7531\u4e8e\u5f02\u6216\u7684\u6027\u8d28\uff0c\u6bcf\u6761\u8fb9\u6700\u591a\u8d70\u4e00\u6b21\uff0c\u4e14\u73af\u4e0a\u8f6c\u4e00\u5708\u80fd\u56de\u5230\u539f\u70b9\uff0c\u4ece\u539f\u70b9\u518d\u7ee7\u7eed\u8d70\u5c31\u76f8\u5f53\u4e8e\u767d\u5ad6\u4e86\u73af\u4e0a\u7684\u6743\u503c\u548c\u3002\u56e0\u6b64\u968f\u4fbf\u627e\u4e00\u6761\u4ece1\u5230n\u7684\u8def\u5f84\uff0c\u8fd9\u65f6\u9898\u76ee\u7b49\u4ef7\u4e8e\u9009\u51e0\u4e2a\u7b80\u5355\u73af\u548c\u73b0\u6709\u7b54\u6848\u5f02\u6216\u4f7f\u5f97\u7b54\u6848\u6700\u5927\uff0c\u518d\u7528dfs\u627e\u5230\u56fe\u4e2d\u6240\u6709\u7b80\u5355\u73af\u5e76\u628a\u7b80\u5355\u73af\u7684\u5f02\u6216\u548c\u6dfb\u52a0\u5230\u7ebf\u6027\u57fa\u4e2d\u5373\u53ef\u3002 P4301 \u65b0nim\u6e38\u620f \u5728\u7b2c\u4e00\u4e2a\u56de\u5408\u4e2d\uff0c\u7b2c\u4e00\u4e2a\u6e38\u620f\u8005\u53ef\u4ee5\u76f4\u63a5\u62ff\u8d70\u82e5\u5e72\u4e2a\u6574\u5806\u7684\u706b\u67f4\u3002\u53ef\u4ee5\u4e00\u5806\u90fd\u4e0d\u62ff\uff0c\u4f46\u4e0d\u53ef\u4ee5\u5168\u90e8\u62ff\u8d70\u3002\u7b2c\u4e8c\u56de\u5408\u4e5f\u4e00\u6837\uff0c\u7b2c\u4e8c\u4e2a\u6e38\u620f\u8005\u4e5f\u6709\u8fd9\u6837\u4e00\u6b21\u673a\u4f1a\u3002\u4ece\u7b2c\u4e09\u4e2a\u56de\u5408\uff08\u53c8\u8f6e\u5230\u7b2c\u4e00\u4e2a\u6e38\u620f\u8005\uff09\u5f00\u59cb\uff0c\u89c4\u5219\u548c Nim \u6e38\u620f\u4e00\u6837\u3002 \u5982\u679c\u4f60\u5148\u62ff\uff0c\u600e\u6837\u624d\u80fd\u4fdd\u8bc1\u83b7\u80dc\uff1f\u5982\u679c\u53ef\u4ee5\u83b7\u80dc\u7684\u8bdd\uff0c\u8fd8\u8981\u8ba9\u7b2c\u4e00\u56de\u5408\u62ff\u7684\u706b\u67f4\u603b\u6570\u5c3d\u91cf\u5c0f\u3002 \u89e3\u6cd5\uff1a\u6392\u5e8f\u7136\u540e\u5012\u7740\uff08\u4ece\u5927\u5230\u5c0f\uff09\u63d2\u5165\u7ebf\u6027\u57fa\uff0c\u5982\u679c\u63d2\u5165\u5931\u8d25\u5c31\u7d2f\u52a0\u5230\u7b54\u6848\u4e2d\u3002\uff08\u8fd9\u9898\u4e0d\u53ef\u80fd\u8f93\u51fa-1\uff09 P4869 albus\u5c31\u662f\u8981\u7b2c\u4e00\u4e2a\u51fa\u573a \u7ed9n\u4e2a\u6570ai\u548c\u4e00\u4e2a\u6570q\uff0cn\u4e2a\u6570\u7684\uff08\u591a\u91cd\u96c6\u7684\uff09\u5b50\u96c6\u5f02\u6216\u503c\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\u5f97\u5e8f\u5217b\uff0c\u6c42q\u5728b\u4e2d\u9996\u6b21\u51fa\u73b0\u7684\u4e0b\u6807\u3002 \u89e3\u6cd5\uff1a\u5c06a\u4e2d\u7684\u6570\u5168\u90e8\u63d2\u5165\u7ebf\u6027\u57fa\u5e76restructure\uff0c\u5229\u7528\u4e8c\u5206\u5728\u7ebf\u6027\u57fa\u4e2d\u6c42\u5f97q\u7684\u6392\u540d\uff0c\u663e\u7136q\u5c31\u662fa\u53bb\u91cd\u540e\u5f97\u5230\u7684b'\u7684\u4e0b\u6807\u3002 \u6839\u636e\u201c\u4e0d\u53bb\u91cd\u5f02\u6216\u96c6\u5408\u201d\u7684\u63a8\u8bba\uff0c\u4e0d\u53bb\u91cd\u5f02\u6216\u96c6\u5408\u5f97\u5230\u7684\u5e8f\u5217b'\uff0c\u5e94\u8be5\u662f\u53bb\u91cd\u5f02\u6216\u96c6\u5408b\u4e2d\u7684\u6bcf\u4e2a\u6570\u91cd\u590d \\(2^{n-lb.cnt}\\) \u6b21\u5f97\u5230\u7684\u3002\u56e0\u6b64\u5c06\u521a\u521a\u5f97\u5230\u7684\u4e0b\u6807\u51cf\u53bb1\uff0c\u4e58\u4e0a\u8fd9\u4e2a\u6570\uff0c\u518d\u52a01\uff0c\u5373\u53ef\u5f97\u5230\u7b54\u6848\u3002","title":"\u7ebf\u6027\u57fa"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_40","text":"","title":"\u751f\u6210\u51fd\u6570"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_41","text":"\u5e42\u7ea7\u6570 \uff1a $$ F(x)=\\sum_{n=0}^\\infty a_nx^n $$ \u5982\u679c\u5e8f\u5217a\u6709\u901a\u9879\u516c\u5f0f\uff0c\u90a3\u4e48\u5b83\u7684\u666e\u901a\u751f\u6210\u51fd\u6570\u7684\u7cfb\u6570\u5c31\u662f\u901a\u9879\u516c\u5f0f\u3002\u4f8b\u5982 \\( \\(a=<1,2,4,8,16,...>\\) \\) \u7684\u751f\u6210\u51fd\u6570\u662f \\( \\(\\sum_{n\\ge 0} 2^nx^n\\) \\) \u52a0\u6cd5 \uff1a $$ F(x)\\pm G(x)=\\sum_n (a_n\\pm b_n)x^n $$ \u56e0\u6b64 \\( \\(F(x)\\pm G(x)\\) \\) \u662f\u5e8f\u5217 \\( \\(<a_n\\pm b_n>\\) \\) \u7684\u666e\u901a\u751f\u6210\u51fd\u6570\u3002 \u4e58\u6cd5\uff08\u5377\u79ef\uff09 \uff1a $$ F(x)G(x)=\\sum_n x^n \\sum_{i=0}^na_ib_{n-i} $$ \u56e0\u6b64 \\( \\(F(x)G(x)\\) \\) \u662f\u5e8f\u5217 \\( \\(<\\sum_{i=0}^na_ib_{n-i}>\\) \\) \u7684\u666e\u901a\u751f\u6210\u51fd\u6570\u3002 \u5e38\u7528\u5c55\u5f00 \uff1a \u7b49\u6bd4\u7ea7\u6570 $$ \\frac1{1-x}=\\sum_{n=0}^\\infty x^n\\ \\frac1{1-kx}=\\sum_{n=0}^\\infty k nx n $$ <0,1,1,1,....> $$ F(x)=\\frac x{1-x} $$ \u5076\u6570<1,0,1,0,1,..> $$ F(x)=\\frac 1{1-x^2} $$ \u7b49\u5dee<1,2,3,4,...> $$ F(x)=\\sum_{n\\ge1}nx {n-1}=(\\sum_{n\\ge1}x n)'=(\\frac{1}{1-x})'=\\frac1{(1-x)^2} $$ \u4e8c\u9879\u5f0f \\( \\(a_n=\\binom{m}{n}\\) \\) $$ F(x)=\\sum_{n\\ge0}\\binom{m}{n}x n=(1+x) m $$ \\( \\(a_n=\\binom{m+n}{n}\\) \\) $$ F(x)=\\frac{1}{(1-x)^{m+1}} $$","title":"\u666e\u901a\u751f\u6210\u51fd\u6570"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_42","text":"\u4e24\u79cd\u5c01\u95ed\u5f62\u5f0f\uff08\u7cfb\u6570\u5176\u5b9e\u5c31\u5bf9\u5e94\u901a\u9879\u516c\u5f0f\uff09\uff1a \u5f53 \\( \\(a_0=0,a_1=1\\) \\) \u65f6\uff08\u4f7f\u7528 \\( \\(\\frac{1}{1-kx}\\) \\) \u7684\u7ea7\u6570\u5c55\u5f00\uff09 $$ F(x)=xF(x)+x^2F(x)-a_0x+a_1x+a_0\\ \\Rightarrow F(x)=\\frac{x}{1-x-x^2}=\\frac{\\frac1{\\sqrt5}}{1-\\frac{1+\\sqrt5}{2}x}-\\frac{\\frac1{\\sqrt5}}{1-\\frac{1-\\sqrt5}{2}x}\\ =\\frac1{\\sqrt5}\\sum_{n=0}^\\infty x n((\\frac{1+\\sqrt5}{2}) n-(\\frac{1-\\sqrt5}{2})^n) $$ \u5f53 \\( \\(a_0=1,a_1=1\\) \\) \u65f6 $$ F(x)=\\frac{1}{1-x-x 2}=\\sum_{n\\ge0}x n\\sum_{i=0}^n\\binom{n-i}{i} $$","title":"\u6590\u6ce2\u90a3\u5951\u6570\u5217"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_43","text":"\\[ H_n=\\sum_{i=0}^{n-1}H_iH_{n-i-1}~(n\\ge1)\\\\ H_0=H_1=1 \\] \u751f\u6210\u51fd\u6570 $$ H(x)=\\sum_{n\\ge0}H_nx n=1+x\\sum_{n\\ge1}\\sum_{i=0} H_ix iH_{n-i-1}x \\ =1+x\\sum_{i\\ge0}H_ix i\\sum_{n\\ge0}H_nx n=1+xH(x)^2 $$ \u5f97 $$ H(x)=\\frac{1\\pm\\sqrt{1-4x}}{2x}=\\frac2{1\\mp\\sqrt{1-4x}} $$ \u53c8 \\( \\(H(0)=1\\) \\) \uff0c\u56e0\u6b64\u53d6\u6b63\u6839\uff0c\u5219\u5229\u7528\u725b\u987f\u4e8c\u9879\u5f0f\u5b9a\u7406\u5c55\u5f00 \\( \\(\\sqrt{1-4x}\\) \\) \uff0c\u7136\u540e\u518d\u4ee3\u56de\u53bb\u7ecf\u8fc7\u4e00\u756a\u8fd0\u7b97\u53ef\u5f97 $$ H(x)=\\frac1{2x}\\sum_{n\\ge1}\\binom{2n-1}{n}\\frac1{(2n-1)}2x n=\\cdots=\\sum_{n\\ge0}\\binom{2n}{n}\\frac1{n+1}x n $$ BZOJ \u6709 n \u5806\u7cd6\u679c\u3002\u4e0d\u540c\u7684\u5806\u91cc\u7cd6\u679c\u7684\u79cd\u7c7b\u4e0d\u540c\uff08\u5373\u540c\u4e00\u4e2a\u5806\u91cc\u7684\u7cd6\u679c\u79cd\u7c7b\u662f\u76f8\u540c\u7684\uff0c\u4e0d\u540c\u7684\u5806\u91cc\u7684\u7cd6\u679c\u7684\u79cd\u7c7b\u662f\u4e0d\u540c\u7684\uff09\u3002\u7b2ci\u4e2a\u5806\u91cc\u6709 \u4e2a\u7cd6\u679c\u3002\u73b0\u5728\u8981\u5403\u6389\u81f3\u5c11a\u4e2a\u7cd6\u679c\uff0c\u4f46\u4e0d\u8d85\u8fc7b\u4e2a\u3002\u6c42\u6709\u591a\u5c11\u79cd\u65b9\u6848\u3002 \\[n\\le 10,0\\le a\\le b\\le 10^7,m_i\\le 10^6\\] i\u5806\u5403j\u4e2a\u7684\u751f\u6210\u51fd\u6570 $$ F_i(x)=\\sum_{j=0} {m_i}x j=\\frac{1-x^{m_i+1}}{1-x} $$ \u8003\u8651\u6240\u6709\u5806\u5c31\u662f\u4e58\u8d77\u6765\uff0c\u5bf9\u5e94\u751f\u6210\u51fd\u6570 $$ G(x)=\\prod_{i=1}^n F_i(x)=(1-x) {-n}\\prod_{i=1} n(1-x^{m_i+1}) $$ \u5176\u4e2d $$ \\begin{aligned} (1-x)^{-n} &=\\sum_{i\\ge 0}\\binom{-n}{i}(-x)^i\\ &=\\sum_{i\\ge 0}\\binom{n-1+i}{i}x^i \\end{aligned} $$ \u53f3\u4fa7\u5f0f\u5b50\u5728n\u8f83\u5c0f\u65f6\u80fd\u591f\u66b4\u529b\u5c55\u5f00\uff0c\u8bbe\u5176\u5c55\u5f00\u540e \\( \\(x^k\\) \\) \u5bf9\u5e94\u7cfb\u6570\u4e3a \\( \\(c_k\\) \\) \uff0c\u52191~b\u7684\u7b54\u6848\u4e3a $$ \\sum_{k=0} nc_k\\sum_{i=0} \\binom{n-1+i}{i}=\\sum_{k=0}^nc_k\\binom{n+b-k}{n} $$","title":"\u5361\u7279\u5170\u6570"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_44","text":"\\[ \\hat F(x)=\\sum_{n}a_n\\frac{x^n}{n!} \\] \u52a0\u6cd5 \uff1a\u5bf9\u5e94\u9879\u7cfb\u6570\u76f8\u52a0 \u4e58\u6cd5\uff08\u5377\u79ef\uff09 \uff1a $$ \\hat F(x)\\hat G(x)=\\sum_{i\\ge0}a_i\\frac{x i}{i!}\\sum_{j\\ge0}b_j\\frac{x j}{j!}\\ =\\sum_{n\\ge0}x n\\sum_{i=0} na_ib_{n-i}\\frac1{i!(n-i)!}\\ =\\sum_{n\\ge0}\\frac{x n}{n!}\\sum_{i=0} na_ib_{n-i}\\binom{n}{i} $$ \u56e0\u6b64\u5176\u662f\u5e8f\u5217 \\( \\(<\\sum_{i=0}^n\\binom{n}{i}a_ib_{n-i}>\\) \\) \u7684\u6307\u6570\u751f\u6210\u51fd\u6570 \u5e38\u89c1\u5c55\u5f00 \uff1a \\[<1,1,\\cdots>$$ $$ \\hat F(x)=\\sum_{n\\ge0}\\frac{x^n}{n!}=e^x $$ \u7b49\u6bd4\u6570\u5217$$<1,p,p^2,\\cdots>$$ $$ \\hat F(x)=\\sum_{n\\ge0}p^n\\frac{x^n}{n!}=e^{xp} \\]","title":"\u6307\u6570\u751f\u6210\u51fd\u6570"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_45","text":"n\u4e2a\u9009r\u4e2a\u7684\u5706\u6392\u5217\uff1a\uff08\u5148\u7528\u666e\u901a\u7684\u6392\u5217\uff0c\u7136\u540e\u53bb\u9664\u8f6c1\u30012\u3001...\u3001r\u6b21\u7684\u60c5\u51b5\u5171r\u79cd\uff0c\u56e0\u6b64\u9664\u4ee5r\uff09 $$ Q(n,r)=\\frac{P(n,r)}{r}=\\frac{n!}{r(n-r)!} $$ \u7279\u522b\u5730\uff0cn\u4e2a\u6570\u7684\u5168\u5706\u6392\u5217\u662f(n-1)!\u79cd\u3002 \u751f\u6210\u51fd\u6570\uff08\u5176\u5173\u4e8ee\u7684\u6307\u6570\uff0c\u5c31\u662f\u4e00\u822c\u6392\u5217\u7684\u6307\u6570\u751f\u6210\u51fd\u6570\uff09 $$ \\hat Q(x)=\\sum_{n\\ge1}\\frac{(n-1)!x n}{n!}=\\sum_{n\\ge1}\\frac{x n}{n}=-\\ln(1-x)\\ \\Rightarrow e^{\\hat Q(x)}=\\hat P(x)=\\frac{1}{1-x} $$ \u4e8b\u5b9e\u4e0a\uff0c\u8bbe\u6392\u5217\u6570\u4e3ap(n)\uff0c\u5219\u5176\u53ef\u4ee5\u770b\u6210\u679a\u4e3e\u5176\u7531k\u4e2a\u6362\u6392\u5217\u6784\u6210\u5e76\u6c42\u548c\u5f97\u5230\uff0c\u8bbe \\( \\(q_k(n)\\) \\) \u8868\u793a\u6392\u5217\u7531k\u4e2a\u7f6e\u6362\u7ec4\u6210\u7684\uff0cc(n)\u8868\u793a\u5706\u6392\u5217\u4e2a\u6570 $$ p(n)=\\sum_{k=1}^nq_k(n)\\ \\hat P(x)=\\sum_{n\\ge1}\\sum_{k=1} nq_k(n)\\frac{x n}{n!}=\\sum_{k=1}^n\\hat q_k(x) $$ \\( \\(q_k(n)\\) \\) \u7684\u751f\u6210\u51fd\u6570\u548c \\( \\(c(n)\\) \\) \u7684\u751f\u6210\u51fd\u6570\u6709\u5982\u4e0b\u5173\u7cfb\uff1a \u53c2\u8003\u8bf7\u89c1\u6b64 $$ \\hat q_k(x)=\\frac1{k!}\\hat c(x)^k $$ \u5219 $$ \\hat P(x)=\\sum_{k=1}^n \\frac1{k!}\\hat c(x) k=e $$","title":"\u5706\u6392\u5217"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_46","text":"\u53ef\u4ee5\u770b\u6210\u6ca1\u6709\u957f\u5ea6\u4e3a1\u7684\u73af\u7684\u6392\u5217\uff0c\u56e0\u6b64\u5176\u751f\u6210\u51fd\u6570 $$ \\hat R(x)=\\sum_{n\\ge2}\\frac{x^n}{n}=-\\ln(1-x)-x $$","title":"\u9519\u6392\u6570"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_47","text":"\u53c2\u8003\uff1a https://www.zhihu.com/question/364818496 \u9012\u63a8\u516c\u5f0f \uff1a $$ f_1=1,f_n=f_{n-1}+3n-2 $$ \u901a\u9879\u516c\u5f0f \uff1a $$ f_n=\\frac{n(3n-1)}{2} $$ \u7279\u522b\u5730\u3001\u5bf9\u4e8e\u5e7f\u4e49\u4e94\u8fb9\u5f62\u6570\uff0c\u4e0a\u5f0f\u7684n\uff1an=0,1,-1,2,-2,... $$ F_n=\\frac{n(3n\\pm 1)}{2} $$ \u6b27\u62c9\u51fd\u6570\uff08\u590d\u53d8\u51fd\u6570)\u7684\u5c55\u5f00\u5f0f \uff1a $$ \\phi(q)=\\prod_{k=1} \\infty(1-q k) $$ \u6574\u6570\u5206\u62c6\u7684\u751f\u6210\u51fd\u6570 \uff1a $$ G(x)=\\sum_{n=0}^\\infty p(n)x n=\\prod_{i=1} \\infty(\\frac{1}{1-x^i}) $$ \u4e5f\u5373\u6b27\u62c9\u51fd\u6570\u7684\u5012\u6570\u3002","title":"\u4e94\u8fb9\u5f62\u6570\u3001\u6574\u6570\u5206\u62c6"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_48","text":"","title":"\u7fa4\u8bba"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_49","text":"\u82e5\u96c6\u5408S\uff08\u975e\u7a7a\uff09 \u548cS \u4e0a\u7684\u8fd0\u7b97*\u6784\u6210\u7684\u4ee3\u6570\u7ed3\u6784(S,*)\u6ee1\u8db3\u4ee5\u4e0b\u6027\u8d28\uff1a \u5c01\u95ed\u6027\uff1a $$ \\forall a,b \\in S, a\\cdot b\\in S $$ \u7ed3\u5408\u5f8b\uff1a $$ \\forall a,b,c \\in S,(a\\cdot b)\\cdot c=a\\cdot(b\\cdot c) $$ \u5355\u4f4d\u5143\uff1a $$ \\exist e\\in S,\\forall a\\in S,e\\cdot a=a\\cdot e=a $$ \u9006\u5143\uff1a $$ \\forall a\\in S,\\exist b\\in S,a\\cdot b=b\\cdot a=e $$ \u79f0b\u4e3aa\u7684\u9006\u5143\uff0c\u8bb0\u4e3a(a)^(-1) \u5219\u79f0(S,*) \u4e3a\u4e00\u4e2a \u7fa4 \u3002\u4f8b\u5982\uff0c\u6574\u6570\u96c6\u548c\u6574\u6570\u95f4\u7684\u52a0\u6cd5 \u6784\u6210\u4e00\u4e2a\u7fa4\uff0c\u5355\u4f4d\u5143\u662f 0\uff0c\u4e00\u4e2a\u6574\u6570\u7684\u9006\u5143\u662f\u5b83\u7684\u76f8\u53cd\u6570\u3002 \u5b50\u7fa4\uff1a(T,*)\uff0cT\u662fS\u7684\u975e\u7a7a\u5b50\u96c6 \u7531\u4e8e\u6709\u7ed3\u5408\u5f8b\uff0c\u56e0\u6b64\u5bf9\u4e8e\u8be5\u8fd0\u7b97\u53ef\u4ee5\u4f7f\u7528\u5feb\u901f\u5e42","title":"\u7fa4\u3001\u5b50\u7fa4"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_50","text":"\u628a\u96c6\u5408\u4e2d\u7684\u5143\u7d20\u6253\u4e71\u4f4d\u7f6e $$ f=\\begin{pmatrix} a_1,\\cdots,a_n\\ a_{p_1},\\cdots,a_{p_n}\\ \\end{pmatrix} $$ \u7f6e\u6362\u8fd0\u7b97\u4e5f\u6ee1\u8db3\u7fa4\u7684\u8fd0\u7b97\u7684\u6027\u8d28\uff1a\u5c01\u95ed\u6027\uff08\u7f6e\u6362\u540e\u5143\u7d20\u4ecd\u5728\u96c6\u5408\u5185\uff09\u3001\u7ed3\u5408\u5f8b\uff08\u7f6e\u6362\u4e58\u6cd5\uff09\u3001\u5355\u4f4d\u5143\uff08\u6052\u7b49\u7f6e\u6362\uff0c\u7f6e\u6362\u540e\u4f4d\u7f6e\u4e0d\u53d8\uff09\u3001\u9006\u5143\uff08\u7f6e\u6362\u7684\u53cd\u5411\u64cd\u4f5c\uff09 \u7f6e\u6362\u7684\u4e58\u6cd5\uff1a $$ f=\\begin{pmatrix} a_1,\\cdots,a_n\\ a_{p_1},\\cdots,a_{p_n}\\ \\end{pmatrix}\\ g=\\begin{pmatrix} a_{p_1},\\cdots,a_{p_n}\\ a_{q_1},\\cdots,a_{q_n}\\ \\end{pmatrix}\\ f\\circ g=\\begin{pmatrix} a_1,\\cdots,a_n\\ a_{q_1},\\cdots,a_{q_n}\\ \\end{pmatrix} $$","title":"\u7f6e\u6362\u7fa4"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_51","text":"\\[ (a_1,\\cdots,a_m)=\\begin{pmatrix} a_1,a_2,\\cdots,a_n\\\\ a_n,a_1,\\cdots,a_{n-1} \\end{pmatrix} \\] \u4e24\u4e2a\u5faa\u73af\u7f6e\u6362\u4e0d\u542b\u6709\u76f8\u540c\u7684\u5143\u7d20\uff0c\u5219\u79f0\u5b83\u4eec\u662f \u4e0d\u76f8\u4ea4 \u7684\u3002 \u4efb\u610f\u4e00\u4e2a\u7f6e\u6362\u90fd\u53ef\u4ee5\u5206\u89e3\u4e3a\u82e5\u5e72\u4e0d\u76f8\u4ea4\u7684\u5faa\u73af\u7f6e\u6362\u7684\u4e58\u79ef\u3002 \uff08\u5982\u679c\u628a\u5143\u7d20\u89c6\u4e3a\u56fe\u7684\u8282\u70b9\uff0c\u6620\u5c04\u5173\u7cfb\u89c6\u4e3a\u6709\u5411\u8fb9\uff0c\u5219\u6bcf\u4e2a\u8282\u70b9\u7684\u5165\u5ea6\u548c\u51fa\u5ea6\u90fd\u4e3a 1\uff0c\u56e0\u6b64\u5f62\u6210\u7684\u56fe\u5f62\u5fc5\u5b9a\u662f\u82e5\u5e72\u4e2a\u73af\u7684\u96c6\u5408\uff0c\u800c\u4e00\u4e2a\u73af\u5373\u53ef\u7528\u4e00\u4e2a\u5faa\u73af\u7f6e\u6362\u8868\u793a\u3002\uff09","title":"\u5faa\u73af\u7f6e\u6362"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#burnside-polya","text":"Burside\u5f15\u7406\uff1a $$ |X/G|=\\frac{1}{|G|}\\sum_{g\\in G}|X^g|\\ X^g={x|x\\in X,g(x)=x} $$ Polya\u5b9a\u7406\uff1a $$ |X/G|=\\frac{1}{|G|}\\sum_{g\\in G}|B|^{c(g)} $$ \u5176\u4e2d \\(c(g)\\) \u662f\u7f6e\u6362g\u80fd\u62c6\u5206\u6210\u7684\u4e0d\u76f8\u4ea4\u5faa\u73af\u7f6e\u6362\u6570\u91cf\u3002 \u5bf9\u4e8e\u65cb\u8f6c\uff1a\u5047\u8bbe\u65cb\u8f6c\u4e86k\u4e0b\uff0c\u5219\u5faa\u73af\u7f6e\u6362\u6570\u91cf\u662f $$ c(g)=\\gcd(n,k) $$ \u5bf9\u4e8e\u7ffb\u8f6c\uff1a $$ c(g)=\\frac{n}{2}+[n\\%2==1] $$ P4980 Polya\u5b9a\u7406\u6a21\u7248 $$ ans=\\frac{\\sum_{k=1}^n\\gcd(n,k)}{n}=\\sum_{d|n}\\phi(d)\\cdot n^{n/d-1} $$ \uff08\u7136\u800c\u8fd9\u9898\u7684\u6b27\u62c9\u51fd\u6570\u5c45\u7136\u80fd\u66b4\u529b\u6c42\u2026\u2026\u771f\u662f\u89c1\u9b3c\uff09","title":"Burnside\u5f15\u7406 \u548c Polya\u5b9a\u7406"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_52","text":"\u6b27\u62c9\u516c\u5f0f \uff1a $$ e^{\\theta i}=\\cos\\theta+i\\sin\\theta $$ \u7cfb\u6570\u8868\u793a\u6cd5\u3001\u70b9\u503c\u8868\u793a\u6cd5 \uff1a \u4f7f\u7528n+1\u4e2a\u70b9\u8868\u793a\u591a\u9879\u5f0f $$ f(x)={(x_0,f(x_0)),\\cdots,(x_n,f(x_n))} $$","title":"\u591a\u9879\u5f0f"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#fft","text":"\u79bb\u6563\u5085\u91cc\u53f6\u53d8\u6362 (Discrete Fourier Transform)\uff1a\u7cfb\u6570\u8868\u793a\u6cd5\u8f6c\u4e3a\u70b9\u503c\u8868\u793a\u6cd5\u3002 \u2026\u2026\u9006\u53d8\u6362 \uff1a\u70b9\u503c->\u7cfb\u6570","title":"\u5feb\u901f\u5085\u7acb\u53f6\u53d8\u6362\uff08FFT\uff09"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_53","text":"\\[ \\vec c=\\vec a \\otimes \\vec b \\] \u5176\u4e2d\u5411\u91cf\u8868\u793a\u591a\u9879\u5f0f\uff0c\u4e14 $$ c_i=\\sum_{j=0}^ia_jb_{i-j} $$ \u5229\u7528\u70b9\u503c\u8868\u793a\u6cd5\u5c06\u70b9\u503c\u76f8\u4e58\u518d\u8f6c\u6362\u4e3a\u7cfb\u6570\u8868\u793a\u6cd5\u4e5f\u53ef\u4ee5\u8ba1\u7b97\u5377\u79ef\uff08On\u7684\u65f6\u95f4\u590d\u6742\u5ea6\uff09\u3002\u56e0\u6b64\u74f6\u9888\u5728\u4e8e\u70b9\u503c\u8868\u793a\u6cd5\u4e0e\u7cfb\u6570\u8868\u793a\u6cd5\u7684\u8f6c\u6362\u3002 \u5c06xi\u53d6\u7279\u5b9a\u7684\u503c\uff0c \\(x_i=\\omega_i^{[n]}=\\omega_n^i\\) \uff0c\u5219\u53ef\u6839\u636e\u67d0\u4e9b\u7279\u6b8a\u6027\u8d28\u5728nlogn\u65f6\u95f4\u5185\u8fdb\u884c\u5feb\u901f\u5085\u7acb\u53f6\u53d8\u6362\uff0c\u5bf9\u591a\u9879\u5f0f\u8fdb\u884c\u6c42\u503c\u548c\u5bf9\u70b9\u96c6\u8fdb\u884c\u63d2\u503c\u3002","title":"\u5377\u79ef"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_54","text":"\u590d\u6570\u610f\u4e49\u4e0b\uff0c\u4e0b\u9762\u65b9\u7a0b\u7684\u89e3\u662fn\u6b21\u590d\u6839 $$ x^n=1 \\Rightarrow (\\omega_n)^n=1 $$ \uff08n\u6b21\uff09\u5355\u4f4d\u590d\u6839\uff1a\u628a\u590d\u5e73\u9762\u5355\u4f4d\u5143\u5206\u6210n\u4efd\uff0c\u7b2c\u4e00\u4e2a\u89d2\u5bf9\u5e94\u7684\u590d\u6570\u5411\u91cf $$ \\omega_n=e^{\\frac{2\\pi i}{n}}\\ {\\omega_n^k|k=0,1,\\cdots,n-1} $$ \\(w_n^0=1\\) \u6027\u8d28 \uff1a $$ w_n^n=1\\ w_n k=w_{2n} \\ w_{2n} {k+n}=-w_{2n} k $$ \u5b9a\u7406 1\uff1a \u5982\u679c \\(a=b\\pmod n\\) \uff0c\u5219 $$ w_n a=w_n b $$ \u8bc1\u660e\uff1a\u5728\u590d\u5e73\u9762\u4e0a\u770b\u5355\u4f4d\u590d\u6839\u5bb9\u6613\u770b\u51fa\u5b9a\u7406\u7684\u53d9\u8ff0\u662f\u6b63\u786e\u7684 \u5b9a\u74062 \uff1a\uff08\u76f8\u6d88\u5b9a\u7406\uff09 $$ \\omega_{dn} {dk}=\\omega_{n} k~(\\text{for }d>0) $$ \u5728\u590d\u5e73\u9762\u4e0a\u4e5f\u5bb9\u6613\u770b\u51fa\u5176\u6b63\u786e\u6027\u3002 \u5b9a\u74062\u7684\u63a8\u8bba \uff1a $$ \\omega_n {n/2}=\\omega_{2} 1=-1~(n>0,n\\text{ is even}) $$ \u5b9a\u74063 \uff1a\uff08\u6298\u534a\u5b9a\u7406\uff09 $$ \\omega_{n} {n/2+k}=-\\omega_n k $$","title":"\u5355\u4f4d\u590d\u6839"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_55","text":"\u5f53 \\(x_k=\\omega_n^k\\) \u65f6\uff08n\u662f\u591a\u9879\u5f0fA\u7684\u6b21\u6570\uff0ck=0~n-1\uff09\u5e26\u5165\u591a\u9879\u5f0fA\u5f97\u5230\u5404\u9879 \\(y_k=A(\\omega_n^k)=\\sum_{i=0}^{n-1}a_i(\\omega_n^k)^i\\) \uff0c\u591a\u9879\u5f0f\u503c\u5411\u91cf\uff08\u70b9\u503c\u8868\u793a\u6cd5\uff09 \\(\\vec y=(y_0,\\cdots,y_{n-1})\\) \u5c31\u88ab\u79f0\u4e3a\u7cfb\u6570\u5411\u91cfa\uff08\u7cfb\u6570\u8868\u793a\u6cd5\uff09\u7684\u79bb\u6563\u5085\u7acb\u53f6\u53d8\u6362\uff0c\u8bb0\u4e3a $$ \\vec y=\\text{DFT}_n(\\vec a) $$","title":"\u79bb\u6563\u5085\u7acb\u53f6\u53d8\u6362"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_56","text":"\u6839\u636e\u503c\u5411\u91cfy\u6c42\u51fa\u7cfb\u6570\u5411\u91cf\uff1a $$ \\vec a=\\text{DFT}^{-1}_n(\\vec y) $$","title":"\u79bb\u6563\u5085\u7acb\u53f6\u9006\u53d8\u6362"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_57","text":"a\u3001b\u662f\u7cfb\u6570\u5411\u91cf\uff08\u957f\u5ea6\u4e3an\uff0c\u6700\u9ad8\u6b21\u4e3an\uff09\uff0c\u5219\u5377\u79efc\uff08\u4e5f\u662f\u7cfb\u6570\u5411\u91cf\uff09 $$ \\vec c=DFT_{2n}^{-1}(DFT_{2n}(\\vec a)\\cdot DFT_{2n}(\\vec b)) $$ \u5176\u4e2d\ud835\udc5b\u4e3a2\u7684\u5e42\u6b21\uff0c\u4e0d\u8db3\u7684\u75280\u8865\u3002\u4e2d\u95f4\u7684\u4e58\u53f7\u8868\u793a\u4e24\u4e2a\u5411\u91cf\u7684\u70b9\u4e58\u3002","title":"\u5377\u79ef\u5b9a\u7406"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_58","text":"\u5feb\u901f\u5c06\u7cfb\u6570\u8868\u793a\u6cd5\u8f6c\u6362\u4e3a\u70b9\u503c\u8868\u793a\u6cd5\u3002 \u4e00\u4e2an\u9636\u591a\u9879\u5f0f\u53ef\u4ee5\u88ab\u62c6\u6210\u4e24\u90e8\u5206\uff08\u5076\u6570\u9879\u7cfb\u6570\u62ff\u51fa\u6765\uff0c\u642d\u914d\u65b0\u7684 \\(x^0\\text~x^{n-1}\\) \uff0c\u6210\u4e3a\u4e00\u4e2a\u65b0\u591a\u9879\u5f0f\uff1b\u5947\u6570\u9879\u7cfb\u6570\u62ff\u51fa\u6765\u6210\u4e3a\u53e6\u4e00\u4e2a\u65b0\u591a\u9879\u5f0f\uff09\uff1a $$ A(x)=A {[0]}(x 2)+xA {[1]}(x 2)\\ A {[0]}(x)=a_0+a_2x+\\cdots+a_{n-2}x \\ A {[1]}(x)=a_1+a_3x+\\cdots+a_{n-1}x \\ $$ \uff08\u6ce8\u610f\u8fd9\u91cc\u5f97\u5e26\u5165x^2\uff0c\u8fd9\u6837\u624d\u9f50\u6b21\uff09 \u7531\u8fd9\u4e24\u4e2a\u591a\u9879\u5f0f\u5f97\u5230\u7684\u79bb\u6563\u5085\u7acb\u53f6\u53d8\u6362\u7684\u7ed3\u679c\uff08\u70b9\u503c\u8868\u793a\u6cd5\u76f8\u91cf\uff09\u662f \\[ \\vec y^{[0]}=DFT_{n/2}(a_0,\\cdots,a_{n-2})\\\\ \\vec y^{[1]}=DFT_{n/2}(a_1,\\cdots,a_{n-1})\\\\ \\vec y=DFT_{n}(a_0,a_1,\\cdots,a_{n-1}) \\] \u5219\u8fd9\u4e24\u4e2a\u76f8\u91cf\u7684\u5404\u9879\u7cfb\u6570\u662f \\[ y_k^{[0]}=A^{[0]}(\\omega^k_{n/2})=A^{[0]}((\\omega^{k}_{n})^2)\\\\ y_k^{[1]}=A^{[1]}(\\omega^k_{n/2})=A^{[1]}((\\omega^{k}_{n})^2) \\] \u90a3\u4e48\u6700\u7ec8\u7ed3\u679c\uff08\u4e4b\u6240\u4ee5\u5206\u6210\u4e24\u90e8\u5206\u662f\u56e0\u4e3ay\u76f8\u91cf\u7684\u4e0b\u6807\u5927\u5c0f\u662f \\(y^{[0]},y^{[1]}\\) \u7684\u4e24\u500d\uff0c\u56e0\u6b64\u5728\u5206\u6cbb\u5b8c\u6210\u540e\u8f6c\u79fb\u65f6\u53ea\u9700\u8981\u679a\u4e3ek\uff1a0~n/2-1\u5373\u53ef\uff09\uff1a \\[ y_k=A(\\omega_n^k)=A^{[0]}((\\omega_n^k)^2)+A^{[1]}((\\omega_n^k)^2)\\omega^k_n=y^{[0]}_k+y^{[1]}_k\\omega_n^k\\\\ y_{k+n/2}=A(\\omega^{k+n/2}_n)=A^{[0]}((\\omega_n^{k+n/2})^2)+A^{[1]}((\\omega_n^{k+n/2})^2)\\omega^{k+n/2}_n\\\\ =A^{[0]}((\\omega_n^{k+n/2})^2)-A^{[1]}((\\omega_n^{k+n/2})^2)\\omega^{k}_n=y^{[0]}_k-y^{[1]}_k\\omega_n^k \\] \u5b9e\u9645\u5b9e\u73b0\u65f6\uff0c\u9700\u8981\u5148\u5c06\u591a\u9879\u5f0f\u957f\u5ea6\u8865\u5168\u52302\u7684\u5e42\u6b21\u3002","title":"\u5feb\u901f\u5085\u7acb\u53f6\u53d8\u6362"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#ifft","text":"\u53ef\u4ee5\u8bc1\u660e\uff1a $$ a_i=\\frac1n\\sum_{i=0} {n-1}y_i(\\omega_n )^i $$ \u5176\u4e2dai\u662f\u7cfb\u6570\u8868\u793a\u6cd5\u7684\u7cfb\u6570\uff0cyi\u662f\u70b9\u503c\u8868\u793a\u6cd5\u7684\u7cfb\u6570\u3002\u8fd9\u548c\u5904\u7406FFT\u662f\u4e00\u6837\u7684\u5f62\u5f0f\u3002\uff08\u4e5f\u5373\uff0c\u77e9\u9635 \\(Y=\\Omega A\\) \u4e2d\uff0cOmega\uff08\u7cfb\u6570\u77e9\u9635\uff09\u7684\u9006\u77e9\u9635\u662f\u6bcf\u4e00\u9879\u53d6\u5012\u6570\uff0c\u7136\u540e\u518d\u9664\u4ee5n\uff08\u4e5f\u5373\u591a\u9879\u5f0f\u957f\u5ea6\uff09\uff09 \u53c8\u56e0\u4e3a $$ \\frac{1}{\\omega_n}=\\omega_n^{-1} $$ \u5c06FFT\u8fc7\u7a0b\u4e2d\u7684pi\u6539\u4e3a-pi\u5c31\u662f\u5728\u505aIFFT\u4e86\u3002\u6700\u540e\u6c42\u5f97\u7684\u7cfb\u6570\u5168\u90e8\u9664\u4ee5n\uff08\u591a\u9879\u5f0f\u957f\u5ea6\uff09\u3002","title":"\u5feb\u901f\u5085\u7acb\u53f6\u9006\u53d8\u6362\uff08IFFT\uff09"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_59","text":"\u5206\u6cbb\u8fc7\u7a0b\u4e2d\u7cfb\u6570\u7684\u4e0b\u6807\u53d8\u6362\u6709\u5982\u4e0b\u89c4\u5f8b\uff1a $$ 1:01234567\\ 2:02461357\\ 3:04261357\\ 4:04261537 $$ \u4e5f\u5373\u4e0b\u4e00\u6b65\u7684\u4e0b\u6807\u5728\u4e8c\u8fdb\u5236\u4e0b\u7684\u53cd\u8f6c\u503c\u4f1a\u6210\u4e3a\u8fd9\u4e00\u6b65\u7684\u4e0b\u6807\u3002 \u9012\u63a8\u5b9e\u73b0\uff1a( https://oi-wiki.org/math/poly/fft/#_8 ) $$ R(0)=0\\ R(x)=\\lfloor\\frac{R(\\lfloor\\frac{x}{2}\\rfloor)}{2}\\rfloor+(x\\mod 2)\\frac{len}{2} $$ 1 2 3 4 5 6 7 8 9 10 11 12 void pre_rev ( int len ) { rev [ 0 ] = 0 ; for ( int i = 1 ; i <= len ; i ++ ) { rev [ i ] = rev [ i >> 1 ] >> 1 ; if ( i & 1 ) { rev [ i ] |= len >> 1 ; } } } SP8372 TSUM - Triple Sums \u9898\u610f\uff1an\u4e2a\u6570\uff0c\u4efb\u53d6\u4e09\u4e2a\u52a0\u8d77\u6765\uff08\u8981\u6c42\u4e0b\u6807i<j<k\uff09\uff0c\u95ee\u6bcf\u4e2a\u53ef\u80fd\u7684\u7ed3\u679c\u7684\u65b9\u6848\u6570\uff08\u503c\u57df\u7edd\u5bf9\u503c20000\uff0cN\u572840000\u5185\uff09\u3002 https://www.cnblogs.com/SuuT/p/9584925.html \u89e3\u6cd5\uff1a\u8bbeA(x)\u662f\u4e0d\u8003\u8651\u987a\u5e8f\u7684\u9009\u6cd5\u7684\u9009\u4e00\u4e2a\u7684\u751f\u6210\u51fd\u6570\uff0c\u5219A(x 2)\u5c31\u662f\u9009\u4e24\u4e2a\u4e00\u6837\u7684\u751f\u6210\u51fd\u6570\uff0cA(x 3)\u5c31\u662f\u9009\u4e09\u4e2a\u4e00\u6837\u7684\u751f\u6210\u51fd\u6570\uff08\u5747\u662f\u4e0d\u8003\u8651\u987a\u5e8f\u7684\uff09 \u8003\u8651\u5bb9\u65a5\u539f\u7406\u628a\u9009\u5230\u76f8\u540c\u7684\u4e0b\u6807\u7684\u60c5\u51b5\u7ed9\u6392\u9664\u6389\uff0c\u5219\u4e0b\u9762\u7684\u5f0f\u5b50\u5c31\u662f\u7b5b\u6389\u4e4b\u540e\u7684\u751f\u6210\u51fd\u6570\uff1a\u51cf\u53bb\u6709\u4e24\u79cd\u76f8\u540c\u7684\u9009\u6cd5\u7684\u751f\u6210\u51fd\u6570\uff0c\u518d\u52a0\u56de\u591a\u51cf\u53bb\u7684\u4e09\u79cd\u76f8\u540c\u7684\u9009\u6cd5\u7684\u751f\u6210\u51fd\u6570 $$ A 3(x)-3A(x 2)A(x)+2A(x^3) $$ \u7531\u4e8ei<j<k\uff0c\u56e0\u6b64\u8fd8\u8981\u9664\u4ee56\u6765\u7b5b\u6389\u5176\u4ed6\u91cd\u590d\u7684\u60c5\u51b5\uff08\u663e\u7136\u67093*2*1\u79cd\u53ef\u80fd\uff09 \u5b9e\u73b0\u65f6\u7531\u4e8e\u6709\u8d1f\u6570\u5b58\u5728\uff0c\u9700\u8981\u6574\u4f53\u5c06\u8bfb\u5165\u7684\u5e8f\u5217\u79fb\u52a82e4\uff0c\u6700\u540e\u8981\u53cd\u5411\u79fb\u52a86e4\uff08\u56e0\u4e3a\u6700\u7ec8\u5f0f\u5b50\u662f3\u6b21\u5f0f\uff1f\uff09 UVA12633 Super Rooks on Chessboard \u9898\u76ee\u5927\u610f\uff1a\u7ed9\u4f60\u4e00\u5f20\u7f51\u683c\uff0c\u4e0a\u9762\u6709\u5f88\u591a\u9a91\u58eb\uff0c\u6bcf\u4e2a\u9a91\u58eb\u80fd\u6a2a\u7740\u7ad6\u7740\u659c\u7740\u653b\u51fb\u4e00\u6761\u76f4\u7ebf\u4e0a\u7684\u683c\u5b50\uff0c\u6c42\u6ca1\u88ab\u653b\u51fb\u7684\u683c\u5b50\u7684\u6570\u91cf\u603b\u548c\uff08R C D\u5c0f\u4e8e50000\uff09 https://blog.csdn.net/u013368721/article/details/45367249 \u89e3\u6cd5\uff1a\u5148\u8ba1\u7b97\u51fa\u4e0d\u8003\u8651\u659c\u65b9\u5411\u7684\u60c5\u51b5\uff0c\u8fd9\u65f6\u5019\u7b54\u6848\u5c31\u662f\u6ca1\u8f66\u7684\u884c\u4e58\u4ee5\u6ca1\u8f66\u7684\u5217\u7684\u6570\u91cf\u3002 \u8003\u8651\u659c\u65b9\u5411\uff0c\u6211\u4eec\u5c31\u8981\u5254\u9664\u6389\u4f1a\u88ab\u659c\u65b9\u5411\u5360\u636e\u7684\u60c5\u51b5\u3002\u8bbe\u591a\u9879\u5f0fR(x)\u8868\u793a\u6ca1\u88ab\u5360\u636e\u7684\u884c\u53f7\u7684\u751f\u6210\u51fd\u6570\uff0cC(x)\u8868\u793a\u6ca1\u88ab\u5360\u636e\u7684\u5217\u53f7\u7684\u751f\u6210\u51fd\u6570\u3002\uff08\u884c\u53f7\u4ece\u4e0a\u5230\u4e0b\u589e\u5927\uff0c\u5217\u53f7\u4ece\u5de6\u5230\u53f3\u589e\u5927\uff0c\u4ece0\u5f00\u59cb\u8ba1\u6570\uff09 $$ R(x)=\\sum_{i=1} {cnt}x \\ C(x)=\\sum_{i=1} {cnt2}x \\ $$ \u8fd9\u65f6\u5c31\u662f\u8981\u6570 \\(r_i-c_j=d_k\\) \u7684i\u3001j\u3001k\u6570\u91cf\uff0c\u4e5f\u5c31\u662f \\((R\\cdot C)(x)\\) \u4e2d \\(x^{d_k}\\) \u7684\u7cfb\u6570\u3002\uff08\u5176\u4e2dri\u3001cj\u3001dk\u662f\u6ca1\u6709\u8f66\u7684\u884c\u53f7\u4e0e\u5217\u53f7\u7684\u96c6\u5408\u4ee5\u53ca\u6709\u8f66\u7684\u5bf9\u89d2\u7ebf\u7684\u96c6\u5408\uff09 \u5177\u4f53\u5b9e\u73b0\u65f6\uff0c\u7531\u4e8e-ci\u662f\u8d1f\u6570\u4e0d\u597d\u5904\u7406\uff0c\u4e8e\u662f\u6574\u4f53\u504f\u79fbC\uff08\u9898\u76ee\u7ed9\u51fa\u7684\u5217\u6570\uff09\uff0cd\u8fd9\u4e2a\u96c6\u5408\u7684\u4e0b\u6807\u4e5f\u6574\u4f53\u504f\u79fbC\u90a3\u4e48\u591a\uff0c\u6700\u540e\u8ba1\u6570\u7684\u65f6\u5019\u76f4\u63a5\u51cf\u53bb\u7cfb\u6570\u4e58\u4ee5[\u90a3\u4e00\u5bf9\u89d2\u7ebf\u662f\u5426\u6709\u8f66]\u5373\u53ef\u3002 HDOJ4609 3-idiots \u9898\u610f\uff1a\u7ed9\u51fan\u4e2a\u6570\uff08\u53ef\u80fd\u76f8\u540c\uff0c\u503c\u57df1~1e5\uff09\uff0c\u4efb\u90093\u4e2a\uff0c\u95ee\u80fd\u591f\u6784\u6210\u4e09\u89d2\u5f62\u7684\u6982\u7387\u3002 https://blog.csdn.net/Maxwei_wzj/article/details/79329154 \u89e3\u6cd5\uff1a\u8bbeA(x)\u4e3a\u4efb\u610f\u90091\u4e2a\u5f97\u5230\u7684\u6570\u7684\u548c\u7684\u751f\u6210\u51fd\u6570\uff0c\u5219 $$ G(x)=\\frac{A(x) 2-A(x 2)}{2} $$ \u8fd9\u4e2a\u662f\u5728\u6392\u5e8f\u540e\u9009\u4e24\u4e2a\u6709\u5e8f\u6570\u5bf9\u6784\u6210\u7684\u548c\u7684\u9009\u6cd5\u6570\u91cf\u7684\u751f\u6210\u51fd\u6570\u3002 \u76f4\u63a5\u53bb\u8003\u8651\u80fd\u6709\u591a\u5c11\u4e2a\u6709\u5e8f\u6570\u5bf9i\u3001j\u3001k\u6ee1\u8db3 \\(A_i+A_j>A_k\\) \u4e14 \\(A_i\\le A_j\\le A_k\\) \u4f1a\u5b58\u5728\u56f0\u96be\uff08\u56e0\u4e3a\u76f4\u63a5\u5957\u7528\u4e0a\u9762\u7684\u751f\u6210\u51fd\u6570\u7684\u7ed3\u679c\u7684\u540e\u7f00\u548c\u662f\u4e0d\u80fd\u4fdd\u8bc1\u540e\u9762\u7684\u6761\u4ef6\u6ee1\u8db3\u7684\uff09\uff0c\u4e8e\u662f\u6211\u4eec\u53cd\u8fc7\u6765\u8003\u8651\u62a0\u6389 \\(A_i+A_j\\le A_k\\) \uff0c\u8fd9\u6837\u5728\u6392\u5e8f\u540e\uff0c\u540e\u8005\u7684\u6761\u4ef6\u81ea\u7136\u6ee1\u8db3\u3002 \u679a\u4e3eAk\u7684\u503c\uff0c\u7136\u540e\u5206\u4e09\u7c7b\u60c5\u51b5\u7edf\u8ba1\u7b54\u6848\uff08tempsum\u662f\u5c0f\u4e8eAk\u7684\u503c\u7684\u6570\u91cf\uff0ctempsum2\u662f\u5c0f\u4e8e\u7b49\u4e8eAk\u7684\u751f\u6210\u51fd\u6570\u7684\u503c\u7684\u7cfb\u6570\u548c\uff0ccnt_i\u662f\u7b49\u4e8ei\u7684\u6570\u7684\u6570\u91cf\uff09\uff1a \\(A_i\\le A_j \\lt A_k\\) \uff1a\u7b54\u6848\u7d2f\u52a0\u4e0a ans+=(tempsum*(tempsum-1)/2-tempsum2)*cnt[i]; \\(A_i\\lt A_j = A_k\\) \uff1a ans+=tempsum*cnt[i]*(cnt[i]-1)/2; \\(A_i\\lt A_j = A_k\\) \uff1a ans+=cnt[i]*(cnt[i]-1)*(cnt[i]-2)/6;","title":"\u8774\u8776\u53d8\u6362"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#number-theoretic-transform","text":"FFT\u4e4b\u6240\u4ee5\u8981\u5f15\u5165\u590d\u6570\uff0c\u662f\u56e0\u4e3a\u5355\u4f4d\u5143\u6839\u6ee1\u8db3\u5faa\u73af\u7fa4\u7684\u6027\u8d28\uff1a $$ {1,\\omega,\\omega 2,\\cdots,\\omega } $$ \u8fd9\u4e2a\u7fa4\u662f \\(2^K\\) \u9636\u5faa\u73af\u7fa4\u3002\u800c\u5728\u5b9e\u6570\u8303\u56f4\u5185\u627e\u4e0d\u5230\u8fd9\u6837\u7684\u5faa\u73af\u7fa4\u3002 \u53c2\u8003\uff1a https://zhuanlan.zhihu.com/p/166197713 \u5728mod p\u610f\u4e49\u4e0b\uff0cp\u7684\u539f\u6839\u5c31\u6070\u597d\u548c\u521a\u521a\u7684\u5355\u4f4d\u5143\u6839\u4e00\u6837\u5177\u6709\u76f8\u540c\u7684\u6027\u8d28\u3002 \u4ee4g\u662fp\uff08\u8d28\u6570\uff09\u7684\u539f\u6839\uff0c\u4ee4 \\(g_N=g^{\\frac{p-1}{N}}~(N|p-1)\\) \uff0c\u5219\uff1a $$ g_N N=g =1 \\pmod p\\ g_{N} {N/2}=g \\frac{p-1}{2}=-1 \\pmod p $$ \\(g^{\\frac{p-1}{2}}\\) \u662f-1\u53ef\u7531\u539f\u6839\u7684\u6027\u8d28+\u4e8c\u6b21\u63a2\u6d4b\u5b9a\u7406\u8bc1\u660e\u5145\u5206\u5fc5\u8981\u6761\u4ef6\u3002 \u4ece\u8fd9\u91cc\u53ef\u4ee5\u77e5\u9053\uff0c\u4e0b\u9762\u7684\u7fa4\u7684\u9636\u6570\u5c31\u662fN-1\uff1a $$ {g,g 2,\\cdots,g =1} $$ \u5173\u952e\u95ee\u9898\u5c31\u5728\u4e8e \\(N|p-1\\) \uff0c\u800cp=998244353\u65f6 $$ p-1=998244353-1=2^{23}\\times17\\times7 $$ \u7531\u4e8e\u5728FFT\u4e2dN\uff08\u4e5f\u5c31\u662f\u6269\u5c55\u540e\u7684\u591a\u9879\u5f0f\u957f\u5ea6\uff09\u662f2\u7684\u5e42\uff0c\u56e0\u6b64\u5927\u591a\u6570\u65f6\u5019\uff08\u53ea\u8981N\u5c0f\u4e8e\u7b49\u4e8e2\u768423\u6b21\u5e42\uff09\u80fd\u591f\u6ee1\u8db3 \\(N|p-1\\) \u3002\u540c\u6837\u7c7b\u4f3c\u7684\u6570\u8fd8\u6709p=1004535809=479 2^{21}+1\u3002 \u8fd9\u4e24\u4e2a\u6570\u7684\u539f\u6839\u90fd\u662f3\u3002 *","title":"\u5feb\u901f\u6570\u8bba\u53d8\u6362\uff08Number theoretic transform\uff09"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#fast-walsh-transform","text":"https://oi-wiki.org/math/poly/fwt/#_3 \u7528\u4e8e\u89e3\u51b3\u4e0e\u4f4d\u8fd0\u7b97\u6709\u5173\u7684\u5377\u79ef\u95ee\u9898\uff1a \\(\\vec c=\\vec a \\oplus \\vec b\\) $$ C_i=\\sum_{i=j|k}A_j B_k $$ \u5bf9\u6216\u8fd0\u7b97\u6765\u8bf4\uff0c\u6784\u9020\uff1a $$ A'=FWT[A]:A' i=\\sum A_j $$ \u4e5f\u5373A' i\u8868\u793a\u4e8c\u8fdb\u5236\u4e0b\u76841\u662fi\u7684\u5b50\u96c6\u7684Aj\u7684\u603b\u548c\uff0c\u5982\u6b64\u6784\u9020\u5c31\u6709 $$ FWT[C]=FWT[A]\\cdot FWT[B]\\ \\sum C_i=\\sum_{i=i|j}A_i\\cdot \\sum_{i=i|j}B_i $$ \u7279\u522b\u5730\uff0c\u591a\u9879\u5f0f\u957f\u5ea6\u4e3a1\u65f6\uff0c\u663e\u7136\u6709 $$ A=FWT[A]=A' $$ \u56e0\u4e3a\u5728\u6216\u7684\u60c5\u51b5\u4e0bi\u81ea\u5df1\u5c31\u662fi\u7684\u5b50\u96c6\u3002\u5bf9\u4e8e\u4e0e\u6765\u8bf4\u4e5f\u540c\u7406\u3002 \u8003\u8651\u9012\u63a8\u516c\u5f0f\u7684\u65f6\u5019\uff0c\u4e3b\u8981\u8003\u8651\u591a\u51fa\u6765\u7684\u90a3\u4e00\u4f4d\u768401\u548c\u8fd0\u7b97\u5b50\u96c6\u6216\u8d85\u96c6\u7684\u5173\u7cfb","title":"\u5feb\u901f\u6c83\u5c14\u4ec0\u53d8\u6362\uff08Fast Walsh Transform\uff09"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#or","text":"merge\u8868\u793a\u4e32\u63a5\uff0cA0\u8868\u793a\u5de6\u534a\u90e8\u5206\uff0cA1\u8868\u793a\u53f3\u534a\u90e8\u5206\u3002 $$ FWT[A]=merge(FWT[A_0],FWT[A_0]+FWT[A_1])\\ UFWT[A']=merge(UFWT[A'_0],UFWT[A'_1]-UFWT[A'_0]) $$","title":"\u6216\uff08OR\uff09"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#and","text":"\u4e0a\u6587\u4e2d\u5b50\u96c6\u53d8\u6210\u8d85\u96c6 $$ FWT[A]=merge(FWT[A_0]+FWT[A_1],FWT[A_1])\\ UFWT[A']=merge(UFWT[A'_0]-UFWT[A'_1],UFWT[A'_1]) $$","title":"\u4e0e\uff08AND\uff09"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#xor","text":"\u8bbe $$ A' k=FWT[A][k]=\\sum {2 n-1}A_i(-1)^{|i\\and k|} $$ \u5176\u4e2d \\(|i\\and k|\\) \u8868\u793ai and k\u4e2d1\u7684\u6570\u76ee\u7684\u5947\u5076\u6027\u3002 \u5219\uff08\u56e0\u4e3a\u6307\u6570\u90a3\u4e2a\u5730\u65b9\u53ea\u662f\u8868\u793a\u5947\u5076\u6027\uff0c\u6240\u4ee5\u53ef\u4ee5\u76f4\u63a5\u4ece\u52a0\u53f7\u66ff\u6362\u6210\u5f02\u6216\u7b26\u53f7\uff09 $$ FWT[A][k]\\cdot FWT[B][k]\\= \\sum_{i=0} {2 n-1} A_i(-1)^{|i\\and k|}\\sum_{i=0} {2 n-1} B_i(-1)^{|i\\and k|}\\ =\\sum_{i=0} {2 n-1}\\sum_{j=0} {2 n-1}A_iB_j(-1)^{|i\\and k|\\oplus|j\\and k|}\\ =\\sum_{i=0} {2 n-1}\\sum_{j=0} {2 n-1}A_iB_j(-1)^{|(i\\oplus j)\\and k|}\\ =\\sum_{val=0} {2 n-1}(\\sum_{j=0} {2 n-1}A_{val}B_{val\\oplus j})(-1)^{|val\\and k|} $$ \u6ce8\u610f\uff1a\u6700\u540e\u4e00\u4e2a\u7b49\u5f0f\u540e\u6c42\u548c\u987a\u5e8f\u5df2\u7ecf\u53d8\u6362\u3002\u62ec\u53f7\u5185\u5c31\u662f \\(C_i\\) $$ FWT[A]=merge(FWT[A_0]+FWT[A_1],FWT[A_0]-FWT[A_1])\\ UFWT[A']=merge(\\frac{UFWT[A'_0]+UFWT[A'_1]}2,\\frac{UFWT[A'_0]-UFWT[A'_1]}2)\\ $$ \u5982\u679c\u662f\u540c\u6216\u5c31\u4ea4\u6362+-\u7b26\u53f7\u3002","title":"\u5f02\u6216\uff08XOR\uff09"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_60","text":"","title":"\u7f51\u7edc\u6d41\u76f8\u5173"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#halls-marriage-theorem","text":"\u8bbe\u4e8c\u5206\u56fe\u4e2dG= \u4e2d\uff0c|V1|=m<=|V2|=n\uff0cG\u4e2d\u5b58\u5728V1\u5230V2\u7684\u5b8c\u5168\u5339\u914d\uff0c \u5f53\u4e14\u4ec5\u5f53 V1\u4e2d\u4efb\u610fk\u4e2a(k=1,2,..,m)\u4e2a\u9876\u70b9\u81f3\u5c11\u4e0eV2\u4e2dk\u4e2a\u9876\u70b9\u76f8\u90bb \uff08\u968f\u4fbf\u6311\u51fa\u4efb\u610f\u4e2a\u7537\u751f\uff0c\u5982\u679c\u4ed6\u4eec\u5fc3\u4eea\u7684\u5973\u751f\u7684\u6570\u91cf\uff08\u91cd\u590d\u4e0d\u7b97\uff09\u6bd4\u8fd9\u4e9b\u6311\u51fa\u7684\u7537\u751f\u6570\u8fd8\u5c11\uff0c\u90a3\u4e48\u5fc5\u7136\u4e0d\u80fd\u5b9e\u73b0\u5b8c\u7f8e\u914d\u5bf9\uff09","title":"Hall's marriage theorem"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_61","text":"N(S)\u8868\u793a\u4e0eS\u76f8\u90bb\uff08\u8fde\u63a5\uff09\u7684\u9876\u70b9\u6570\u91cf $$ |M|=|V_1|-max_{S\\subset V_1}(|S|-|N(S)|) $$","title":"\u4e8c\u5206\u56fe\u6700\u5927\u5339\u914d\u6570\u91cf"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#naibi","text":"\u6211\u4eec\u601d\u8003\u4e09\u79cd\u60c5\u51b5\uff1a 1.\u5f53\u8fd9\u4e2aS\u5b50\u96c6\u662f\u4e2a\u7a7a\u5b50\u96c6\u7684\u65f6\u5019\uff0c\u90a3\u4e48|M|=|U| 2.\u5f53\u8fd9\u4e2aS\u5b50\u96c6\u5c31\u662fU\u7684\u672c\u8eab\u7684\u65f6\u5019\uff0c\u90a3\u4e48N(S)\u5c31\u7b49\u4e8eV\uff08\u5976\u8336\u7684\u6570\u91cf\uff09\uff0c\u5373|M|=|V| 3.\u5f53S\u662f|U|\u7684\u4e00\u4e2a\u5b50\u96c6\uff0c\u6211\u4eec\u4e00\u4e2a\u73ed\u4e00\u4e2a\u73ed\u7684\u8003\u8651\uff0c\u5f53S\u662f\u4e00\u4e2a\u73ed\u7684\u5b66\u751f\u7684\u65f6\u5019\uff0c\u90a3\u4e48\uff1a |M|=Sa-\uff08ai-\uff08Sb-bi\uff09\uff09\u5176\u4e2dSa\uff0cSb\u5206\u522b\u4ee3\u8868\u5b66\u751f\u603b\u6570\u91cf\u548c\u5976\u8336\u603b\u6570\u91cf\uff0cai\uff0cbi\u4ee3\u8868\u672c\u73ed\u5b66\u751f\u6570\u91cf\u548c\u672c\u73ed\u505a\u7684\u5976\u8336\u6570 \uff08\u4e3a\u4ec0\u4e48\u7b2c\u4e09\u4e2a\u60c5\u51b5\u4e0d\u4e00\u4e2a\u4e2a\u5b66\u751f\u8003\u8651\u706b\u6216\u8005\u4e24\u4e2a\u73ed\u4e09\u4e2a\u73ed\u7684\u8003\u8651\u5462\uff0c\u56e0\u4e3a\u6211\u4eec\u6c42\u7684\u662fmax\uff0c\u4e5f\u5c31\u662f\u6700\u5927\u503c\uff0c\u90a3\u4e48\u8fd9\u4e9b\u8003\u8651\u90fd\u662f\u65e0\u6548\u7684\uff0c\u5927\u5bb6\u753b\u4e00\u4e0b\u5c31\u77e5\u9053\u4e86\uff0c\u5f88\u5bb9\u6613\u7406\u89e3\uff09 \u4e09\u4e2a\u60c5\u51b5\u53d6\u6700\u5c0f\u503c\u8bb0\u4e3a\u7ed3\u679c \u4e3a\u4f55\u4e0d\u4e00\u4e2a\u4e2a\u8003\u8651\uff1a\u82e5\u5982\u6b64\u505a\uff0c|S|\u5c0f\u800c|N(S)|\u5927\uff0c\u5c06S\u6269\u5927\u5230\u540c\u73ed\u7ea7\uff0c\u7ed3\u679c\u4f1a\u66f4\u597d \u4e3a\u4f55\u4e0d\u6570\u4e2a\u73ed\u7ea7\u4e00\u8d77\u8003\u8651\uff1a\u82e5\u5982\u6b64\u505a\uff0c|N(S)|=|V2|\uff08\u4e5f\u5c31\u662f\u5976\u8336\u6570\u91cf\uff09\u4e3a\u5b9a\u503c\uff0c\u5219\u5c06S\u6269\u5927\u5230\u6240\u6709\u4eba\uff0c\u7ed3\u679c\u4f1a\u66f4\u597d\uff0c\u4f46\u8fd9\u548c\u60c5\u51b52\u662f\u91cd\u5408\u7684 \u4e09\u4e2a\u60c5\u51b5\u53d6\u6700\u5c0f\u503c\uff1a-max >>>> min \u539f\u6587\u94fe\u63a5\uff1a https://blog.csdn.net/qq_41925919/java/article/details/99689223","title":"\u6709n\u4e2a\u73ed\u7ea7\uff0c\u6bcf\u4e2a\u73ed\u7ea7\u6709ai\u4e2a\u4eba\uff0c\u4e00\u4e2a\u73ed\u7ea7\u53ef\u4ee5\u505a\u51fabi\u676f\u5976\u8336\uff0c\u4e00\u4e2a\u73ed\u7ea7\u7684\u4eba\u4e0d\u80fd\u559d\u672c\u73ed\u505a\u7684\u5976\u8336\uff0c\u53ef\u4ee5\u559d\u522b\u7684\u73ed\u505a\u7684\u5976\u8336\uff0c\u95ee\u6700\u591a\u6709\u591a\u5c11\u4eba\u559d\u5230\u5976\u8336"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_62","text":"\u5e26\u6743\u95ed\u5408\u5b50\u56fe\uff1a\u6743\u5728\u70b9\u4e0a\uff0c\u5b50\u56fe\u4e2d\u7684\u70b9\u7684\u51fa\u8fb9\u5747\u5728\u5b50\u56fe\u4e2d \u6700\u5927\u6743\u95ed\u5408\u5b50\u56fe\uff1a\u503c\u7b49\u4e8e \u201c\u6240\u6709\u6b63\u70b9\u6743\u503c\u7684\u548c\u201d\u51cf\u53bb\u201cs-t\u6700\u5c0f\u5272\u201d https://www.cnblogs.com/dilthey/p/7565206.html \u5c0fM\u7684\u4f5c\u7269 \uff08\u6b64\u9898\u7684\u53e6\u4e00\u4e2a\u505a\u6cd5\uff1aA\u3001B\u4f5c\u4e3a\u6e90\u70b9\u548c\u6c47\u70b9\uff0c\u4f5c\u7269\u4f5c\u4e3a\u4e2d\u95f4\u8282\u70b9\uff0c\u518d\u6784\u9020\u8fde\u7ed3\u6e90\u70b9\uff08\u6c47\u70b9\uff09\u548c\u4f5c\u7269\u8282\u70b9\u7684\u5956\u52b1\u8282\u70b9\uff0c\u7136\u540e\u6c42\u6700\u5c0f\u5272\uff09 https://blog.csdn.net/clover_hxy/article/details/55043578","title":"\u6700\u5927\u6743\u95ed\u5408\u5b50\u56fe"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_63","text":"\u6709 \u4e2a\u7269\u54c1\u548c\u4e24\u4e2a\u96c6\u5408 \uff0c\u5982\u679c\u5c06\u4e00\u4e2a\u7269\u54c1\u653e\u5165 \u96c6\u5408\u4f1a\u82b1\u8d39 \uff0c\u653e\u5165 \u96c6\u5408\u4f1a\u82b1\u8d39 \uff1b\u8fd8\u6709\u82e5\u5e72\u4e2a\u5f62\u5982 \u9650\u5236\u6761\u4ef6\uff0c\u8868\u793a\u5982\u679c \u548c \u540c\u65f6\u4e0d\u5728\u4e00\u4e2a\u96c6\u5408\u4f1a\u82b1\u8d39 \u3002\u6bcf\u4e2a\u7269\u54c1\u5fc5\u987b\u4e14\u53ea\u80fd\u5c5e\u4e8e\u4e00\u4e2a\u96c6\u5408\uff0c\u6c42\u6700\u5c0f\u7684\u4ee3\u4ef7\u3002 \u8fd9\u662f\u4e00\u4e2a\u7ecf\u5178\u7684 \u4e8c\u8005\u9009\u5176\u4e00 \u7684\u6700\u5c0f\u5272\u9898\u76ee\u3002\u6211\u4eec\u5bf9\u4e8e\u6bcf\u4e2a\u96c6\u5408\u8bbe\u7f6e\u6e90\u70b9 \u548c\u6c47\u70b9 \uff0c\u7b2c \u4e2a\u70b9\u7531 \u8fde\u4e00\u6761\u5bb9\u91cf\u4e3a \u7684\u8fb9\u3001\u5411 \u8fde\u4e00\u6761\u5bb9\u91cf\u4e3a \u7684\u8fb9\u3002\u5bf9\u4e8e\u9650\u5236\u6761\u4ef6 \uff0c\u6211\u4eec\u5728 \u4e4b\u95f4\u8fde\u5bb9\u91cf\u4e3a \u7684\u53cc\u5411\u8fb9\u3002 \u6ce8\u610f\u5230\u5f53\u6e90\u70b9\u548c\u6c47\u70b9\u4e0d\u76f8\u8fde\u65f6\uff0c\u4ee3\u8868\u8fd9\u4e9b\u70b9\u90fd\u9009\u62e9\u4e86\u5176\u4e2d\u4e00\u4e2a\u96c6\u5408\u3002\u5982\u679c\u5c06\u8fde\u5411 \u6216 \u7684\u8fb9\u5272\u5f00\uff0c\u8868\u793a\u4e0d\u653e\u5728 \u6216 \u96c6\u5408\uff0c\u5982\u679c\u628a\u7269\u54c1\u4e4b\u95f4\u7684\u8fb9\u5272\u5f00\uff0c\u8868\u793a\u8fd9\u4e24\u4e2a\u7269\u54c1\u4e0d\u653e\u5728\u540c\u4e00\u4e2a\u96c6\u5408\u3002 \u6700\u5c0f\u5272\u5c31\u662f\u6700\u5c0f\u82b1\u8d39\u3002","title":"\u6700\u5c0f\u5272\u7684\u4e00\u4e2a\u95ee\u9898\u6a21\u578b\u00b6"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#computational-geometry","text":"\u8ba1\u7b97\u51e0\u4f55\u5168\u5bb6\u6876\uff1a https://www.cnblogs.com/Xing-Ling/p/12102489.html kuangbin\u7684\u677f\u5b50\uff1a https://kuangbin.github.io/2019/04/28/20190428/#more Pecco\u7684\u677f\u5b50\uff1a https://zhuanlan.zhihu.com/p/338057154 \u8fd9\u91cc\u4e3b\u8981\u7528kuangbin\u7684\u677f\u5b50\u3002","title":"\u8ba1\u7b97\u51e0\u4f55(Computational Geometry)"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_64","text":"\u5411\u91cfa\u7684\u5de6\u624b\u8fb9\u662f\u6b63\u533a\u57df\uff08\u5305\u62ec180\u5ea6\u7ebf\uff09\uff0c\u53f3\u624b\u8fb9\u662f\u8d1f\u533a\u57df\u3002\u56e0\u6b64\u4e24\u4e2a\u76f8\u91cfa\u3001b\u7684\u5939\u89d2\u662f\u6b63\u65f6\uff0cb\u5728a\u5de6\u4fa7\uff0c\u5426\u5219\u5728\u53f3\u4fa7\u3002\uff08\u8fd9\u4e2a\u7ea6\u5b9a\u5728\u53c9\u4e58\u3001\u534a\u5e73\u9762\u4ea4\u4e2d\u90fd\u6709\u7528\uff09 \\[ |\\vec a\\times\\vec b|=|\\vec a||\\vec b|\\sin<\\vec a,\\vec b>\\\\ |\\vec a\\cdot \\vec b|=|\\vec a||\\vec b|\\cos<\\vec a,\\vec b> \\]","title":"\u5e38\u8bc6"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_65","text":"\u70b9\u548c\u5411\u91cf\u4f7f\u7528\u540c\u4e00\u5957\u7ed3\u6784Point\uff0c\u4f46\u662f\u5141\u8bb8\u5411\u91cf\u62e5\u6709\u522b\u540dVec\u3002\u70b9\u548c\u5411\u91cf\u7279\u6709\u7684\u65b9\u6cd5\u5728\u5b9a\u4e49\u65f6\u52a0\u4ee5\u533a\u5206","title":"\u539f\u5219"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_66","text":"HDU1756 cupids arrow 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 #include <iostream> #include <cmath> #include <algorithm> using namespace std ; const double eps = 1e-8 ; inline int dcmp ( double a ){ return a <- eps ? -1 : ( a > eps ? 1 : 0 );} //\u5904\u7406\u7cbe\u5ea6 inline double Abs ( double a ){ return a * dcmp ( a );} //\u53d6\u7edd\u5bf9\u503c struct Point { double x , y ; Point ( double X = 0 , double Y = 0 ) { x = X , y = Y ; } }; typedef Point Vector ; double Dot ( Vector a , Vector b ) { return a . x * b . x + a . y * b . y ;} double Cro ( Vector a , Vector b ) { return a . x * b . y - a . y * b . x ;} double Len ( Vector a ) { return sqrt ( Dot ( a , a ));} Vector operator + ( Vector a , Vector b ){ return Vector ( a . x + b . x , a . y + b . y );} Vector operator - ( Vector a , Vector b ){ return Vector ( a . x - b . x , a . y - b . y );} Vector operator * ( Vector a , double b ){ return Vector ( a . x * b , a . y * b );} bool operator == ( Point a , Point b ){ return ! dcmp ( a . x - b . x ) &&! dcmp ( a . y - b . y );} //\u4e24\u70b9\u5750\u6807\u91cd\u5408\u5219\u76f8\u7b49 int n ; Point a [ 110 ]; bool check_PL ( Point p , Point a , Point b ) { return ! dcmp ( Cro ( p - a , b - a )) && dcmp ( Dot ( p - a , p - b )) <= 0 ; //\u53c9\u4e58\u4e3a0\u8868\u4e09\u70b9\u5171\u7ebf\uff0c\u70b9\u79ef\u5c0f\u4e8e0\u8868\u793aPA\u3001PB\u53cd\u5411 } int PIP ( Point * P , int n , Point a ) { int cnt = 0 ; double temp = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int j = i == n ? 1 : i + 1 ; if ( check_PL ( a , P [ i ], P [ j ])) return 2 ; //\u70b9\u5728\u8fb9\u4e0a if ( a . y >= min ( P [ i ]. y , P [ j ]. y ) && a . y < max ( P [ i ]. y , P [ j ]. y )) //\u7eb5\u5750\u6807\u5728\u8be5\u7ebf\u6bb5\u4e24\u7aef\u70b9\u4e4b\u95f4 { //temp:\u76f8\u4f3c\u4e09\u89d2\u5f62\u786e\u5b9a\u4ea4\u70b9\u7684x\u5750\u6807 temp = P [ i ]. x + ( a . y - P [ i ]. y ) / ( P [ j ]. y - P [ i ]. y ) * ( P [ j ]. x - P [ i ]. x ); cnt += dcmp ( temp - a . x ) > 0 ; //\u4ea4\u70b9\u5728A\u53f3\u65b9 } } return cnt & 1 ; } int main () { ios :: sync_with_stdio ( false ); while ( cin >> n ) { for ( int i = 1 ; i <= n ; i ++ ) { int x , y ; cin >> x >> y ; a [ i ]. x = x , a [ i ]. y = y ; } int m ; cin >> m ; for ( int i = 1 ; i <= m ; i ++ ) { int x , y ; cin >> x >> y ; Point b ( x , y ); if ( PIP ( a , n , b )) cout << \"Yes\" << endl ; else cout << \"No\" << endl ; } } return 0 ; }","title":"\u70b9\u5728\u4efb\u610f\u591a\u8fb9\u5f62\u5185"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_67","text":"\u53ef\u4ee5\u4f7f\u7528\u4e8c\u5206\u6cd5\u5224\u65ad HRBUST 1429 \u51f8\u591a\u8fb9\u5f62 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 #include <iostream> #include <cmath> #include <algorithm> using namespace std ; const double eps = 1e-8 ; inline int dcmp ( double a ){ return a <- eps ? -1 : ( a > eps ? 1 : 0 );} //\u5904\u7406\u7cbe\u5ea6 inline double Abs ( double a ){ return a * dcmp ( a );} //\u53d6\u7edd\u5bf9\u503c struct Point { double x , y ; Point ( double X = 0 , double Y = 0 ) { x = X , y = Y ; } }; typedef Point Vector ; double Dot ( Vector a , Vector b ) { return a . x * b . x + a . y * b . y ;} double Cro ( Vector a , Vector b ) { return a . x * b . y - a . y * b . x ;} double Len ( Vector a ) { return sqrt ( Dot ( a , a ));} Vector operator + ( Vector a , Vector b ){ return Vector ( a . x + b . x , a . y + b . y );} Vector operator - ( Vector a , Vector b ){ return Vector ( a . x - b . x , a . y - b . y );} Vector operator * ( Vector a , double b ){ return Vector ( a . x * b , a . y * b );} bool operator == ( Point a , Point b ){ return ! dcmp ( a . x - b . x ) &&! dcmp ( a . y - b . y );} //\u4e24\u70b9\u5750\u6807\u91cd\u5408\u5219\u76f8\u7b49 const int N = 1e5 + 10 ; int n ; Point a [ N ], b [ N ]; bool check_PL ( Point p , Point a , Point b ) { return ! dcmp ( Cro ( p - a , b - a )) && dcmp ( Dot ( p - a , p - b )) <= 0 ; //\u53c9\u4e58\u4e3a0\u8868\u4e09\u70b9\u5171\u7ebf\uff0c\u70b9\u79ef\u5c0f\u4e8e0\u8868\u793aPA\u3001PB\u53cd\u5411 } bool judge ( Point a , Point L , Point R ) //\u5224\u65adAL\u662f\u5426\u5728AR\u53f3\u8fb9 { return dcmp ( Cro ( L - a , R - a )) > 0 ; } int PIP_of_convex ( Point * P , int n , Point a ) { if ( judge ( P [ 1 ], a , P [ 2 ]) || judge ( P [ 1 ], P [ n ], a )) return 0 ; if ( check_PL ( a , P [ 1 ], P [ 2 ]) || check_PL ( a , P [ 1 ], P [ n ])) return 2 ; int L = 2 , R = n -1 ; while ( L < R ) { int mid = ( L + R + 1 ) / 2 ; //OOO)XX if ( judge ( P [ 1 ], P [ mid ], a )) L = mid ; else R = mid -1 ; } if ( judge ( P [ L ], a , P [ L + 1 ])) return 0 ; //\u4e25\u683c\u5728\u5916\u4fa7 if ( check_PL ( a , P [ L ], P [ L + 1 ])) return 2 ; return 1 ; } int main () { ios :: sync_with_stdio ( false ); while ( cin >> n ) { for ( int i = n ; i >= 1 ; i -- ) { int x , y ; cin >> x >> y ; a [ i ]. x = x , a [ i ]. y = y ; } int m ; cin >> m ; bool flag = true ; for ( int i = 1 ; i <= m ; i ++ ) { int x , y ; cin >> x >> y ; b [ i ]. x = x , b [ i ]. y = y ; } for ( int i = 1 ; i <= m ; i ++ ) { if ( PIP_of_convex ( a , n , b [ i ]) != 1 ) { flag = false ; break ;} } if ( flag ) cout << \"YES\" << endl ; else cout << \"NO\" << endl ; } return 0 ; } //http://acm.hrbust.edu.cn/vj/index.php?c=problem-problem&id=55043","title":"\u70b9\u5728\u51f8\u591a\u8fb9\u5f62\u5185"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#convex-hull","text":"","title":"\u51f8\u5305(Convex Hull)"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#graham","text":"\u9700\u8981\u6781\u89d2\u6392\u5e8f https://blog.csdn.net/qq_39826163/article/details/83861353","title":"Graham\u626b\u63cf\u6cd5"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#andrew","text":"\u9700\u8981\u6309\u7167\u5750\u6807x\u3001y\u4f9d\u6b21\u6392\u5e8f\u5e76\u6b63\u53cd\u8dd1\u5171\u4e24\u6b21 https://oi-wiki.org/geometry/convex-hull/ https://www.cnblogs.com/yjbjingcha/p/7255457.html P1452 \u65cb\u8f6c\u5361\u58f3\u6a21\u7248 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 #include <cstdio> #include <cmath> #include <algorithm> using namespace std ; const double eps = 1e-8 ; inline int dcmp ( double a ){ return a <- eps ? -1 : ( a > eps ? 1 : 0 );} //\u5904\u7406\u7cbe\u5ea6 inline double Abs ( double a ){ return a * dcmp ( a );} //\u53d6\u7edd\u5bf9\u503c struct Point { double x , y ; Point ( double X = 0 , double Y = 0 ) { x = X , y = Y ; } }; typedef Point Vector ; double Dot ( Vector a , Vector b ) { return a . x * b . x + a . y * b . y ;} double Cro ( Vector a , Vector b ) { return a . x * b . y - a . y * b . x ;} double Len ( Vector a ) { return sqrt ( Dot ( a , a ));} Vector operator + ( Vector a , Vector b ){ return Vector ( a . x + b . x , a . y + b . y );} Vector operator - ( Vector a , Vector b ){ return Vector ( a . x - b . x , a . y - b . y );} Vector operator * ( Vector a , double b ){ return Vector ( a . x * b , a . y * b );} bool operator == ( Point a , Point b ){ return ! dcmp ( a . x - b . x ) &&! dcmp ( a . y - b . y );} //\u4e24\u70b9\u5750\u6807\u91cd\u5408\u5219\u76f8\u7b49 bool cmp1 ( Vector a , Vector b ) { if ( a . x == b . x ) return a . y < b . y ; return a . x < b . x ; } int n , conv_p ; Point a [ 50010 ], conv [ 50010 ]; int Convex_Hull ( Point * P , int n , Point * st ) { int t = 0 ; if ( n == 1 ) { st [ 1 ] = st [ 2 ] = P [ 1 ]; return t = 1 ; } if ( n == 2 ) { st [ 1 ] = P [ 1 ]; st [ 2 ] = st [ 3 ] = P [ 2 ]; return t = 2 ; } sort ( P + 1 , P + 1 + n , cmp1 ); for ( int i = 1 ; i <= n ; i ++ ) { while ( t > 1 && dcmp ( Cro ( st [ t ] - st [ t -1 ], P [ i ] - st [ t -1 ]) <= 0 )) { t -- ; } st [ ++ t ] = P [ i ]; } int temp = t ; for ( int i = n -1 ; i >= 1 ; i -- ) { while ( t > temp && dcmp ( Cro ( st [ t ] - st [ t -1 ], P [ i ] - st [ t -1 ]) <= 0 )) { t -- ; } st [ ++ t ] = P [ i ]; } return -- t ; } int dis2 ( Vector a , Vector b ) { return ( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y ); } int Rotating_calipers ( Point * conv , int t ) { int ans = 0 , j = 2 ; for ( int i = 1 ; i <= t ; i ++ ) { while ( fabs ( Cro ( conv [ i ] - conv [ j ], conv [ i + 1 ] - conv [ j ])) < fabs ( Cro ( conv [ i ] - conv [ j + 1 ], conv [ i + 1 ] - conv [ j + 1 ]))) { j ++ ; if ( j > t ) j = 1 ; } ans = max ( ans , dis2 ( conv [ i ], conv [ j ])); } return ans ; } int main () { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; i ++ ) { int x , y ; scanf ( \"%d %d\" , & x , & y ); a [ i ]. x = x , a [ i ]. y = y ; } conv_p = Convex_Hull ( a , n , conv ); printf ( \"%d\" , Rotating_calipers ( conv , conv_p )); return 0 ; }","title":"Andrew \u7b97\u6cd5"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#rotating-calipers","text":"https://www.jvruo.com/archives/79/ \u7528\u4e8e\u6c42\u5e73\u9762\u6700\u8fdc\u70b9\u5bf9","title":"\u65cb\u8f6c\u5361\u58f3(Rotating calipers)"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_68","text":"https://www.jvruo.com/archives/67/ \u8fd9\u73a9\u610f\u4e5f\u592a\u590d\u6742\u4e86\u2026\u2026","title":"\u534a\u5e73\u9762\u4ea4"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_69","text":"","title":"\u56fe\u8bba"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#hld","text":"\u7528\u4e8e\u89e3\u51b3\u6811\u4e0a\u8def\u5f84\u4fee\u6539\u3001\u67e5\u8be2\u7b49\u95ee\u9898\u3002\u5c06\u6811\u5212\u5206\u6210\u82e5\u5e72\u91cd\u94fe\u540e\uff0c\u91c7\u7528\u91cd\u94fedfs\u4f18\u5148\u65b9\u5f0f\u83b7\u5f97dfn\uff0c\u8fd9\u6837\u4e00\u6765\u6811\u4e0a\u8282\u70b9\u7684dfn\u662f\u8fde\u7eed\u7684\u3002\u7ef4\u62a4dfn\u548c\u70b9\u7684\u5173\u7cfb\uff0c\u540c\u65f6\u4f7f\u7528\u6570\u636e\u7ed3\u6784\uff08\u7ebf\u6bb5\u6811\u7b49\uff09\u7ef4\u62a4\u8fde\u7eeddfn\u4e0a\u7684\u8282\u70b9\u4fe1\u606f\u4ee5\u505a\u5230\u5feb\u901f\u6811\u94fe\u4e0a\u67e5\u8be2\u548c\u4fee\u6539\u3002","title":"\u6811\u94fe\u5256\u5206(HLD)"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_70","text":"\u91cd\u5b50\u8282\u70b9 \uff1a\u5b50\u8282\u70b9\u4e2d \u5b50\u6811\u6700\u5927 \uff08\u5b50\u6811\u4e2d\u8282\u70b9\u6700\u591a\uff0c\u5305\u542b\u6811\u6839\uff09\u7684\u4e00\u4e2a\u5b50\u8282\u70b9\u3002 \u8f7b\u5b50\u8282\u70b9 \uff1a\u9664\u4e86\u91cd\u5b50\u8282\u70b9\u5916\u7684\u5b50\u8282\u70b9 \u91cd\u8fb9 \uff1a\u6839\u5230\u91cd\u5b50\u8282\u70b9\u7684\u8fb9 \u8f7b\u8fb9 \uff1a\u9664\u4e86\u6839\u5230\u91cd\u5b50\u8282\u70b9\u7684\u8fb9\u5916\u7684\u5176\u4ed6\u5230\u5b50\u8282\u70b9\u7684\u8fb9 \u91cd\u94fe \uff1a\u82e5\u5e72\u7531\u91cd\u8fb9\u8fde\u6210\u7684\u94fe\uff08\u5176\u4f59\u843d\u5355\u8282\u70b9\u4e5f\u89c6\u4e3a\u4e00\u6761\u91cd\u94fe\uff09 \u901a\u8fc7\u4e24\u6b21dfs\u5b9e\u73b0\uff0c\u7b2c\u4e00\u6b21dfs\u6807\u8bb0\u91cd\u5b50\u8282\u70b9\u3001\u6df1\u5ea6\u3001\u7236\u4eb2\u3001\u5b50\u6811\u5927\u5c0f\uff1b\u7b2c\u4e8c\u6b21\u6807\u8bb0dfn\uff08\u91cd\u8fb9\u4f18\u5148\u904d\u5386\uff09\u3001rnk\uff08dfn\u7684\u53cd\u51fd\u6570\uff0c\u4e5f\u5373\u901a\u8fc7dfn\u83b7\u5f97\u8282\u70b9\u539f\u6807\u53f7\uff09\u3001top\uff08\u6240\u5728\u91cd\u94fe\u94fe\u9876\uff09\u3002 \u6027\u8d28 \uff1a \u6811\u4e0a\u6bcf\u4e2a\u8282\u70b9\u90fd\u5c5e\u4e8e\u4e14\u4ec5\u5c5e\u4e8e\u4e00\u6761\u91cd\u94fe\uff0c\u6240\u6709\u7684\u91cd\u94fe\u5c06\u6574\u68f5\u6811 \u5b8c\u5168\u5256\u5206\u3002 \u91cd\u8fb9\u4f18\u5148\u904d\u5386\uff0c\u5219\u6700\u540e\u6bcf\u6761\u91cd\u94fe\u7684dfn\uff08top\u7684dfn\uff09\u662f\u4e0a\u5347\u7684\uff0c\u6bcf\u4e2a\u8282\u70b9\u6309\u7167dfn\u6392\u5e8f\u5373\u53ef\u5f97\u5230\u8fde\u7eed\u7684\u5256\u5206\u94fe\u3002 \u5b50\u6811\u5185\u3001\u94fe\u5185\u7684dfn\u90fd\u662f\u8fde\u7eed\u7684\u3002 \u5411\u4e0b\u7ecf\u8fc7\u8f7b\u8fb9\uff0c\u5219\u5b50\u6811\u5927\u5c0f\u81f3\u5c11\u9664\u4ee52\u3002 \u91cd\u94fe\u6570\u91cf\u4e0d\u8d85\u8fc7 \\( \\(O(\\log n)\\) \\) \u8def\u5f84\u4e0a\u7ef4\u62a4 \uff1a\u6bcf\u6b21\u9009\u62e9\u6df1\u5ea6\u8f83\u5927\u7684\u94fe\u5f80\u4e0a\u8df3\uff0c\u76f4\u5230\u4e24\u70b9\u5728\u540c\u4e00\u6761\u94fe\u4e0a\u3002 \u5b50\u6811\u7ef4\u62a4 \uff1a\u8bb0\u5f55\u6240\u5728\u5b50\u6811\u8fde\u7eed\u533a\u95f4\u672b\u7aef\u7684\u7ed3\u70b9\uff08\u4ed6\u55b5\u7684\u4e0d\u662f\u76f4\u63a5\u8bb0\u5f55\u5b50\u6811dfn\u6700\u5927\u662f\u8c01\u5c31\u884c\u4e86\u5417\uff08\uff09\uff09 LCA \uff1a\u548c\u8def\u5f84\u4e0a\u7ef4\u62a4\u76f8\u4f3c\uff0c\u4e0d\u8fc7\u5f53\u4e24\u4e2a\u8282\u70b9\u8df3\u5230\u540c\u4e00\u94fe\u65f6\uff0c\u53d6\u6df1\u5ea6\u8f83\u5c0f\u8282\u70b9\u4f5c\u4e3aLCA [P2590 ZJOI2008]\u6811\u7684\u7edf\u8ba1 \u57fa\u672c\u4e0a\u4e5f\u662f\u6a21\u677f\u9898\u4e86 P3379 \u3010\u6a21\u677f\u3011\u6700\u8fd1\u516c\u5171\u7956\u5148\uff08LCA\uff09 \u4f20\u7edf\u5e94\u7528 P3384 \u3010\u6a21\u677f\u3011\u8f7b\u91cd\u94fe\u5256\u5206 \u6a21\u677f\u9898 [P3976 TJOI2015]\u65c5\u6e38 \u4ecea\u8d70\u5230b\uff0c\u8def\u5f84\u4e0a\u627e\u4e24\u4e2a\u70b9\u4e70\u5356\uff08\u4e70\u70b9\u548c\u5356\u70b9\u8981\u4e00\u4e2a\u5728\u524d\u4e00\u4e2a\u5728\u540e\uff09\uff08\u4e8f\u94b1\u5219\u8f93\u51fa0\uff09\uff0c\u5b8c\u4e8b\u540e\u4fee\u6539\u8def\u5f84\u4e0a\u7684\u70b9\u6743\u503c\u3002 \u89e3\u6cd5\uff1a\u6811\u5256\u540e\uff0c\u7ebf\u6bb5\u6811\u7ef4\u62a4\u8def\u5f84\u6743\u503c\u6700\u5927\u503c\u3001\u6700\u5c0f\u503c\u3001\u4ece\u6839\u5230\u53f6\u5b50\u7684\u6700\u5927\u6700\u5c0f\u503c\u5dee(RTL)\u3001\u4ece\u53f6\u5b50\u5230\u6839\u7684\u6700\u5927\u6700\u5c0f\u503c\u5dee(LTR)\u3002\u7ef4\u62a4\u8fd9\u51e0\u4e2a\u503c\u5373\u53ef\u3002","title":"\u91cd\u94fe\u5256\u5206"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#dsu-on-tree","text":"\u53c2\u8003\uff1a https://www.cnblogs.com/zwfymqz/p/9683124.html#_label1_4 \u7528\u4e8e\u89e3\u51b3\u4e00\u7c7b\u7b26\u5408\u4e0b\u8ff0\u7279\u5f81\u7684\u9898\uff1a \u5bf9\u4efb\u610f\u7684\u5b50\u6811\u8be2\u95ee\uff08\u4e5f\u5373\u7edf\u8ba1\u7b54\u6848\u901a\u5e38\u53ea\u548c\u5b50\u6811\u6709\u5173\uff09 \u65e0\u4fee\u6539 \u6d41\u7a0b \uff1a \u5bf9\u4e8e\u6bcf\u4e2a\u8282\u70b9x \u9012\u5f52\u89e3\u51b3\u6240\u6709\u8f7b\u5b50\u6811\uff0c\u4e0d\u4fdd\u7559\u5f71\u54cd \u9012\u5f52\u89e3\u51b3\u91cd\u5b50\u6811\uff0c\u4fdd\u7559\u5f71\u54cd \uff08\u901a\u8fc7\u4f20\u9012\u53c2\u6570\u8868\u660e\uff09 \u518d\u626b\u63cf\u4e00\u904d\u8f7b\u5b50\u6811\uff0c\u540c\u65f6\u7edf\u8ba1\u7b54\u6848 \u5c06\u7b54\u6848\u4fdd\u5b58\u5230ans[x] \u6839\u636e\u53c2\u6570\uff0c\u5982\u679c\u9700\u8981\u5220\u9664\u5b50\u6811\u7684\u5f71\u54cd\uff0c\u5c31\u5c3d\u6570\u5220\u9664\u4e4b\uff08\u518d\u904d\u5386\u4e00\u904d\u6574\u4e2a\u5b50\u6811\uff09\uff08\u6ce8\u610f\u8fd9\u91cc\u533a\u5206\u7b54\u6848\u548c\u5f71\u54cd\uff01\uff09 \u8fd9\u91cc\u7684\u5f71\u54cd\u662f\u7528\u6765\u8f85\u52a9\u7edf\u8ba1\u5f53\u524d\u5b50\u6811\u6839\u8282\u70b9\u7b54\u6848\u7684\u4e1c\u897f\u3002\u4f8b\u5982\u5982\u679c\u8981\u6570\u5b50\u6811\u6709\u591a\u5c11\u79cd\u989c\u8272\uff0c\u90a3\u4e48cnt\u6570\u7ec4\u8868\u793a\u7b2ci\u79cd\u989c\u8272\u51fa\u73b0\u4e86\u591a\u5c11\u6b21\uff0c\u8fd9\u5c31\u662f\u9700\u8981\u5728\u626b\u63cf\u5b50\u6811\u7684\u65f6\u5019\u9700\u8981\u7edf\u8ba1\u7684\u5f71\u54cd\uff0c\u7b54\u6848\u66f4\u65b0\u4f9d\u8d56\u4e8e\u6b64\u3002 \u590d\u6742\u5ea6 \uff1a\uff08\u6765\u6e90\u4e8e\u9a6c\u524d\u5352\uff09 \u4e00\u4e2a\u70b9\u88ab\u8bbf\u95ee\u5230\uff0c\u53ea\u6709\u4e24\u79cd\u60c5\u51b5 1\u3001\u5728\u66b4\u529b\u7edf\u8ba1\u8f7b\u8fb9\u7684\u65f6\u5019\u8bbf\u95ee\u5230\u3002 \u6839\u636e\u524d\u9762\u7684\u6027\u8d28\uff0c\u8be5\u6b21\u6570<logn 2\u3001\u901a\u8fc7\u91cd\u8fb9 / \u5728\u904d\u5386\u7684\u65f6\u5019\u88ab\u8bbf\u95ee\u5230 \u663e\u7136\u53ea\u6709\u4e00\u6b21 cf600E. Lomsat gelral \u9898\u610f\uff1a\u7ed9\u51fa\u4e00\u4e2a\u6811\uff0c\u6c42\u51fa\u6bcf\u4e2a\u8282\u70b9\u7684\u5b50\u6811\u4e2d\u51fa\u73b0\u6b21\u6570\u6700\u591a\u7684\u989c\u8272\u7684\u7f16\u53f7\u548c\uff08\u53ef\u80fd\u6709\u591a\u79cd\u989c\u8272\u51fa\u73b0\u6b21\u6570\u90fd\u662f\u6700\u591a\u7684\uff09 \u89e3\u6cd5\uff1a\u5f71\u54cd\u5c31\u662f\u4e0a\u6587\u4e2d\u8bf4\u7684cnt\uff08\u5b50\u6811\u4e2d\u67d0\u79cd\u989c\u8272\u51fa\u73b0\u4e86\u591a\u5c11\u6b21\uff09\uff0c\u540c\u65f6\u5f00\u4e00\u4e2a\u8f85\u52a9\u53d8\u91cfmaxval\u6765\u8bb0\u5f55\u51fa\u73b0\u6b21\u6570\u6700\u591a\u7684\u989c\u8272\u7684\u51fa\u73b0\u6b21\u6570\u662f\u591a\u5c11\u3002","title":"\u6811\u4e0a\u542f\u53d1\u5f0f\u5408\u5e76\uff08DSU on Tree\uff09"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#tarjan","text":"","title":"\u6709\u5411\u56feTarjan \uff08\u5f85\u8865\u5145\uff09"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_71","text":"HDU2376 Average Distance \u5206\u6210 \u5b50\u6811 \u4e58\u4ee5 \u5b50\u6811\u5916\u7684\u70b9\uff0c\u518d\u4e58\u4ee5\u8fb9\u7684\u6743\u503c\uff0c\u5373\u53ef\u5f97\u5230\u8fb9\u7684\u8d21\u732e\u3002 \u4e25\u683c\u6765\u8bf4\u5e94\u8be5\u662f\u8d2a\u5fc3\u800c\u4e0d\u662f\u8fb9\u5206\u6cbb\u2026\u2026","title":"(\u53ef\u80fd\u662f)\u8fb9\u5206\u6cbb"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_72","text":"","title":"\u5b57\u7b26\u4e32"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#kmp","text":"(by hqh 20201018) https://oi-wiki.org/string/z-func/ \u4e0b\u6587\u4e2d\u5b57\u7b26\u4e32\u4ece1\u5f00\u59cb\u8ba1\u6570\u3002 LCP \uff1a\u6700\u957f\u516c\u5171\u524d\u7f00 \u5b9a\u4e49\u5b57\u7b26\u4e32a(\u957f\u4e3am)\u5173\u4e8e\u6a21\u5f0f\u4e32b\u7684 extend\u6570\u7ec4 \uff1aextend[i]\u8868\u793aa\u7684\u5b50\u4e32a[i~m]\u548cb\u7684LCP\u957f\u5ea6\u3002\u5982a='abcde'\uff0cb='bcd', \u5219a\u7684extend[2]=3\uff08\u6700\u957f\u516c\u5171\u524d\u7f00\u4e3abcd\uff09 \u5b9a\u4e49\u5b57\u7b26\u4e32b(\u957f\u4e3an)\u7684 z\u51fd\u6570 \uff1az[i]\u8868\u793ab[i~n]\u4e0eb\u81ea\u8eab\u7684LCP\u957f\u5ea6\u3002\u5982b='ababc'\uff0cz\u51fd\u6570\u4e3a[5 0 2 0 0]\u3002z[1]\u5b9e\u9645\u4e0a\u662f\u65e0\u610f\u4e49\u7684\uff0c\u4e00\u822c\u5b9a\u4e49\u5176\u4e3ab\u7684\u957f\u5ea6\u3002 \u6c42z\u51fd\u6570\u7684\u7b97\u6cd5 \uff1a \u6838\u5fc3\u601d\u60f3\u662f\u5728\u91c7\u7528\u66b4\u529b\u5339\u914d\u7684\u57fa\u7840\u4e0a\uff0c\u6c42z[i]\u524d\u5148\u521d\u59cb\u5316z[i]\u4e3a\u4e4b\u524d\u67d0\u4e2a\u5df2\u7ecf\u6c42\u51fa\u7684\u503c\uff0c\u7136\u540e\u518d\u66b4\u529b\u5339\u914d\u3002 \u5047\u8bbe\u73b0\u5728\u6c42\u5230\u67d0\u4e2a\u4f4d\u7f6ei\uff0c\u8bb0\u5f55\u4e4b\u524d\u80fd\u8bbf\u95ee\u5230\u7684\u6700\u53f3\u4f4d\u7f6e\u4e3ar\uff0c\u5bf9\u5e94\u8bbf\u95ee\u5230\u8fd9\u4e2a\u4f4d\u7f6e\u7684\u4e0b\u6807\u4e3al\u3002\u5219b\u4e2d\uff0cl~r\u4e0e1~r-l+1\u5bf9\u5e94\u5b50\u4e32\u76f8\u7b49\u3002\u8fd9\u610f\u5473\u7740i\u5f00\u59cb\u5904\u67d0\u4e00\u90e8\u5206\u548c1~r-l+1\u662f\u4e00\u6837\u7684\uff0c \u89c1\u4e0b\u56fe \u3002\u56e0\u6b64\u81f3\u5c11\u53ef\u4ee5\u4fdd\u8bc1z[i]\u6709z[i-l+1]\u90a3\u4e48\u591a\u3002\u5f53\u7136\u4e5f\u6709\u53ef\u80fdz[i-l+1]\u4f5c\u4e3ai\u5904\u7684\u521d\u59cb\u957f\u5ea6\u4f1a\u8d85\u51fa\u76ee\u524d\u5df2\u7ecf\u77e5\u9053\u7684\u6700\u53f3\u4f4d\u7f6e\uff0c\u56e0\u6b64\u5e94\u8be5\u9650\u5236\u5176\u4e0d\u80fd\u8d85\u8fc7r\uff08\u56e0\u4e3ar\u7684\u53f3\u8fb9\u6211\u4eec\u662f\u4e0d\u77e5\u9053\u7684\uff0c\u9700\u8981\u66b4\u529b\u5339\u914d\u5f97\u77e5\uff09\u3002 \u521d\u59cb\u5316\u4e4b\u540e\u76f4\u63a5\u66b4\u529b\u5339\u914d\u5373\u53ef\u3002\u53ef\u4ee5\u8bc1\u660e\u6b64\u79cd\u505a\u6cd5\u590d\u6742\u5ea6\u662fOn\u7684\u3002\uff08\u8bc1\u660e\u53c2\u89c1\u94fe\u63a5\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void get_z ( int n = b_l ) { int l = 1 , r = 1 ; z [ 1 ] = b_l ; //undefined for ( int i = 2 ; i <= n ; i ++ ) { if ( i <= r ) z [ i ] = min ( z [ i - l + 1 ], r - i + 1 ); //init while ( i + z [ i ] <= n && b [ z [ i ] + 1 ] == b [ i + z [ i ]]) //i+z[i] is next position, so accessible pos is i+z[i]-1 z [ i ] ++ ; if ( i + z [ i ] -1 > r ) l = i , r = i + z [ i ] -1 ; } } \u6c42extend\u7684\u7b97\u6cd5\uff1a \u548cz\u51fd\u6570\u5dee\u4e0d\u591a 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void exkmp ( int m = a_l , int n = b_l ) //get extend array { while ( extend [ 1 ] <= m && a [ 1 + extend [ 1 ]] == b [ 1 + extend [ 1 ]]) extend [ 1 ] ++ ; int l = 1 , r = 1 ; for ( int i = 2 ; i <= m ; i ++ ) { if ( i <= r ) extend [ i ] = min ( z [ i - l + 1 ], r - i + 1 ); while ( i + extend [ i ] <= m && b [ extend [ i ] + 1 ] == a [ i + extend [ i ]]) extend [ i ] ++ ; if ( i + extend [ i ] -1 > r ) l = i , r = i + extend [ i ] -1 ; } } \u6a21\u5f0f\u5339\u914d \uff1a\u663e\u7136\u6c42\u51faextend\u6570\u7ec4\u540e\uff0cextend[i]=n\u5904\u610f\u5473\u7740\u5339\u914d\u6210\u529f\uff08\u4ecei\u5f00\u59cb\u7684\u4e00\u6bb5\u5b50\u4e32\u4e0eb\u5b8c\u5168\u91cd\u5408\uff09\u3002 \u672c\u8d28\u4e0d\u540c\u5b50\u4e32\u6570\u76ee \uff1a\u5047\u8bbe\u5bf9\u4e8e\u5b57\u7b26\u4e32a\uff08\u957f\u4e3an\uff09\uff0c\u540ei+1\u5b57\u7b26\u6784\u6210\u7684\u5b50\u4e32\u4e2d\u672c\u8d28\u4e0d\u540c\u5b50\u4e32\u6570\u76ee\u5df2\u7ecf\u6c42\u51fa\uff08\u8bbe\u4e3aans\uff09\uff0c\u73b0\u5728\u6211\u4eec\u6765\u6c42\u540ei\u4e2a\u5b57\u7b26\u4e2d\u672c\u8d28\u4e0d\u540c\u5b50\u4e32\u6570\u76ee\u3002\u8fd9\u4e2a\u95ee\u9898\u76f8\u5f53\u4e8e\u5728\u5b57\u7b26\u4e32\u5934\u6dfb\u52a0\u4e86\u4e00\u4e2a\u5b57\u7b26c,\u4f7f\u5f97a:=c+a\u3002\u518d\u7528On\u7684\u65f6\u95f4\u6c42\u51fa\u65b0\u5b57\u7b26\u4e32\u7684z\u51fd\u6570\uff0c\u7136\u540e\u904d\u5386z[2~n]\uff0c\u8fd9\u4e4b\u4e2d\u6700\u5927\u7684\u503cz[j]\u5373\u4e3a\u65b0\u5b57\u7b26\u4e32\u7684\u6700\u957f\u91cd\u5408\u524d\u7f00\uff0c\u663e\u7136\u5c0f\u4e8e\u6b64\u957f\u5ea6\u7684\u65b0\u5b57\u7b26\u4e32\u524d\u7f00\u4e5f\u4f1a\u91cd\u5408\uff0c\u56e0\u6b64ans+=n-max(z[2~n]) \u5b57\u7b26\u4e32\u538b\u7f29 \uff1a\uff08\u5f85\u8865\u5145\uff09 P5410 \u3010\u6a21\u677f\u3011\u6269\u5c55 KMP\uff08Z \u51fd\u6570\uff09 \u6a21\u677f\u9898 [P2375 NOI2014]\u52a8\u7269\u56ed \u9898\u610f\uff1a\u6c42\u5b57\u7b26\u4e32a\u7684num\u6570\u7ec4\uff0cnum[i]\u8868\u793a\u5b50\u4e32a[1~i]\u540e\u7f00\u4e0e\u524d\u7f00\u76f8\u540c\u4e14\u524d\u540e\u7f00\u4e92\u4e0d\u91cd\u53e0\u7684\u6570\u76ee\u3002\u5982\"abababa\",num[7]=2\uff0c\u56e0\u4e3a\"a\", \"aba\"\u4e3a\u76f8\u540c\u524d\u540e\u7f00\uff0c\u4f46\"ababa\"\u4e0d\u662f\uff0c\u56e0\u4e3a\u91cd\u53e0\u4e86\u3002 \u89e3\u6cd5\uff1a\u8003\u8651\u5230a\u7684z\u51fd\u6570\u7684\u610f\u4e49\u4e3ai\u5f00\u59cb\u7684\u5b50\u4e32\u4e0e\u81ea\u8eab\u7684LCP\u957f\u5ea6\uff0c\u90a3\u4e48\u5bf9\u4e8e\u66f4\u77ed\u7684\u957f\u5ea6\uff08\u8bbe\u6b64\u65f6\u7ec8\u70b9\u4e3aj\uff09\uff0ca[i~j]\u4e5f\u662fa\u7684\u524d\u7f00\u3002\u6bd4\u5982a=\"bbbbb\",z[3]=3\uff0c\u4e5f\u5373a[1~3]\u4e0ea[3~5]\u76f8\u540c\uff0c\u90a3\u4e48a[1~2]\u4e0ea[3~4], a[1]\u4e0ea[3]\u4e5f\u76f8\u540c\u3002 \u56e0\u6b64\u5047\u5982\u6ca1\u6709\u4e0d\u80fd\u91cd\u53e0\u7684\u9650\u5236\uff0c\u90a3\u4e48\u5bf9\u4e8e\u4f4d\u7f6ei\uff0c\u5176z[i]\u4f1a\u5bf9i~i+z[i]-1\u5904\u7684num\u90fd\u67091\u7684\u8d21\u732e\u3002\u8003\u8651\u4e0a\u4e0d\u80fd\u91cd\u53e0\u7684\u9650\u5236\uff0c\u56e0\u4e3az[i]\u53ef\u80fd\u5f88\u5927\u800c\u5bfc\u81f4\u516c\u5171\u524d\u7f00\u91cd\u53e0\uff0c\u56e0\u6b64\u5bf9\u4e8ez[i]>=i\u7684\u90e8\u5206\u7684\u8d21\u732e\u4e0d\u4e88\u8003\u8651\u5373\u53ef\u3002\u4e5f\u5373z[i]\u5bf9i~min(i+z[i]-1,i+(i-1)-1)\u7684numm\u6709\u8d21\u732e\u3002 \u6700\u540e\u5dee\u5206\u4e00\u4e0b\u518d\u7d2f\u52a0\u5dee\u5206\u8d21\u732e\u5373\u53ef\u3002\uff08\u5f53\u7136\u8fd9\u9898\u4f60\u4e5f\u53ef\u4ee5\u7528\u4e00\u822ckmp\u505a\uff09","title":"\u6269\u5c55kmp"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#cf1051e-vasya-and-big-integers","text":"\u9898\u610f\uff1a\u7ed9\u4e09\u4e2a\u5927\u6570a,L,R, \u6c42\u5c06a\u5212\u5206\u6210\u6bcf\u6bb5\u6784\u6210\u7684\u6570\u65e0\u524d\u5bfc\u96f6\u4e14\u5927\u5c0f\u4ecb\u4e8e[L,R]\u4e4b\u95f4\u7684\u65b9\u6848\u6570\uff08Mod 998244353\uff09 \\(1\\le a\\le 1e(1e6), 0\\le L\\le R\\le 1e(1e6)\\) \uff0c\u4e5f\u5373\u4e0a\u9650\u6709\u5341\u4e07\u4f4d\u3002 \u89e3\u6cd5\uff1a\u8bbe \\(dp[j]\\) \u8868\u793a\u4ee5j~j+1\u4e4b\u95f4\u4f5c\u4e3a\u4e00\u6bb5\u7684\u8fb9\u754c\uff0c\u5212\u5206\u7684\u65b9\u6848\u6570\u3002\u5219 $$ dp[j]=\\sum(dp[i]) $$ \u5176\u4e2di\u4e3a\u540c\u65f6\u6ee1\u8db3\u4e0b\u97623\u4e2a\u6761\u4ef6\u7684\u6240\u6709\u6b63\u6574\u6570\uff1a \\(0\\le i \\le j-1\\) \\(a[i+1]\\neq 0\\) \uff08\u9664\u975eL\u4ec5\u6709\u4e00\u4f4d\uff0c\u53c2\u89c1\u4e0b\u6587\u8ba8\u8bba\uff09 \\(a[i+1 \\text{~} j]\\) \u6784\u6210\u7684\u6570\u5728[L,R]\u4e4b\u5185 \u6761\u4ef62\u662f\u4e3a\u4e86\u9650\u5236\u6709\u524d\u5bfc\u96f6\u7684\u5212\u5206\u4e0d\u80fd\u88ab\u8f6c\u79fb\u3002\u53ea\u6709\u4e00\u79cd\u60c5\u51b5\u4e0b\u8fd9\u6bb5\u80fd\u4ee50\u5f00\u5934\uff0c\u5c31\u662f\u8fd9\u6bb5\u6784\u6210\u7684\u6570\u672c\u8eab\u5c31\u662f0\u3002\u8fd9\u79cd\u60c5\u51b5\u4e0bL=0\uff0c\u56e0\u6b64i=j-1\u8fd9\u79cd\u60c5\u51b5\u7684\u5212\u5206\u9700\u8981\u505a\u7279\u5224\u3002 \u9664\u6b64\u4e4b\u5916\uff0c\u6613\u53d1\u73b0\u6ee1\u8db3\u6761\u4ef6\u7684i\u662f\u8fde\u7eed\u7684\u3002\u8bbea[i+1~j]\u6784\u6210\u7684\u6570\u4f4dM\uff0c|M|\u4e3a\u4e00\u4e2a\u6570\u7684\u6570\u4f4d\u957f\u5ea6\uff0c\u5219\u663e\u7136|L|<|M|<|R|\u7684\u60c5\u51b5\u90fd\u6ee1\u8db3\u6761\u4ef63\uff0c\u552f\u72ec\u53d6\u7b49\u53f7\u5904\u9700\u8981\u6bd4\u8f83L\u6216\u8005R\u4e0eM\u7684\u5927\u5c0f\u65b9\u80fd\u786e\u5b9a\u5bf9\u5e94\u4f4d\u7f6e\u7684i\u662f\u5426\u6ee1\u8db3\u6761\u4ef63\u3002\u800c\u6570\u7684\u6bd4\u8f83\u53ef\u901a\u8fc7\u6bd4\u8f83\u4e24\u6570\u7684LCP\u540e\u4e00\u4f4d\u89e3\u51b3\u3002\u6c42\u51faL\u3001R\u7684z\u51fd\u6570\uff0c\u518d\u6c42\u51faa\u5173\u4e8eL\u3001R\u7684extend\u6570\u7ec4\u5373\u53ef\u3002\u5f53\u7136\u6700\u540e\u8981\u4fdd\u8bc1i\u6ee1\u8db3\u6761\u4ef61. \u8fde\u7eed\u7684\u4e00\u6bb5i\u7684\u8f6c\u79fb\u53ef\u901a\u8fc7\u4fdd\u5b58dp\u7684\u524d\u7f00\u548cdpsum\u5b9e\u73b0\uff0c\u4f46\u5f53a[j+1]=0\u65f6,\u5176\u4e0d\u5e94\u8be5\u88ab\u8ba1\u5165dpsum\u4e2d\uff0c\u4ee5\u514d\u7834\u574f\u6761\u4ef62. \u5177\u4f53\u5b9e\u73b0\u53c2\u89c1\u4ee3\u7801\u3002","title":"CF1051E Vasya and Big Integers"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#ac","text":"\uff08By hqh 20201031\uff09 https://oi-wiki.org/string/ac-automaton/ \u81ea\u52a8\u673a\u662f\u4e00\u79cd\u6709\u5411\u56fe\uff0c\u56fe\u4e0a\u7684\u7ed3\u70b9\u8868\u793a\u5904\u4e8e\u67d0\u79cd\u72b6\u6001\uff0c\u800c\u8fb9\u8868\u793a\u72b6\u6001\u7684\u8f6c\u79fb\u3002 AC\u81ea\u52a8\u673a\u7684\u4e3b\u8981\u7528\u9014\u662f\u201c\u591a\u6a21\u5f0f\u5339\u914d\u201d\uff0c\u4e5f\u5373\u7ed9\u5b9a\u82e5\u5e72\u4e2a\u6a21\u5f0f\u4e32\uff0c\u518d\u7ed9\u5b9a\u4e00\u4e2a\u4e3b\u4e32\uff0c\u8981\u6c42\u51fa\u6bcf\u4e2a\u6a21\u5f0f\u4e32\u5728\u4e3b\u4e32\u4e2d\u7684\u51fa\u73b0\u6b21\u6570\u3002 \u4e3b\u8981\u7684\u601d\u60f3\u662f\u5c06\u591a\u4e2a\u6a21\u5f0f\u4e32\u6784\u5efatrie\u6811\uff0c\u7136\u540e\u901a\u8fc7\u4fee\u6539trie\u6811\u7684\u4e00\u4e9b\u8fb9\uff0c\u6765\u5b9e\u73b0\u591a\u6a21\u5f0f\u5feb\u901f\u5339\u914d\u3002\u56e0\u6b64\u4f60\u53ef\u4ee5\u7406\u89e3\u4e3a\u5728trie\u6811\u4e0a\u8dd1kmp\u3002 \u5bf9AC\u81ea\u52a8\u673a\u800c\u8a00\uff0c\u6bcf\u4e2a\u7ed3\u70b9\u7684\u72b6\u6001\u8868\u793a\u5f53\u524d\u591a\u6a21\u5f0f\u5339\u914d\u7684\u8fdb\u5ea6\uff08\u5728\u5339\u914d\u7ed3\u675f\u5904\uff0c\u5bf9\u5e94\u7ed3\u70b9\u62e5\u6709\u4e00\u4e2a\u5339\u914d\u5b8c\u6210\u6807\u8bc6\u7b26end[u]\u8868\u793a\u6210\u529f\u5339\u914d\u4e00\u4e2a\u6a21\u5f0f\u4e32\uff09\uff1b\u8fb9\u662f\u5b57\u7b26\uff0c\u5f15\u5bfc\u8f6c\u79fb\u5230\u4e0b\u4e00\u4e2a\u72b6\u6001\u3002 ### fail\u6307\u9488 \u6784\u5efa\u81ea\u52a8\u673a\u7684\u5173\u952e\u5728\u4e8efail\u6307\u9488\u3002\u6784\u5efa\u5b8c\u6210trie\u6811\u540e\uff0c\u6211\u4eec\u5229\u7528bfs\u6784\u5efafail\u6307\u9488\u3002 fail\u6307\u9488\u4ee3\u8868\u7684\u610f\u4e49\u662f\u6307\u5411trie\u6811\u4e2d\u7684\u53e6\u4e00\u4e2a\u7ed3\u70b9\uff0c\u8fd9\u4e2a\u7ed3\u70b9\u6ee1\u8db3\u4ece\u6839\u8d70\u5230\u5bf9\u5e94\u7ed3\u70b9\u6240\u5bf9\u5e94\u7684\u5b57\u7b26\u4e32\uff0c\u662f\u5f53\u524d\u7ed3\u70b9\u5bf9\u5e94\u7684\u5b57\u7b26\u4e32\u7684 \u6700\u957f\u540e\u7f00 \u3002\u6bd4\u5982\u5f53\u524d\u7ed3\u70b9\u5bf9\u5e94\u5b57\u7b26\u4e32\u662fabaaa\uff0ctrie\u6811\u4e0a\u8fd8\u6709\u53e6\u4e00\u6761\u8def\u5f84\u8868\u793aaaa\uff0c\u5219\u5176fail\u6307\u5411\u6b64\u7ed3\u70b9\u3002 \u5f53\u6211\u4eec\u5339\u914d\u8fc7\u7a0b\u4e2d\u5931\u914d\u65f6\uff08\u8d70\u5230\u67d0\u4e00\u4e2a\u7ed3\u70b9\u540e\uff0ctrie\u6811\u4e0a\u5bf9\u5e94\u4e0b\u4e00\u4e2a\u5b57\u7b26\u7684\u7ed3\u70b9\u4e0d\u5b58\u5728\uff09\uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u8df3\u5230fail\uff0c\u518d\u7ee7\u7eed\u5c1d\u8bd5\u5339\u914d\u3002\u8fd9\u76f8\u5f53\u4e8e\u629b\u5f03\u4e00\u90e8\u5206\u5f53\u524d\u6a21\u5f0f\u4e32\u524d\u7f00\u4f7f\u5f97\u5339\u914d\u80fd\u591f\u7ee7\u7eed\u8fdb\u884c\u3002 \u5177\u4f53\u6784\u5efa\u65b9\u5f0f\u662f\u7528bfs\uff0c\u53d6\u51fa\u961f\u5934\u7ed3\u70b9u\uff0c\u7136\u540e\u904d\u5386\u6b64\u8282\u70b9\u7684\u63a5\u4e0b\u6765\u7684\u6240\u6709\u53ef\u80fd\u5b57\u7b26i\uff080~25\uff09\uff0c\u6309\u7167\u5982\u4e0b\u4ee3\u7801\u9012\u63a8\u5730\u66f4\u65b0\u4e0b\u4e00\u4e2a\u7ed3\u70b9\u7684fail\u6307\u9488\uff1a 1 fail[trie[u][i]]=trie[fail[u]][i]; \u4e5f\u5373\u8ba9\u4e0b\u4e00\u4e2a\u7ed3\u70b9\u7684fail\u6307\u9488\uff0c\u6307\u5411\u5f53\u524d\u7ed3\u70b9fail\u6307\u9488\u7684\u4e0b\u4e00\u4e2a\u5b57\u7b26i\u5bf9\u5e94\u7684\u7ed3\u70b9\u3002\u56e0\u4e3a\u662f\u7528bfs\uff0c\u53ef\u4ee5\u4fdd\u8bc1\u4e0b\u4e00\u4e2a\u7ed3\u70b9\u66f4\u6d45\u7684\u7ed3\u70b9\u5df2\u7ecf\u88ab\u66f4\u65b0\uff0c\u6240\u4ee5\u53ef\u4ee5\u8fd9\u4e48\u505a\u3002 \u5176\u4ed6\u8be6\u7ec6\u4fe1\u606f\u8bf7\u53c2\u89c1\u6587\u5934\u6240\u7ed9\u94fe\u63a5\u3002","title":"AC\u81ea\u52a8\u673a"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_73","text":"\u4f7f\u7528fail\u6307\u9488\u5728\u5931\u914d\u65f6\u8df3\u8dc3\u5f88\u86cb\u75bc\uff0c\u56e0\u4e3a\u5982\u679c\u8df3\u4e86\u4e4b\u540e\u8fd8\u662f\u5931\u914d\u90a3\u4e48\u4f60\u8fd8\u662f\u5f97\u7ee7\u7eed\u4ecefail[u]\u7ee7\u7eed\u8df3\u5230fail[fail[u]]\uff0c\u90a3\u4e48\u6709\u6ca1\u6709\u66f4\u597d\u7684\u65b9\u6cd5\u5462\uff1f \u6ce8\u610f\u5230\u5982\u679c\u5728u\u5904\u524d\u5f80i\u5b57\u7b26\u65f6\u5931\u914d\uff0c\u90a3\u4e48trie[u][i] \u5fc5\u7136\u672a\u5b9a\u4e49\uff0c\u6211\u4eec\u901a\u8fc7\u6539\u5199trie[u][i] \u4f7f\u5f97\u5176\u76f4\u63a5\u6307\u5411\u4e0b\u4e00\u4e2a\u4e0d\u5931\u914d\u7684fail\u5373\u53ef\u3002 \u6bd4\u5982\uff1a 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u3002\u3002\u3002 \uff08\u524d\u9762\u662fBFS\u53d6\u51fa\u961f\u5934u\u7ed3\u70b9\uff09 for(int i=0;i<26;i++) { if(trie[u][i]) { fail[trie[u][i]]=trie[fail[u]][i]; q.push(trie[u][i]); } else { trie[u][i]=trie[fail[u]][i]; } } \u3002\u3002\u3002 \u4f7f\u7528 trie[u][i]=trie[fail[u]][i]; \u5728\u6c42fail\u7684\u540c\u65f6\u6539\u5199\u672a\u5b9a\u4e49trie\u6307\u9488\u5373\u53ef\u3002\u8fd9\u6837\uff0c\u5728\u5339\u914d\u65f6\u53ef\u4ee5\u76f4\u63a5\u4ee4 u=trie[u][i] \uff08\u4e0d\u8bba\u662f\u5426\u5931\u914d\uff09\u3002 \u8fd9\u6837\u4e4b\u540etrie\u5176\u5b9e\u5df2\u7ecf\u4e0d\u518d\u662f\u4e00\u68f5\u6811\uff0c\u800c\u662f\u4e00\u4e2a\u4f1a\u81ea\u6307\u7684\u56fe\uff0c\u6211\u4eec\u79f0\u4e4b\u4e3a\u5b57\u5178\u56fe\u3002","title":"\u5b57\u5178\u56fe"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#last","text":"\u4e8b\u5b9e\u4e0a\uff0c\u6c42\u6bcf\u4e2a\u6a21\u5f0f\u4e32\u5728\u4e3b\u4e32\u4e2d\u7684\u51fa\u73b0\u6b21\u6570\uff0c\u4e0d\u4ec5\u9700\u8981\u5728\u5b57\u5178\u56fe\u4e0a\u904d\u5386\uff0c\u800c\u4e14\u6bcf\u904d\u5386\u4e00\u4e2a\u7ed3\u70b9\u8fd8\u5f97\u8df3fail\uff08\u4e0d\u8bba\u5931\u914d\u4e0e\u5426\uff09\uff0c\u56e0\u4e3a\u4f60\u5e76\u4e0d\u77e5\u9053\u5f53\u524d\u5339\u914d\u4f4d\u7f6e\u6709\u591a\u5c11\u4e2a\u6a21\u5f0f\u4e32\u80fd\u5339\u914d\u3002 \u6bd4\u5982\uff1a\u4e3b\u4e32abaaa\uff0c\u6a21\u5f0f\u4e32aaa\u3001baaa\uff1b\u5339\u914d\u5230\u4e3b\u4e32\u7684\u6700\u540e\u4e00\u4e2aa\u65f6\uff0c\u4f1a\u5728trie\u56fe\u4e0a\u7684baaa\u5904\uff0c\u4f46\u8fd8\u662f\u5f97\u8df3fail\uff0c\u8df3\u5230trie\u56fe\u4e0a\u7684aaa\u4e0a\uff0c\u624d\u80fd\u77e5\u9053\u8fd9\u4e2a\u5b57\u7b26\u4e32\u4e5f\u5728\u4e3b\u4e32\u6700\u540e\u4e00\u4e2aa\u5904\u6210\u529f\u5339\u914d\u3002 \u8fd9\u4e2a\u505a\u6cd5\u5e26\u6765\u7684\u4ee3\u4ef7\u5176\u5b9e\u53ef\u4ee5\u6362\u6210\u53e6\u4e00\u79cd\u505a\u6cd5\u4ee5\u5f7b\u5e95\u6539\u5584\uff08\u89c1\u4e0b\u6587fail\u6811\uff09\uff0c\u4f46\u8fd9\u91cc\u5148\u8bf4\u660e\u53e6\u4e00\u79cd\u4f18\u5316\u65b9\u6cd5\u3002 \u5728\u8df3fail\u7684\u8fc7\u7a0b\u4e2d\uff0c\u5e76\u4e0d\u662f\u6bcf\u4e00\u4e2a\u7ed3\u70b9\u90fd\u662f\u67d0\u4e00\u6a21\u5f0f\u4e32\u7684\u7ec8\u70b9\u3002\u800c\u5728\u5b57\u5178\u56fe\u6784\u5efa\u5b8c\u6bd5\u540e\uff0cfail\u6811\u5176\u5b9e\u5bf9\u5339\u914d\u800c\u8a00\u610f\u4e49\u5c31\u4e0d\u5927\u4e86\uff0c\u56e0\u6b64\u6211\u4eec\u5e0c\u671bfail\u80fd\u76f4\u63a5\u8df3\u5230\u201c\u67d0\u4e2a\u6a21\u5f0f\u4e32\u201d\u7684\u7ed3\u5c3e\u3002\u6211\u4eec\u5f15\u5165last\u6570\u7ec4\uff0c\u5176\u53ef\u4ee5\u76f4\u63a5\u8df3\u5230\u201c\u67d0\u4e2a\u6a21\u5f0f\u4e32\u201d\u7684\u7ed3\u5c3e\u3002 \u6211\u4eec\u5728\u6784\u5efafail\u6307\u9488\u65f6\u6dfb\u52a0\u8fd9\u4e48\u4e00\u53e5\u8bdd\uff1a 1 2 3 4 5 6 ... fail[trie[u][i]]=trie[fail[u]][i]; last[trie[u][i]]=(id[fail[trie[u][i]]]==0)?(last[fail[trie[u][i]]]):(fail[trie[u][i]]); //\u6709\u6548\u5b57\u7b26\u4e32\u7ed3\u5c3e q.push(trie[u][i]); ... id[u] \u8868\u793a\u7ed3\u70b9u\u4f5c\u4e3a\u67d0\u4e00\u6a21\u5f0f\u4e32\u7684\u7ed3\u5c3e\uff0c\u5bf9\u5e94\u7684\u5b57\u7b26\u4e32\u7f16\u53f7\uff08\u5982\u679cu\u4e0d\u662f\u67d0\u4e00\u4e32\u7684\u7ed3\u5c3e\u8282\u70b9\uff0c\u90a3\u4e48\u5176\u4e3a0\uff09\u3002\u901a\u8fc7last\u7684\u9012\u63a8\u5373\u53ef\u6c42\u5f97last\u6570\u7ec4\u3002\u5728\u5339\u914d\u6c42\u89e3\u6bcf\u4e2a\u6a21\u5f0f\u4e32\u5728\u4e3b\u4e32\u4e2d\u7684\u51fa\u73b0\u6b21\u6570\u7684\u8fc7\u7a0b\u4e2d\uff0c\u6539\u8df3last\u800c\u975efail\u5373\u53ef\u3002 \u4f46\u8fd9\u4e48\u505a\u7684\u4f18\u5316\u4ec5\u4ec5\u53ea\u662f\u5e38\u6570\u4e0a\u7684\uff0c\u5982\u679c\u7ed9\u82e5\u5e72\u4e2a\u6a21\u5f0f\u4e32a\u3001aa\u3001aaa\u3001aaaa\u2026\u2026\uff0c\u90a3\u8fd8\u662f\u4f1a\u88ab\u5361\uff0c\u56e0\u6b64\u6211\u4eec\u5f15\u5165fail\u6811\u3002","title":"last\u4f18\u5316"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#fail","text":"\u5c06\u6240\u6709\u7ed3\u70b9\u7684fail\u6307\u9488\u53cd\u8fc7\u6765\u63a5\uff0c\u5c06\u6784\u6210\u4e00\u4e2a\u4ee5trie\u56fe0\u7ed3\u70b9\u4e3a\u6839\u7684\u6811\uff0c\u6210\u4e3afail\u6811\u3002\u4ecefail\u6811\u5411\u4e0b\u8d70\uff0c\u76f8\u5f53\u4e8e\u5728\u5f53\u524d\u5b57\u7b26\u4e32\u524d\u6dfb\u52a0\u524d\u7f00\u3002\u6bd4\u5982abb\uff0c\u4ecefail\u6811\u5411\u4e0b\u8d70\u5230fuabb\uff08\u5f53\u7136\u53ef\u80fd\u4f1a\u6709\u597d\u51e0\u4e2a\u5b69\u5b50\uff0c\u8fd9\u91cc\u53ea\u662f\u4e3e\u4e2a\u4f8b\u5b50\uff09\u3002 \u6784\u5efa\u6b64\u6811\u4e5f\u5f88\u7b80\u5355\uff0c\u5728fail\u6307\u9488\u6784\u5efa\u5b8c\u6210\u540e\uff1a 1 2 3 4 for(int i=1;i<=total;i++) { adde(fail[i],i); } \u56de\u5230\u4e0a\u9762\u7684\u95ee\u9898\uff0c\u4e4b\u524d\u6211\u4eec\u901a\u8fc7last\u6570\u7ec4\u8fdb\u884c\u4e86\u4f18\u5316\u3002\u73b0\u5728\u5229\u7528fail\u6811\uff0c\u6211\u4eec\u53ef\u4ee5\u5229\u7528\u6811\u4e0a\u5dee\u5206\u7684\u65b9\u6cd5\uff0c\u6307\u5728\u5f53\u524d\u7ed3\u70b9u\u5904\u6dfb\u52a0\u4e00\u4e2a\u6807\u8bb01\uff0c\u8868\u793a\u81eau\u5230\u6839\u7684\u8def\u5f84\u90fd\u4f1a\u53d7\u6b64\u6807\u8bb0\u5f71\u54cd\u3002\u5339\u914d\u7ed3\u675f\u4e4b\u540e\u5bf9fail\u6811\u505adfs\u4ee5\u6c42\u51fa\u5dee\u5206\u7684\u76f8\u52a0\u503c\uff0c\u6700\u540e\u770b\u6bcf\u4e00\u4e2a\u7ed3\u70b9\u7684\u503c\uff0c\u6b64\u503c\u5c31\u662f\u5bf9\u5e94\u7684\u5b57\u7b26\u4e32\u7684\u51fa\u73b0\u6b21\u6570\u3002 \u5f53\u7136fail\u6811\u8fd8\u6709\u5f88\u591a\u7528\u9014\uff0c\u9664\u4e86\u5dee\u5206\u4e4b\u5916\uff0c\u8fd8\u53ef\u4ee5\u5bf9\u5176dfn+\u7ebf\u6bb5\u6811\u3001\u6811\u72b6\u6570\u7ec4\u3001\u6811\u94fe\u5256\u5206\u2026\u2026\u55ef\u3002 P3808 \u3010\u6a21\u677f\u3011AC\u81ea\u52a8\u673a\uff08\u7b80\u5355\u7248\uff09 \u677f\u5b50\u9898\uff0c\u53ea\u7528\u6c42\u51fa\u51fa\u73b0\u7684\u6a21\u5f0f\u4e32\u800c\u4e0d\u9700\u8981\u7edf\u8ba1\u4e2a\u6570\uff0c\u76f4\u63a5\u8df3fail\u6307\u9488\u5b8c\u6210\u5339\u914d\u3002 P3796 \u3010\u6a21\u677f\u3011AC\u81ea\u52a8\u673a\uff08\u52a0\u5f3a\u7248\uff09 \u540c\u6837\u662f\u677f\u5b50\u9898\uff0c\u6c42\u51fa\u51fa\u73b0\u7684\u6a21\u5f0f\u4e32\u7684\u6b21\u6570\uff0c\u6539\u7528last\u6307\u9488\u8df3\u8dc3\u5373\u53ef\u3002 P5357 \u3010\u6a21\u677f\u3011AC\u81ea\u52a8\u673a\uff08\u4e8c\u6b21\u52a0\u5f3a\u7248\uff09 \u9898\u610f\u548c\u52a0\u5f3a\u7248\u76f8\u540c\uff0c\u4f46\u9700\u8981\u7528fail\u6811+\u5dee\u5206\u624d\u80fd\u8fc7\uff08\u89c4\u907f\u6389\u5339\u914d\u65f6\u8df3\u4efb\u4f55\u6307\u9488\uff09\uff0c\u5177\u4f53\u505a\u6cd5\u4e0a\u6587\u5df2\u6709\u63cf\u8ff0 Educational Codeforces Round 97 (Rated for Div. 2) G\uff1aDeath DBMS \u9898\u610f\uff1a\u7ed9\u4e00\u5806\u6a21\u5f0f\u4e32\uff08\u53ef\u80fd\u672c\u8d28\u76f8\u540c\uff0c\u4f46\u4ed6\u4eec\u7684\u7f16\u53f7\u4e0d\u540c\uff09\uff0c\u6bcf\u4e2a\u7f16\u53f7\u5bf9\u5e94\u7684\u5b57\u7b26\u4e32\u521d\u59cb\u6743\u503c\u4e3a0\uff0c\u7136\u540e\u7ed9\u51fa\u4e24\u79cd\u64cd\u4f5c\uff1a\u7b2c\u4e00\u79cd\u64cd\u4f5c\u7ed9\u51fa\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u6c42\u51fa\u5176\u4e2d\u51fa\u73b0\u7684\u6a21\u5f0f\u4e32\u7684\u6700\u5927\u6743\u503c\uff1b\u7b2c\u4e8c\u79cd\u64cd\u4f5c\u7ed9\u51fa\u4e24\u4e2a\u6570x y\uff0c\u8981\u5c06\u7b2cx\u4e2a\u6a21\u5f0f\u4e32\u7684\u6743\u503c\u6539\u4e3ay \u89e3\u6cd5\uff1a\u6ce8\u610f\u6b64\u9898\u4e2d\uff0c\u4e24\u4e2a\u672c\u8d28\u76f8\u540c\u7684\u5b57\u7b26\u4e32\u53ef\u80fd\u4f1a\u6709\u4e0d\u540c\u7684\u6743\u503c\u3002 \u4f7f\u7528ac\u81ea\u52a8\u673a\u6784\u5efa\u5b57\u5178\u56fe\uff0c\u90a3\u4e48\u201c\u4e24\u4e2a\u672c\u8d28\u76f8\u540c\u7684\u5b57\u7b26\u4e32\u53ef\u80fd\u4f1a\u6709\u4e0d\u540c\u7684\u6743\u503c\u201d\u5c31\u76f8\u5f53\u4e8e\u5728\u5b57\u5178\u56fe\u7684\u7ed3\u70b9\u4e0a\u7ef4\u62a4\u591a\u4e2a\u6743\u503c\uff08\u4fee\u6539\u548c\u67e5\u8be2\u6700\u5927\u503c\uff09\u3002 \u53ef\u4ee5\u5728\u6bcf\u4e2a\u7ed3\u70b9\u4e0a\u5f00\u4e2a\u52a8\u6001\u5f00\u70b9\u7684\u7ebf\u6bb5\u6811\u3002\u4f46\u4e3a\u4e86\u5b9e\u73b0\u65b9\u4fbf\uff0c\u8fd9\u91cc\u4f7f\u7528N\u4e2a\uff08N\u4e3a\u5b57\u5178\u56fe\u4e2d\u7ed3\u70b9\u4e2a\u6570\uff09multiset\u6765\u7ef4\u62a4\u6bcf\u4e2a\u7ed3\u70b9\u4e0a\u7684\u591a\u4e2a\u6743\u503c\u3002 \u5269\u4e0b\u7684\u5c31\u7b80\u5355\u4e86\u3002\u5bf9\u4e8e\u64cd\u4f5c\u4e00\uff0c\u7528ac\u81ea\u52a8\u673a\u5339\u914d\uff0c\u6bcf\u8d70\u5230\u4e00\u4e2a\u7ed3\u70b9\u8df3last\uff08\u8fd9\u9898\u7684\u6570\u636e\u8df3fail\u4f1at\uff09\uff0c\u7136\u540e\u6c42\u5bf9\u5e94\u7ed3\u70b9multiset\u4e2d\u503c\u7684\u6700\u5927\u503c\u3002\u5bf9\u4e8e\u64cd\u4f5c2\uff0c\u5728\u5b57\u5178\u56fe\u4e0a\u627e\u5230\u5bf9\u5e94\u4e32\u540e\u4fee\u6539\u5bf9\u5e94multiset\uff08\u5220\u9664\u65e7\u7684\u6743\u503c\u5e76\u63d2\u5165\u65b0\u6743\u503c\uff09\u5373\u53ef","title":"fail\u6811"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_74","text":"\u540e\u7f00\u6570\u7ec4SA \uff1a\u5b57\u7b26\u4e32\u5404\u4e2a\u540e\u7f00\u7684\u6392\u540d\u5230\u4e0b\u6807\u7684\u6620\u5c04\u3002\u5982aabab\uff0c\u6309\u5b57\u5178\u5e8f\u4ece\u5c0f\u5230\u5927\u6392\uff0c\u540e\u7f00\u5206\u522b\u4e3aaabab\u3001ab\u3001abab\u3001b\u3001bab\uff0csa[1~5 ] =1 4 2 5 3 \u6392\u540d\u6570\u7ec4RK \uff1a\u4ece\u67d0\u4e00\u4f4d\u7f6ei\u5f00\u59cb\u5230\u5b57\u7b26\u4e32\u672b\u5c3e\u6240\u6784\u6210\u7684\u540e\u7f00\uff0c\u5728\u6240\u6709\u540e\u7f00\u4e2d\u7684\u6392\u540d\u3002\u76f8\u5f53\u4e8eSA\u7684\u9006\u6620\u5c04\u3002 \u6c42\u6cd5 \uff1a\u500d\u589e\u6cd5\u3002\u6bcf\u6b21\u8003\u8651\u957f\u5ea6w\u4e3a1\u30012\u30014\u30018\u2026\u2026\uff08\u5230\u5c0f\u4e8e\u7b49\u4e8en\u7684\u6700\u59272\u7684\u5e42\u6b21\u4e3a\u6b62\uff09\u7684\u5b50\u4e32\uff0c\u5bf9\u4e8e\u67d0\u4e2a\u4f4d\u7f6ei\uff0c\u7528\u5176\u4f4d\u7f6ei\u7684sa\u5bf9\u5e94\u503c\u4f5c\u4e3a\u7b2c\u4e00\u5173\u952e\u5b57\uff0c\u4f4d\u7f6e\u4e3ai+w\u7684sa\u5bf9\u5e94\u503c\u4f5c\u4e3a\u7b2c\u4e8c\u5173\u952e\u5b57\uff08\u5982\u679ci+w\u5927\u4e8en\u5c31\u770b\u6210\u65e0\u7a77\u5c0f\uff09\uff0c\u8fdb\u884c\u6392\u5e8f\u3002\u7531\u4e8e\u53ea\u6709\u4e24\u4e2a\u5173\u952e\u5b57\uff0c\u56e0\u6b64\u6392\u5e8f\u4f7f\u7528\u7ebf\u6027\u6392\u5e8f\u6cd5 \uff08\u6bd4\u5982\u8ba1\u6570\u6392\u5e8f\u6216\u8005\u57fa\u6570\u6392\u5e8f\uff0c\u4e0b\u6587\u4e2d\u4e3b\u8981\u91c7\u7528\u8ba1\u6570\u6392\u5e8f\uff0c\u56e0\u5176\u590d\u6742\u5ea6\u53ea\u548c\u503c\u57df\u6709\u5173\uff09\uff0c\u53ef\u5c06\u6c42SA\u7684\u6574\u4f53\u65f6\u95f4\u590d\u6742\u5ea6\u4e0b\u964d\u81f3O\uff08nlogn\uff09\u3002\u5177\u4f53\u53c2\u89c1\u4ee3\u7801\u3002 \u53e6\u4e00\u79cd\u6c42\u6cd5\u662f\u7528\u540e\u7f00\u81ea\u52a8\u673a\u3002\u53c2\u89c1\u201c\u540e\u7f00\u81ea\u52a8\u673a\u201d\u4e00\u8282\u3002","title":"\u540e\u7f00\u6570\u7ec4"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#height","text":"\u542b\u4e49\uff1a\u7b2ci\u540d\u548c\u7b2ci-1\u540d(\u6ce8\u610f\u662f\u6392\u540d)\u7684\u6700\u957f\u516c\u5171\u524d\u7f00\u957f\u5ea6 1 height[i]=lcp(sa[i],sa[i-1]) \u5f15\u7406\uff1a\u7b2ci\u4e2a\u4f4d\u7f6e\u7684\u540e\u7f00\u5bf9\u5e94\u7684height\u503c\uff0c\u5927\u4e8e\u7b49\u4e8e\u4e0a\u4e00\u4e2a\u4f4d\u7f6e\uff08i-1\uff09\u7684height\u503c-1 1 height[rk[i]]>=height[rk[i-1]]-1 \u6c42\u89e3\uff1a\u501f\u52a9\u4e0a\u9762\u7684\u5f15\u7406\u53ef\u5728On\u65f6\u95f4\u5185\u6c42\u51faheight\u6570\u7ec4\u3002 1 2 3 4 5 for ( i = 1 , k = 0 ; i <= n ; ++ i ) { if ( k ) -- k ; while ( s [ i + k ] == s [ sa [ rk [ i ] - 1 ] + k ]) ++ k ; ht [ rk [ i ]] = k ; // height\u592a\u957f\u4e86\u7f29\u5199\u4e3aht }","title":"Height \u6570\u7ec4"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#height_1","text":"","title":"Height \u6570\u7ec4\u7684\u5e94\u7528"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#suffix-automatorsam","text":"\u540e\u7f00\u81ea\u52a8\u673a\u662f\u80fd\u591f\u5339\u914d\u67d0\u4e2a\u5b57\u7b26\u4e32S\u7684\u6240\u6709\u540e\u7f00\u7684\u81ea\u52a8\u673a\u3002\u5c31\u662f\u8bf4\u53d6S\u7684\u4efb\u4f55\u4e00\u4e2a\u540e\u7f00\uff08\u5305\u62ecS\u81ea\u8eab\uff09\uff0c\u5728SAM\u4e2d\u4ece\u5f00\u59cb\u8282\u70b9t0\u8d70\uff0c\u80af\u5b9a\u90fd\u80fd\u8d70\u5230\u67d0\u4e00\u4e2a\u7ec8\u6b62\u72b6\u6001\u3002 \u7b26\u5408\u8fd9\u4e2a\u6027\u8d28\u7684\u56fe\u662f\u6709\u5411\u65e0\u73af\u56fe\uff0c\u5e76\u4e14\u6709\u5f88\u591a\u56fe\u90fd\u7b26\u5408\u4e0a\u9762\u7684\u8981\u6c42\u3002\u4f46SAM\u662f\u5176\u4e2d\u8282\u70b9\u6570\u91cf\u6700\u5c11\u7684\u4e00\u4e2a\uff08 \u6781\u5c0f\u6027 \uff09\u3002","title":"\u540e\u7f00\u81ea\u52a8\u673a\uff08Suffix Automator\uff0cSAM\uff09"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#endpossam","text":"\u5b57\u7b26\u4e32S=abcbc\u3002\u8003\u8651\u5b50\u4e32bc\u5728S\u7684\u7ec8\u6b62\u4f4d\u7f6e\uff08endpos\u96c6\u5408\uff09\uff0c\u4e3a3\u30015\u3002\u5b50\u4e32c\u5728S\u4e2d\u7684\u7ec8\u6b62\u4f4d\u7f6e\u4e5f\u4e3a3\u30015\u3002\u50cf\u8fd9\u6837\u7ec8\u6b62\u4f4d\u7f6e\u96c6\u5408\u5b8c\u5168\u76f8\u540c\u7684S\u7684\u5b50\u4e32\u79f0\u4e3aendpos\u7b49\u4ef7\u7c7b\u3002 \u5728SAM\u4e2d\uff0c SAM\u7684\u4e00\u4e2a\u8282\u70b9\u5c31\u4ee3\u8868\u4e00\u4e2aendpos\u7b49\u4ef7\u7c7b \u3002\u56e0\u6b64\u5982\u679c\u6709\u4e00\u4e2a\u8282\u70b9\u4ee3\u8868\u5b50\u4e32bc\uff0c\u5219\u8fd9\u4e2a\u8282\u70b9\u4e5f\u4ee3\u8868\u5b50\u4e32c\uff0c\u53cd\u4e4b\u4ea6\u7136\u3002","title":"endpos\u7b49\u4ef7\u7c7b\u3001SAM\u4e2d\u7684\u8282\u70b9\u610f\u4e49"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#len","text":"\u663e\u7136\u4e00\u4e2a\u7b49\u4ef7\u7c7b\u4e2d\u53ef\u80fd\u5305\u542b\u591a\u4e2aS\u7684\u5b50\u4e32\uff0c\u6211\u4eec\u53d6\u5176\u4e2d\u6700\u957f\u7684\u4e00\u4e2a\uff0c\u4f5c\u4e3a\u8fd9\u4e2a\u7b49\u4ef7\u7c7b\u5bf9\u5e94\u8282\u70b9v\u7684\u6700\u957f\u4e32\uff0c\u5e76\u8bb0len\uff08v\uff09\u4e3a\u8fd9\u4e2a\u6700\u957f\u4e32\u7684\u957f\u5ea6\u3002","title":"\u8282\u70b9\u7684\u6700\u957f\u4e32\u3001\u8282\u70b9\u7684len"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#linkfather","text":"\u8282\u70b9\u7684\u6700\u957f\u4e32\u7684\u524d\u51e0\u4e2a\uff08\u6309\u7167\u957f\u5ea6\u9012\u51cf\u6765\u6570\uff09\u540e\u7f00\u90fd\u4f1a\u5728\u8fd9\u4e2a\u8282\u70b9\u6240\u5728\u7b49\u4ef7\u7c7b\u4e2d\u3002\u4f46\u53ef\u80fd\u4ece\u4e4b\u540e\u67d0\u4e2a\u4f4d\u7f6e\u5f00\u59cb\u7684\u540e\u7f00\u5c31\u90fd\u4e0d\u5728\u8fd9\u4e2a\u7b49\u4ef7\u7c7b\u4e2d\u4e86\u3002\u6211\u4eec\u8bb0\u4e0d\u5728\u5f53\u524d\u8282\u70b9\u7b49\u4ef7\u7c7b\u4e2d\u6700\u957f\u7684\u4e32\u4e3aB\uff0c\u5219B\u5bf9\u5e94\u53e6\u4e00\u4e2a\u7b49\u4ef7\u7c7bu\uff08\u5982\u679cB\u4e0d\u5b58\u5728\uff0c\u5c31\u4ee4u\u4e3aSAM\u7684\u8d77\u59cb\u8282\u70b9\uff09\u3002\u6211\u4eec\u4ee4link\uff08v\uff09=u\uff0c\u79f0\u4e3a \u540e\u7f00\u94fe\u63a5 \u3002 \u6240\u6709SAM\u4e2d\u7684\u8282\u70b9\uff08\u9664\u4e86\u8d77\u59cb\u8282\u70b9\uff09\u90fd\u6709\u540e\u7f00\u8fde\u63a5\u3002\u8fd9\u4e9b\u540e\u7f00\u8fde\u63a5\u6784\u6210\u4e00\u9897\uff08\u6709\u5411\uff09\u6811\uff0c\u4ece\u53f6\u5b50\u6307\u5230\u6811\u6839\u3002\u79f0\u4e4b\u4e3a \u540e\u7f00\u94fe\u63a5\u6811 \u3002","title":"\u8282\u70b9\u7684link\uff08father\uff09"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_75","text":"\u5de6\u56fe\u662f\u5b57\u7b26\u4e32S=abcbc\u7684\u540e\u7f00\u81ea\u52a8\u673a\uff08SAM\uff09\uff0c\u53f3\u56fe\u4e3a\u5176\u540e\u7f00\u94fe\u63a5\u6811\u3002 \u5b57\u7b26\u4e32S\u7684\u6240\u6709\u524d\u7f00\u5728\u81ea\u52a8\u673a\u4e2d\u4e5f\u5bf9\u5e94\u7740\u4e0d\u540c\u7684\u8282\u70b9\u3002\u4ece\u521d\u59cb\u72b6\u6001t0\u5f00\u59cb\u6309\u7167\u5b57\u7b26\u4e32S\u8d70\uff0c\u6240\u7ecf\u8fc7\u7684\u8282\u70b9\u88ab\u79f0\u4e3a \u7ec8\u70b9\u8282\u70b9 \u3002\u5982\u53f3\u56fe\u4e2d\u7684a\u3001ab\u3001abc\u3001abcb\u3001abcbc\u3002\uff08\u6ce8\u610f\u548c\u7ec8\u6b62\u72b6\u6001\u533a\u5206\uff09 \u5b9a\u4e49\u6bcf\u4e2a\u8282\u70b9\u7684 \u7ec8\u70b9\u96c6\u5408 \uff1a\u6bcf\u4e2a\u8282\u70b9\u7684\u7ec8\u70b9\u96c6\u5408\u7b49\u4e8e\u5176 \u5b50\u6811 \u5185\u6240\u6709\u7ec8\u70b9\u8282\u70b9\u5bf9\u5e94\u7684\u7ec8\u70b9\u7684\u96c6\u5408\u3002\u6bd4\u5982b\u8282\u70b9\u7684\u5b50\u6811\u4e2d\u6709ab\u3001abcb\u8282\u70b9\uff0cb\u7684\u7ec8\u70b9\u96c6\u5408\u5c31\u662fab\u3001abcb\u8282\u70b9\u3002 \u5982\u679c\u8282\u70b9 A \u662f B \u7684\u7956\u5148\uff0c\u5219\u8282\u70b9 A \u5bf9\u5e94\u7684\u5b57\u7b26\u4e32\u662f\u8282\u70b9 B \u5bf9\u5e94\u7684\u5b57\u7b26\u4e32\u7684 \u540e\u7f00 \u3002 S\u7684\u524d\u7f00\u5b50\u4e32s1(1,p) s2(1,q)\u5bf9\u5e94\u7684\u6700\u957f\u516c\u5171\u540e\u7f00\uff0c\u662f\u4e24\u4e32\u5bf9\u5e94\u8282\u70b9u\u3001v\u7684LCA\u5bf9\u5e94\u5b57\u7b26\u4e32\u3002 \u8282\u70b9len\u7684\u5927\u5c0f\u968f\u7740\u6df1\u5ea6\u9012\u589e\u800c\u4e0d\u4e0b\u964d\u3002 \u540e\u7f00\u94fe\u63a5\u6811\u4e2d\u7684\u975e\u53f6\u5b50\u8282\u70b9\u5bf9\u5e94\u7684\u6700\u957f\u4e32\uff0c\u8fd9\u4e2a\u6700\u957f\u4e32\u76f8\u5f53\u4e8e\u4ece\u5176\u7ec8\u70b9\u96c6\u5408\u4e2d\u7684\u4efb\u610f\u4e00\u4e2a\u7ec8\u70b9\u7684\u4e0b\u6807\u5f80\u524d\u53d6\u8fd9\u4e2a\u975e\u53f6\u5b50\u8282\u70b9\u7684len\u4e2a\u957f\u5ea6\uff08\u5305\u542b\u8fd9\u4e2a\u5f00\u59cb\u53d6\u7684\u4f4d\u7f6e\uff09\u7684\u5b57\u7b26\u7ec4\u6210\u3002 \u540e\u7f00\u94fe\u63a5\u6811\u4e2d\u7684\u53f6\u5b50\u8282\u70b9\u5c31\u662f\u7ec8\u70b9\u8282\u70b9\u3002\u4f46\u53cd\u8fc7\u6765\u4e0d\u4e00\u5b9a\u6210\u7acb\uff08\u5982S=ababa\uff0caba\u662f\u524d\u7f00\uff0c\u4f46aba\u51fa\u73b0\u4e86\u4e24\u6b21\uff0c\u6709\u66f4\u957f\u7684ababa\u4f5c\u4e3a\u5176\u513f\u5b50\uff09\u3002\u8fd9\u662f\u7531\u4e8e\u5176\u4ed6\u51fa\u73b0\u53ea\u6709\u4e00\u6b21\u7684\u975e\u524d\u7f00\u4e32\u90fd\u88ab\u5305\u542b\u5728\u67d0\u4e00\u53ea\u51fa\u73b0\u4e00\u6b21\u7684\u524d\u7f00\u4e32\u4e2d\u4e86\u3002\u6362\u53e5\u8bdd\u8bf4\u5982\u679cbab\u53ea\u51fa\u73b0\u4e86\u4e00\u6b21\uff0c\u90a3\u4e48\uff08\u4ece\u5934\u5230\uff09...bab\u4e5f\u80af\u5b9a\u53ea\u51fa\u73b0\u4e00\u6b21\u3002 \u8bbe\u6240\u6709\u7ec8\u70b9\u8282\u70b9\u7684siz\u4e3a1\u3002\u4ece\u53f6\u5b50\u8282\u70b9\u5f00\u59cbbfs\uff0c\u7d2f\u52a0siz\uff0c\u975e\u53f6\u5b50\u8282\u70b9\u7684siz\u503c\u5c31\u662f\u8fd9\u4e2a\u8282\u70b9\u7684\u7ec8\u70b9\u96c6\u5408\u5927\u5c0f\uff0c\u4e5f\u5373\u8fd9\u4e2a\u8282\u70b9\u5bf9\u5e94\u6700\u957f\u4e32\u51fa\u73b0\u7684\u6b21\u6570\u3002\uff08\u540e\u9762\u6a21\u677f\u9898\u4f1a\u7528\u5230\uff09","title":"\u540e\u7f00\u94fe\u63a5\u6811\u3001\u7ec8\u70b9\u8282\u70b9"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_76","text":"\u6b65\u9aa4\u6709\u70b9\u9ebb\u70e6\uff08\u5176\u5b9e\u8fd8\u597d\uff09\uff0c\u53c2\u89c1https://oi-wiki.org/string/sam/ \u72b6\u6001\u6570\u4e0d\u4f1a\u8d85\u8fc72n-1 \u8f6c\u79fb\u6570\u4e0d\u4f1a\u8d85\u8fc73n-4 \u6784\u5efa\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a\u7ebf\u6027\u7ea7\u522b","title":"\u6784\u5efa\u65b9\u6cd5"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_77","text":"\u7ed9\u5b9a\u7684\u5b57\u7b26\u4e32P\u662f\u5426\u5728S\u4e2d\u51fa\u73b0\uff1a \u76f4\u63a5\u4ece\u8d77\u70b9\u8d70\uff0c\u4e2d\u9014\u9047\u5230\u67d0\u4e2a\u5b57\u6bcd\u8d70\u4e0d\u4e0b\u53bb\u4e86\u5c31\u8bf4\u660e\u6ca1\u51fa\u73b0 \u4e0d\u540c\u5b50\u4e32\u4e2a\u6570\uff1a \u6709\u5411\u65e0\u73af\u56fe\u52a8\u6001\u89c4\u5212\u3002\u6216\u8005\u7528len\uff08i\uff09-len\uff08link\uff08i\uff09\uff09\u5bf9\u6bcf\u4e2a\u7ed3\u70b9\u6c42\u548c\u3002\uff08\u8fd9\u4e2a\u5f0f\u5b50\u662f\u76f8\u5f53\u4e8e\u8fd9\u4e2a\u72b6\u6001\u5bf9\u6574\u4e2a\u4e32S\u7684\u4e0d\u91cd\u590d\u5b50\u4e32\u8d21\u732e\uff09 \u6c42\u6240\u6709\u4e0d\u540c\u5b50\u4e32\u603b\u957f\u5ea6","title":"\u5e94\u7528"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_78","text":"","title":"\u6742\u9879\u3001\u5947\u6280\u6deb\u5de7"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#vectorset","text":"1\uff09\u5728a\u540e\u9762\u63d2\u5165b\uff0c\u65b9\u6cd5\u4e3a a.insert(a.end(),b,begin(),b.end()); 2\uff09\u5728a\u7684\u524d\u9762\u63d2\u5165b\uff0c\u65b9\u6cd5\u4e3a a.insert(a.begin(),b,begin(),b.end()); \u5408\u5e76set: a.insert(b,begin(),b.end());","title":"vector\u3001set\u7684\u5408\u5e76"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_79","text":"CF Global Round 9 F. Integer Game 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include <iostream> using namespace std ; long long a [ 4 ], p1 , p2 ; int main () { ios :: sync_with_stdio ( false ); for ( int i = 1 ; i <= 3 ; i ++ ) cin >> a [ i ]; cout << \"First\" << endl ; cout << ( long long ) 1e11 << endl ; cout . flush (); cin >> p1 ; a [ p1 ] += ( long long ) 1e11 ; long long temp = 2 * a [ p1 ]; for ( int i = 1 ; i <= 3 ; i ++ ) { if ( i != p1 ) temp -= a [ i ]; } cout << temp << endl ; cout . flush (); cin >> p2 ; a [ p2 ] += temp ; cout << a [ p2 ] - a [ p1 ] << endl ; //d=c-a=(2c-a)-c=a[p2]-a[p1] cout . flush (); return 0 ; } CF 669 1407C \u2014 Chocolate Bunny 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include <iostream> #include <cstdio> using namespace std ; int n , a [ 10100 ]; int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); cin >> n ; int pos = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { int x , y ; cout << \"? \" << pos << \" \" << i << endl ; cout . flush (); cin >> x ; cout << \"? \" << i << \" \" << pos << endl ; cout . flush (); cin >> y ; if ( x < y ) { a [ i ] = y ; } else { a [ pos ] = x ; pos = i ; } } a [ pos ] = n ; cout << \"! \" ; for ( int i = 1 ; i <= n ; i ++ ) { cout << a [ i ] << \" \" ; } cout << endl ; cout . flush (); return 0 ; }","title":"\u4ea4\u4e92\u9898"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#priority_queue","text":"\u5f53\u7136\u4e5f\u80fd\u91cd\u8f7d\u8fd0\u7b97\u7b26\u641e\u5b9a 1 2 3 4 5 6 //\u5347\u5e8f\u961f\u5217\uff0c\u5c0f\u9876\u5806 priority_queue <int,vector<int>,greater<int> > q; //\u964d\u5e8f\u961f\u5217\uff0c\u5927\u9876\u5806 priority_queue <int,vector<int>,less<int> >q; //\u5bf9\u4e8elonglong greater<long long>()","title":"priority_queue"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_80","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include <stdio.h> #include <stdlib.h> int allsum ( int * a , int n , int m ) { int ( * b )[ m ] = ( int ( * )[ m ]) a ; //\u8f6c\u6362\u4e3a\u6570\u7ec4\u6307\u9488 int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) sum += b [ i ][ j ]; //\u7edf\u8ba1\u7b54\u6848 return sum ; } int n , m ; int main () { scanf ( \"%d%d\" , & n , & m ); int ( * a )[ m ] = ( int ( * )[ m ]) calloc ( n * m , sizeof ( int )); //\u6309\u7167\u5927\u5c0f\u5206\u914d\u6570\u7ec4\u5185\u5b58 for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) scanf ( \"%d\" , & a [ i ][ j ]); //\u8f93\u5165 printf ( \"%d\" , allsum ( & a [ 0 ][ 0 ], n , m )); free ( a ); return 0 ; }","title":"\u52a8\u6001\u5206\u914d\u4e8c\u7ef4\u6570\u7ec4\u5185\u5b58"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_81","text":"https://zh.wikipedia.org/wiki/%E7%AD%89%E5%B9%82%E6%B1%82%E5%92%8C $$ \\sum_{i=1}^{n} i^{0} =n\\ \\sum_{i=1}^{n} i^{1} = \\frac{n(n+1)}{2} = \\frac{1}{2}n^2 +\\frac{1}{2} n \\ \\sum_{i=1}^{n} i^{2} = \\frac{n(n+1)(2n+1)}{6} = \\frac{1}{3}n^3 + \\frac{1}{2}n^2 + \\frac{1}{6}n\\ \\sum_{i=1}^{n} i^{3} = \\left[\\frac{n(n+1)}{2}\\right]^{2} = \\frac{1}{4}n^4 + \\frac{1}{2}n^3 + \\frac{1}{4}n^2\\ \\sum_{i=1}^{n} i^{4} = \\frac{n(n+1)(2n+1)(3n^2+3n-1)}{30} = \\frac{1}{5}n^5 + \\frac{1}{2}n^4 + \\frac{1}{3}n^3 - \\frac{1}{30}n\\ \\sum_{i=1}^{n} i^{5} = \\frac{n {2}(n+1) (2n^2+2n-1)}{12} = \\frac{1}{6}n^6 + \\frac{1}{2}n^5 + \\frac{5}{12}n^4 - \\frac{1}{12}n^2\\ \\sum_{i=1}^{n} i^{6} = \\frac{n(n+1)(2n+1)(3n 4+6n 3-3n+1)}{42} = \\frac{1}{7}n^7 + \\frac{1}{2}n^6 + \\frac{1}{2}n^5 - \\frac{1}{6}n^3 + \\frac{1}{42}n\\ \\sum_{i=1}^{n} i^{7} = \\frac{n 2(n+1) 2(3n 4+6n 3-n^2-4n+2)}{24} = \\frac{1}{8}n^8 + \\frac{1}{2}n^7 + \\frac{7}{12}n^6 - \\frac{7}{24}n^4 + \\frac{1}{12}n^2\\ \\sum_{i=1}^{n} i^{8} = \\frac{n(n+1)(2n+1)(5n 6+15n 5+5n 4-15n 3-n 2+9n-3)}{90}=\\frac{1}{9}n 9 + \\frac{1}{2}n^8 + \\frac{2}{3}n^7 - \\frac{7}{15}n^5 + \\frac{2}{9}n^3 - \\frac{1}{30}n\\ \\sum_{i=1}^{n} i^{9} = \\frac{n 2(n+1) 2(n 2+n-1)(2n 4+4n 3-n 2-3n+3)}{20}=\\frac{1}{10}n {10}+\\frac{1}{2}n 9+\\frac{3}{4}n 8-\\frac{7}{10}n 6+\\frac{1}{2}n 4-\\frac{3}{20}n 2\\ \\sum_{i=1}^{n} i^{10} = \\frac{n(n+1)(2n+1)(n 2+n-1)(3n 6+9n 5+2n 4-11n 3+3n 2+10n-5)}{66}=\\frac{1}{11}n {11}+\\frac{1}{2}n +\\frac{5}{6}n 9-n 7+n 5-\\frac{1}{2}n 3+\\frac{5}{66}n\\ \\sum_{i=0}^{n} i^{m-1} = \\sum_{k=0}^m S_k^m n k\uff0c\u5176\u4e2dS_0 m = 0\uff0cS_m^m = \\frac{1}{m}\uff0c\u7576m\u2212k\u70ba\u5927\u65bc1\u7684\u5947\u6578\u6642\uff0cS_k^m = 0\\ \\sum_{i=0}^{n} i^m = {1\\over{m+1}}\\sum_{i=0}^m{m+1\\choose{i}} B_i (n+1)^{m+1-i},(B_i\u4e3a\u4f2f\u52aa\u5229\u6570)\\ \\displaystyle \\sum_{i=1}^n i^{m+1} = \\sum_{k=0}^m L_k^m \\binom{n+k+1}{m+2},\\left(L_k^m = \\sum_{r=0}^k (-1)^r \\binom{m+2}{r} (k+1-r)^{m+1}\\right)\\ $$","title":"\u81ea\u7136\u6570\u5e42\u548c"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#python","text":"1 2 3 import sys sys . stdin = open ( \"l_in.txt\" , \"r\" ) sys . stdout = open ( \"l_out2.txt\" , \"w\" )","title":"Python \u91cd\u5b9a\u5411\u8f93\u51fa\u8f93\u5165"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#atan2yx","text":"\u8fd9\u4e2a\u51fd\u6570\u5b9a\u4e49\u5728cmath\u91cc\uff0c\u8fd4\u56de\u4e00\u4e2a\u70b9(x,y)\u7684\u6781\u89d2\uff0c\u503c\u57df\u5728 \\((-\\pi,\\pi]\\) \u4e4b\u95f4\u3002 \u4e3b\u8981\u7528\u4e8e\u6781\u89d2\u6392\u5e8f\u7b49\u3002","title":"atan2(y,x)"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#_82","text":"","title":"\u8f93\u5165\u4e00\u884c"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#cingetlinechar-m-int-size","text":"\u8f93\u5165\u6700\u591am\u4e2a\u5b57\u7b26\u5230\u5730\u5740m\u5904\u5f00\u59cb\u7684\u5b57\u7b26\u4e32\u3002\u6ce8\u610f\u5982\u679c\u4e4b\u524d\u7528cin\u8bfb\u5165\u7684\u8bdd\u8981\u901a\u8fc7\u7279\u6b8a\u624b\u6bb5\u6d88\u9664\u4e4b\u524d\u7684\u6362\u884c\u7b26\uff0c\u4e0b\u540c\u3002","title":"cin.getline(char *m, int size)"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#getlinecinstr","text":"\u4ece\u6d41\u4e2d\u8bfb\u5165\u5230str\u4e2d","title":"getline(cin,*str)"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#char-fgetschar-str-int-cnt-stdfile-stream","text":"\u4ece\u6d41\u4e2d\uff08\u6587\u4ef6\u6d41\uff0c\u6216stdin\uff09\u8bfb\u5165\u6700\u591acnt\u4e2a\u5b57\u7b26\u7684\u5b57\u7b26\u4e32\u5230str\u4e2d\u3002 ps\uff1a\u4e0b\u9762\u7684\u64cd\u4f5c\u53ef\u4ee5\u79fb\u9664\u591a\u4f59\u7684\u7a7a\u767d\u7b26 1 cin >> ws","title":"char fgets(char str, int cnt, std::FILE* stream)"},{"location":"old/OI%E6%9D%82%E7%AC%94%E8%AE%B0/#1","text":"\uff08 https://www.cnblogs.com/graphics/archive/2010/06/21/1752421.html \uff09 1 2 3 4 5 int BitCount5 ( unsigned int n ) { unsigned int tmp = n - (( n >> 1 ) & 033333333333 ) - (( n >> 2 ) & 011111111111 ); return (( tmp + ( tmp >> 3 )) & 030707070707 ) % 63 ; }","title":"\u5feb\u901f\u8ba1\u7b97\u4e8c\u8fdb\u5236\u4e2d1\u7684\u4e2a\u6570"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/","text":"\u5b66\u4e0d\u6765Python \u00b6 \u4e00\u4e9b\u524d\u8a00 \u00b6 \u4e4b\u6240\u4ee5\u4e0b\u51b3\u5fc3\u5199\u8fd9\u4e2a\u7cfb\u5217\uff0c\u662f\u56e0\u4e3a\u8fd9\u4e48\u957f\u4e45\u4ee5\u6765\u6211\u5b66Python\u90fd\u662f\u5728\u9700\u8981\u4f7f\u7528\u65f6\u4e34\u65f6\u53c2\u8003\u7684\u7f51\u4e0a\u7684\u6559\u7a0b\uff0c\u52a0\u4e0a\u6211\u81ea\u5df1\u4ee5\u524d\u5e76\u6ca1\u6709\u8bb0\u5f55\u81ea\u5df1\u5b66\u4e60\u5185\u5bb9\u7684\u4e60\u60ef\uff0c\u56e0\u800c\u5bfc\u81f4\u6211Python\u5b66\u7684\u4e1c\u897f\u90fd\u76f8\u5f53\u96f6\u6563\u4e14\u534a\u540a\u5b50\u3002\u56e0\u6b64\u6211\u5199\u8fd9\u4e2a\u7cfb\u5217\u4e3b\u8981\u4e5f\u662f\u8981\u7ed9\u81ea\u5df1\u5b66\u8fc7\u7684\u4e1c\u897f\u505a\u4e00\u4e2a\u5f52\u7eb3\u65b9\u4fbf\u4ee5\u540e\u81ea\u5df1\u67e5\u9605\u3002 \u603b\u6240\u5468\u77e5\uff0cPython\u7684\u8bed\u6cd5\u7b80\u5355\uff0c\u56e0\u6b64\u88ab\u5404\u79cd\u201c\u673a\u6784\u201d\u7528\u6765\u5f53\u505a\u7f16\u7a0b\u7684\u5165\u95e8\u8bed\u8a00\u3002\u7136\u800c\u5b9e\u9645\u4e0a\u5982\u679c\u6ca1\u6709\u63a5\u89e6\u8fc7\u7f16\u7a0b\u4e14\u4e0d\u4e86\u89e3Python\u80cc\u540e\u7684\u4e00\u4e9b\u673a\u5236\u7684\u8bdd\uff0c\u8fd9\u95e8\u8bed\u8a00\u5176\u5b9e\u975e\u5e38\u96be\u5b66\u2014\u2014\u5b83\u7684\u5751\u592a\u591a\u4e86\u3002\u8fd9\u4e5f\u662f\u6211\u5b66\u8fd9\u95e8\u8bed\u8a00\u8fc7\u7a0b\u4e2d\u7684\u611f\u609f\uff0c\u56e0\u6b64\u8fd9\u4e2a\u7cfb\u5217\u4e5f\u662f\u4e3a\u4e86\u603b\u7ed3\u4e00\u4e0b\u5b83\u7684\u4e00\u4e9b\u5751\u4ee5\u514d\u6211\u4ee5\u540e\u518d\u8e29\uff08\u5f53\u7136\u4e5f\u4ec5\u9650\u4e8e\u6211\u7684\u80fd\u529b\u8303\u56f4\u5185\u4e86\uff09\u3002\u4e5f\u56e0\u4e3a\u8fd9\u4e2a\u539f\u56e0\uff0c\u6211\u51b3\u5b9a\u7ed9\u8fd9\u4e2a\u7cfb\u5217\u53d6\u540d\u53eb\u201c\u5b66\u4e0d\u6765Python\u201d\u3002 \u6700\u540e\uff0c\u6211\u5bf9\u6211\u81ea\u5df1\u6525\u5199\u6587\u7ae0\u7684\u6c34\u5e73\u6ca1\u591a\u5c11\u81ea\u4fe1\uff0c\u6240\u4ee5\u5176\u5b9e\u6211\u5199\u7684\u4e1c\u897f\u4e0d\u4e00\u5b9a\u9002\u5408\u7ed9\u522b\u4eba\u770b\uff0c\u751a\u81f3\u4e8e\u8bf4\u662f\u5f53\u505a\u201c\u6559\u7a0b\u201d\u2014\u2014\u8fd9\u4e2a\u7cfb\u5217\u5e94\u8be5\u8bf4\u662f\u4e00\u4e2a\u5199\u7ed9\u6211\u81ea\u5df1\u770b\u7684\u201c\u6559\u7a0b\u201d\uff0c\u5f53\u7136\u6211\u4f1a\u5c3d\u91cf\u628a\u6211\u60f3\u7ed9\u81ea\u5df1\u770b\u7684\u5185\u5bb9\u5199\u6210\u5176\u4ed6\u4eba\u4e5f\u80fd\u770b\u61c2\u7684\u5f62\u5f0f\u3002\u8fd9\u4e2a\u7cfb\u5217\u4e5f\u4f1a\u53c2\u8003\u4e00\u4e9b\u7f51\u4e0a\u6bd4\u8f83\u6709\u540d\u7684\u6559\u7a0b\uff08\u6bd4\u5982liaoxuefeng\u548cPython\u5b98\u7f51\u7684\u6559\u7a0b\uff09\uff0c\u5fc5\u8981\u7684\u65f6\u5019\u4e5f\u4f1a\u7ed9\u51fa\u53c2\u8003\u94fe\u63a5\u3002\u53e6\u5916\uff0c\u7531\u4e8e\u6211\u6c34\u5e73\u6709\u9650\uff0c\u8fd9\u7bc7\u6587\u7ae0\u4e0d\u4f1a\u8be6\u7ec6\u5730\u8bf4\u660e\u8fd9\u4e2a\u8bed\u8a00\u4e2d\u7684\u6bcf\u4e00\u4e2a\u7ec6\u8282\uff0c\u66f4\u591a\u7684\u65f6\u5019\u53ea\u662f\u505c\u7559\u5728\u201c\u80fd\u7528\u5c31\u884c\u201d\u7684\u6c34\u5e73\uff0c\u6587\u4e2d\u6240\u8bf4\u7684\u5185\u5bb9\u4e5f\u672a\u5fc5100%\u51c6\u786e\uff0c\u8fd8\u8bf7\u89c1\u8c05\u3002 \u5982\u679c\u6587\u4e2d\u6709\u9519\u8bef\u65e0\u4efb\u6b22\u8fce\u6307\u51fa\u3002\u90a3\u4e48\u6700\u540e\u5c31\u8bf7\u591a\u6307\u6559\u4e86\u3002 \u57fa\u7840\u8bed\u6cd5 \u00b6 \u57fa\u672c\u6982\u5ff5\u548cPython\u7684\u7279\u5f81 \u00b6 Python\u662f \u9762\u5411\u5bf9\u8c61\u7684\u8bed\u8a00 \uff1a\u5728Python\u4e2d\uff0c\u4efb\u4f55\u7684\u7c7b\u578b\uff08\u5982\u4e0b\u6587\u63d0\u5230\u7684\u6570\u5b57\u3001\u5b57\u7b26\u4e32\uff09\u90fd\u662f\u67d0\u79cd \u7c7b \u3002 \u7c7b \uff1a\u4e00\u79cd\u62bd\u8c61\u7684\u7c7b\u578b\uff0c\u672c\u8d28\u4e0a\u662f\u4e00\u79cd\u6570\u636e\u7ed3\u6784\uff0c\u5b83\u6307\u4ee3\u4e00\u7c7b\u6709\u8be6\u7ec6\u5b9a\u4e49\u7684\u4e8b\u7269\u3002\u4f8b\u5982\uff0c\u6570\u5b66\u4e0a\u7684\u96c6\u5408\uff08\u4e00\u7c7b\u4e8b\u7269\uff09\u53ef\u4ee5\u7406\u89e3\u6210\u4e00\u79cd\u7c7b\u3002\u4eba\u7c7b\u4e5f\u662f\u4e00\u79cd\u7c7b\u3002 \u5b9e\u4f8b\u3001\u5bf9\u8c61 \uff1a\u7c7b\u4e2d\u7684\u67d0\u4e2a\u7279\u5b9a\u7684\u5b9e\u4f53\u79f0\u4e3a \u5b9e\u4f8b \uff0c\u4e5f\u5373 \u5bf9\u8c61 \u3002\u4f8b\u5982\uff0c\u67d0\u4e2a\u96c6\u5408{1,2,3}\u662f\u96c6\u5408\u7684\u4e00\u4e2a\u5b9e\u4f8b\uff0c\u53e6\u4e00\u4e2a\u96c6\u5408{5,6,7}\u53c8\u662f\u96c6\u5408\u7684\u53e6\u4e00\u4e2a\u5b9e\u4f8b\u3002\u67d0\u4e2a\u7279\u5b9a\u7684\u4eba\u4e5f\u53ef\u4ee5\u7406\u89e3\u4e3a\u201c\u4eba\u7c7b\u201d\u8fd9\u4e2a\u7c7b\u7684\u5b9e\u4f8b\u3002 \u5f53\u7136\u6570\u5b66\u4e0a\u7684\u96c6\u5408\u672c\u8eab\u4e0d\u662f\u6570\u636e\u7ed3\u6784\uff0c\u4e0b\u6587\u4e2d\u4f1a\u63d0\u5230Python\u4e2d\u7684\u4e00\u79cd\u7c7b\u578b\u53ebset\uff0c\u5b83\u5c31\u662f\u6570\u5b66\u96c6\u5408\u5728Python\u4e2d\u7684\u5b9e\u73b0\uff0c\u662f\u4e00\u79cd\u6570\u636e\u7ed3\u6784\u3002 \u6210\u5458 \uff1a\u4e00\u4e2a\u7c7b\u4e2d\u5305\u542b\u7684 \u5c5e\u6027 \u548c \u65b9\u6cd5 \u7edf\u79f0\u4e3a\u6210\u5458\u3002 \u5c5e\u6027 \uff1a\u63cf\u8ff0\u4e86\u8fd9\u4e2a\u7c7b\u7684\u6240\u6709\u5b9e\u4f8b\u6240\u62e5\u6709\u7684\u5c5e\u6027\u6709\u54ea\u4e9b\u3002\u4f8b\u5982\uff0c\uff08\u6709\u9650\uff09\u96c6\u5408\u62e5\u6709\u5927\u5c0f\u8fd9\u4e2a\u5c5e\u6027\uff0c {1,2}\u8fd9\u4e2a\u96c6\u5408\u4f5c\u4e3a\u96c6\u5408\u7c7b\u7684\u5b9e\u4f8b\uff0c\u5927\u5c0f\u8fd9\u4e2a\u5c5e\u6027\u7684\u503c\u662f2\u3002\u4eba\u7c7b\u62e5\u6709\u8eab\u9ad8\u8fd9\u4e2a\u5c5e\u6027\uff0c\u800c\u67d0\u4e2a\u7279\u5b9a\u7684\u4eba\u8eab\u9ad8\u662f172cm\u5c31\u662f\u8fd9\u4e2a\u7279\u5b9a\u7684\u4eba\u5728\u8eab\u9ad8\u8fd9\u4e2a\u5c5e\u6027\u4e0a\u7684\u503c\u3002 \u65b9\u6cd5 \uff1a\u63cf\u8ff0\u4e86\u8fd9\u4e2a\u7c7b\u7684\u6240\u6709\u5b9e\u4f8b\u6240\u80fd\u505a\u7684\u64cd\u4f5c\uff08\u901a\u5e38\u8fd9\u4e9b\u64cd\u4f5c\u4f1a\u548c\u5b9e\u4f8b\u672c\u8eab\u6709\u5173\uff09\u6709\u54ea\u4e9b\u3002\u4f8b\u5982\uff0c\u96c6\u5408\u7c7b\u5b9a\u4e49\u4e86\u53d6\u4ea4\u96c6\u3001\u5e76\u96c6\u3001\u5220\u9664\u67d0\u5143\u7d20\u7b49\u64cd\u4f5c\uff08\u8fd9\u4e9b\u64cd\u4f5c\u5c31\u662f\u65b9\u6cd5\uff09\uff0c\u90a3\u4e48\u5bf9\u4e8e\u4e00\u4e2a\u7279\u5b9a\u7684\u96c6\u5408\uff5b1\uff0c2\uff0c3\uff5d\uff0c\u5b83\u53ef\u4ee5\u4e0e\u53e6\u4e00\u4e2a\u96c6\u5408\uff5b5\uff0c6\uff0c7\uff5d\u53d6\u5e76\u96c6\u3001\u4ea4\u96c6\u4ece\u800c\u5f97\u5230\u53e6\u4e00\u4e2a\u96c6\u5408\uff0c\u4e5f\u53ef\u4ee5\u5220\u9664\u96c6\u5408\u4e2d\u67d0\u4e00\u7279\u5b9a\u5143\u7d20\u5f97\u5230\u53e6\u4e00\u4e2a\u96c6\u5408\uff08\u4f8b\u5982\u5220\u63893\u5c31\u53ef\u4ee5\u5f97\u5230\uff5b1\uff0c2\uff5d\uff09\u3002 \u53d8\u91cf \uff1a\u7ed1\u5b9a\u5230\u67d0\u4e2a\u7279\u5b9a\u5b9e\u4f8b\u7684\u6307\u9488\uff08\u5728Python\u610f\u4e49\u4e0b\uff09\u3002\u4f8b\u5982\u4ee4a=10\uff0c\u90a3\u4e48\u5c31\u8bf4a\u6307\u5411\u4e8610\u3002 \u51fd\u6570 \uff1a\u4e00\u7cfb\u5217\u5df2\u7ecf\u5c01\u88c5\u597d\u4e86\u7684\u4ee3\u7801\u5757\uff0c\u63a5\u53d7\u7279\u5b9a\u53c2\u6570\u5e76\u6267\u884c\uff08\u4e5f\u5373\u8c03\u7528\uff09\u540e\u5373\u53ef\u8fd4\u56de\u7ed3\u679c\uff08\u5f53\u7136\u4e5f\u6709\u53ef\u80fd\u53ea\u662f\u8fd0\u884c\u800c\u4e0d\u8fd4\u56de\u7ed3\u679c\uff09\u3002 Python\u662f \u5f31\u7c7b\u578b\u7684\u8bed\u8a00 \uff1a\u8981\u5b9a\u4e49\u53d8\u91cf\uff0c\u53ea\u9700\u8981\u7ed9\u5b83\u8d4b\u503c\u4e00\u4e2a\u76f8\u5e94\u7c7b\u578b\u7684\u5bf9\u8c61\u5b9e\u4f8b\u5373\u53ef\u3002\u4e0d\u9700\u8981\u7279\u522b\u6307\u660e\u5176\u7c7b\u578b\u3002 Python\u4f9d\u8d56 \u7f29\u8fdb \u533a\u5206\u4ee3\u7801\u5757\uff1a\u4f18\u70b9\u662f\u5927\u591a\u6570\u65f6\u5019\u4e0d\u9700\u8981\u6253\u82b1\u62ec\u53f7\u548c\u5206\u53f7\u6765\u533a\u5206\u4ee3\u7801\u5757\u548c\u4e00\u884c\u7684\u7ed3\u675f\uff0c\u7f3a\u70b9\u5c31\u662fPython\u5bf9\u7f29\u8fdb\u7684\u8981\u6c42\u6781\u5176\u4e25\u683c\u3002 \u57fa\u672c\u6570\u636e\u7c7b\u578b \u00b6 Python\u4e2d\u6709\u51e0\u79cd\u57fa\u672c\u6700\u5e38\u7528\u7684\u57fa\u672c\u6570\u636e\u7c7b\u578b\uff0c\u5b83\u4eec\u7684\u672c\u8d28\u90fd\u662f\u5bf9\u8c61\u3002\u4e0b\u9762\u4f1a\u5bf9\u8fd9\u4e9b\u7c7b\u578b\u505a\u4e00\u4e9b\u8f83\u4e3a\u8be6\u7ec6\u7684\u8bf4\u660e\u3002 \u7c7b\u578b \u4f8b\u5b50 \u8bf4\u660e \u6574\u6570\uff08int\uff09 123 \u9ad8\u7cbe\u5ea6\u5927\u6574\u6570 \u6d6e\u70b9\u6570\uff08float\uff09 114.514,1.0,1e18 \u5b57\u7b26\u4e32\uff08str\uff09 \"TML104\" \u5e03\u5c14\u503c\uff08bool\uff09 True,False \u4ee5\u5927\u5199\u5f00\u5934\uff0c\u53ea\u6709\u4e24\u4e2a\u5408\u6cd5\u7684\u503c \u590d\u6570 1+2j \u6574\u6570 \u00b6 \u5341\u8fdb\u5236 \u00b6 \u4e00\u822c\u5730\uff0c\u968f\u4fbf\u8f93\u5165\u67d0\u4e2a\u5341\u8fdb\u5236\u6570\u5c31\u662f\u6574\u6570\u4e86\u3002\u4f46\u4ed6\u4eec\u4e0d\u80fd\u6709\u591a\u4f59\u7684\u524d\u5bfc\u96f6\u3002 1 2 3 a = 123456 b =- 1123 c = 0 \u5f53\u7136\u4f60\u4e5f\u53ef\u4ee5\u7528\u4e0b\u5212\u7ebf\u5206\u5272\u6570\u5b57\uff0cPython\u4f1a\u8ba4\u4e3a\u4ed6\u4eec\u662f\u8fde\u5728\u4e00\u8d77\u7684\u3002 1 a = 114_514 \u5176\u4ed6\u8fdb\u5236 \u00b6 \u5728\u5bf9\u5e94\u8fdb\u5236\u7684\u6570\u524d\u52a0\u4e0a\u201c0b\u201d\u3001\u201c0o\u201d\u3001\u201c0x\u201d\uff0c\u5c31\u53ef\u4ee5\u4ee5\u4e8c\u3001\u516b\u3001\u5341\u8fdb\u5236\u8868\u793a\u522b\u7684\u6574\u6570\u3002 1 2 3 a = 0b11 b =- 0x3f c = 0o12 \u6d6e\u70b9\u6570 \u00b6 \u53ef\u4ee5\u76f4\u89c2\u5730\u7406\u89e3\uff1a\u5e26\u6709\u5c0f\u6570\u70b9\u7684\u6570\u5c31\u662f\u6d6e\u70b9\u6570\u3002\u5f53\u7136\uff0c\u4f60\u4e5f\u53ef\u4ee5\u7528\u79d1\u5b66\u8ba1\u6570\u6cd5\u6765\u8868\u793a\u6d6e\u70b9\u6570\uff0c\u5f62\u5982\u201cxey\u201d\uff0c\u7b49\u4ef7\u4e8e \\(x\\cdot 10^y\\) 1 2 3 4 a = 1.0 b = 3e9 c = 38e38 d = 1e-12 \u8fd9\u91cc \\(b=3*10^9\\) \uff0c \\(c=3.8*10^{39},d=1*10^{-12}\\) \uff0c\u4f46\u8981\u6ce8\u610f\u4ed6\u4eec\u90fd\u662f\u6d6e\u70b9\u6570\u3002 \u6ce8\u610f\u533a\u5206\uff1a1\u548c1.0\u662f \u4e24\u79cd\u4e0d\u540c\u7c7b\u578b\u7684\u6570 \uff0c\u524d\u8005\u662f\u6574\u6570\uff08int\uff09\u3001\u540e\u8005\u662f\u6d6e\u70b9\u6570\uff08float\uff09\uff0c\u4e0b\u6587\u4e2d\u7684\u9664\u6cd5\u8fd0\u7b97\u4f1a\u6d89\u53ca\u5230\u8fd9\u70b9\u3002 \u5982\u679c\u5c0f\u6570\u4ee50.\u5f00\u5934\uff0c\u90a3\u4e48\u53ef\u4ee5\u7701\u7565\u63890\u3002\u4e0b\u9762\u7684a\u7b49\u4e8e-0.03\u3002 1 a =- .03 \u7531\u4e8e\u8ba1\u7b97\u673a\u4fdd\u5b58\u6d6e\u70b9\u6570\u7684\u5f62\u5f0f\u5b58\u5728\u4e00\u5b9a\u7684\u201c\u7f3a\u9677\u201d\u5bfc\u81f4\u8fd0\u7b97\u53ef\u80fd\u4f1a\u5b58\u5728\u7cbe\u5ea6\u95ee\u9898\uff0c\u56e0\u6b64\u80fd\u7528\u6574\u6570\u7684\u60c5\u51b5\u4e0b\u5c3d\u91cf\u7528\u6574\u6570\u3002 \u5b57\u7b26\u4e32 \u00b6 \u5176\u5b9e\u8fd9\u73a9\u610f\u5e94\u8be5\u4e0d\u7b97\u57fa\u672c\u6570\u636e\u7c7b\u578b\u4e86\u2026\u2026\u56e0\u4e3a\u5b57\u7b26\u4e32\u4e8b\u5b9e\u4e0a\u62e5\u6709\u4e00\u4e9b\u9ad8\u7ea7\u7279\u6027\uff0c\u4ee5\u540e\u4f30\u8ba1\u4f1a\u5f00\u4e00\u8282\u4e13\u95e8\u8bf4\u660e\u5b57\u7b26\u4e32\uff0c\u56e0\u6b64\u8fd9\u91cc\u53ea\u662f\u5148\u63d0\u4e00\u5634\u3002 \u4f7f\u7528\u4e00\u5bf9\u534a\u89d2\u5355\u5f15\u53f7\u6216\u53cc\u5f15\u53f7\u5305\u88f9\u7684\u5185\u5bb9\u662f\u5355\u884c\u5b57\u7b26\u4e32\uff0c\u4f7f\u7528\u4e09\u5bf9\u534a\u89d2\u5355\u5f15\u53f7\u6216\u53cc\u5f15\u53f7\u5305\u88f9\u7684\u5185\u5bb9\u662f\u591a\u884c\u5b57\u7b26\u4e32\u3002 1 2 3 4 5 a = \"Hello,world\" b = '''R1 R2 R3 ''' \u6ce8\u610f\u8d4b\u503c\u7684\u65f6\u5019\u591a\u884c\u5b57\u7b26\u4e32\u7684\u5f00\u5934\u4e09\u4e2a\u5f15\u53f7\u5fc5\u987b\u8981\u548c\u53d8\u91cf\u540c\u884c\uff0c\u5426\u5219\u5c31\u4f1a\u53d8\u6210\u4e0b\u6587\u4e2d\u7684\u6ce8\u91ca\u7684\u5199\u6cd5\u4e86\u3002 \u5e03\u5c14\u503c \u00b6 \u8fd9\u4e2a\u5c31\u6ca1\u4ec0\u4e48\u597d\u8bf4\u660e\u7684\u4e86\u3002\u5e03\u5c14\u503c\u53ea\u6709\u4e24\u79cd\u53d6\u503c\uff1aTrue\u3001False\uff0c\u6ce8\u610f\u4e0d\u50cfC\u8bed\u8a00\uff0c\u8fd9\u91cc\u5b83\u4eec\u5f00\u5934\u9996\u5b57\u6bcd\u5fc5\u987b\u8981\u5927\u5199\u3002 1 2 a = True b = False \u590d\u6570 \u00b6 \u8fd9\u4e2a\u7c7b\u578b\u4e0d\u600e\u4e48\u5e38\u7528\uff0c\u8fd9\u91cc\u53ea\u662f\u63d0\u4e00\u4e0b\u3002\u7528\"a+bj\"\u6765\u6784\u9020\u4e00\u4e2a\u590d\u6570\uff0c\u4e5f\u53ef\u4ee5\u7528complex(\"a+bj\")\u4ee5\u5b57\u7b26\u4e32\u6765\u6784\u9020\u590d\u6570\u3002 1 2 a = complex ( \"1+2j\" ) b = 1 + 2 j \u53d8\u91cf\u548c\u7b80\u5355\u8d4b\u503c \u00b6 \u4f7f\u7528\u7b49\u4e8e\u53f7\u6765\u7ed9\u53d8\u91cf\u8d4b\u503c\u3002\u4e0a\u6587\u4e2d\u5df2\u7ecf\u7ed9\u51fa\u4f8b\u5b50\u3002 \u4f60\u4e5f\u53ef\u4ee5\u540c\u65f6\u5bf9\u591a\u4e2a\u53d8\u91cf\u8d4b\u503c\uff0c\u8fd9\u6837abc\u4e09\u4e2a\u53d8\u91cf\u5c31\u90fd\u662f10\uff1a 1 a = b = c = 10 python\u4e2d\u7684\u53d8\u91cf\u4e0e\u5176\u8bf4\u662f\u53d8\u91cf\uff0c\u4e0d\u5982\u8bf4\u662f\u67d0\u79cd\u201c\u6307\u9488\u201d\u2014\u2014\u5b83\u7684\u672c\u8d28\u5176\u5b9e\u662f\u6307\u5411\u5bf9\u8c61\u7684\u6307\u9488\uff08\u4e5f\u5c31\u662f\u4f20\u9012\u5f15\u7528\uff09\u3002\u8fd9\u4e2a\u6982\u5ff5\u5bf9\u7406\u89e3\u540e\u9762\u7684\u5217\u8868\u7b49\u53ef\u53d8\u7c7b\u578b\u4f1a\u6709\u5e2e\u52a9\u3002 \u5220\u9664 \u00b6 \u7ed9\u53d8\u91cfa\u8d4b\u503c\u540e\uff0c\u53ef\u4ee5\u7528del\u8bed\u53e5\u5220\u9664\u53d8\u91cfa\u6307\u5411\u7684\u5bf9\u8c61\uff0c\u8fd9\u6837a\u5c31\u91cd\u65b0\u56de\u5230\u672a\u5b9a\u4e49\u7684\u72b6\u6001\u4e86\u3002 1 2 3 a = [ 3 , 4 , 5 ] del a a #NameError: name 'a' is not defined \u57fa\u672c\u8fd0\u7b97 \u00b6 \u4e0b\u6587\u4e2d\u5c06\u4f1a\u5217\u51fa\u6bd4\u8f83\u5e38\u7528\u7684\u8fd0\u7b97\uff0c\u4e0d\u4f1a\u5217\u51fa\u6240\u6709\u8fd0\u7b97\uff08\u56e0\u4e3a\u592a\u591a\u4e86\u6211\u81ea\u5df1\u90fd\u4e0d\u4f1a= =\uff09\u3002 \u4ee3\u6570\u8fd0\u7b97\u7b26\u8fd0\u7b97 \u00b6 \u4e0b\u6587\u4e2d\u793a\u4f8b\u7b49\u53f7\u53f3\u4fa7\u8868\u793a\u8fd0\u7b97\u7ed3\u679c\u3002 \u9664\u975e\u6709\u7279\u6b8a\u8bf4\u660e\uff0c\u4e0b\u8868\u4e2d\u7b26\u53f7\u7686\u4e3a\u4e8c\u5143\u8fd0\u7b97\u7b26\uff0c\u4e14\u6d6e\u70b9\u6570\u3001\u6574\u6570\u3001\u5e03\u5c14\u503c\u5747\u53ef\u53c2\u4e0e\u8fd0\u7b97 $$ \\begin{array} {|} \\hline { \u8fd0\u7b97 }&{ \u7b26\u53f7 }&{ \u7279\u6b8a\u8bf4\u660e }&{ \u793a\u4f8b }\\ \\hline { \u52a0\u6cd5 }&{ + }&{ \u5bf9\u4e8e\u5217\u8868\u3001\u5b57\u7b26\u4e32\u7b49\u5bf9\u8c61\u6b64\u7b26\u53f7\u6709\u7279\u6b8a\u7528\u9014 }&{ 1+2 =3\\ [3]+[4] =[3,4]\\ \"13\"+\"222\" =\"13222\" }\\ \\hline { \u51cf\u6cd5 }&{ - }&{ }&{ 1-2 =-1 }\\ \\hline { \u4e58\u6cd5 }&{ }&{ \u5bf9\u4e8e\u5217\u8868\u3001\u5b57\u7b26\u4e32\u7b49\u5bf9\u8c61\u6b64\u7b26\u53f7\u6709\u7279\u6b8a\u7528\u9014 }&{ 1 2 =2\\ \"13\" 5 =\"1313131313\"\\ [3,4] 2 =[3,4,3,4] }\\ \\hline { \u6574\u6570\u9664\u6cd5\uff08\u5730\u677f\u9664\u6cd5\uff09 }&{ // }&{ \u8fd4\u56de\u6574\u6570\u503c\uff08\u5411\u4e0b\u53d6\u6574\uff0c\u4e5f\u5373\u8d1f\u6570\u65b9\u5411\u53d6\u6574\uff09\\\u9664\u4ee50\u4f1a\u629b\u51faZeroDivisionError\u5f02\u5e38 }&{ 3//4 =0\\ -3//4 =-1 }\\ \\hline { \u6d6e\u70b9\u6570\u9664\u6cd5 }&{ / }&{ \u8fd4\u56de\u6d6e\u70b9\u6570\u503c\uff0c\u9664\u4ee50\u4f1a\u629b\u51faZeroDivisionError\u5f02\u5e38 }&{ 3//4 =0.75 }\\ \\hline { \u53d6\u6a21 }&{ \\% }&{ a\\%b\u7684\u7ed3\u679c\u4e3aa-(a//b) b\uff0c\u9664\u4ee50\u4f1a\u629b\u51faZeroDivisionError\u5f02\u5e38;\\\u5bf9\u5b57\u7b26\u4e32\u5bf9\u8c61\u6709\u7279\u6b8a\u7528\u9014\uff08\u683c\u5f0f\u5316\u5b57\u7b26\u4e32\uff09;\\\u6ce8\u610f\uff1a\u6839\u636e\u8fd9\u4e2a\u516c\u5f0f\uff0c\u4f60\u4e8b\u5b9e\u4e0a\u53ef\u4ee5\u5bf9\u6d6e\u70b9\u6570\u53d6\u6a21 }&{ 4\\%3 =1\\ 4\\%-3 =-2\\ -4\\%3 =2\\ -4\\%-3 =-1\\ 4.2\\%3.0 =1.2000000000000002 }\\ \\hline { \u4e58\u65b9 }&{ pow(a,b) \u6216 a b }&{ }&{ 4 3 =64\\ 2 *0.5 =1.4142135623730951 }\\\\ \\hline \\end{array}\\ $$ \u8fd0\u7b97 \u7b26\u53f7 \u7279\u6b8a\u8bf4\u660e \u793a\u4f8b \u52a0\u6cd5 + \u5bf9\u4e8e\u5217\u8868\u3001\u5b57\u7b26\u4e32\u7b49\u5bf9\u8c61\u6b64\u7b26\u53f7\u6709\u7279\u6b8a\u7528\u9014 1+2 =3 [3]+[4] =[3,4] \"13\"+\"222\" =\"13222\" \u51cf\u6cd5 - 1-2 =-1 \u4e58\u6cd5 * \u5bf9\u4e8e\u5217\u8868\u3001\u5b57\u7b26\u4e32\u7b49\u5bf9\u8c61\u6b64\u7b26\u53f7\u6709\u7279\u6b8a\u7528\u9014 1 2 =2 \"13\" 5 =\"1313131313\" [3,4]*2 =[3,4,3,4] \u6574\u6570\u9664\u6cd5\uff08\u5730\u677f\u9664\u6cd5\uff09 // \u8fd4\u56de\u6574\u6570\u503c\uff08\u5411\u4e0b\u53d6\u6574\uff0c\u4e5f\u5373\u8d1f\u6570\u65b9\u5411\u53d6\u6574\uff09\uff0c\u9664\u4ee50\u4f1a\u629b\u51faZeroDivisionError\u5f02\u5e38 3//4 =0 -3//4 =-1 \u6d6e\u70b9\u6570\u9664\u6cd5 / \u8fd4\u56de\u6d6e\u70b9\u6570\u503c\uff0c\u9664\u4ee50\u4f1a\u629b\u51faZeroDivisionError\u5f02\u5e38 3//4 =0.75 \u53d6\u6a21 % a%b\u7684\u7ed3\u679c\u4e3aa-(a//b)*b\uff0c\u9664\u4ee50\u4f1a\u629b\u51faZeroDivisionError\u5f02\u5e38\uff1b\u5bf9\u5b57\u7b26\u4e32\u5bf9\u8c61\u6709\u7279\u6b8a\u7528\u9014\uff08\u683c\u5f0f\u5316\u5b57\u7b26\u4e32\uff09\uff1b\u6ce8\u610f\uff1a\u6839\u636e\u8fd9\u4e2a\u516c\u5f0f\uff0c\u4f60\u4e8b\u5b9e\u4e0a\u53ef\u4ee5\u5bf9\u6d6e\u70b9\u6570\u53d6\u6a21 4%3 =1 4%-3 =-2 -4%3 =2 -4%-3 =-1 4.2%3.0 =1.2000000000000002 \u4e58\u65b9 pow(a,b) \u6216 a**b 4 3 =64 2 0.5 =1.4142135623730951 \u5e03\u5c14\u903b\u8f91\u8fd0\u7b97 \u00b6 \u53c2\u4e0e\u8fd0\u7b97\u7684\u901a\u5e38\u662f\u5e03\u5c14\u503c\u3002 \u8fd0\u7b97 \u7b26\u53f7 \u7279\u6b8a\u8bf4\u660e \u793a\u4f8b \u6216 a or y True or False = True \u4e0e a and b True or False = False \u975e not a \u5355\u76ee\u8fd0\u7b97\u7b26 not False =True \u6bd4\u8f83\u8fd0\u7b97 \u00b6 \u53c2\u4e0e\u8fd0\u7b97\u7684\u901a\u5e38\u662f\u5e03\u5c14\u503c\u3002\u5f53\u7136\uff0c\u5217\u8868\u3001\u5143\u7ec4\u3001\u5b57\u7b26\u4e32\u7b49\u4e5f\u53ef\u6bd4\u8f83\u5927\u5c0f\uff0c\u4f46\u4e0d\u7b49\u53f7\u4e24\u8fb9\u4e00\u822c\u5f97\u662f\u540c\u7c7b\u578b\u7684\u5bf9\u8c61\u3002 \u8fd0\u7b97 \u7b26\u53f7 \u7279\u6b8a\u8bf4\u660e \u793a\u4f8b \u5c0f\u4e8e < \u5217\u8868\u3001\u5143\u7ec4\u3001\u5b57\u7b26\u4e32\uff1a\u6309\u5b57\u5178\u5e8f\u6bd4\u8f83\uff0c\u4e0b\u540c \u5c0f\u4e8e\u7b49\u4e8e <= \u5927\u4e8e > \u5927\u4e8e\u7b49\u4e8e >= \u7b49\u4e8e == \uff08\u901a\u5e38\u662f\uff09\u5224\u65ad\u4e24\u4e2a\u5bf9\u8c61\u7684\u503c\u662f\u5426\u76f8\u7b49\uff0c\u76f8\u7b49\u7684\u5b9a\u4e49\u5bf9\u4e8e\u4e0d\u540c\u7684\u5bf9\u8c61\u800c\u8a00\u53ef\u80fd\u4e0d\u540c\uff1b\u7279\u522b\u5730\uff0c\u7531\u4e8e\u6d6e\u70b9\u6570\u7cbe\u5ea6\u95ee\u9898\uff0c\u5bf9\u6d6e\u70b9\u6570\u4f7f\u7528\u6b64\u7b26\u53f7\u5e94\u5f53\u614e\u91cd \u5bf9\u8c61\u6807\u8bc6 is \u4e24\u4e2a\u5bf9\u8c61\u662f\u540c\u4e00\u4e2a\u5bf9\u8c61\uff08\u8fd9\u91cc\u540c\u4e00\u4e2a\u5bf9\u8c61\u7684\u610f\u601d\u5927\u81f4\u662f\u4ed6\u4eec\u7684\u5185\u5b58\u5730\u5740\u5b8c\u5168\u4e00\u6837\uff09\u65f6\u8fd4\u56deTrue\uff0c\u5426\u5219\u8fd4\u56deFalse 1 is 1 =True [1] is [1] =False \u5426\u5b9a\u5bf9\u8c61\u6807\u8bc6 is not \u4e0a\u4e00\u6761\u7684\u5426\u5b9a\u5f62\u5f0f \u6210\u5458\u68c0\u6d4b\u8fd0\u7b97 in \u6216 not in \u68c0\u6d4ba\u662f\uff08\u4e0d\u662f\uff09b\u7684\u4e00\u4e2a\u6210\u5458\u3002\uff08\u6216\u8005\u8bf4a\u662f\u5426\u5728b\u91cc\uff09\uff1b\u7279\u522b\u5730\uff0c\u5bf9\u5b57\u5178\u6765\u8bf4a\u662fb\u7684\u952e\u65f6\u8fd4\u56deTrue 3 in [1,3] =True 5 in [1,3] =False is\u7684\u4f7f\u7528\u548c\u5bf9\u8c61\u7684id\u6709\u5173\uff0c\u4e4b\u540e\u6211\u4eec\u4f1a\u8be6\u7ec6\u8bf4\u660e\u3002 \u53e6\u5916\uff0cpython\u4e2d\u8fd8\u53ef\u4ee5\u628a\u51e0\u4e2a\u6bd4\u8f83\u7b26\u53f7\u8fde\u7740\u5199\uff1a a<x<=b \uff0c\u8fd9\u79cd\u5199\u6cd5\u5c31\u7ed3\u679c\u800c\u8a00\u7b49\u4ef7\u4e8e a<x and x<=b \uff0c\u4f46x\u7684\u503c\u53ea\u4f1a\u6c42\u89e3\u4e00\u6b21\u3002\u6b64\u5916\uff0c a<x>b \u4e5f\u7b49\u4ef7\u4e8e a<x and x>b \uff0ca\u548cb\u4e4b\u95f4\u4e0d\u4f1a\u8fdb\u884c\u6bd4\u8f83\u3002 \u4f4d\u8fd0\u7b97 \u00b6 \u4f4d\u8fd0\u7b97\u901a\u5e38\u5728\u6574\u6570\u4e0b\u8fdb\u884c\u3002\u7531\u4e8epython\u4e2d\u7684\u6574\u6570\u662f\u5927\u6574\u6570\uff0c\u505a\u4e0b\u9762\u7684\u8fd0\u7b97\u76f8\u5f53\u4e8e\u5bf9\u65e0\u7a77\u4e2a\u4e8c\u8fdb\u5236\u8865\u7801\u4f4d\u505a\u8fd0\u7b97\uff08\u5f53\u7136\u5b9e\u9645\u5b9e\u73b0\u7684\u65f6\u5019\u4e0d\u53ef\u80fd\u662f\u8fd9\u6837\uff0c\u8fd9\u4e48\u8bf4\u53ea\u662f\u65b9\u4fbf\u7406\u89e3\uff09 \u8fd0\u7b97 \u7b26\u53f7 \u7279\u6b8a\u8bf4\u660e \u793a\u4f8b \u6309\u4f4d\u6216 | -3 | -4 =-3 \u6309\u4f4d\u4e0e & -3&-4 =1 \u6309\u4f4d\u5f02\u6216 ^ -3^-4 =1 \u6309\u4f4d\u53d6\u53cd ~a \u7b49\u4ef7\u4e8e\u8fd4\u56de-a-1 ~-3=2 \u5de6\u79fb a<<b \u7b26\u53f7\u4f4d\u4e0d\u4f1a\u79fb\u52a8\uff0c\u591a\u51fa\u6765\u7684\u4f4d\u75280\u586b\u5145\uff1b\u7b49\u4ef7\u4e8e\u4e58\u4ee52\u7684b\u6b21\u65b9 22<<3 =176 \u53f3\u79fb a>>b \u7b26\u53f7\u4f4d\u4e0d\u4f1a\u79fb\u52a8\uff0c\u51cf\u5c11\u7684\u4f4d\u88ab\u820d\u53bb\uff1b\u7b49\u4ef7\u4e8e\u5730\u677f\u9664\u4ee52\u7684b\u6b21\u65b9 22>>3 =2 \u7c7b\u578b\u8f6c\u6362\u8fd0\u7b97\u51fd\u6570 \u00b6 \u7c7b\u578b\u8f6c\u6362\u975e\u5e38\u7075\u6d3b\uff0c\u4e0a\u6587\u63d0\u5230\u7684\u57fa\u672c\u6570\u636e\u7c7b\u578b\u51e0\u4e4e\u90fd\u53ef\u4ee5\u76f8\u4e92\u8f6c\u6362\uff0c\u751a\u81f3\u53ef\u4ee5\u76f4\u63a5\u628a\u5b57\u7b26\u4e32\u8f6c\u6362\u6210\u6574\u6570\u3001\u6d6e\u70b9\u6570\u3001\u590d\u6570\u7b49\u3002 \u8fd9\u4e9b\u8f6c\u6362\u975e\u5e38\u91cd\u8981\uff0c\u8f93\u5165\u6570\u5b57\u9700\u8981\u4f9d\u8d56\u8fd9\u4e9b\u8f6c\u6362\u7528\u7684\u51fd\u6570\u3002 \u8fd0\u7b97 \u7b26\u53f7 \u7279\u6b8a\u8bf4\u660e \u793a\u4f8b \u6574\u6570\u8f6c\u6362 int(a) \u6d6e\u70b9\u6570\u8f6c\u6362\u6210\u5c0f\u6570\u65f6\u662f\u5411\u96f6\u53d6\u6574 int(-2.5) =-2 \u6d6e\u70b9\u6570\u8f6c\u6362 float(a) float(-1) =-1.0 \u590d\u6570\u8f6c\u6362 complex(re,im) \u6216 complex(string) re\u662f\u5b9e\u90e8\u3001im\u662f\u865a\u90e8\uff1b\u4e5f\u53ef\u4ee5\u76f4\u63a5\u7528a+bj\u5f62\u5f0f\u7684\u5b57\u7b26\u4e32\u8f6c\u6362\u6210\u590d\u6570 complex(1,2) complex(\"1+2j\") \u5b57\u7b26\u4e32\u8f6c\u6362 str(a) str(12345) =\"12345\" \u5e03\u5c14\u503c\u8f6c\u6362 bool(a) \u5bf9\u6574\u6570\u6765\u8bf4\uff0c\u53ea\u8981\u4e0d\u662f0\uff0c\u5c31\u8fd4\u56deTrue\uff1b\u5bf9\u5b57\u7b26\u4e32\u6765\u8bf4\uff0c\u53ea\u8981\u975e\u7a7a\uff0c\u5c31\u8fd4\u56deTrue\uff1b\u5176\u4ed6\u7c7b\u578b\u4e5f\u53ef\u7c7b\u63a8 bool(-1) =True bool(0)=False \u57fa\u672c\u51fd\u6570\u8fd0\u7b97 \u00b6 \u4e0b\u9762\u7684\u8fd0\u7b97\u7406\u8bba\u4e0a\u5c5e\u4e8e\u4ee3\u6570\u8fd0\u7b97\uff0c\u4f46\u4f7f\u7528\u65f6\u5f62\u5982\u8c03\u7528\u51fd\u6570\uff08\u4e8b\u5b9e\u4e0a\u4ed6\u4eec\u672c\u8d28\u4e0a\u5c31\u662f\u51fd\u6570\uff09\uff0c\u56e0\u6b64\u5355\u72ec\u5217\u51fa\u3002 \u8fd0\u7b97 \u7b26\u53f7 \u7279\u6b8a\u8bf4\u660e \u793a\u4f8b \u4e58\u65b9 pow(a,b) \u6216 a**b \uff08\u4e0a\u6587\u5df2\u6709\u8be6\u7ec6\u8bf4\u660e\uff09 \u7edd\u5bf9\u503c abs(a) abs(-3) =3 \u5e26\u4f59\u9664\u6cd5 divmod(a,b) \u8fd4\u56de\u4e8c\u5143\u7ec4(a//b, a%b) div(4,3) =(1,1) \u8fd0\u7b97\u4f18\u5148\u7ea7 \u00b6 \u53c2\u89c1\uff1a https://docs.python.org/zh-cn/3/reference/expressions.html#operator-precedence \u6ce8\u91ca \u00b6 \u7528#\u5f00\u5934\u7684\u4e00\u884c\u4ee3\u7801\u8868\u793a\u6ce8\u91ca\u3002\u4e5f\u53ef\u4ee5\u7528\u5355\u72ec\u7684\u591a\u884c\u5b57\u7b26\u4e32\u8868\u793a\u6ce8\u91ca\u3002 1 2 3 4 5 # note \"\"\" other note \"\"\" \u591a\u884c\u6ce8\u91ca\u4f1a\u5728\u540e\u6587\u7684\u51fd\u6570\u4e2d\u7528\u5230\uff0c\u8d77\u5230\u7c7b\u4f3c\u4e8e\u51fd\u6570\u4f5c\u7528\u6587\u6863\u7684\u4f5c\u7528\u3002 \u5355\u884c\u6ce8\u91ca\u6709\u65f6\u4e5f\u6709\u53e6\u4e00\u4e2a\u4f5c\u7528\u3002\u5982\u679c\u4f60\u5728\u4f60\u7684py\u6587\u4ef6\u5f00\u5934\u52a0\u4e0a\u8fd9\u4e48\u4e00\u53e5\u6ce8\u91ca\uff1a 1 # coding: utf-8 \u90a3\u4e48\u6574\u4e2a\u6587\u4ef6\u5c06\u4f1a\u88ab\u7f16\u7801\u4e3autf-8\u540e\u6267\u884c\u3002 \u4f60\u53ef\u80fd\u4f1a\u89c9\u5f97\u5f88\u4e0d\u81ea\u7136\uff0c\u56e0\u4e3a\u4e00\u822c\u5370\u8c61\u4e2d\u6ce8\u91ca\u9664\u4e86\u7ed9\u4eba\u770b\u4ee5\u5916\u5c31\u6ca1\u4ec0\u4e48\u522b\u7684\u7528\u5904\u4e86\uff0c\u4f46\u5728\u8fd9\u91cc\u5b83\u786e\u5b9e\u5f71\u54cd\u4e86\u7a0b\u5e8f\u7684\u8fd0\u884c\uff08\u4f60\u53ef\u4ee5\u628a\u4e0a\u9762\u7684utf-8\u6362\u6210\u522b\u7684\u968f\u4fbf\u4ec0\u4e48\u4e1c\u897f\uff0c\u7136\u540e\u8fd0\u884c\u7684\u65f6\u5019\u4f1a\u62a5\u9519\uff09\u3002\u4e8b\u5b9e\u4e0a \u5b98\u65b9\u6587\u6863 \u628a\u8fd9\u79cd\u64cd\u4f5c\u53eb\u505aEncoding declarations\uff0c\u5b83\u662f\u901a\u8fc7\u6b63\u5219\u8868\u8fbe\u5f0f\u5339\u914d \u524d\u4e24\u884c \u6ce8\u91ca\u5b9e\u73b0\u7684\uff0c\u4f5c\u7528\u5c31\u662f\u6211\u4eec\u63d0\u5230\u7684\u6539\u53d8\u7f16\u7801\u3002\u4e5f\u5c31\u662f\u8bf4\u8fd9\u79cd\u7279\u6b8a\u7684\u5199\u6cd5\u53ea\u5bf9\u5f00\u5934\u524d\u4e24\u884c\u6ce8\u91ca\u6709\u7528\u3002 \u6709\u6ca1\u6709\u522b\u7684\u7c7b\u4f3c\u5199\u6cd5\u53ef\u4ee5\u4f7f\u5f97\u6ce8\u91ca\u6539\u53d8\u8fd0\u884c\u7684\u884c\u4e3a\u5462\uff1f\u636e\u6211\u6240\u77e5\u4e5f\u5c31\u53ea\u6709\u8fd9\u4e00\u4e2a\u4e86\uff0c\u81f3\u4e8e\u522b\u7684\u6709\u6ca1\u6709\u2026\u2026\u6211\u4e5f\u4e0d\u77e5\u9053\uff08\u9003\uff09 \u53e6\u5916\u6211\u7684\u5199\u6cd5\u5e76\u4e0d\u662f\u5b98\u65b9\u63a8\u8350\u7684\u5199\u6cd5\uff0c\u5982\u679c\u771f\u7684\u8981\u7528\u53ef\u4ee5\u53c2\u8003\u5b98\u65b9\u6587\u6863\uff08\u4e0a\u6587\u7684\u94fe\u63a5\u5df2\u7ecf\u7ed9\u51fa\uff09\u3002 \u63a7\u5236\u53f0\u4e0a\u7684\u8f93\u5165\u548c\u8f93\u51fa \u00b6 \u5728\u63a7\u5236\u53f0\u8f93\u5165\u8f93\u51fa\uff0c\u4e3b\u8981\u4f9d\u9760input\u548cprint\u4e24\u4e2a\u51fd\u6570\u3002 print \u00b6 \u53ef\u4ee5\u76f4\u63a5\u8f93\u51fa\u6570\u5b57\u3001\u5b57\u7b26\u4e32\u7b49\u7c7b\u578b\uff1bprint\u51fd\u6570\u4f1a\u628a\u4ed6\u4eec\u81ea\u52a8\u8f6c\u6362\u6210\u5b57\u7b26\u4e32\u7c7b\u578b\u540e\u8f93\u51fa\uff1b \u4e5f\u53ef\u4ee5\u7528\u9017\u53f7\u5206\u9694\u6765\u540c\u65f6\u8f93\u51fa\u591a\u4e2a\u5185\u5bb9\uff0c\u4ed6\u4eec\u4e4b\u95f4\u4f1a\u7528\u7a7a\u683c\u5206\u9694\u3002 print\u9ed8\u8ba4\u4ee5\u4e00\u4e2a\u6362\u884c\u7b26(\\n)\u7ed3\u5c3e\uff0c\u53ef\u4ee5\u6539\u53d8print\u51fd\u6570\u7684 end\u5173\u952e\u5b57\u53c2\u6570 \u4e3a\u53e6\u4e00\u4e2a\u5b57\u7b26\u4e32\u6765\u6539\u53d8\u7ed3\u5c3e\uff0c\u4f8b\u5982\u5c06\u5b83\u6539\u6210\u4e00\u4e2a\u7a7a\u4e32end=''\uff0c\u5c31\u53ef\u4ee5\u8ba9\u5b83\u4e0d\u6362\u884c\u3002 1 2 3 a = b = 15 print ( a , b , \"Yes\" ) print ( a , end = '' ) input \u00b6 \u8c03\u7528\u6b64\u51fd\u6570\u540e\uff0c\u5c06\u4f1a\u5728\u63a7\u5236\u53f0\u8bfb\u5165 \u4e00\u884c \u952e\u76d8\u8f93\u5165\uff08\u4e0d\u5305\u62ec\u6362\u884c\u7b26\u53f7\uff09\uff0c\u5e76\u8fd4\u56de\u5b57\u7b26\u4e32\u3002 \u4e5f\u53ef\u4ee5\u7ed9input\u4f20\u5165\u4e00\u4e2a\u5b57\u7b26\u4e32\u4f5c\u4e3a\u53c2\u6570\uff0c\u8fd9\u6837\u5728\u8bfb\u5165\u524d\u4f1a\u5148\u8f93\u51fa\u4e00\u884c\u5b57\u7b26\u4e32\u63d0\u793a\u7528\u6237\u8f93\u5165\u7684\u5185\u5bb9\u3002\uff08\u5927\u591a\u6570\u65f6\u5019\u8fd9\u4e2a\u529f\u80fd\u6bd4\u8f83\u9e21\u808b\u7528\u4e0d\u4e0a\uff09 1 a = input ( '123 \\n ' ) \u8981\u60f3\u8f93\u5165\u6574\u6570\u3001\u6d6e\u70b9\u6570\uff0c\u9700\u8981\u7528\u4e0a\u6587\u63d0\u5230\u7684\u7c7b\u578b\u8f6c\u6362\u51fd\u6570\uff0c\u4ee5\u6574\u6570\u4e3a\u4f8b 1 a = int ( input ()) \u5f53\u7136\u8fd9\u6837\u6bcf\u6b21\u6bcf\u884c\u53ea\u80fd\u8f93\u5165\u4e00\u4e2a\u6570\u3002\u5982\u679c\u4f60\u5e0c\u671b\u6bcf\u884c\u8f93\u5165\u82e5\u5e72\u4e2a\u4ee5\u7a7a\u683c\u5206\u9694\u7684\u6570\uff08\u4f8b\u5982\u4e09\u4e2a\uff09\uff0c\u53ef\u4ee5\u8fd9\u4e48\u5199\uff1a 1 a , b , c = map ( int , input () . split ()) input().split()\u5c06\u4f1a\u628a\u8bfb\u5165\u7684\u5b57\u7b26\u4e32\u6309\u7167\u7a7a\u683c\u5206\u9694\u6210\u82e5\u5e72\u5b57\u7b26\u4e32\uff0c\u6700\u540e\u6309\u987a\u5e8f\u585e\u8fdb\u4e00\u4e2a\u5217\u8868\u4e2d\u5e76\u8fd4\u56de\u6539\u5217\u8868\u3002map\u53ef\u4ee5\u4ee5\u4e00\u4e2a\u51fd\u6570\u4f5c\u4e3a\u53c2\u6570(\u7b2c\u4e00\u4e2a\u53c2\u6570)\uff0c\u5c06\u4e00\u4e2a\u5217\u8868\uff08\u7b2c\u4e8c\u4e2a\u53c2\u6570\uff09\u4e2d\u7684\u6bcf\u4e2a\u5143\u7d20\u8f93\u5165\u5230\u8fd9\u4e2a\u51fd\u6570\u4e2d\uff0c\u8fd4\u56de\u6620\u5c04\u540e\u7684\u7ed3\u679c\uff0c\u6700\u540e\u518d\u901a\u8fc7\u89e3\u5305\u8bed\u6cd5\u9010\u4e2a\u8d4b\u503c\u5230a\u3001b\u3001c\u4e09\u4e2a\u53d8\u91cf\u4e2d\u3002\u5173\u4e8e\u6d89\u53ca\u5230\u7684\u5217\u8868\u3001\u5b57\u7b26\u4e32\u65b9\u6cd5\u7b49\u4e4b\u540e\u4f1a\u8be6\u7ec6\u8bf4\u660e\u3002 \u5982\u679c\u4f60\u60f3\u8bfb\u5165\u6570\u91cf\u4e0d\u5b9a\u7684\u6574\u6570\u5e8f\u5217\uff08\u5e76\u5f97\u5230\u4e00\u4e2a\u5217\u8868\uff09\uff0c\u6709\u4e24\u79cd\u5199\u6cd5\uff1a 1 2 L1 = list ( map ( int , input () . split ())) L2 = [ int ( x ) for x in input () . split ()] \u7b2c\u4e00\u79cd\u505a\u6cd5\u662f\u901a\u8fc7\u5c06map\u5bf9\u8c61\u901a\u8fc7list\u7c7b\u578b\u8f6c\u6362\u51fd\u6570\u8f6c\u6362\u6210\u5217\u8868\u540e\u5b9e\u73b0\u7684\uff08\u6ce8\u610fmap\u8fd9\u4e2a\u51fd\u6570\u8fd4\u56de\u7684\u4e0d\u76f4\u63a5\u662f\u4e00\u4e2a\u5217\u8868\uff0c\u800c\u662f\u4e00\u4e2amap\u5bf9\u8c61\uff09\u3002\u7b2c\u4e8c\u79cd\u505a\u6cd5\u7528\u5230\u4e86\u5217\u8868\u751f\u6210\u5f0f\u7684\u7279\u6027\uff0c\u4e4b\u540e\u4f1a\u8be6\u7ec6\u8bf4\u660e\u3002 \u6742\u9879 \u00b6 pass \u00b6 \u4f7f\u7528pass\u53ef\u4ee5\u5728\u672c\u5e94\u8f93\u5165\u4ee3\u7801\u7684\u5730\u65b9\u5360\u4f4d\uff0c\u5176\u6ca1\u6709\u5b9e\u9645\u610f\u4e49\u3002\u4f8b\u5982\u4f60\u53ef\u4ee5\u8fd9\u4e48\u5b9a\u4e49\u201c\u7a7a\u51fd\u6570\u201d\uff1a 1 2 def Func (): pass \u5206\u53f7 \u00b6 \u4f7f\u7528\u5206\u53f7\u53ef\u4ee5\u201c\u538b\u884c\u201d\u2014\u2014\u5c06\u672c\u6765\u9700\u8981\u5199\u6210\u591a\u884c\u7684\u4ee3\u7801\u5199\u5728\u4e00\u884c 1 a = 1 ; b = 2 ; c = 3 ; \u53cd\u659c\u6760\u7eed\u884c\u7b26 \u00b6 \u4f7f\u7528\u53cd\u659c\u6760\u53ef\u4ee5\u5c06\u4e00\u884c\u62c6\u6210\u82e5\u5e72\u884c\uff0c\u4f46\u8981\u6ce8\u610f\u53cd\u659c\u6760\u540e\u9762\u4e0d\u80fd\u6709\u522b\u7684\u4e1c\u897f\u3002 1 2 print ( input () . split ( \\ )) \u5e38\u7528\u6570\u636e\u7ed3\u6784\u7b80\u4ecb \u00b6 \u53ef\u53d8\u5bf9\u8c61\u3001\u4e0d\u53ef\u53d8\u5bf9\u8c61 \u00b6 \u4e0d\u53ef\u53d8\u5bf9\u8c61 \uff1a\u5bf9\u8c61\u4e00\u65e6\u521b\u5efa\uff0c\u5bf9\u8c61\u4e2d\u5185\u5bb9\u5c31\u4e0d\u53ef\u518d\u6539\u53d8\uff0c\u53ea\u80fd\u7528\u8fd9\u4e2a\u5bf9\u8c61\u53bb\u521b\u5efa\u53e6\u4e00\u4e2a\u65b0\u7684\u5bf9\u8c61\u3002\u5982\u6574\u6570\u3001\u5b57\u7b26\u4e32\u7b49\u3002 \u53ef\u53d8\u5bf9\u8c61 \uff1a\u5bf9\u8c61\u4e2d\u7684\u5185\u5bb9\u5728\u521b\u5efa\u540e\u4ecd\u7136\u662f\u53ef\u53d8\u7684\u3002\u5982\u5217\u8868\u3001\u5b57\u5178\u3001\u96c6\u5408\u3002 \u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u6574\u6570\u7684\u8fd0\u7b97\u5176\u5b9e\u662f\u5728\u7b97\u5b8c\u4e4b\u540e\u65b0\u5efa\u4e86\u4e00\u4e2a\u6574\u6570\u5bf9\u8c61\uff0c\u800c\u4e0d\u662f\u5728\u539f\u6709\u5bf9\u8c61\u57fa\u7840\u4e0a\u4fee\u6539\u503c\u3002\u5b57\u7b26\u4e32\u7b49\u4e5f\u540c\u7406\uff0c\u5b57\u7b26\u4e32\u7684\u62fc\u63a5\u7b49\u64cd\u4f5c\u5b9e\u9645\u4e0a\u662f\u65b0\u751f\u6210\u4e86\u53e6\u4e00\u4e2a\u5b57\u7b26\u4e32\u5bf9\u8c61\u3002\u800c\u5bf9\u4e8e\u53ef\u53d8\u5bf9\u8c61\u800c\u8a00\u5c31\u672a\u5fc5\u4e86\uff0c\u53ef\u80fd\u6709\u4e9b\u65b9\u6cd5\u662f\u6539\u53d8\u539f\u6765\u5bf9\u8c61\u7684\uff0c\u53ef\u80fd\u6709\u4e9b\u662f\u8fd4\u56de\u65b0\u5bf9\u8c61\u7684\u3002 \u8981\u60f3\u770b\u4e24\u4e2a\u53d8\u91cf\u6240\u6307\u5411\u7684\u5bf9\u8c61\u662f\u4e0d\u662f \u540c\u4e00\u4e2a \u5bf9\u8c61\uff0c\u53ef\u4ee5\u4f7f\u7528id\u51fd\u6570\u67e5\u770b\u5bf9\u8c61\u7684\u5730\u5740\u3002\u53ea\u6709\u5730\u5740\u5b8c\u5168\u76f8\u540c\uff0c\u4e24\u4e2a\u5bf9\u8c61\u624d\u76f8\u540c\uff0c\u8fd9\u70b9\u5df2\u5728\u4e4b\u524d\u5bf9is\u7684\u8bf4\u660e\u4e2d\u63d0\u5230\u3002 \u5217\u8868 \u00b6 \u5217\u8868\u7c7b\u4f3c\u4e8eC\u4e2d\u7684vector\uff0c\u4e0d\u8fc7\u5b9e\u9645\u4e0a\u5b83\u66f4\u63a5\u8fd1\u5e7f\u4e49\u8868\u3002 \u5217\u8868\u662f \u53ef\u53d8 \u7684\uff1a\u8868\u53ef\u4ee5\u81ea\u7531\u5730\u589e\u52a0\u3001\u5220\u9664\u5143\u7d20\uff0c\u4e5f\u53ef\u4ee5\u6539\u53d8\u5217\u8868\u4e2d\u67d0\u4e2a\u7279\u5b9a\u4f4d\u7f6e\u5143\u7d20\u7684\u503c\uff0c\u957f\u5ea6\u4e0d\u5b9a\u3002 \u8868\u4e2d\u5143\u7d20\u53ef\u4ee5\u662f\u4efb\u4f55\u5bf9\u8c61\uff08\u6bd4\u5982\u6574\u6570\u3001\u6d6e\u70b9\u6570\u3001\u53e6\u4e00\u4e2a\u5217\u8868\u7b49\u7b49\uff09\uff0c\u8868\u4e2d\u5143\u7d20\u751a\u81f3\u53ef\u4ee5\u662f\u81ea\u5df1\u3002 \u65b0\u5efa\u5217\u8868 \u00b6 1 2 3 a = [] #\u7a7a\u5217\u8868 b = [ 1 , 2 , 3 ,[ 4 , 5 , 6 ]] #\u6709\u521d\u59cb\u503c\u7684\u5217\u8868\uff0c\u6700\u540e\u4e00\u4e2a\u5143\u7d20\u662f\u53e6\u4e00\u4e2a\u5217\u8868\uff0c\u56e0\u6b64\u8fd9\u4e2a\u5217\u8868\u662f\u5d4c\u5957\u7684 c = list ( \"abc\" ) #\u4f7f\u7528\u5176\u4ed6\u53ef\u8fed\u4ee3\u5bf9\u8c61\u6784\u9020\u65b0\u5217\u8868 list\u51fd\u6570\u662f\u6784\u9020\u4e00\u4e2a\u65b0\u5217\u8868\u7528\u7684\u51fd\u6570\u3002\u5982\u679c\u4e0d\u4f20\u5165\u53c2\u6570\u90a3\u4e48\u5c06\u4f1a\u8fd4\u56de\u7a7a\u5217\u8868\uff08\u56e0\u6b64 a=list() \u548c a=[] \u6548\u679c\u4e00\u6837\uff09\uff0c\u5982\u679c\u4f20\u5165\u4e86\u53e6\u4e00\u4e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\uff08\u4e4b\u540e\u4f1a\u63d0\u5230\uff09\uff0c\u90a3\u4e48\u5b83\u4f1a\u4ee5\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e2d\u7684\u6bcf\u4e00\u4e2a\u5143\u7d20\u4f5c\u4e3a\u5217\u8868\u4e2d\u7684\u5143\u7d20\u3002 \u5173\u4e8e\u5217\u8868\u7684\u8be6\u7ec6\u65b9\u6cd5\u53c2\u89c1\u4e4b\u540e\u7684\u201c\u5e38\u7528\u6570\u636e\u7ed3\u6784\u65b9\u6cd5\u4e0e\u76f8\u5173\u5e38\u7528\u51fd\u6570\u201d\u3002 \u5143\u7ec4 \u00b6 \u4e0e\u5217\u8868\u7c7b\u4f3c\uff0c\u4f46\u662f\uff0c\u5b83\u7684\u5143\u7d20\u5728\u521d\u59cb\u5316\u5b8c\u6210\u4e4b\u540e\u5c31\u4e0d\u518d\u53ef\u6539\u53d8\u3002 \u5143\u7ec4\u662f \u4e0d\u53ef\u53d8\u7684 \uff1a\u4e0d\u80fd\u5220\u9664\u6216\u8005\u6dfb\u52a0\u5143\u7d20\u3002 \u8868\u4e2d\u5143\u7d20\u53ef\u4ee5\u662f\u4efb\u4f55\u5bf9\u8c61\u3002 \u65b0\u5efa\u5143\u7ec4 \u00b6 1 2 3 4 a = () #\u7a7a\u5143\u7ec4 b = ( 4 , 2 , 3 ,[ 5 , 7 ],( 6 , 1 )) #\u5e26\u6709\u82e5\u5e72\u521d\u59cb\u5143\u7d20\u7684\u5143\u7ec4 c = 4 , 2 , 3 , #\u5728\u6ca1\u6709\u6b67\u4e49\u7684\u60c5\u51b5\u4e0b\uff0c\u7b49\u53f7\u53f3\u503c\u7701\u7565\u62ec\u53f7\u4e5f\u76f8\u5f53\u4e8e\u5143\u7ec4 d = tuple ([ 1 , 2 , 3 ]) #d==(1,2,3) tuple\u540c\u6837\u662f\u7528\u4e8e\u6784\u9020\u4e00\u4e2a\u65b0\u5143\u7ec4\u7528\u7684\u51fd\u6570\u3002 \u5217\u8868\u548c\u5143\u7ec4\u4e2d\u7684\u5143\u7d20\u95ee\u9898 \u00b6 \u9700\u8981\u6307\u51fa\u7684\u662f\uff0c\u201c\u5143\u7ec4\u662f\u4e0d\u53ef\u53d8\u7684\u201d\u6307\u7684\u662f\u5143\u7ec4\u4e2d\u6240\u5305\u542b\u7684\u201c\u5185\u5bb9\u201d\u4e0d\u80fd\u518d\u66f4\u6539\u4e86\u3002\u4f46\u201c\u5185\u5bb9\u201d\u6307\u7684\u7a76\u7adf\u662f\u4ec0\u4e48\u5462\uff1f \u4e4b\u524d\u7684\u6587\u7ae0\u63d0\u5230\u4e86\u5728python\u4e2d\u53d8\u91cf\u7684\u672c\u8d28\u5b9e\u9645\u4e0a\u662f\u6307\u5411\u5bf9\u8c61\u7684\u201d\u6307\u9488\u201c\uff0c\u56e0\u6b64\uff0c\u5982\u679c\u4f60\u662f\u901a\u8fc7\u8fd9\u4e2a\u6307\u9488\u53bb\u6539\u53d8\u4e86\u4e00\u4e2a\u53ef\u53d8\u5bf9\u8c61\uff0c\u90a3\u4e48\u6240\u6709\u6307\u5411\u8fd9\u4e2a\u5bf9\u8c61\u7684\u6307\u9488\uff08\u4e5f\u5373\u53d8\u91cf\uff09\u6240\u6307\u5411\u7684\u5185\u5bb9\u81ea\u7136\u4e5f\u4f1a\u53d1\u751f\u6539\u53d8\u3002\u4f8b\u5982\uff1a 1 2 3 a = b = [ 1 , 2 , 3 ] a . append ( 4 ) #\u5728\u5217\u8868\u672b\u5c3e\u63d2\u5165\u65b0\u5143\u7d20 print ( a , b ) #[1, 2, 3, 4] [1, 2, 3, 4] \u53ef\u4ee5\u770b\u5230\uff0c\u7531\u4e8ea\u548cb\u6307\u5411\u7684\u662f\u540c\u4e00\u4e2a\u5bf9\u8c61\uff0c\u56e0\u6b64\u5bf9\u8fd9\u4e2a\u5bf9\u8c61\u7684\u64cd\u4f5c\u4f1a\u5f71\u54cd\u5230\u6240\u6709\u6307\u5411\u8fd9\u4e2a\u5bf9\u8c61\u7684\u53d8\u91cf\u3002 \u518d\u770b\u4e00\u4e2a\u5d4c\u5957\u5217\u8868\u7684\u4f8b\u5b50\uff0c\u8fd9\u4e2a\u5217\u8868\u6700\u540e\u4e00\u4e2a\u5143\u7d20\u662f\u53e6\u4e00\u4e2a\u5217\u8868\uff0c\u6211\u4eec\u8bd5\u56fe\u5bf9\u6700\u540e\u8fd9\u4e2a\u5217\u8868\u63d2\u5165\u5143\u7d20\uff1a 1 2 3 4 b = [ 1 , 2 , 3 ,[ 4 , 5 , 6 ]] a = b [ 3 ] #\u53d6\u5f97\u6307\u5411[4,5,6]\u7684\u53d8\u91cf\uff08\u6307\u9488\uff09 a . append ( 4 ) print ( b ) #[1,2,3,[4,5,6,4]] \u7701\u7565\u6389a\u53d8\u91cf\u4f9d\u7136\u80fd\u591f\u6210\u529f\uff1a 1 2 3 b = [ 1 , 2 , 3 ,[ 4 , 5 , 6 ]] b [ 3 ] . append ( 4 ) print ( b ) #[1,2,3,[4,5,6,4]] \u53ef\u4ee5\u770b\u5230b\u4e2d\u663e\u793a\u7684\u5185\u5bb9\u4e5f\u53d1\u751f\u4e86\u6539\u53d8\u3002\u8fd9\u8bf4\u660e\u4e86\u4e00\u4e2a\u95ee\u9898\uff1a \u5217\u8868\u4e2d\u7684\u53e6\u4e00\u4e2a\u5217\u8868 \uff0c\u5b9e\u9645\u4e0a\u5b58\u7684\u4e5f\u662f\u6307\u5411\u8fd9\u4e2a \u53e6\u4e00\u4e2a\u5217\u8868\u7684\u6307\u9488 \uff0c\u6216\u8005\u8bf4\u662f\u4e00\u79cd \u5f15\u7528 \uff0c\u771f\u6b63\u7684\u8fd9\u4e2a\u53e6\u4e00\u4e2a\u5217\u8868\u5176\u5b9e\u5728\u53e6\u4e00\u4e2a\u5730\u65b9\u5b58\u7740\u3002\u53ea\u662f\u5728\u8fd9\u91cc\u5e76\u6ca1\u6709\u4e00\u4e2a\u660e\u663e\u7684\u53d8\u91cf\u8868\u660e\u5b83\u662f\u4e00\u4e2a\u201d\u5f15\u7528\u201c\u3002 \u5982\u679c\u628a\u4e0a\u4f8b\u4e2d\u7684b\u6539\u6210\u5143\u7ec4\u800c\u522b\u7684\u4e0d\u53d8\uff0c\u90a3\u4e48\u53bb\u6539\u53d8\u5217\u8868\u5c31\u4f1a\u5bfc\u81f4b\u6307\u5411\u7684\u5143\u7ec4\u201c\u770b\u4e0a\u53bb\u53d8\u4e86\u201d\uff0c\u4f46\u5b9e\u9645\u4e0a\u5143\u7ec4\u4e2d\u5b58\u7684\u662f\u6307\u5411\u5404\u4e2a\u5bf9\u8c61\u7684\u6307\u9488\uff0c\u5143\u7ec4\u786e\u5b9e\u6ca1\u6709\u6539\u53d8\u3002 1 2 3 b = ( 1 , 2 , 3 ,[ 4 , 5 , 6 ]) b [ 3 ] . append ( 4 ) print ( b ) #(1,2,3,[4,5,6,4]) \u96c6\u5408 \u00b6 \u7c7b\u4f3c\u6570\u5b66\u4e0a\u7684\u96c6\u5408\uff0c\u4e00\u4e2a\u96c6\u5408\u4e2d\u7684\u5143\u7d20\u662f\u552f\u4e00\u7684\u3002\u63d2\u5165\u96c6\u5408\u4e2d\u5df2\u6709\u7684\u5143\u7d20\u540e\uff0c\u96c6\u5408\u4f1a\u81ea\u52a8\u5408\u5e76\u91cd\u590d\u7684\u5143\u7d20\u3002 \u96c6\u5408\u662f \u53ef\u53d8\u7684 \u3002 Python\u4e2d\u7684\u96c6\u5408\u5e95\u5c42\u662f\u7528\u54c8\u5e0c\u5b9e\u73b0\u7684\uff0c\u56e0\u6b64\u63d2\u5165\u6216\u521d\u59cb\u5316\u96c6\u5408\u7684\u5bf9\u8c61\u5fc5\u987b\u8981\u662f \u53ef\u54c8\u5e0c\u7684 \uff08hashable\uff09\u3002\u6570\u3001\u5b57\u7b26\u4e32\u3001\u4e0d\u5305\u542b\u53ef\u53d8\u5bf9\u8c61\u7684\u5143\u7ec4\u90fd\u662f\u53ef\u54c8\u5e0c\u7684\uff0c\u4f46\u53ef\u53d8\u5bf9\u8c61\uff08\u5982\u5217\u8868\uff09\u5c31\u4e0d\u662f\u3002 \u65b0\u5efa\u96c6\u5408 \u00b6 1 2 s = set () s = set ([ 1 , 2 , 5 , 8 , 0 ]) #\u6709\u521d\u503c\u7684\u521d\u59cb\u5316\uff1a{0,1,2,5,8} \u867d\u7136\u96c6\u5408\u5f62\u5982{}\uff0c\u4f46\u662f\u4e0d\u80fd\u7528{}\u65b0\u5efa\u4e00\u4e2a\u7a7a\u96c6\u5408\uff0c\u56e0\u4e3a\u8fd9\u4e48\u5199\u5176\u5b9e\u662f\u5728\u65b0\u5efa\u4e00\u4e2a\u7a7a\u5b57\u5178\u3002 \u5b57\u5178 \u00b6 \u5982\u679c\u4f60\u63a5\u89e6\u8fc7json\u6216\u8005C++\u7684map\u7684\u8bdd\u4f60\u5e94\u8be5\u5bf9\u5b57\u5178\u5f88\u719f\u6089\u3002\u5b57\u5178\u4fdd\u5b58\u4e86\u4e00\u7cfb\u5217\u952e\u503c\u5bf9\u7684\u96c6\u5408\uff0c\u5e76\u53ef\u628a\u952e\u7528\u7c7b\u4f3c\u4e8e\u7d22\u5f15\u7684\u65b9\u5f0f\u53d6\u5f97\u503c\u3002 \u5b57\u5178\u662f \u53ef\u53d8\u7684 \u3002 \u952e \u5fc5\u987b\u8981\u662f \u53ef\u54c8\u5e0c\u7684 \uff0c\u548c\u96c6\u5408\u7c7b\u4f3c\u3002\u5b57\u5178\u5e95\u5c42\u4e5f\u662f\u7528\u54c8\u5e0c\u8868\u5b9e\u73b0\u7684\u3002 \u65b0\u5efa\u5b57\u5178 \u00b6 1 2 3 4 5 s = {} #\u7a7a\u5b57\u5178 s = dict () #\u7a7a\u5b57\u5178 s = { 1 : 2 , \"3\" : 4 ,( 5 ):[ 6 , 7 , 8 ]} #\u5e26\u6709\u6574\u6570\u3001\u5b57\u7b26\u4e32\u548c\u5143\u7ec4\u4f5c\u4e3a\u952e\u7684\u5b57\u5178 s [ 1 ] s [ \"3\" ] #\u6309\u7167\u7d22\u5f15\u53d6\u5f97\u503c \u5b57\u7b26\u4e32 \u00b6 \u5b57\u7b26\u4e32\u4e4b\u524d\u5df2\u7ecf\u63d0\u5230\u8fc7\uff0c\u8fd9\u91cc \u5b57\u7b26\u4e32\u662f \u4e0d\u53ef\u53d8\u7684 \u524d\u7f00 \u00b6 Prefix r R \u539f\u751f\u5b57\u7b26\u4e32\uff0c\u4e0d\u4f1a\u8f6c\u4e49 f F \u683c\u5f0f\u5b57\u7b26\u4e32\uff08\u53c2\u89c1\u683c\u5f0f\u5316\u5b57\u7b26\u4e32\u4e00\u8282\uff09 u U \u9ed8\u8ba4\u7684\u524d\u7f00\uff0c\u8868\u793a\u4ee5Unicode\u65b9\u5f0f\u4fdd\u5b58\u5b57\u7b26\u4e32 b B \u751f\u6210bytes\u7c7b\u578b\uff0c\u5176\u4e2d\u53ea\u5141\u8bb8\u4f7f\u7528ascii\u5b57\u7b26\uff0c\u8d85\u51fa127\u7684\u5b57\u7b26\u9700\u8981\u8f6c\u4e49\u3002\u5e8f\u5217\u4e2d\u7684\u6bcf\u4e2a\u503c\u7684\u5927\u5c0f\u88ab\u9650\u5236\u4e3a 0 <= x < 256 (\u5982\u679c\u8fdd\u53cd\u6b64\u9650\u5236\u5c06\u5f15\u53d1 ValueError ) \u53ef\u8fed\u4ee3\u5bf9\u8c61(Iterable)\u3001\u8fed\u4ee3\u5668\uff08Iterator\uff09 \u00b6 \u53ef\u8fed\u4ee3\u5bf9\u8c61 \uff1a\u53ef\u88abfor\u5faa\u73af\uff08\u4e4b\u540e\u4f1a\u63d0\u5230\uff09\u8fed\u4ee3\u7684\u5bf9\u8c61\u7edf\u79f0\u4e3a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u3002\u5217\u8868\u3001\u5b57\u5178\u3001\u5143\u7ec4\u3001\u96c6\u5408\u3001\u5b57\u7b26\u4e32\u7b49\u90fd\u662f\u53ef\u8fed\u4ee3\u5bf9\u8c61\u3002 \u8fed\u4ee3\u5668 \uff1a \u6d45\u62f7\u8d1d\u3001\u6df1\u62f7\u8d1d \u00b6 \u5e38\u7528\u6570\u636e\u7ed3\u6784\u65b9\u6cd5\u4e0e\u76f8\u5173\u5e38\u7528\u51fd\u6570 \u00b6 \u5171\u901a\u64cd\u4f5c\u4e0e\u65b9\u6cd5 \u00b6 \u5e8f\u5217\u7c7b\u578b \uff1a\u5217\u8868\u3001\u5143\u7ec4\u3001range\u3001\u5b57\u7b26\u4e32\u7b49 \u901a\u7528\u64cd\u4f5c \u00b6 \u51e0\u4e4e\u6240\u6709\u5bf9\u8c61\u90fd\u80fd\u7528\uff0c\u5305\u62ec\u5217\u8868\u548c\u5143\u7ec4\u3001\u5b57\u5178\u3001\u96c6\u5408\u3001\u5b57\u7b26\u4e32\u7b49 \u8fd0\u7b97\u3001\u51fd\u6570\u6216\u65b9\u6cd5 \u7b26\u53f7 \u7279\u6b8a\u8bf4\u660e \u793a\u4f8b \u6210\u5458\u68c0\u6d4b\u8fd0\u7b97 a in b \u6216 a not in b \u89c1\u4e0a\u6587\u57fa\u672c\u8fd0\u7b97\u4e00\u8282\uff1b\u7279\u522b\u5730\uff0c\u5bf9\u5b57\u5178\u6765\u8bf4a\u662fb\u7684\u952e\u65f6\u8fd4\u56deTrue \u53d6\u5f97\u957f\u5ea6 len(a) \u53d6\u5f97a\u5bf9\u8c61\u7684\u957f\u5ea6\uff08\u5143\u7d20\u4e2a\u6570\uff09 \u6700\u5c0f\u503c min(a) a\u4e2d\u5143\u7d20\u6700\u5c0f\u503c \u6700\u5927\u503c max(a) a\u4e2d\u5143\u7d20\u6700\u5927\u503c \u5e8f\u5217\u901a\u7528\u64cd\u4f5c \u00b6 \u9664\u975e\u6709\u7279\u6b8a\u8bf4\u660e\uff0c\u4e0b\u9762\u7684\u64cd\u4f5c\u53ef\u7528\u4e8e\u5143\u7ec4\u3001\u5217\u8868\u3001\u5b57\u7b26\u4e32\u3002 \u8fd0\u7b97\u3001\u51fd\u6570\u6216\u65b9\u6cd5 \u7b26\u53f7 \u7279\u6b8a\u8bf4\u660e \u793a\u4f8b \u4e32\u63a5 a+b \u9996\u5c3e\u76f8\u63a5\uff0c\u8fd4\u56de\u65b0\u5bf9\u8c61 [1,2]+[3,4] =[1,2,3,4] \u91cd\u590d s*n (n\u662f\u6574\u6570) \u91cd\u590dn\u6b21\u81ea\u5df1\u5bf9\u81ea\u5df1\u7684\u4e32\u63a5\uff0c\u8fd4\u56de\u65b0\u5bf9\u8c61\uff1b\u91cd\u590d\u7684\u5143\u7d20\u5c06\u4f1a\u5f15\u7528\u88ab\u590d\u5236\u7684\u5bf9\u8c61 \"ab\"*3=\"ababab\" \u7d22\u5f15 s[i] \u53d6s\u4e2d\u7b2ci\u4e2a\uff08\u81ea0\u5f00\u59cb\u8ba1\u6570\uff09\u5143\u7d20\uff0c\u53ef\u4ee5\u4e3a\u8d1f\u6570\uff08\u76f8\u5f53\u4e8e\u4e0b\u6807\u53d8\u4e3an-i\uff09\uff1b\u8d8a\u754c\u8bbf\u95ee\u4f1a\u629b\u51faIndexError\u5f02\u5e38 \"ab\"[1] =\"b\" \u5207\u7247 s[i:j] \u53d6s\u4e2d\u7b2ci\u5230j\u4e2a\uff08\u4e0d\u5305\u62ec\u7b2cj\u4e2a\uff09\u5143\u7d20\uff0c\u6b65\u957f\u4e3a1\uff1b\u8d85\u51fa\u8303\u56f4\u7684i\u3001j\u4f1a\u88ab\u81ea\u52a8\u89c4\u7ea6\u52300\u6216len(s)\uff1b\u82e5i\u3001j\u7f3a\u7701\u4f1a\u81ea\u52a8\u8bbe\u5b9a\u62100\u548clen(s) \u201cabcd\u201d[2:4]=\"cd\" s[i:j:k] \u7531\u6ee1\u8db3x=i+nk\u7684\u6240\u6709s[x]\u7ec4\u6210\u7684\u5e8f\u5217\uff0c\u5176\u4e2dn\u662f\u6240\u6709\u6ee1\u8db30<=n<(j-i)/k\u7684\u6574\u6570\uff1b\u8d85\u51fa\u8303\u56f4\u7684i\u3001j\u4f1a\u88ab\u81ea\u52a8\u89c4\u7ea6\uff1b\u7f3a\u7701\u7684i\u3001j\u4f1a\u88ab\u81ea\u52a8\u8bbe\u5b9a\u6210\u5f00\u59cb\u6216\u7ed3\u675f\u4f4d\u7f6e\uff08\u53d6\u51b3\u4e8ek\u7684\u6b63\u8d1f\uff09 \"abcd\"[1:4:2]=\"bd\" \"abcd\"[::-1]=\"dcba\" \u67e5\u627e\u7d22\u5f15 a.index(x) \u5728a\u4e2d\u627e\u5230\u7b2c\u4e00\u6b21\u51fa\u73b0x\u7684\u4e0b\u6807\uff1b\u627e\u4e0d\u5230\u4f1a\u629b\u51faValueError\u5f02\u5e38 [2,3,5,4].index(3) =1 a.index(x,i,j) \u7b49\u4ef7\u4e8e\u5728a[i:j]\u4e2d\u627e\u7b2c\u4e00\u6b21\u51fa\u73b0x\u7684\u5bf9\u5e94\u7684a\u7684\u4e0b\u6807 [2,3,5,4].index(3,1,2) =1 \u8ba1\u6570 a.count(x) \u8fd4\u56dex\u5728a\u4e2d\u51fa\u73b0\u6b21\u6570 [1,1,2,3,5].count(1)=2 \u91cd\u590d\u3001\u5207\u7247\u7b49\u64cd\u4f5c\u662f\u6d45\u62f7\u8d1d \u53ef\u53d8\u5e8f\u5217\u901a\u7528\u64cd\u4f5c \u00b6 \u5c31\u76ee\u524d\u800c\u8a00\uff0c\u4e3b\u8981\u662f\u5217\u8868\u4f1a\u7528\u5230\u8fd9\u4e9b\u72ec\u6709\u7684\u64cd\u4f5c\u3002\u5176\u4e2d\u6709\u4e9b\u64cd\u4f5c\u5176\u4ed6\u53ef\u53d8\u7c7b\u578b\uff08\u4f46\u4e0d\u662f\u53ef\u53d8\u5e8f\u5217\u7c7b\u578b\uff09\u4e5f\u53ef\u4f7f\u7528\u3002 \u8fd0\u7b97\u3001\u51fd\u6570\u6216\u65b9\u6cd5 \u7b26\u53f7 \u7279\u6b8a\u8bf4\u660e \u793a\u4f8b \u8d4b\u503c a[i]=x a[i:j]=x a[i:j:k]=x \u5220\u9664 del a[i] del a[i:j] del a[i:j:k] del\u64cd\u4f5c\u8fd8\u53ef\u4ee5\u7528\u5728\u5355\u72ec\u7684\u5bf9\u8c61\u4e0a\uff1b \u5b57\u5178\u53ef\u7528\u5de6\u683c\u5f53\u4e2d\u7684\u7b2c\u4e00\u4e2a\u64cd\u4f5c \u5c3e\u90e8\u63d2\u5165 a.append(x) \u5728\u672b\u5c3e\u63d2\u5165\u65b0\u5143\u7d20 \u6e05\u7a7a a.clear() \u5b57\u5178\u3001\u96c6\u5408\u4e5f\u53ef\u7528 \u6d45\u62f7\u8d1d a.copy() \u5c31\u7ed3\u679c\u7b49\u4e8ea[:]\uff1b \u5b57\u5178\u3001\u96c6\u5408\u4e5f\u53ef\u7528 \u6269\u5c55 a.extend(b) \u76f8\u5f53\u4e8e\u7528\u53ef\u8fed\u4ee3\u5bf9\u8c61b\u8f6c\u6362\u6210\u5bf9\u5e94\u5e8f\u5217\u540e\u518d\u4e32\u63a5\uff1b\u5c31\u7ed3\u679c\u7b49\u4e8ea+=b [1,2].extend((3,4))=[1,2,3,4] \u4e00\u822c\u63d2\u5165 a.insert(i,x) \u5728\u4e0b\u6807i\u4e4b\u540e\u63d2\u5165x\uff0c\u4e4b\u540e\u7684\u5143\u7d20\u90fd\u5411\u540e\u79fb\u52a8\u4e00\u4f4d \u5f39\u51fa a.pop([i]) \u5220\u6389\u7b2ci\u4e2a\u5143\u7d20\uff1b\u5982\u679c\u7701\u7565i\u5219\u9ed8\u8ba4\u5220\u6389\u6700\u540e\u4e00\u4e2a\u5143\u7d20 \u79fb\u9664 a.remove(x) \u5220\u6389\u7b2c\u4e00\u4e2a\u7b49\u4e8ex\u7684\u5143\u7d20 \u53cd\u8f6c a.reverse() \u5217\u8868 \u00b6 \u8fd0\u7b97\u3001\u51fd\u6570\u6216\u65b9\u6cd5 \u7b26\u53f7 \u7279\u6b8a\u8bf4\u660e \u793a\u4f8b \u901a\u7528\u64cd\u4f5c \uff08\u89c1\u4e0a\u6587\uff09 \u5e8f\u5217\u901a\u7528\u64cd\u4f5c \u53ef\u53d8\u5e8f\u5217\u901a\u7528\u64cd\u4f5c \u6784\u9020 list([iterable]) \u53ef\u4f20\u5165\u53ef\u8fed\u4ee3\u5bf9\u8c61\u6784\u9020\u5217\u8868 \u6392\u5e8f a.sort([key=None, reverse=False]) \u9ed8\u8ba4\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\uff1b\u5c06\u5173\u952e\u5b57\u53c2\u6570reverse\u8d4b\u503c\u4e3aTrue\u53ef\u4ece\u5927\u5230\u5c0f\u6392\u5e8f\uff1bkey\u4f20\u5165\u4e00\u4e2a\u51fd\u6570\u5219\u53ef\u81ea\u5b9a\u4e49\u6bd4\u8f83\u89c4\u5219 \u5217\u8868\u751f\u6210\u5f0f\u7279\u6027\u89c1\u4e0b\u6587\u3002 \u5143\u7ec4 \u00b6 \u8fd0\u7b97\u3001\u51fd\u6570\u6216\u65b9\u6cd5 \u7b26\u53f7 \u7279\u6b8a\u8bf4\u660e \u793a\u4f8b \u901a\u7528\u64cd\u4f5c \uff08\u89c1\u4e0a\u6587\uff09 \u5e8f\u5217\u901a\u7528\u64cd\u4f5c \u6784\u9020 tuple([iterable]) \u53ef\u4f20\u5165\u53ef\u8fed\u4ee3\u5bf9\u8c61\u6784\u9020\u5143\u7ec4 \u96c6\u5408 \u00b6 \u96c6\u5408\u5141\u8bb8\u4e00\u4e9b\u7b80\u5355\u7684\u96c6\u5408\u8fd0\u7b97\u3002 \u8fd0\u7b97\u3001\u51fd\u6570\u6216\u65b9\u6cd5 \u7b26\u53f7 \u7279\u6b8a\u8bf4\u660e \u793a\u4f8b \u901a\u7528\u64cd\u4f5c \uff08\u89c1\u4e0a\u6587\uff09 \u6784\u9020 set([iterable]) \u53ef\u4f20\u5165\u53ef\u8fed\u4ee3\u5bf9\u8c61\u6784\u9020\u96c6\u5408\uff0c\u4f46\u5176\u4e2d\u7684\u5143\u7d20\u5fc5\u987b\u662f\u53ef\u54c8\u5e0c\u7684 \u6d45\u62f7\u8d1d s1.copy() \u6dfb\u52a0\u5143\u7d20 s1.add(x) \u5220\u9664\u5143\u7d20 s1.remove(x) \u4e0d\u5b58\u5728\u5219\u629b\u51faKeyError \u79fb\u9664\u5143\u7d20 s1.discard(x) \u4e0d\u5b58\u5728\u5219\u4ec0\u4e48\u4e5f\u4e0d\u505a \u5f39\u51fa\u5143\u7d20 s1.pop() \u5f39\u51fa\"\u7b2c\u4e00\u4e2a\u5143\u7d20\"\uff1b\u7a7a\u96c6\u5408\u4f1a\u629b\u51faKeyError \u6e05\u7a7a s1.clear() \u4ea4\u96c6 s1 & s2 \u6216\u8005 s1.intersection(s2) \u8fd4\u56de\u4e24\u4e2a\u96c6\u5408\u7684\u4ea4\u96c6 \u5e76\u96c6 s1 | s2 \u6216\u8005 s1.union(s2) \u5bf9\u79f0\u5dee\u96c6\uff08\u5f02\u6216\uff09 s1 ^ s2 \u6216\u8005 s1.symmetric_difference(s2) \u5dee\u96c6 s1 - s2 \u6216\u8005 s1.difference(s2) \u4e0a\u97624\u6761\u64cd\u4f5c\u7684\u66f4\u65b0\u7248\u672c s1 |= s2 , s1&=s2, s1-=s2, s1^=s2 \u5b50\u96c6\u5224\u5b9a s1 <= s2 \u6216 s1.issubset(s2) \u7b26\u5408\u6761\u4ef6\u8fd4\u56deTrue\uff0c\u4e0b\u540c \u771f\u5b50\u96c6\u5224\u5b9a s1 < s2 \u8d85\u96c6\u5224\u5b9a s1>=s2 \u6216 s1.issuperset(s2) \u771f\u8d85\u96c6\u5224\u5b9a s1 > s2 \u76f8\u4ea4\u5224\u5b9a s1.isdisjoint(s2) \u4ea4\u96c6\u7a7a\u5219\u8fd4\u56deTrue \u5b57\u5178 \u00b6 \u4e0b\u9762\u4f1a\u5217\u51fa\u5b57\u5178\u7684\u5e38\u7528\u65b9\u6cd5\uff08\u4e0d\u662f\u5168\u90e8\uff09 \u8fd0\u7b97\u3001\u51fd\u6570\u6216\u65b9\u6cd5 \u7b26\u53f7 \u7279\u6b8a\u8bf4\u660e \u793a\u4f8b \u901a\u7528\u64cd\u4f5c \uff08\u89c1\u4e0a\u6587\uff09 \u6784\u9020 dict([(k1:w1),(k2:w2),...]) dict(k1=w1,k2=w2) \u53ef\u4f20\u5165\u5217\u8868\uff08\u5217\u8868\u4e2d\u662f\u82e5\u5e72\u4e24\u4e2a\u503c\u7ec4\u6210\u7684\u5143\u7ec4\uff09\u6784\u9020\u5b57\u5178\uff0c\u4e5f\u53ef\u4f20\u5165\u5173\u952e\u5b57\u53c2\u6570\u6784\u9020\u5b57\u5178\u7b49\u3002\u8be6\u7ec6\u89c1\u5b98\u65b9\u6587\u6863 \u6d45\u62f7\u8d1d d.copy() \u6e05\u7a7a d.clear() \u7d22\u5f15\u548c\u8d4b\u503c d[k] d[k]=x k\u4e0d\u5b58\u5728\u65f6\uff0c\u76f8\u5f53\u4e8e\u63d2\u5165\u65b0\u7684\u952e\u503c\u5bf9\uff1b\u5b57\u5178\u4f1a\u786e\u4fdd\u81ea\u5df1\u7684\u5143\u7d20\u6309\u7167\u63d2\u5165\u987a\u5e8f\u6392\u5217 \u6309\u952e\u53d6\u503c d.get(k,[def=None]) \u8fd4\u56de\u8fd9\u4e2a\u952e\u5bf9\u5e94\u7684\u503c\uff1b\u5982\u679c\u6307\u5b9a\u4e86def\u53c2\u6570\u5219\u4f1a\u5728\u627e\u4e0d\u5230k\u8fd9\u4e2a\u952e\u7684\u65f6\u5019\u8fd4\u56dedef\uff0c\u5426\u5219\u8fd4\u56deNone \u6309\u952e\u5220\u9664 del d[k] \u627e\u4e0d\u5230k\u8fd9\u4e2a\u952e\u5219\u629b\u51faKeyError \u6309\u952e\u5220\u96642 d.pop(k,[def=None]) \u5220\u9664\u952e\u503c\u5bf9\u5e76\u8fd4\u56de\u8fd9\u4e2a\u952e\u5bf9\u5e94\u7684\u503c\uff1b\u5982\u679c\u6307\u5b9a\u4e86def\u53c2\u6570\u5219\u4f1a\u5728\u627e\u4e0d\u5230k\u8fd9\u4e2a\u952e\u7684\u65f6\u5019\u8fd4\u56dedef\uff0c\u5426\u5219\u4f1a\u629b\u51faKeyError \u5f39\u51fa\u5143\u7d20 d.popitem() \u5f39\u51fa\u7b2c\u4e00\u4e2a\u952e\u503c\u5bf9\u5e76\u8fd4\u56de\u4e4b\uff08\u4ee5\u5143\u7ec4\u5f62\u5f0f\uff09 \u8bbe\u7f6e\u9ed8\u8ba4\u503c d.setdefault(k,[def=None]) \u5b57\u5178\u4e2d\u5df2\u5b58\u5728k\u5219\u8fd4\u56ded[k]\uff0c\u5426\u5219d[k]=def\uff0c\u5e76\u8fd4\u56dedef\u7684\u5185\u5bb9 \u66f4\u65b0 d.update([dd]) \u6216 d |= dd \uff08Py3.9\uff09 \u4f7f\u7528dd\uff08\u5b57\u5178\u6216\u7531\u82e5\u5e72\u4e24\u4e2a\u503c\u7ec4\u6210\u7684\u5143\u7ec4\u6784\u6210\u7684\u5217\u8868\uff09\u66f4\u65b0d\u4e2d\u7684\u5185\u5bb9 \u5408\u5e76\uff08py3.9\uff09 d| dd dd\u662f\u53e6\u4e00\u4e2a\u5b57\u5178\uff0c\u5c06\u521b\u5efa\u4e24\u4e2a\u5b57\u5178\u5408\u5e76\u7684\u65b0\u5b57\u5178\u3002\uff08\u4ee5dd\u4e2d\u7684\u952e\u503c\u5bf9\u4f18\u5148\uff09 \u89c6\u56fe\u5bf9\u8c61 d.items() d.keys() d.values() \u83b7\u53d6\u952e\u503c\u5bf9\u3001\u952e\u3001\u503c\u7684\u89c6\u56fe\u5bf9\u8c61\uff0c\u4e3b\u8981\u7528\u4e8e\u8fed\u4ee3 \u5b57\u7b26\u4e32 \u00b6 \u5b57\u7b26\u4e32\u7684\u65b9\u6cd5\u76f8\u5f53\u591a\uff0c\u8fd9\u91cc\u4e5f\u53ea\u80fd\u5217\u51fa\u6bd4\u8f83\u5e38\u7528\u7684\u65b9\u6cd5 \u8fd0\u7b97\u3001\u51fd\u6570\u6216\u65b9\u6cd5 \u7b26\u53f7 \u7279\u6b8a\u8bf4\u660e \u793a\u4f8b \u901a\u7528\u64cd\u4f5c \uff08\u89c1\u4e0a\u6587\uff09 \u5e8f\u5217\u901a\u7528\u64cd\u4f5c \u6784\u9020 str([iterable]) \u53ef\u4f20\u5165\u53ef\u8fed\u4ee3\u5bf9\u8c61\u6784\u9020\u5b57\u7b26\u4e32 \u8ba1\u6570 s.count(s2,[st,ed]) \u8fd4\u56des2\u5728s[st:ed]\u5185\u7684\u51fa\u73b0\u6b21\u6570 \"abcdeeee\".count(\"e\",5,7)=2 \u67e5\u627e s.find(s2,[st,ed]) \u8fd4\u56des2\u5728s[st:ed]\u5185\u51fa\u73b0\u7684\u6700\u5c0f\u4e0b\u6807;\u627e\u4e0d\u5230\u5219\u8fd4\u56de-1 \"abcdeee\".find(\"e\")=4 \u53cd\u5411\u67e5\u627e s.rfind(s2,[st,ed]) \u540c\u4e0a\uff0c\u4f46\u627e\u7684\u662f\u6700\u5927\u4e0b\u6807 \"abcdeee\".rfind(\"e\")=6 \u5206\u9694 s.partition(s2) \u5728s\u4e2d\u627e\u5230s2\u7b2c\u4e00\u6b21\u51fa\u73b0\u7684\u4f4d\u7f6e\uff0c\u5e76\u5c06s\u62c6\u6210s2\u524d\u3001s2\u548cs2\u540e\u4e09\u4e2a\u4e32\uff0c\u8fd4\u56de\u8fd9\u4e09\u8005\u6784\u6210\u7684\u5143\u7ec4\uff08a\uff0cb\uff0cc\uff09\uff1b\u5982\u679c\u6ca1\u6709\u627e\u5230s2\u5219b\u3001c\u5c06\u4f1a\u662f\u7a7a\u4e32 \"abcdeee\".partition(\"de\") =('abc', 'de', 'ee') \"abcdeee\".partition(\"k\")=('abcdeee', '', '') \u62c6\u5206 s.split(s1=None,maxsplit=-1) \u5c06\u5b57\u7b26\u4e32\u4ee5s1\u4f4d\u5206\u9694\u7b26\u62c6\u5206\u6210\u82e5\u5e72\u5b57\u7b26\u4e32\u5e76\u7ec4\u6210\u5217\u8868\uff1b\uff08\u5982\u679cs1\u7f3a\u7701\u5219\u8868\u660e\u4ee5\u4efb\u610f\u957f\u7a7a\u683c\u4f5c\u4e3a\u5206\u9694\u7b26\u53f7\uff09\uff1b\u6307\u5b9amaxsplit\u4e3a\u6b63\u503c\u5219\u8868\u660e\u6b64\u62c6\u5206\u6700\u591a\u4f1a\u8fdb\u884c\u8fd9\u4e48\u591a\u6b21 \"h e ll o\".split()=['h', 'e', 'll', 'o'] \"wawawawa\".split(\"a\",2)=['w', 'w', 'wawa'] \u66ff\u6362 s.replace(s1,s2,[cnt]) \u5c06s\u4e2d\u51fa\u73b0\u7684s1\u5b50\u4e32\u5168\u90e8\u66ff\u6362\u6210s2\uff1b\u6307\u660ecnt\u8868\u660e\u6700\u591a\u8fdb\u884ccnt\u6b21\u66ff\u6362 'abcabcabc'.replace('abc','d',2)='ddabc' \u62fc\u63a5 s.join(L) \u4ee5\u5b57\u7b26\u4e32s\u4f5c\u4e3a\u5206\u9694\u7b26\u53f7\uff0c\u5c06\u53ef\u8fed\u4ee3\u5bf9\u8c61L\uff08\u5143\u7d20\u5fc5\u987b\u5168\u662f\u5b57\u7b26\u4e32\uff09\u4e2d\u7684\u6240\u6709\u5143\u7d20\u4e32\u63a5 '|'.join([\"L\",\"O\",\"V\",\"E\"])=\"L|O|V|E\" ''.join([\"L\",\"O\",\"V\",\"E\"])=\"LOVE\" \u5c0f\u5199\u5316\u3001\u5927\u5199\u5316 s.lower() s.upper() \u5c06s\u8f6c\u6362\u4e3a\u5168\u5c0f\u5199\u6216\u5168\u5927\u5199 \u5168\u5c0f\u5199\u3001\u5168\u5927\u5199\u5224\u5b9a s.islower() s.isupper() s\u4e2d\u7684\u5b57\u6bcd\u5168\u662f\u5c0f\u5199\u6216\u5927\u5199\u5219\u8fd4\u56deTrue \u7a7a\u683c\u4e32\u5224\u5b9a s.isspace() s\u975e\u7a7a\u4e14\u5168\u662f\u7a7a\u683c\uff0c\u8fd4\u56deTrue \u6570\u5b57\u4e32\u5224\u5b9a s.isdigit() s\u5168\u662f\u963f\u62c9\u4f2f\u6570\u5b57\uff0c\u8fd4\u56deTrue \u7f16\u7801 s.encode(encoding=\"utf-8\") \u6307\u5b9a\u5b57\u7b26\u4e32s\u7684\u7f16\u7801\uff0c\u5728\u5199\u722c\u866b\u7684\u65f6\u5019\u53ef\u80fd\u6709\u7528\uff1b\u9ed8\u8ba4\u7528utf-8\u7f16\u7801 \u683c\u5f0f\u5316 s.format(...) \u6216 s1 % ... \u53c2\u89c1\u4e4b\u540e\u7684\u683c\u5f0f\u5316\u5b57\u7b26\u4e32 \u5b57\u7b26\u4e32\u7684\u4e0a\u8ff0\u6d89\u53ca\u67e5\u627e\u5b50\u4e32\u7684\u64cd\u4f5c\u4f7f\u7528\u7684\u7b97\u6cd5\u662f Boyer-Moore \uff0c\u5e73\u5747\u60c5\u51b5\u4e0b\u590d\u6742\u5ea6\u4e3aO\uff08n\uff09\uff0c\u4f46\u6700\u5dee\u60c5\u51b5\u4e0b\u53ef\u8fbeO\uff08nm\uff09 \u5176\u4ed6\u7279\u6027 \u00b6 \u63a8\u5bfc\u5f0f \u00b6 \u5728\u521b\u5efa\u5217\u8868\u3001\u96c6\u5408\u548c\u5b57\u5178\u65f6\uff0c\u53ef\u8ba9\u5217\u8868\u4ee5\u4e00\u5b9a\u7684\u89c4\u5219\u751f\u6210\u5176\u4e2d\u7684\u5143\u7d20\uff0c\u4ee5\u5217\u8868\u4e3a\u4f8b\uff1a 1 L = [ x for x in range ( 1 , 11 )] \u8fd9\u4e2a\u4f8b\u5b50\u4f1a\u628aL=[1,2,3,4,5,6,7,8,9,10]\u3002range\u51fd\u6570\u4f1a\u751f\u62101\u523011-1=10\u517110\u4e2a\u6570\u5b57\u7684\u5e8f\u5217\uff0cfor\u5faa\u73af\u4f1a\u8fed\u4ee3\u8fd9\u4e2a\u7c7b\u578b\uff0c\u5e76\u5c06\u8fed\u4ee3\u5230\u7684\u5143\u7d20\uff08\u7ecf\u8fc7\u4e00\u4e9b\u5904\u7406\u540e\uff09\u9010\u4e2a\u4f5c\u4e3aL\u4e2d\u7684\u5143\u7d20\u3002 \u66f4\u4e00\u822c\u5730\uff0c \u5217\u8868\u63a8\u5bfc\u5f0f\u7684\u8bed\u6cd5 \uff1a\uff08\u6807\u51c6\u7684\u5df4\u79d1\u65af\u8303\u5f0f\u8868\u793a\u6cd5\u89c1 https://docs.python.org/zh-cn/3/reference/expressions.html#grammar-token-comp-for \uff09 1 \u8868\u8fbe\u5f0f for \u53d8\u91cf1 in \u53ef\u8fed\u4ee3\u5bf9\u8c61 [ if \u6761\u4ef6 ] for \u53d8\u91cf2 in \u53ef\u8fed\u4ee3\u5bf9\u8c61 [ if \u6761\u4ef6 ] ... \u53d8\u91cf1\u30012\u3001...\u662f\u5728\u8868\u8fbe\u5f0f\u4e2d\u6d89\u53ca\u5230\u7684\u53d8\u91cf\u3002\u5176\u4e2d\u5404\u4e2a\u53d8\u91cf\u5fc5\u987b\u6ee1\u8db3\u6761\u4ef6\u624d\u4f1a\u88ab\u8003\u8651\uff0c\u4e0d\u6ee1\u8db3\u6761\u4ef6\u5c31\u4f1a\u8df3\u8fc7\u3002 \u4f8b\u5982\uff0c\u4e0b\u9762\u7684\u4ee3\u7801\u4f1a\u751f\u6210[2,4,6,8]\u548c[21,23,25,27,29]\u4e2d\u5143\u7d20\u4e24\u4e24\u76f8\u52a0\u7684\u7ed3\u679c\u7ec4\u6210\u7684\u5217\u8868\uff1a 1 2 [ x + y for x in range ( 1 , 10 ) if x % 2 == 0 for y in range ( 20 , 30 ) if y % 2 == 1 ] #[23, 25, 27, 29, 31, 25, 27, 29, 31, 33, 27, 29, 31, 33, 35, 29, 31, 33, 35, 37] \u628a\u524d\u4e00\u4e2aif\u6761\u4ef6\u62c9\u5230\u540e\u9762\u7684if\u4e2d\uff0c\u8d77\u5230\u7684\u6548\u679c\u662f\u4e00\u6837\u7684 1 2 [ x + y for x in range ( 1 , 10 ) for y in range ( 20 , 30 ) if y % 2 == 1 and x % 2 == 0 ] #[23, 25, 27, 29, 31, 25, 27, 29, 31, 33, 27, 29, 31, 33, 35, 29, 31, 33, 35, 37] \u5bf9 \u96c6\u5408 \u800c\u8a00\uff0c\u53ea\u9700\u8981\u628a\u4e0a\u9762\u7684\u6846\u6362\u6210\u82b1\u62ec\u53f7\u5c31\u80fd\u53d8\u6210\u96c6\u5408\u63a8\u5bfc\u5f0f\u4e86\uff1a 1 2 { x + y for x in range ( 1 , 10 ) for y in range ( 20 , 30 ) if y % 2 == 1 and x % 2 == 0 } #{33, 35, 37, 23, 25, 27, 29, 31} \u5bf9 \u5b57\u5178 \u800c\u8a00\uff0c\u8868\u8fbe\u5f0f\u9700\u8981\u6539\u6210\u7528\u5f15\u53f7\u5206\u9694\u7684\u4e24\u4e2a\u8868\u8fbe\u5f0f\uff0c\u9700\u8981\u6ce8\u610f\u7684\u662f\u4e00\u5f00\u59cb\u7684\u952e\u503c\u5bf9\u53ef\u80fd\u4f1a\u88ab\u540e\u6765\u7684\u8986\u76d6\uff1a 1 2 { x - y : x + y for x in range ( 1 , 10 ) if x % 2 == 0 for y in range ( 20 , 30 ) if y % 2 == 1 } #{-19: 35, -21: 37, -23: 35, -25: 33, -27: 31, -17: 33, -15: 31, -13: 29} \u603b\u7ed3\u4e00\u4e0b\u5c31\u662f\uff1a 1 2 3 4 #\u5217\u8868\u3001\u96c6\u5408\u63a8\u5bfc\u5f0f \u8868\u8fbe\u5f0f for \u53d8\u91cf1 in \u53ef\u8fed\u4ee3\u5bf9\u8c61 [ if \u6761\u4ef6 ] for \u53d8\u91cf2 in \u53ef\u8fed\u4ee3\u5bf9\u8c61 [ if \u6761\u4ef6 ] ... #\u5b57\u5178\u63a8\u5bfc\u5f0f \u8868\u8fbe\u5f0f1 : \u8868\u8fbe\u5f0f2 for \u53d8\u91cf1 in \u53ef\u8fed\u4ee3\u5bf9\u8c61 [ if \u6761\u4ef6 ] for \u53d8\u91cf2 in \u53ef\u8fed\u4ee3\u5bf9\u8c61 [ if \u6761\u4ef6 ] ... \u5f53\u7136\u4e0a\u6587\u4e2d\u6211\u4eec\u53ea\u8ba8\u8bba\u4e86\u4e09\u4e2d\u7c7b\u578b\u7684\u63a8\u5bfc\u5f0f\u3002\u65e2\u7136\u5217\u8868\u90fd\u6709\u63a8\u5bfc\u5f0f\u4e86\uff0c\u90a3\u5143\u7ec4\u5462\uff1f\u5143\u7ec4\u4e8b\u5b9e\u4e0a\u6ca1\u6709\u63a8\u5bfc\u5f0f\u8fd9\u4e2a\u8bf4\u6cd5\uff0c\u5982\u679c\u771f\u7684\u60f3\u8981\u83b7\u5f97\u4e00\u4e2a\u63a8\u5bfc\u5f0f\u63a8\u5bfc\u51fa\u7684\u5143\u7ec4\uff0c\u8bf7\u5148\u4f7f\u7528\u5217\u8868\u63a8\u5bfc\u5f0f\uff0c\u7136\u540e\u4f7f\u7528tuple\u51fd\u6570\u8f6c\u6362\u6210\u5143\u7ec4\u3002 \u7b80\u5355\u5730\u5c06\u63a8\u5bfc\u5f0f\u6700\u5916\u5c42\u7684\u82b1\u62ec\u53f7\u6216\u65b9\u62ec\u53f7\u6362\u6210\u5706\u62ec\u53f7\uff0c\u5f97\u5230\u7684\u5c06\u662f\u751f\u6210\u5668\u63a8\u5bfc\u5f0f\u800c\u4e0d\u518d\u662f\u5143\u7ec4\uff0c\u5176\u884c\u4e3a\u4e5f\u548c\u5e8f\u5217\u5bf9\u8c61\u4e0d\u4e00\u6837\uff0c\u56e0\u6b64\u4ee5\u540e\u6211\u4eec\u518d\u8ba8\u8bba\u5b83\u3002 \u5e38\u7528\u51fd\u6570\u603b\u7ed3 \u00b6 \u8fd9\u91cc\u5c06\u6309\u7528\u9014\u7c7b\u578b\u628a\u5e38\u7528\u7684\u5185\u7f6e\u51fd\u6570\uff08\u4e0d\u5305\u62ec\u5185\u7f6e\u6a21\u5757\u91cc\u7684\u51fd\u6570\uff09\u505a\u5212\u5206\u3002 \u7c7b\u578b\u8f6c\u6362\u51fd\u6570 \u00b6 \u8fd9\u4e9b\u51fd\u6570\u5df2\u7ecf\u5728\u524d\u9762\u7684\u201c\u57fa\u672c\u6570\u636e\u7c7b\u578b\u201d\u4e2d\u63d0\u5230\uff0c\u8fd9\u91cc\u5c06\u53ea\u5217\u51fa\u5b83\u4eec\u3002 int(x,base=10) -> int \u00b6 \u8f93\u5165x\uff0c\u5c06x\u4ee5base\u8fdb\u5236\u89e3\u6790\u621010\u8fdb\u5236\u540e\u8fd4\u56de\u6574\u6570. float(x) ->float \u00b6 bool(x) -> bool \u00b6 complex(x) -> complex \u00b6 \u5e38\u7528\u6570\u636e\u7ed3\u6784\u6784\u9020\u51fd\u6570 \u00b6 \u8fd9\u4e9b\u51fd\u6570\u5df2\u7ecf\u5728\u524d\u9762\u7684\u201c\u5e38\u7528\u6570\u636e\u7ed3\u6784\u65b9\u6cd5\u4e0e\u76f8\u5173\u5e38\u7528\u51fd\u6570\u201d\u4e2d\u63d0\u5230\uff0c\u8fd9\u91cc\u5c06\u53ea\u5217\u51fa\u5b83\u4eec\u3002 list([iterable]) -> list \u00b6 tuple([iterable]) ->tuple \u00b6 str([iterable]) -> str \u00b6 set([iterable]) -> set \u00b6 dict(...) -> dict \u00b6 \u6570\u5b66\u548c\u8fdb\u5236\u8f6c\u6362 \u00b6 \u66f4\u591a\u4e0e\u6570\u5b66\u6709\u5173\u7684\u51fd\u6570\u8bf7\u53c2\u8003math\u5e93\u4e2d\u7684\u51fd\u6570\u3002 abs(x) \u00b6 \u8fd4\u56dex\u7684\u7edd\u5bf9\u503c\u6216\u6a21\uff08\u590d\u6570\uff09 max(x,y,...) \u6216 max([iterable]) \u00b6 \u4f20\u5165\u81f3\u5c11\u4e24\u4e2a\u53c2\u6570\u6216\u8005\u4e00\u4e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\uff0c\u5c06\u8fd4\u56de\u8fd9\u4e9b\u53c2\u6570\u6216\u8fd9\u4e2a\u5bf9\u8c61\u4e2d\u7684\uff08\u7b2c\u4e00\u4e2a\uff09\u6700\u5927\u5143\u7d20\u3002 min(x,y,...) \u6216 min([iterable]) \u00b6 \u540c\u4e0a\uff0c\u4f46\u8fd4\u56de\uff08\u7b2c\u4e00\u4e2a\uff09\u6700\u5c0f\u5143\u7d20\u3002 sum([iterable]) \u00b6 \u4f20\u5165\u53ef\u8fed\u4ee3\u5bf9\u8c61\uff0c\u8fd4\u56de\u5bf9\u8c61\u4e2d\u6240\u6709\u5143\u7d20\u7684\u548c pow(a,b,[m]) \u00b6 \u8fd4\u56dea\u7684b\u6b21\u5e42\uff0c\u5982\u679c\u6307\u5b9a\u4e86m\uff08\u5fc5\u987b\u662f\u6574\u6570\uff09\uff0c\u90a3\u4e48\u8fd4\u56dea\u7684b\u6b21\u5e42\u5bf9m\u53d6\u4f59\u6570\u7684\u7ed3\u679c\u3002 py3.8\u4e2d\uff0cb\u652f\u6301\u5728\u4f20\u5165m\u7684\u60c5\u51b5\u4e0b\u4f20\u5165\u8d1f\u6570\u4e86\uff0c\u8fd9\u610f\u5473\u7740\u4f60\u53ef\u4ee5\u76f4\u63a5\u7528\u8fd9\u4e2a\u51fd\u6570\u6c42\u4e00\u4e2a\u6570\u7684\u6a21\u9006\u5143\u3002 divmod(a,b) \u00b6 \u5e26\u4f59\u9664\u6cd5\uff0c\u8fd4\u56de\u4e8c\u5143\u7ec4(a//b, a%b)\u3002 round(x,[d]) \u00b6 \u5c06x\u56db\u820d\u4e94\u5165\u5230d\u4f4d\u5c0f\u6570\uff0cd\u672a\u6307\u5b9a\u5219\u8868\u660e\u56db\u820d\u4e94\u5165\u5230\u6574\u6570\u3002 \u4f46\u8981\u6ce8\u610f\uff0c\u7531\u4e8e\u6d6e\u70b9\u6570\u7cbe\u5ea6\u95ee\u9898\uff0c\u67d0\u4e9b\u6570\u503c\u53ef\u80fd\u4f1a\u5728\u8fb9\u754c\u5904\u4ea7\u751f\u53cd\u76f4\u89c9\u7684\u7ed3\u679c\u3002\u4f8b\u5982 1 2 round ( 4.5 ) #4 round ( 5.5 ) #6 hex(x) \u00b6 \u8f93\u5165\u6574\u6570x\uff0c\u8fd4\u56de0x\u5f00\u5934\u768416\u8fdb\u5236\u5b57\u7b26\u4e32\u3002 oct(x) \u00b6 \u540c\u4e0a\uff0c\u8fd4\u56de0o\u5f00\u5934\u76848\u8fdb\u5236\u5b57\u7b26\u4e32\u3002 bin(x) \u00b6 \u540c\u4e0a\uff0c\u8fd4\u56de0b\u5f00\u5934\u76842\u8fdb\u5236\u5b57\u7b26\u4e32\u3002 \u8f93\u5165\u548c\u8f93\u51fa \u00b6 input([prompt]) \u00b6 \u4ece\u6807\u51c6\u8f93\u5165\u8bfb\u5165\u4e00\u884c\u5b57\u7b26\u4e32\u3002\u6307\u5b9aprompt\u4ee5\u5728\u8bfb\u5165\u524d\u8f93\u51fa\u4e00\u884c\u63d0\u793a\u3002 print(*obj, sep=' ' , end='\\n', file=sys.stdout, flush=Fase) \u00b6 \u8f93\u51fa\u82e5\u5e72\u4e2a\u4f20\u5165\u7684obj\u53c2\u6570\uff0c\u6bcf\u4e2a\u53c2\u6570\u4e4b\u95f4\u4ee5sep\u5206\u9694\uff08\u9ed8\u8ba4\u662f\u7a7a\u683c\uff09\uff0c\u8f93\u51fa\u5b8c\u6210\u540e\u518d\u8f93\u51fa\u4e00\u4e2aend\u5b57\u7b26\u4e32\uff08\u9ed8\u8ba4\u662f\u6362\u884c\uff09\u3002 \u6307\u5b9afile\u4ee5\u89c4\u5b9a\u8f93\u51fa\u5230\u4f55\u5904\uff0c\u9ed8\u8ba4\u662f\u6807\u51c6\u8f93\u51fa\u6d41\u3002 \u6307\u5b9aflush\u4e3aTrue\uff0c\u5219\u8f93\u51fa\u5b8c\u6210\u540e\u5c06\u5237\u65b0\u8f93\u51fa\u6d41\uff08\u7acb\u5373\u5c06\u7f13\u51b2\u533a\u7684\u5185\u5bb9\u90fd\u8f93\u51fa\u5230\u6587\u4ef6\u4e2d\uff09\u3002 open(f, mode='r', ...) \u00b6 \u6253\u5f00\u6587\u4ef6f\u5e76\u8fd4\u56de\u6587\u4ef6\u5bf9\u8c61\uff0c\u5229\u7528\u8fd9\u4e2a\u6587\u4ef6\u5bf9\u8c61\u53ef\u4ee5\u5411\u91cc\u9762\u8bfb\u5199\u5185\u5bb9\u3002 mode\u6307\u5b9a'r'\u4e3a\u8bfb\u53d6\uff0c\u6307\u5b9a'w'\u4e3a\u5199\u5165\u3002\u5728\u8fd9\u4e4b\u540e\u8ffd\u52a0\u5199'b'\u3001't'\u53ef\u4ee5\u4e8c\u8fdb\u5236\u6a21\u5f0f\uff08\u4f8b\u5982\u8bfb\u5199\u56fe\u7247\uff09\u6216\u6587\u672c\u6a21\u5f0f\uff08\u9ed8\u8ba4\uff09\u8bfb\u5199\uff0c\u8ffd\u5199'a'\u4ee3\u8868\u6587\u4ef6\u5b58\u5728\u65f6\u5728\u672b\u5c3e\u8ffd\u52a0\u8bfb\u5199\u7b49\u3002\u5177\u4f53\u8bf4\u660e\u53c2\u770b\u5b98\u65b9\u6587\u6863\u3002 \u8fed\u4ee3\u76f8\u5173\u51fd\u6570 \u00b6 range([st],ed,[step]) \u00b6 \u751f\u6210\u4e00\u4e2a\u4ecest\uff08\u9ed8\u8ba4\u4e3a0\uff09\u5230ed\uff08\u4e0d\u5305\u62eced\uff09\uff0c\u6b65\u957f\u4e3astep\uff08\u9ed8\u8ba4\u4e3a1\uff09\u7684range\u5e8f\u5217\u5bf9\u8c61\u3002\u901a\u5e38\u7528\u4e8efor\u5faa\u73af\u8fed\u4ee3\u3002 range\u5bf9\u8c61\u662f\u4e0d\u53ef\u53d8\u7684\u5e8f\u5217\u7c7b\u578b\uff0c\u4e5f\u652f\u6301\u4e00\u4e9b\uff08\u4f46\u4e0d\u662f\u6240\u6709\uff09\u5e8f\u5217\u64cd\u4f5c\uff1a \u8fd0\u7b97\u3001\u51fd\u6570\u6216\u65b9\u6cd5 \u7b26\u53f7 \u7279\u6b8a\u8bf4\u660e \u793a\u4f8b \u901a\u7528\u64cd\u4f5c \uff08\u89c1\u4e0a\u6587\uff09 \u5e8f\u5217\u901a\u7528\u64cd\u4f5c (\u4e32\u63a5\u3001\u91cd\u590d\u9664\u5916) \u6784\u9020 range(...) \u4f7f\u7528range\u5bf9\u8c61\u8fed\u4ee3\u4f1a\u6bd4\u4f7f\u7528\u5217\u8868\u751f\u6210\u5f0f\u751f\u6210\u7684\u4e00\u4e32\u5e8f\u5217\u66f4\u9ad8\u6548\u3002 iter(iterable) \u00b6 \u8fd4\u56de\u53ef\u8fed\u4ee3\u5bf9\u8c61\u7684\u4e00\u4e2a\u8fed\u4ee3\u5668\uff08iterator\uff09\uff08\u4ece\u5934\u5f00\u59cb\uff09\u3002 reversed(iterable) \u00b6 \u8fd4\u56de\u53ef\u8fed\u4ee3\u5bf9\u8c61\u7684\u53cd\u5411\u8fed\u4ee3\u5668\uff08for\u5faa\u73af\u65f6\uff0c\u5c06\u4eceL\u7684\u5c3e\u90e8\u5230\u5934\u90e8\u8fed\u4ee3\uff09 zip(*[iterables]) \u00b6 \u540c\u65f6\u8fed\u4ee3\u591a\u4e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u3002\u5f53\u8fd9\u5f53\u4e2d\u6700\u77ed\u7684\u4e00\u4e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u8fed\u4ee3\u5b8c\u6bd5\u65f6\uff0c\u7ed3\u675f\u8fed\u4ee3\u3002 1 2 3 4 for x , y , z in zip ([ 1 , 2 ],[ 3 , 4 , 5 ],[ 6 , 7 ]): print ( x , y , z ) #1 3 6 #2 4 7 enumerate(iterable, start=0) \u00b6 \u8fd4\u56de\u53e6\u4e00\u4e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\uff0c\u5bf9\u8c61\u4e2d\u7684\u6bcf\u4e00\u4e2a\u5143\u7d20\u4ee5\u5143\u7ec4(i,v)\u8868\u793a\uff0ci\u8868\u793a\u5176\u662f\u7b2ci\u4e2a\uff08\u4ece0\u5f00\u59cb\u8ba1\u6570\uff09\u5143\u7d20\uff0cv\u8868\u793a\u5143\u7d20\u5185\u5bb9\u3002 1 2 3 4 5 for i , v in enumerate ([ 7 , 8 , 9 ]): print ( i , v ) #0 7 #1 8 #2 9 next(iterator,[def]) \u00b6 \u4f20\u5165\u8fed\u4ee3\u5668\uff0c\u8fd4\u56de\u8fed\u4ee3\u5668\u6240\u6307\u5143\u7d20\u5e76\u4ee4\u8fed\u4ee3\u5668\u79fb\u52a8\u5230\u4e0b\u4e00\u4e2a\u4f4d\u7f6e\u3002\u5982\u679c\u8fed\u4ee3\u5b8c\u4e86\u4f1a\u629b\u51faStopIteration\u3002 \u5b57\u7b26 \u00b6 chr(x) \u00b6 x\u662f\u6574\u6570\uff0c\u8fd4\u56de\u5bf9\u5e94unicode\u503c\u7684\u5355\u4e2a\u5b57\u7b26\u7684\u5b57\u7b26\u4e32\u3002\u4f8b\u5982chr(65)='A' ord(x) \u00b6 x\u662f\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\u7684\u5b57\u7b26\u4e32\uff0c\u8fd4\u56de\u5b57\u7b26\u5bf9\u5e94\u7684Unicode\u7801\u3002\u4e0d\u662f\u4e00\u4e2a\u5b57\u7b26\u7684\u5b57\u7b26\u4e32\u4f1a\u629b\u51faTypeError\u3002 \u6392\u5e8f \u00b6 sorted([iterable],*,key=None, reverse=False) \u00b6 \u8fd4\u56de\u65b0\u7684\u5df2\u6392\u5e8f\u7684\u53ef\u8fed\u4ee3\u5bf9\u8c61\u3002 \u6307\u5b9akey\u4e3a\u51fd\u6570\u53ef\u6539\u53d8\u7528\u4e8e\u6bd4\u8f83\u201c\u5927\u5c0f\u201d\u7684\u89c4\u5219\u3002\u6307\u5b9areverse\u4e3aTrue\u53ef\u4f7f\u5176\u4ece\u5927\u5230\u5c0f\u6392\u5217\u3002\u66f4\u591a\u8bf7\u53c2\u8003\u5b98\u65b9\u6587\u6863\uff1a https://docs.python.org/zh-cn/3/howto/sorting.html#sortinghowto \u3002 \u7c7b\u578b\u5224\u5b9a \u00b6 isinstance(obj,cls) \u00b6 \u68c0\u6d4bobj\u662f\u5426\u662fcls\u8fd9\u4e2a\u7c7b\u7684\u4e00\u4e2a\u5b9e\u4f8b\u3002 1 2 3 isinstance ([ 1 , 2 , 3 ], list ) #True from collections.abc import Iterable isinstance ([ 1 , 2 , 3 ], Iterable ) #True type(obj) \u00b6 \u8fd4\u56deobj\u7684\u7c7b\u578b\uff08\u4e00\u4e2atype\u5bf9\u8c61\uff09\u3002 1 2 type ( 123 ) # <class 'int'> \u6267\u884c \u00b6 eval(obj,...) \u00b6 \u5c06obj\uff08\u901a\u5e38\u662f\u5b57\u7b26\u4e32\uff09\u5f53\u4f5cpython\u8868\u8fbe\u5f0f\u8fd0\u884c\uff0c\u7136\u540e\u8fd4\u56de\u8fd0\u884c\u7ed3\u679c\u3002\u6709\u8bed\u6cd5\u9519\u8bef\u4f1a\u629b\u51faSyntaxError\u3002 exec(obj, ...) \u00b6 \u5c06obj\uff08\u901a\u5e38\u662f\u5b57\u7b26\u4e32\uff09\u5f53\u4f5cpython\u4ee3\u7801\u6267\u884c\u3002\u8fd4\u56deNone\u3002\u6709\u8bed\u6cd5\u9519\u8bef\u4f1a\u629b\u51faSyntaxError\u3002 \u5e38\u7528\u5185\u7f6e\u5e93\u51fd\u6570\u603b\u7ed3 \u00b6 math \u00b6 Python\u7684\u5185\u7f6e\u6570\u5b66\u5e93 1 import math \u6d6e\u70b9\u6570 \u00b6 ceil(x) \u00b6 \u8fd4\u56dex\u7684\u5411\u4e0a\u53d6\u6574\u503c floor(x) \u00b6 \u8fd4\u56dex\u7684\u5411\u4e0b\u53d6\u6574\u503c isclose(a,b,*,rel_tol=1e-9,abs_tol=0.0) \u00b6 \u5224\u65ad\u4e24\u4e2a\u6d6e\u70b9\u6570a\u3001b\u662f\u5426\u8db3\u591f\u76f8\u8fd1\uff0c\u5141\u8bb8\u7684\u8bef\u5dee\u4e3arel_tol\u3002 fabs(x) \u00b6 x\u7684\u7edd\u5bf9\u503c\uff08\u6d6e\u70b9\u6570\uff09 fmod(x,y) \u00b6 \u9002\u7528\u4e8e\u6d6e\u70b9\u6570\u7684\u53d6\u6a21\u8fd0\u7b97 \u7ec4\u5408\u8ba1\u6570\u76f8\u5173 \u00b6 comb(n,k) \u00b6 \u7ec4\u5408\u6570 \\(C_{n}^k\\) factorial(x) \u00b6 \u8fd4\u56dex\u7684\u9636\u4e58\uff0cx\u9700\u8981\u662f\u5927\u4e8e\u7b49\u4e8e0\u7684\u6574\u6570\uff0c\u5426\u5219\u4f1a\u629b\u51fa\u5f02\u5e38\u3002 perm(n,k=None) \u00b6 k<=n\uff0c\u8fd4\u56de \\(\\frac{n!}{(n-k)!}\\) \uff1b\u5426\u5219\u8fd4\u56de0 \u6570\u8bba \u00b6 gcd(a,b) / gcd(*ints) \u00b6 \u8f93\u5165\u4e24\u4e2a/\u82e5\u5e72\uff08Py3.9\uff09\u6574\u6570\uff0c\u8fd4\u56de\u8fd9\u4e9b\u6570\u7684\u6700\u5927\u516c\u56e0\u6570\u3002\u7279\u522b\u5730\uff0c\u8f93\u5165\u7684\u6570\u5168\u4e3a0\u65f6\uff0c\u8fd4\u56de0\u3002\u8fd9\u548c\u81ea\u5df1\u624b\u5199\u7684gcd\u51fd\u6570\u884c\u4e3a\u76f8\u540c\u3002 lcm(*ints) (Py3.9) \u00b6 \u8f93\u5165\u82e5\u5e72\u6574\u6570\uff0c\u8fd4\u56de\u6700\u5c0f\u516c\u500d\u6570\u3002 \u6c42\u79ef\u4e0e\u6c42\u548c \u00b6 prod(iterable,*,start=1) \u00b6 \u6c42\u53ef\u8fed\u4ee3\u5bf9\u8c61\u7684\u79ef\uff0c\u521d\u59cb\u503c\u4e3astart\u3002 fsum(iterable) \u00b6 \u8fd4\u56de\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e2d\u7684\u6d6e\u70b9\u503c\u548c\uff08\u7cbe\u786e\u5730\uff09 \u7b97\u6570 \u00b6 exp(x) \u00b6 \u6307\u6570\u51fd\u6570 log(x,[base]) \u00b6 \u4ee5base\u4e3a\u5e95\u6570\u7684x\u7684\u5bf9\u6570 log2(x) log10(x) \u00b6 \u7c7b\u4f3c\u4e0a\u4e00\u51fd\u6570 sqrt(x) \u00b6 \u7b97\u6570\u5e73\u65b9\u6839 isqrt(x) \u00b6 \u4e0a\u4e00\u51fd\u6570\u7684\u5411\u4e0b\u53d6\u6574\u503c sin(x) cos(x) tan(x) asin(x) acos(x) atan(x) \u00b6 \u4e09\u89d2\u51fd\u6570 atan2(y,x) \u00b6 \u4ee5\u5f27\u5ea6\u4e3a\u5355\u4f4d\u8fd4\u56deatan(y/x)\uff0c\u7ed3\u679c\u5728 \\([-\\pi,\\pi]\\) \u4e4b\u95f4\u3002 dist(p,q) \u00b6 p\u3001q\u662f\u53ef\u8fed\u4ee3\u5bf9\u8c61\uff0c\u8fd4\u56de\u4ed6\u4eec\u7684\u6b27\u51e0\u91cc\u5f97\u8ddd\u79bb\u3002 \u5e38\u6570 \u00b6 pi e tau\uff082pi\uff09 \u00b6 cmath \u00b6 \u7528\u4e8e\u590d\u6570\u7b97\u6570\u7684\u5e93 phase\uff08x\uff09 \u00b6 \u8fd4\u56de\u590d\u6570x\u7684\u76f8\u4f4d\u3002[-pi,pi]\u4e4b\u95f4 polar\uff08x\uff09 \u00b6 \u8fd4\u56de\u590d\u6570x\u5728\u6781\u5750\u6807\u7cfb\u4e2d\u7684\u8868\u793a\u65b9\u5f0f\uff08\u4e8c\u5143\u7ec4\uff09 rect\uff08r\uff0cphi\uff09 \u00b6 \u901a\u8fc7\u6781\u5750\u6807\u7684\u534a\u5f84\u548c\u89d2\u5ea6\u8fd4\u56de\u5bf9\u5e94\u590d\u6570 random \u00b6 \u4f2a\u968f\u673a\u6570\u5e93 \u5e8f\u5217 \u00b6 choice\uff08seq\uff09 \u00b6 \u4ece\u975e\u7a7a\u5e8f\u5217 seq \u8fd4\u56de\u4e00\u4e2a\u968f\u673a\u5143\u7d20\u3002 shuffle\uff08x\uff0c[random]\uff09 \u00b6 \u5c06x\u6309\u7167random\u51fd\u6570\u751f\u6210\u7684\u503c\uff08[0.0,1.0)\uff09\u968f\u673a\u6253\u4e71\u3002 \u968f\u673a\u6570 \u00b6 random() \u00b6 \u8fd4\u56de[0.0,1.0)\u5185\u7684\u968f\u673a\u6570 uniform\uff08a\uff0cb\uff09 \u00b6 \u8fd4\u56dea~b\u5185\u7684\u968f\u673a\u6d6e\u70b9\u6570 randint\uff08a\uff0cb\uff09 \u00b6 \u8fd4\u56dea~b\u5185\u7684\u968f\u673a\u6574\u6570 randrange(st,ed, [step]) / randrange(ed) \u00b6 \u53c2\u6570\u5f62\u5982range\uff0c\u8fd4\u56de\u8fd9\u4e4b\u4e2d\u7684\u4e00\u4e2a\u6570 statistics \u00b6 \u7edf\u8ba1\u5b66\u51fd\u6570\u3002\u5982\u65e0\u7279\u6b8a\u8bf4\u660e\uff0c\u4e0b\u6587\u4e2d\u51fd\u6570\u53c2\u6570\u4e3a\u53ef\u8fed\u4ee3\u5bf9\u8c61 mean\uff08x\uff09 \u00b6 \u7b97\u6570\u5e73\u5747\u6570 fmean\uff08x\uff09 \u00b6 \u5feb\u901f\u8ba1\u7b97\u7b97\u6570\u5e73\u5747\u6570\uff08\u603b\u662f\u8fd4\u56de\u6d6e\u70b9\u6570\uff09 median(x) / median_low(x) / median_high(x) \u00b6 \u4e2d\u4f4d\u6570/\u9ad8\u4e2d\u4f4d\u6570/\u4f4e\u4e2d\u4f4d\u6570 itertools \u00b6 \u5305\u62ec\u5404\u7c7b\u7528\u4e8e\u8fed\u4ee3\u5bb9\u5668\u7684\u51fd\u6570 permutations ( iterable , r=None ) \u00b6 \u8fde\u7eed\u8fd4\u56de\u7531 iterable \u5143\u7d20\u751f\u6210\u957f\u5ea6\u4e3a r \u7684\u6392\u5217\uff08\u8fed\u4ee3\u5668\uff09\u3002 combinations ( iterable , r ) \u00b6 \u8fd4\u56de\u7531\u8f93\u5165 iterable \u4e2d\u5143\u7d20\u7ec4\u6210\u957f\u5ea6\u4e3a r \u7684\u5b50\u5e8f\u5217\u3002 combinations_with_replacement ( iterable , r ) \u00b6 \u8fd4\u56de\u7531\u8f93\u5165 iterable \u4e2d\u5143\u7d20\u7ec4\u6210\u7684\u957f\u5ea6\u4e3a r \u7684\u5b50\u5e8f\u5217\uff0c\u5141\u8bb8\u6bcf\u4e2a\u5143\u7d20\u53ef\u91cd\u590d\u51fa\u73b0\u3002 datetime \u00b6 os \u00b6 \u5b57\u7b26\u4e32\u683c\u5f0f\u5316 \u00b6 https://docs.python.org/zh-cn/3/tutorial/inputoutput.html#formatted-string-literals s.format( args, *kwargs) \u00b6 \u683c\u5f0f\u5316s\u4e2d\u5e26\u6709\u82b1\u62ec\u53f7\u7684\u90e8\u5206\u3002 *args \uff1a \u4f9d\u6b21\u66ff\u6362\uff0c\u6216\u8005\u6839\u636e\u82b1\u62ec\u53f7\u4e2d\u7684\u7d22\u5f15\u66ff\u6362 **kwargs\uff1a\u5b57\u5178\uff0c\u6839\u636e\u82b1\u62ec\u53f7\u4e2d\u7684\u503c\u4f5c\u4e3a\u952e\u6765\u66ff\u6362 1 \"The sum of 1 + 2 is {0} \" . format ( 1 + 2 ) \u683c\u5f0f\u5b57\u7b26\u4e32\u8bed\u6cd5 \u00b6 \u5927\u6982\u957f\u8fd9\u6837\uff1a 1 { [ \u57df\u540d ] [ ! \u8f6c\u6362\u65d7\u6807 ] [: \u683c\u5f0f\u63a7\u5236\u7b26 ] } \u57df\u540d\uff1a\u5982\u679c\u4e3a\u6570\u5b57\uff0c\u5219\u5b83\u6307\u5411\u4e00\u4e2a\u4f4d\u7f6e\u53c2\u6570\uff0c\u800c\u5982\u679c\u4e3a\u5173\u952e\u5b57\uff0c\u5219\u5b83\u6307\u5411\u4e00\u4e2a\u547d\u540d\u5173\u952e\u5b57\u53c2\u6570\u3002\uff08\u7701\u7565\u5219\u9ed8\u8ba4\u4e3a\u4f4d\u7f6e\u53c2\u6570\u4ece0\u9012\u589e\uff09 \u8f6c\u6362\u65d7\u6807\uff1a a\uff1a\u76f8\u5f53\u4e8e\u5728\u4ee3\u5165\u524d\u5957\u7528\u4e00\u6b21ascii\u51fd\u6570 s\uff1a\u76f8\u5f53\u4e8e\u5728\u4ee3\u5165\u524d\u5957\u7528\u4e00\u6b21str\u51fd\u6570\uff08\u5f71\u54cdprint\u7684\u8f93\u51fa\uff09 r\uff1a\u76f8\u5f53\u4e8e\u5728\u4ee3\u5165\u524d\u5957\u7528\u4e00\u6b21repr\u51fd\u6570\uff08repr\u4f1a\u5f71\u54cd\u5bf9\u8c61\u5728\u63a7\u5236\u53f0\u7684\u8f93\u51fa\uff09 \u5e38\u7528\u7684\u683c\u5f0f\u63a7\u5236\u7b26\uff08\u683c\u5f0f\u89c4\u683c\u8ff7\u4f60\u8bed\u8a00\uff09\uff1a format_spec ::= [[fill]align][sign][#][0][width][grouping_option][.precision][type] \u586b\u5145fill\uff1a\u5982\u679c\u6307\u5b9a\u4e86\u4e00\u4e2a\u6709\u6548\u7684 align \u503c\uff0c\u5219\u53ef\u4ee5\u5728\u8be5\u503c\u524d\u9762\u52a0\u4e00\u4e2a fill \u5b57\u7b26\uff0c\u5b83\u53ef\u4ee5\u4e3a\u4efb\u610f\u5b57\u7b26\uff0c\u5982\u679c\u7701\u7565\u5219\u9ed8\u8ba4\u4e3a\u7a7a\u683c\u7b26\u3002 \u5bf9\u9f50\u9009\u9879align\uff1a< > = ^ \u5206\u522b\u8868\u793a \u5de6\u53f3\u5bf9\u9f50\u3001\u5f3a\u5236\u5c06\u586b\u5145\u653e\u7f6e\u5728\u7b26\u53f7\uff08\u5982\u679c\u6709\uff09\u4e4b\u540e\u4f46\u5728\u6570\u5b57\u4e4b\u524d\u3002\u8fd9\u7528\u4e8e\u4ee5\u201c+000000120\u201d\u5f62\u5f0f\u6253\u5370\u5b57\u6bb5\u3001\u5c45\u4e2d\u3002 width \uff1a\u662f\u4e00\u4e2a\u5b9a\u4e49\u6700\u5c0f\u603b\u5b57\u6bb5\u5bbd\u5ea6\u7684\u5341\u8fdb\u5236\u6574\u6570\uff0c\u5305\u62ec\u4efb\u4f55\u524d\u7f00\u3001\u5206\u9694\u7b26\u548c\u5176\u4ed6\u683c\u5f0f\u5316\u5b57\u7b26\u3002 \u5982\u679c\u672a\u6307\u5b9a\uff0c\u5219\u5b57\u6bb5\u5bbd\u5ea6\u5c06\u7531\u5185\u5bb9\u786e\u5b9a\u3002 precision \uff1a \u662f\u4e00\u4e2a\u5341\u8fdb\u5236\u6570\u5b57\uff0c\u8868\u793a\u5bf9\u4e8e\u4ee5 'f' and 'F' \u683c\u5f0f\u5316\u7684\u6d6e\u70b9\u6570\u503c\u8981\u5728\u5c0f\u6570\u70b9\u540e\u663e\u793a\u591a\u5c11\u4e2a\u6570\u4f4d\uff0c\u6216\u8005\u5bf9\u4e8e\u4ee5 'g' \u6216 'G' \u683c\u5f0f\u5316\u7684\u6d6e\u70b9\u6570\u503c\u8981\u5728\u5c0f\u6570\u70b9\u524d\u540e\u5171\u663e\u793a\u591a\u5c11\u4e2a\u6570\u4f4d\u3002 \u4e00\u4e9b\u4f7f\u7528\u4f8b\u5b50 1 2 3 4 5 6 7 8 9 10 11 12 'X: {0[0]} ; Y: {0[1]} ' . format ( coord ) #coord=(3,5) # 'X: 3; Y: 5' ' {:<30} ' . format ( 'left aligned' ) # 'left aligned ' ' {:^30} ' . format ( 'centered' ) # ' centered ' ' {:*^30} ' . format ( 'centered' ) # use '*' as a fill char #'***********centered***********' 'Correct answers: {:.2%} ' . format ( points / total ) # 'Correct answers: 86.36%' f-string \u00b6 1 f ' { variable : format_spec } ' \u65e7\u683c\u5f0f\u5316\u65b9\u6cd5 \u00b6 1 2 ' %d %5.3f ' % ( 1 , 2 ) # '1 2.000' \u5b57\u7b26\u4e32\u540e\u7684\u767e\u5206\u53f7\u987b\u662f\u5143\u7ec4\u6216\u5b57\u5178\u3002\u82e5\u662f\u5b57\u5178\uff0c\u5b57\u7b26\u4e32\u4e2d\u7684\u767e\u5206\u53f7\u5e94\u8be5\u5199\u6210 %(key)d \u7684\u5f62\u5f0f\u3002\uff08\u800c\u4e14\u5b57\u5178\u952e\u5fc5\u987b\u662f\u5b57\u7b26\u4e32\u624d\u884c\uff09 https://docs.python.org/zh-cn/3/library/stdtypes.html#old-string-formatting \u89e3\u5305 \u00b6 \uff08\u6574\u6570\u7684\uff09id \u00b6 \u6761\u4ef6\u5224\u65ad\u548c\u5faa\u73af \u00b6 \u7b2c\u4e09\u65b9\u5e93 \u00b6 Request \u00b6 Panda \u00b6 1 import pandas as pd Dataframe \u00b6 \u4e8c\u7ef4\u8868\u683c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 df = pd.DataFrame( { \"Name\": [ \"Braund, Mr. Owen Harris\", \"Allen, Mr. William Henry\", \"Bonnell, Miss. Elizabeth\", ], \"Age\": [22, 35, 58], \"Sex\": [\"male\", \"male\", \"female\"], } ) Name Age Sex 0 Braund, Mr. Owen Harris 22 male 1 Allen, Mr. William Henry 35 male 2 Bonnell, Miss. Elizabeth 58 female Series \u00b6 \u6bcf\u4e00\u5217\u5c31\u662f\u4e00\u4e2aSeries 1 2 3 4 5 6 df [ \"Age\" ] 0 22 1 35 2 58 Name : Age , dtype : int64 1 ages = pd . Series ([ 22 , 35 , 58 ], name = \"Age\" ) conda \u00b6 \u5728powershell\u4e0b\u8fd0\u884c \u00b6 https://github.com/conda/conda/issues/8428 https://blog.csdn.net/z_dmsd/article/details/107394983 https://zhuanlan.zhihu.com/p/89356758 \u5728powershell\u4e2d\u8fd0\u884c\u8bf7\u5148 1 2 3 4 5 powershell -ExecutionPolicy Bypass Set-ExecutionPolicy -ExecutionPolicy RemoteSigned ... conda init powershell ... \u6e05\u6d01 \u00b6 https://www.jianshu.com/p/f14ac62bef99 1 conda clean -a \u73af\u5883 \u00b6 \u521b\u5efa\u73af\u5883\u3001\u5220\u9664\u3001\u6fc0\u6d3b\u548c\u9000\u51fa\uff0c\u5b89\u88c5\u5305 1 2 3 4 5 conda create -n ngs python=3.8 conda remove -n ngs --all conda activate ngs conda deactivate conda install package \u5e38\u7528\u547d\u4ee4 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 # to search for packages conda search [package] # To update all packages conda update --all --yes # List all packages installed conda list [-n env] # conda list environments conda env list # create new env conda create -n [name] package [package] ... # activate env conda activate [name] # deavtivate env conda deactivate # view conda configuration information conda --version conda info conda info --envs pip \u00b6 1 pip --default-timeout = 100 --no-cache-dir install matplotlib -i https://mirrors.aliyun.com/pypi/simple/ \u6362\u6e90\u53c2\u8003\uff1a https://blog.csdn.net/weixin_41524411/article/details/114191177 \u7f13\u5b58\uff1a https://reality0ne.com/pip-cahce-dir/ \u7f13\u5b58\u4fdd\u5b58\u5728\u5f53\u524d\u7528\u6237home\u4e0b\u7684.cache\u4e2d\u3002\u8981\u907f\u514dcache\u53ef\u4ee5\u7528--no-cache-dir","title":"\u5b66\u4e0d\u6765Python"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#python","text":"","title":"\u5b66\u4e0d\u6765Python"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_1","text":"\u4e4b\u6240\u4ee5\u4e0b\u51b3\u5fc3\u5199\u8fd9\u4e2a\u7cfb\u5217\uff0c\u662f\u56e0\u4e3a\u8fd9\u4e48\u957f\u4e45\u4ee5\u6765\u6211\u5b66Python\u90fd\u662f\u5728\u9700\u8981\u4f7f\u7528\u65f6\u4e34\u65f6\u53c2\u8003\u7684\u7f51\u4e0a\u7684\u6559\u7a0b\uff0c\u52a0\u4e0a\u6211\u81ea\u5df1\u4ee5\u524d\u5e76\u6ca1\u6709\u8bb0\u5f55\u81ea\u5df1\u5b66\u4e60\u5185\u5bb9\u7684\u4e60\u60ef\uff0c\u56e0\u800c\u5bfc\u81f4\u6211Python\u5b66\u7684\u4e1c\u897f\u90fd\u76f8\u5f53\u96f6\u6563\u4e14\u534a\u540a\u5b50\u3002\u56e0\u6b64\u6211\u5199\u8fd9\u4e2a\u7cfb\u5217\u4e3b\u8981\u4e5f\u662f\u8981\u7ed9\u81ea\u5df1\u5b66\u8fc7\u7684\u4e1c\u897f\u505a\u4e00\u4e2a\u5f52\u7eb3\u65b9\u4fbf\u4ee5\u540e\u81ea\u5df1\u67e5\u9605\u3002 \u603b\u6240\u5468\u77e5\uff0cPython\u7684\u8bed\u6cd5\u7b80\u5355\uff0c\u56e0\u6b64\u88ab\u5404\u79cd\u201c\u673a\u6784\u201d\u7528\u6765\u5f53\u505a\u7f16\u7a0b\u7684\u5165\u95e8\u8bed\u8a00\u3002\u7136\u800c\u5b9e\u9645\u4e0a\u5982\u679c\u6ca1\u6709\u63a5\u89e6\u8fc7\u7f16\u7a0b\u4e14\u4e0d\u4e86\u89e3Python\u80cc\u540e\u7684\u4e00\u4e9b\u673a\u5236\u7684\u8bdd\uff0c\u8fd9\u95e8\u8bed\u8a00\u5176\u5b9e\u975e\u5e38\u96be\u5b66\u2014\u2014\u5b83\u7684\u5751\u592a\u591a\u4e86\u3002\u8fd9\u4e5f\u662f\u6211\u5b66\u8fd9\u95e8\u8bed\u8a00\u8fc7\u7a0b\u4e2d\u7684\u611f\u609f\uff0c\u56e0\u6b64\u8fd9\u4e2a\u7cfb\u5217\u4e5f\u662f\u4e3a\u4e86\u603b\u7ed3\u4e00\u4e0b\u5b83\u7684\u4e00\u4e9b\u5751\u4ee5\u514d\u6211\u4ee5\u540e\u518d\u8e29\uff08\u5f53\u7136\u4e5f\u4ec5\u9650\u4e8e\u6211\u7684\u80fd\u529b\u8303\u56f4\u5185\u4e86\uff09\u3002\u4e5f\u56e0\u4e3a\u8fd9\u4e2a\u539f\u56e0\uff0c\u6211\u51b3\u5b9a\u7ed9\u8fd9\u4e2a\u7cfb\u5217\u53d6\u540d\u53eb\u201c\u5b66\u4e0d\u6765Python\u201d\u3002 \u6700\u540e\uff0c\u6211\u5bf9\u6211\u81ea\u5df1\u6525\u5199\u6587\u7ae0\u7684\u6c34\u5e73\u6ca1\u591a\u5c11\u81ea\u4fe1\uff0c\u6240\u4ee5\u5176\u5b9e\u6211\u5199\u7684\u4e1c\u897f\u4e0d\u4e00\u5b9a\u9002\u5408\u7ed9\u522b\u4eba\u770b\uff0c\u751a\u81f3\u4e8e\u8bf4\u662f\u5f53\u505a\u201c\u6559\u7a0b\u201d\u2014\u2014\u8fd9\u4e2a\u7cfb\u5217\u5e94\u8be5\u8bf4\u662f\u4e00\u4e2a\u5199\u7ed9\u6211\u81ea\u5df1\u770b\u7684\u201c\u6559\u7a0b\u201d\uff0c\u5f53\u7136\u6211\u4f1a\u5c3d\u91cf\u628a\u6211\u60f3\u7ed9\u81ea\u5df1\u770b\u7684\u5185\u5bb9\u5199\u6210\u5176\u4ed6\u4eba\u4e5f\u80fd\u770b\u61c2\u7684\u5f62\u5f0f\u3002\u8fd9\u4e2a\u7cfb\u5217\u4e5f\u4f1a\u53c2\u8003\u4e00\u4e9b\u7f51\u4e0a\u6bd4\u8f83\u6709\u540d\u7684\u6559\u7a0b\uff08\u6bd4\u5982liaoxuefeng\u548cPython\u5b98\u7f51\u7684\u6559\u7a0b\uff09\uff0c\u5fc5\u8981\u7684\u65f6\u5019\u4e5f\u4f1a\u7ed9\u51fa\u53c2\u8003\u94fe\u63a5\u3002\u53e6\u5916\uff0c\u7531\u4e8e\u6211\u6c34\u5e73\u6709\u9650\uff0c\u8fd9\u7bc7\u6587\u7ae0\u4e0d\u4f1a\u8be6\u7ec6\u5730\u8bf4\u660e\u8fd9\u4e2a\u8bed\u8a00\u4e2d\u7684\u6bcf\u4e00\u4e2a\u7ec6\u8282\uff0c\u66f4\u591a\u7684\u65f6\u5019\u53ea\u662f\u505c\u7559\u5728\u201c\u80fd\u7528\u5c31\u884c\u201d\u7684\u6c34\u5e73\uff0c\u6587\u4e2d\u6240\u8bf4\u7684\u5185\u5bb9\u4e5f\u672a\u5fc5100%\u51c6\u786e\uff0c\u8fd8\u8bf7\u89c1\u8c05\u3002 \u5982\u679c\u6587\u4e2d\u6709\u9519\u8bef\u65e0\u4efb\u6b22\u8fce\u6307\u51fa\u3002\u90a3\u4e48\u6700\u540e\u5c31\u8bf7\u591a\u6307\u6559\u4e86\u3002","title":"\u4e00\u4e9b\u524d\u8a00"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_2","text":"","title":"\u57fa\u7840\u8bed\u6cd5"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#python_1","text":"Python\u662f \u9762\u5411\u5bf9\u8c61\u7684\u8bed\u8a00 \uff1a\u5728Python\u4e2d\uff0c\u4efb\u4f55\u7684\u7c7b\u578b\uff08\u5982\u4e0b\u6587\u63d0\u5230\u7684\u6570\u5b57\u3001\u5b57\u7b26\u4e32\uff09\u90fd\u662f\u67d0\u79cd \u7c7b \u3002 \u7c7b \uff1a\u4e00\u79cd\u62bd\u8c61\u7684\u7c7b\u578b\uff0c\u672c\u8d28\u4e0a\u662f\u4e00\u79cd\u6570\u636e\u7ed3\u6784\uff0c\u5b83\u6307\u4ee3\u4e00\u7c7b\u6709\u8be6\u7ec6\u5b9a\u4e49\u7684\u4e8b\u7269\u3002\u4f8b\u5982\uff0c\u6570\u5b66\u4e0a\u7684\u96c6\u5408\uff08\u4e00\u7c7b\u4e8b\u7269\uff09\u53ef\u4ee5\u7406\u89e3\u6210\u4e00\u79cd\u7c7b\u3002\u4eba\u7c7b\u4e5f\u662f\u4e00\u79cd\u7c7b\u3002 \u5b9e\u4f8b\u3001\u5bf9\u8c61 \uff1a\u7c7b\u4e2d\u7684\u67d0\u4e2a\u7279\u5b9a\u7684\u5b9e\u4f53\u79f0\u4e3a \u5b9e\u4f8b \uff0c\u4e5f\u5373 \u5bf9\u8c61 \u3002\u4f8b\u5982\uff0c\u67d0\u4e2a\u96c6\u5408{1,2,3}\u662f\u96c6\u5408\u7684\u4e00\u4e2a\u5b9e\u4f8b\uff0c\u53e6\u4e00\u4e2a\u96c6\u5408{5,6,7}\u53c8\u662f\u96c6\u5408\u7684\u53e6\u4e00\u4e2a\u5b9e\u4f8b\u3002\u67d0\u4e2a\u7279\u5b9a\u7684\u4eba\u4e5f\u53ef\u4ee5\u7406\u89e3\u4e3a\u201c\u4eba\u7c7b\u201d\u8fd9\u4e2a\u7c7b\u7684\u5b9e\u4f8b\u3002 \u5f53\u7136\u6570\u5b66\u4e0a\u7684\u96c6\u5408\u672c\u8eab\u4e0d\u662f\u6570\u636e\u7ed3\u6784\uff0c\u4e0b\u6587\u4e2d\u4f1a\u63d0\u5230Python\u4e2d\u7684\u4e00\u79cd\u7c7b\u578b\u53ebset\uff0c\u5b83\u5c31\u662f\u6570\u5b66\u96c6\u5408\u5728Python\u4e2d\u7684\u5b9e\u73b0\uff0c\u662f\u4e00\u79cd\u6570\u636e\u7ed3\u6784\u3002 \u6210\u5458 \uff1a\u4e00\u4e2a\u7c7b\u4e2d\u5305\u542b\u7684 \u5c5e\u6027 \u548c \u65b9\u6cd5 \u7edf\u79f0\u4e3a\u6210\u5458\u3002 \u5c5e\u6027 \uff1a\u63cf\u8ff0\u4e86\u8fd9\u4e2a\u7c7b\u7684\u6240\u6709\u5b9e\u4f8b\u6240\u62e5\u6709\u7684\u5c5e\u6027\u6709\u54ea\u4e9b\u3002\u4f8b\u5982\uff0c\uff08\u6709\u9650\uff09\u96c6\u5408\u62e5\u6709\u5927\u5c0f\u8fd9\u4e2a\u5c5e\u6027\uff0c {1,2}\u8fd9\u4e2a\u96c6\u5408\u4f5c\u4e3a\u96c6\u5408\u7c7b\u7684\u5b9e\u4f8b\uff0c\u5927\u5c0f\u8fd9\u4e2a\u5c5e\u6027\u7684\u503c\u662f2\u3002\u4eba\u7c7b\u62e5\u6709\u8eab\u9ad8\u8fd9\u4e2a\u5c5e\u6027\uff0c\u800c\u67d0\u4e2a\u7279\u5b9a\u7684\u4eba\u8eab\u9ad8\u662f172cm\u5c31\u662f\u8fd9\u4e2a\u7279\u5b9a\u7684\u4eba\u5728\u8eab\u9ad8\u8fd9\u4e2a\u5c5e\u6027\u4e0a\u7684\u503c\u3002 \u65b9\u6cd5 \uff1a\u63cf\u8ff0\u4e86\u8fd9\u4e2a\u7c7b\u7684\u6240\u6709\u5b9e\u4f8b\u6240\u80fd\u505a\u7684\u64cd\u4f5c\uff08\u901a\u5e38\u8fd9\u4e9b\u64cd\u4f5c\u4f1a\u548c\u5b9e\u4f8b\u672c\u8eab\u6709\u5173\uff09\u6709\u54ea\u4e9b\u3002\u4f8b\u5982\uff0c\u96c6\u5408\u7c7b\u5b9a\u4e49\u4e86\u53d6\u4ea4\u96c6\u3001\u5e76\u96c6\u3001\u5220\u9664\u67d0\u5143\u7d20\u7b49\u64cd\u4f5c\uff08\u8fd9\u4e9b\u64cd\u4f5c\u5c31\u662f\u65b9\u6cd5\uff09\uff0c\u90a3\u4e48\u5bf9\u4e8e\u4e00\u4e2a\u7279\u5b9a\u7684\u96c6\u5408\uff5b1\uff0c2\uff0c3\uff5d\uff0c\u5b83\u53ef\u4ee5\u4e0e\u53e6\u4e00\u4e2a\u96c6\u5408\uff5b5\uff0c6\uff0c7\uff5d\u53d6\u5e76\u96c6\u3001\u4ea4\u96c6\u4ece\u800c\u5f97\u5230\u53e6\u4e00\u4e2a\u96c6\u5408\uff0c\u4e5f\u53ef\u4ee5\u5220\u9664\u96c6\u5408\u4e2d\u67d0\u4e00\u7279\u5b9a\u5143\u7d20\u5f97\u5230\u53e6\u4e00\u4e2a\u96c6\u5408\uff08\u4f8b\u5982\u5220\u63893\u5c31\u53ef\u4ee5\u5f97\u5230\uff5b1\uff0c2\uff5d\uff09\u3002 \u53d8\u91cf \uff1a\u7ed1\u5b9a\u5230\u67d0\u4e2a\u7279\u5b9a\u5b9e\u4f8b\u7684\u6307\u9488\uff08\u5728Python\u610f\u4e49\u4e0b\uff09\u3002\u4f8b\u5982\u4ee4a=10\uff0c\u90a3\u4e48\u5c31\u8bf4a\u6307\u5411\u4e8610\u3002 \u51fd\u6570 \uff1a\u4e00\u7cfb\u5217\u5df2\u7ecf\u5c01\u88c5\u597d\u4e86\u7684\u4ee3\u7801\u5757\uff0c\u63a5\u53d7\u7279\u5b9a\u53c2\u6570\u5e76\u6267\u884c\uff08\u4e5f\u5373\u8c03\u7528\uff09\u540e\u5373\u53ef\u8fd4\u56de\u7ed3\u679c\uff08\u5f53\u7136\u4e5f\u6709\u53ef\u80fd\u53ea\u662f\u8fd0\u884c\u800c\u4e0d\u8fd4\u56de\u7ed3\u679c\uff09\u3002 Python\u662f \u5f31\u7c7b\u578b\u7684\u8bed\u8a00 \uff1a\u8981\u5b9a\u4e49\u53d8\u91cf\uff0c\u53ea\u9700\u8981\u7ed9\u5b83\u8d4b\u503c\u4e00\u4e2a\u76f8\u5e94\u7c7b\u578b\u7684\u5bf9\u8c61\u5b9e\u4f8b\u5373\u53ef\u3002\u4e0d\u9700\u8981\u7279\u522b\u6307\u660e\u5176\u7c7b\u578b\u3002 Python\u4f9d\u8d56 \u7f29\u8fdb \u533a\u5206\u4ee3\u7801\u5757\uff1a\u4f18\u70b9\u662f\u5927\u591a\u6570\u65f6\u5019\u4e0d\u9700\u8981\u6253\u82b1\u62ec\u53f7\u548c\u5206\u53f7\u6765\u533a\u5206\u4ee3\u7801\u5757\u548c\u4e00\u884c\u7684\u7ed3\u675f\uff0c\u7f3a\u70b9\u5c31\u662fPython\u5bf9\u7f29\u8fdb\u7684\u8981\u6c42\u6781\u5176\u4e25\u683c\u3002","title":"\u57fa\u672c\u6982\u5ff5\u548cPython\u7684\u7279\u5f81"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_3","text":"Python\u4e2d\u6709\u51e0\u79cd\u57fa\u672c\u6700\u5e38\u7528\u7684\u57fa\u672c\u6570\u636e\u7c7b\u578b\uff0c\u5b83\u4eec\u7684\u672c\u8d28\u90fd\u662f\u5bf9\u8c61\u3002\u4e0b\u9762\u4f1a\u5bf9\u8fd9\u4e9b\u7c7b\u578b\u505a\u4e00\u4e9b\u8f83\u4e3a\u8be6\u7ec6\u7684\u8bf4\u660e\u3002 \u7c7b\u578b \u4f8b\u5b50 \u8bf4\u660e \u6574\u6570\uff08int\uff09 123 \u9ad8\u7cbe\u5ea6\u5927\u6574\u6570 \u6d6e\u70b9\u6570\uff08float\uff09 114.514,1.0,1e18 \u5b57\u7b26\u4e32\uff08str\uff09 \"TML104\" \u5e03\u5c14\u503c\uff08bool\uff09 True,False \u4ee5\u5927\u5199\u5f00\u5934\uff0c\u53ea\u6709\u4e24\u4e2a\u5408\u6cd5\u7684\u503c \u590d\u6570 1+2j","title":"\u57fa\u672c\u6570\u636e\u7c7b\u578b"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_4","text":"","title":"\u6574\u6570"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_5","text":"\u4e00\u822c\u5730\uff0c\u968f\u4fbf\u8f93\u5165\u67d0\u4e2a\u5341\u8fdb\u5236\u6570\u5c31\u662f\u6574\u6570\u4e86\u3002\u4f46\u4ed6\u4eec\u4e0d\u80fd\u6709\u591a\u4f59\u7684\u524d\u5bfc\u96f6\u3002 1 2 3 a = 123456 b =- 1123 c = 0 \u5f53\u7136\u4f60\u4e5f\u53ef\u4ee5\u7528\u4e0b\u5212\u7ebf\u5206\u5272\u6570\u5b57\uff0cPython\u4f1a\u8ba4\u4e3a\u4ed6\u4eec\u662f\u8fde\u5728\u4e00\u8d77\u7684\u3002 1 a = 114_514","title":"\u5341\u8fdb\u5236"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_6","text":"\u5728\u5bf9\u5e94\u8fdb\u5236\u7684\u6570\u524d\u52a0\u4e0a\u201c0b\u201d\u3001\u201c0o\u201d\u3001\u201c0x\u201d\uff0c\u5c31\u53ef\u4ee5\u4ee5\u4e8c\u3001\u516b\u3001\u5341\u8fdb\u5236\u8868\u793a\u522b\u7684\u6574\u6570\u3002 1 2 3 a = 0b11 b =- 0x3f c = 0o12","title":"\u5176\u4ed6\u8fdb\u5236"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_7","text":"\u53ef\u4ee5\u76f4\u89c2\u5730\u7406\u89e3\uff1a\u5e26\u6709\u5c0f\u6570\u70b9\u7684\u6570\u5c31\u662f\u6d6e\u70b9\u6570\u3002\u5f53\u7136\uff0c\u4f60\u4e5f\u53ef\u4ee5\u7528\u79d1\u5b66\u8ba1\u6570\u6cd5\u6765\u8868\u793a\u6d6e\u70b9\u6570\uff0c\u5f62\u5982\u201cxey\u201d\uff0c\u7b49\u4ef7\u4e8e \\(x\\cdot 10^y\\) 1 2 3 4 a = 1.0 b = 3e9 c = 38e38 d = 1e-12 \u8fd9\u91cc \\(b=3*10^9\\) \uff0c \\(c=3.8*10^{39},d=1*10^{-12}\\) \uff0c\u4f46\u8981\u6ce8\u610f\u4ed6\u4eec\u90fd\u662f\u6d6e\u70b9\u6570\u3002 \u6ce8\u610f\u533a\u5206\uff1a1\u548c1.0\u662f \u4e24\u79cd\u4e0d\u540c\u7c7b\u578b\u7684\u6570 \uff0c\u524d\u8005\u662f\u6574\u6570\uff08int\uff09\u3001\u540e\u8005\u662f\u6d6e\u70b9\u6570\uff08float\uff09\uff0c\u4e0b\u6587\u4e2d\u7684\u9664\u6cd5\u8fd0\u7b97\u4f1a\u6d89\u53ca\u5230\u8fd9\u70b9\u3002 \u5982\u679c\u5c0f\u6570\u4ee50.\u5f00\u5934\uff0c\u90a3\u4e48\u53ef\u4ee5\u7701\u7565\u63890\u3002\u4e0b\u9762\u7684a\u7b49\u4e8e-0.03\u3002 1 a =- .03 \u7531\u4e8e\u8ba1\u7b97\u673a\u4fdd\u5b58\u6d6e\u70b9\u6570\u7684\u5f62\u5f0f\u5b58\u5728\u4e00\u5b9a\u7684\u201c\u7f3a\u9677\u201d\u5bfc\u81f4\u8fd0\u7b97\u53ef\u80fd\u4f1a\u5b58\u5728\u7cbe\u5ea6\u95ee\u9898\uff0c\u56e0\u6b64\u80fd\u7528\u6574\u6570\u7684\u60c5\u51b5\u4e0b\u5c3d\u91cf\u7528\u6574\u6570\u3002","title":"\u6d6e\u70b9\u6570"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_8","text":"\u5176\u5b9e\u8fd9\u73a9\u610f\u5e94\u8be5\u4e0d\u7b97\u57fa\u672c\u6570\u636e\u7c7b\u578b\u4e86\u2026\u2026\u56e0\u4e3a\u5b57\u7b26\u4e32\u4e8b\u5b9e\u4e0a\u62e5\u6709\u4e00\u4e9b\u9ad8\u7ea7\u7279\u6027\uff0c\u4ee5\u540e\u4f30\u8ba1\u4f1a\u5f00\u4e00\u8282\u4e13\u95e8\u8bf4\u660e\u5b57\u7b26\u4e32\uff0c\u56e0\u6b64\u8fd9\u91cc\u53ea\u662f\u5148\u63d0\u4e00\u5634\u3002 \u4f7f\u7528\u4e00\u5bf9\u534a\u89d2\u5355\u5f15\u53f7\u6216\u53cc\u5f15\u53f7\u5305\u88f9\u7684\u5185\u5bb9\u662f\u5355\u884c\u5b57\u7b26\u4e32\uff0c\u4f7f\u7528\u4e09\u5bf9\u534a\u89d2\u5355\u5f15\u53f7\u6216\u53cc\u5f15\u53f7\u5305\u88f9\u7684\u5185\u5bb9\u662f\u591a\u884c\u5b57\u7b26\u4e32\u3002 1 2 3 4 5 a = \"Hello,world\" b = '''R1 R2 R3 ''' \u6ce8\u610f\u8d4b\u503c\u7684\u65f6\u5019\u591a\u884c\u5b57\u7b26\u4e32\u7684\u5f00\u5934\u4e09\u4e2a\u5f15\u53f7\u5fc5\u987b\u8981\u548c\u53d8\u91cf\u540c\u884c\uff0c\u5426\u5219\u5c31\u4f1a\u53d8\u6210\u4e0b\u6587\u4e2d\u7684\u6ce8\u91ca\u7684\u5199\u6cd5\u4e86\u3002","title":"\u5b57\u7b26\u4e32"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_9","text":"\u8fd9\u4e2a\u5c31\u6ca1\u4ec0\u4e48\u597d\u8bf4\u660e\u7684\u4e86\u3002\u5e03\u5c14\u503c\u53ea\u6709\u4e24\u79cd\u53d6\u503c\uff1aTrue\u3001False\uff0c\u6ce8\u610f\u4e0d\u50cfC\u8bed\u8a00\uff0c\u8fd9\u91cc\u5b83\u4eec\u5f00\u5934\u9996\u5b57\u6bcd\u5fc5\u987b\u8981\u5927\u5199\u3002 1 2 a = True b = False","title":"\u5e03\u5c14\u503c"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_10","text":"\u8fd9\u4e2a\u7c7b\u578b\u4e0d\u600e\u4e48\u5e38\u7528\uff0c\u8fd9\u91cc\u53ea\u662f\u63d0\u4e00\u4e0b\u3002\u7528\"a+bj\"\u6765\u6784\u9020\u4e00\u4e2a\u590d\u6570\uff0c\u4e5f\u53ef\u4ee5\u7528complex(\"a+bj\")\u4ee5\u5b57\u7b26\u4e32\u6765\u6784\u9020\u590d\u6570\u3002 1 2 a = complex ( \"1+2j\" ) b = 1 + 2 j","title":"\u590d\u6570"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_11","text":"\u4f7f\u7528\u7b49\u4e8e\u53f7\u6765\u7ed9\u53d8\u91cf\u8d4b\u503c\u3002\u4e0a\u6587\u4e2d\u5df2\u7ecf\u7ed9\u51fa\u4f8b\u5b50\u3002 \u4f60\u4e5f\u53ef\u4ee5\u540c\u65f6\u5bf9\u591a\u4e2a\u53d8\u91cf\u8d4b\u503c\uff0c\u8fd9\u6837abc\u4e09\u4e2a\u53d8\u91cf\u5c31\u90fd\u662f10\uff1a 1 a = b = c = 10 python\u4e2d\u7684\u53d8\u91cf\u4e0e\u5176\u8bf4\u662f\u53d8\u91cf\uff0c\u4e0d\u5982\u8bf4\u662f\u67d0\u79cd\u201c\u6307\u9488\u201d\u2014\u2014\u5b83\u7684\u672c\u8d28\u5176\u5b9e\u662f\u6307\u5411\u5bf9\u8c61\u7684\u6307\u9488\uff08\u4e5f\u5c31\u662f\u4f20\u9012\u5f15\u7528\uff09\u3002\u8fd9\u4e2a\u6982\u5ff5\u5bf9\u7406\u89e3\u540e\u9762\u7684\u5217\u8868\u7b49\u53ef\u53d8\u7c7b\u578b\u4f1a\u6709\u5e2e\u52a9\u3002","title":"\u53d8\u91cf\u548c\u7b80\u5355\u8d4b\u503c"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_12","text":"\u7ed9\u53d8\u91cfa\u8d4b\u503c\u540e\uff0c\u53ef\u4ee5\u7528del\u8bed\u53e5\u5220\u9664\u53d8\u91cfa\u6307\u5411\u7684\u5bf9\u8c61\uff0c\u8fd9\u6837a\u5c31\u91cd\u65b0\u56de\u5230\u672a\u5b9a\u4e49\u7684\u72b6\u6001\u4e86\u3002 1 2 3 a = [ 3 , 4 , 5 ] del a a #NameError: name 'a' is not defined","title":"\u5220\u9664"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_13","text":"\u4e0b\u6587\u4e2d\u5c06\u4f1a\u5217\u51fa\u6bd4\u8f83\u5e38\u7528\u7684\u8fd0\u7b97\uff0c\u4e0d\u4f1a\u5217\u51fa\u6240\u6709\u8fd0\u7b97\uff08\u56e0\u4e3a\u592a\u591a\u4e86\u6211\u81ea\u5df1\u90fd\u4e0d\u4f1a= =\uff09\u3002","title":"\u57fa\u672c\u8fd0\u7b97"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_14","text":"\u4e0b\u6587\u4e2d\u793a\u4f8b\u7b49\u53f7\u53f3\u4fa7\u8868\u793a\u8fd0\u7b97\u7ed3\u679c\u3002 \u9664\u975e\u6709\u7279\u6b8a\u8bf4\u660e\uff0c\u4e0b\u8868\u4e2d\u7b26\u53f7\u7686\u4e3a\u4e8c\u5143\u8fd0\u7b97\u7b26\uff0c\u4e14\u6d6e\u70b9\u6570\u3001\u6574\u6570\u3001\u5e03\u5c14\u503c\u5747\u53ef\u53c2\u4e0e\u8fd0\u7b97 $$ \\begin{array} {|} \\hline { \u8fd0\u7b97 }&{ \u7b26\u53f7 }&{ \u7279\u6b8a\u8bf4\u660e }&{ \u793a\u4f8b }\\ \\hline { \u52a0\u6cd5 }&{ + }&{ \u5bf9\u4e8e\u5217\u8868\u3001\u5b57\u7b26\u4e32\u7b49\u5bf9\u8c61\u6b64\u7b26\u53f7\u6709\u7279\u6b8a\u7528\u9014 }&{ 1+2 =3\\ [3]+[4] =[3,4]\\ \"13\"+\"222\" =\"13222\" }\\ \\hline { \u51cf\u6cd5 }&{ - }&{ }&{ 1-2 =-1 }\\ \\hline { \u4e58\u6cd5 }&{ }&{ \u5bf9\u4e8e\u5217\u8868\u3001\u5b57\u7b26\u4e32\u7b49\u5bf9\u8c61\u6b64\u7b26\u53f7\u6709\u7279\u6b8a\u7528\u9014 }&{ 1 2 =2\\ \"13\" 5 =\"1313131313\"\\ [3,4] 2 =[3,4,3,4] }\\ \\hline { \u6574\u6570\u9664\u6cd5\uff08\u5730\u677f\u9664\u6cd5\uff09 }&{ // }&{ \u8fd4\u56de\u6574\u6570\u503c\uff08\u5411\u4e0b\u53d6\u6574\uff0c\u4e5f\u5373\u8d1f\u6570\u65b9\u5411\u53d6\u6574\uff09\\\u9664\u4ee50\u4f1a\u629b\u51faZeroDivisionError\u5f02\u5e38 }&{ 3//4 =0\\ -3//4 =-1 }\\ \\hline { \u6d6e\u70b9\u6570\u9664\u6cd5 }&{ / }&{ \u8fd4\u56de\u6d6e\u70b9\u6570\u503c\uff0c\u9664\u4ee50\u4f1a\u629b\u51faZeroDivisionError\u5f02\u5e38 }&{ 3//4 =0.75 }\\ \\hline { \u53d6\u6a21 }&{ \\% }&{ a\\%b\u7684\u7ed3\u679c\u4e3aa-(a//b) b\uff0c\u9664\u4ee50\u4f1a\u629b\u51faZeroDivisionError\u5f02\u5e38;\\\u5bf9\u5b57\u7b26\u4e32\u5bf9\u8c61\u6709\u7279\u6b8a\u7528\u9014\uff08\u683c\u5f0f\u5316\u5b57\u7b26\u4e32\uff09;\\\u6ce8\u610f\uff1a\u6839\u636e\u8fd9\u4e2a\u516c\u5f0f\uff0c\u4f60\u4e8b\u5b9e\u4e0a\u53ef\u4ee5\u5bf9\u6d6e\u70b9\u6570\u53d6\u6a21 }&{ 4\\%3 =1\\ 4\\%-3 =-2\\ -4\\%3 =2\\ -4\\%-3 =-1\\ 4.2\\%3.0 =1.2000000000000002 }\\ \\hline { \u4e58\u65b9 }&{ pow(a,b) \u6216 a b }&{ }&{ 4 3 =64\\ 2 *0.5 =1.4142135623730951 }\\\\ \\hline \\end{array}\\ $$ \u8fd0\u7b97 \u7b26\u53f7 \u7279\u6b8a\u8bf4\u660e \u793a\u4f8b \u52a0\u6cd5 + \u5bf9\u4e8e\u5217\u8868\u3001\u5b57\u7b26\u4e32\u7b49\u5bf9\u8c61\u6b64\u7b26\u53f7\u6709\u7279\u6b8a\u7528\u9014 1+2 =3 [3]+[4] =[3,4] \"13\"+\"222\" =\"13222\" \u51cf\u6cd5 - 1-2 =-1 \u4e58\u6cd5 * \u5bf9\u4e8e\u5217\u8868\u3001\u5b57\u7b26\u4e32\u7b49\u5bf9\u8c61\u6b64\u7b26\u53f7\u6709\u7279\u6b8a\u7528\u9014 1 2 =2 \"13\" 5 =\"1313131313\" [3,4]*2 =[3,4,3,4] \u6574\u6570\u9664\u6cd5\uff08\u5730\u677f\u9664\u6cd5\uff09 // \u8fd4\u56de\u6574\u6570\u503c\uff08\u5411\u4e0b\u53d6\u6574\uff0c\u4e5f\u5373\u8d1f\u6570\u65b9\u5411\u53d6\u6574\uff09\uff0c\u9664\u4ee50\u4f1a\u629b\u51faZeroDivisionError\u5f02\u5e38 3//4 =0 -3//4 =-1 \u6d6e\u70b9\u6570\u9664\u6cd5 / \u8fd4\u56de\u6d6e\u70b9\u6570\u503c\uff0c\u9664\u4ee50\u4f1a\u629b\u51faZeroDivisionError\u5f02\u5e38 3//4 =0.75 \u53d6\u6a21 % a%b\u7684\u7ed3\u679c\u4e3aa-(a//b)*b\uff0c\u9664\u4ee50\u4f1a\u629b\u51faZeroDivisionError\u5f02\u5e38\uff1b\u5bf9\u5b57\u7b26\u4e32\u5bf9\u8c61\u6709\u7279\u6b8a\u7528\u9014\uff08\u683c\u5f0f\u5316\u5b57\u7b26\u4e32\uff09\uff1b\u6ce8\u610f\uff1a\u6839\u636e\u8fd9\u4e2a\u516c\u5f0f\uff0c\u4f60\u4e8b\u5b9e\u4e0a\u53ef\u4ee5\u5bf9\u6d6e\u70b9\u6570\u53d6\u6a21 4%3 =1 4%-3 =-2 -4%3 =2 -4%-3 =-1 4.2%3.0 =1.2000000000000002 \u4e58\u65b9 pow(a,b) \u6216 a**b 4 3 =64 2 0.5 =1.4142135623730951","title":"\u4ee3\u6570\u8fd0\u7b97\u7b26\u8fd0\u7b97"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_15","text":"\u53c2\u4e0e\u8fd0\u7b97\u7684\u901a\u5e38\u662f\u5e03\u5c14\u503c\u3002 \u8fd0\u7b97 \u7b26\u53f7 \u7279\u6b8a\u8bf4\u660e \u793a\u4f8b \u6216 a or y True or False = True \u4e0e a and b True or False = False \u975e not a \u5355\u76ee\u8fd0\u7b97\u7b26 not False =True","title":"\u5e03\u5c14\u903b\u8f91\u8fd0\u7b97"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_16","text":"\u53c2\u4e0e\u8fd0\u7b97\u7684\u901a\u5e38\u662f\u5e03\u5c14\u503c\u3002\u5f53\u7136\uff0c\u5217\u8868\u3001\u5143\u7ec4\u3001\u5b57\u7b26\u4e32\u7b49\u4e5f\u53ef\u6bd4\u8f83\u5927\u5c0f\uff0c\u4f46\u4e0d\u7b49\u53f7\u4e24\u8fb9\u4e00\u822c\u5f97\u662f\u540c\u7c7b\u578b\u7684\u5bf9\u8c61\u3002 \u8fd0\u7b97 \u7b26\u53f7 \u7279\u6b8a\u8bf4\u660e \u793a\u4f8b \u5c0f\u4e8e < \u5217\u8868\u3001\u5143\u7ec4\u3001\u5b57\u7b26\u4e32\uff1a\u6309\u5b57\u5178\u5e8f\u6bd4\u8f83\uff0c\u4e0b\u540c \u5c0f\u4e8e\u7b49\u4e8e <= \u5927\u4e8e > \u5927\u4e8e\u7b49\u4e8e >= \u7b49\u4e8e == \uff08\u901a\u5e38\u662f\uff09\u5224\u65ad\u4e24\u4e2a\u5bf9\u8c61\u7684\u503c\u662f\u5426\u76f8\u7b49\uff0c\u76f8\u7b49\u7684\u5b9a\u4e49\u5bf9\u4e8e\u4e0d\u540c\u7684\u5bf9\u8c61\u800c\u8a00\u53ef\u80fd\u4e0d\u540c\uff1b\u7279\u522b\u5730\uff0c\u7531\u4e8e\u6d6e\u70b9\u6570\u7cbe\u5ea6\u95ee\u9898\uff0c\u5bf9\u6d6e\u70b9\u6570\u4f7f\u7528\u6b64\u7b26\u53f7\u5e94\u5f53\u614e\u91cd \u5bf9\u8c61\u6807\u8bc6 is \u4e24\u4e2a\u5bf9\u8c61\u662f\u540c\u4e00\u4e2a\u5bf9\u8c61\uff08\u8fd9\u91cc\u540c\u4e00\u4e2a\u5bf9\u8c61\u7684\u610f\u601d\u5927\u81f4\u662f\u4ed6\u4eec\u7684\u5185\u5b58\u5730\u5740\u5b8c\u5168\u4e00\u6837\uff09\u65f6\u8fd4\u56deTrue\uff0c\u5426\u5219\u8fd4\u56deFalse 1 is 1 =True [1] is [1] =False \u5426\u5b9a\u5bf9\u8c61\u6807\u8bc6 is not \u4e0a\u4e00\u6761\u7684\u5426\u5b9a\u5f62\u5f0f \u6210\u5458\u68c0\u6d4b\u8fd0\u7b97 in \u6216 not in \u68c0\u6d4ba\u662f\uff08\u4e0d\u662f\uff09b\u7684\u4e00\u4e2a\u6210\u5458\u3002\uff08\u6216\u8005\u8bf4a\u662f\u5426\u5728b\u91cc\uff09\uff1b\u7279\u522b\u5730\uff0c\u5bf9\u5b57\u5178\u6765\u8bf4a\u662fb\u7684\u952e\u65f6\u8fd4\u56deTrue 3 in [1,3] =True 5 in [1,3] =False is\u7684\u4f7f\u7528\u548c\u5bf9\u8c61\u7684id\u6709\u5173\uff0c\u4e4b\u540e\u6211\u4eec\u4f1a\u8be6\u7ec6\u8bf4\u660e\u3002 \u53e6\u5916\uff0cpython\u4e2d\u8fd8\u53ef\u4ee5\u628a\u51e0\u4e2a\u6bd4\u8f83\u7b26\u53f7\u8fde\u7740\u5199\uff1a a<x<=b \uff0c\u8fd9\u79cd\u5199\u6cd5\u5c31\u7ed3\u679c\u800c\u8a00\u7b49\u4ef7\u4e8e a<x and x<=b \uff0c\u4f46x\u7684\u503c\u53ea\u4f1a\u6c42\u89e3\u4e00\u6b21\u3002\u6b64\u5916\uff0c a<x>b \u4e5f\u7b49\u4ef7\u4e8e a<x and x>b \uff0ca\u548cb\u4e4b\u95f4\u4e0d\u4f1a\u8fdb\u884c\u6bd4\u8f83\u3002","title":"\u6bd4\u8f83\u8fd0\u7b97"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_17","text":"\u4f4d\u8fd0\u7b97\u901a\u5e38\u5728\u6574\u6570\u4e0b\u8fdb\u884c\u3002\u7531\u4e8epython\u4e2d\u7684\u6574\u6570\u662f\u5927\u6574\u6570\uff0c\u505a\u4e0b\u9762\u7684\u8fd0\u7b97\u76f8\u5f53\u4e8e\u5bf9\u65e0\u7a77\u4e2a\u4e8c\u8fdb\u5236\u8865\u7801\u4f4d\u505a\u8fd0\u7b97\uff08\u5f53\u7136\u5b9e\u9645\u5b9e\u73b0\u7684\u65f6\u5019\u4e0d\u53ef\u80fd\u662f\u8fd9\u6837\uff0c\u8fd9\u4e48\u8bf4\u53ea\u662f\u65b9\u4fbf\u7406\u89e3\uff09 \u8fd0\u7b97 \u7b26\u53f7 \u7279\u6b8a\u8bf4\u660e \u793a\u4f8b \u6309\u4f4d\u6216 | -3 | -4 =-3 \u6309\u4f4d\u4e0e & -3&-4 =1 \u6309\u4f4d\u5f02\u6216 ^ -3^-4 =1 \u6309\u4f4d\u53d6\u53cd ~a \u7b49\u4ef7\u4e8e\u8fd4\u56de-a-1 ~-3=2 \u5de6\u79fb a<<b \u7b26\u53f7\u4f4d\u4e0d\u4f1a\u79fb\u52a8\uff0c\u591a\u51fa\u6765\u7684\u4f4d\u75280\u586b\u5145\uff1b\u7b49\u4ef7\u4e8e\u4e58\u4ee52\u7684b\u6b21\u65b9 22<<3 =176 \u53f3\u79fb a>>b \u7b26\u53f7\u4f4d\u4e0d\u4f1a\u79fb\u52a8\uff0c\u51cf\u5c11\u7684\u4f4d\u88ab\u820d\u53bb\uff1b\u7b49\u4ef7\u4e8e\u5730\u677f\u9664\u4ee52\u7684b\u6b21\u65b9 22>>3 =2","title":"\u4f4d\u8fd0\u7b97"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_18","text":"\u7c7b\u578b\u8f6c\u6362\u975e\u5e38\u7075\u6d3b\uff0c\u4e0a\u6587\u63d0\u5230\u7684\u57fa\u672c\u6570\u636e\u7c7b\u578b\u51e0\u4e4e\u90fd\u53ef\u4ee5\u76f8\u4e92\u8f6c\u6362\uff0c\u751a\u81f3\u53ef\u4ee5\u76f4\u63a5\u628a\u5b57\u7b26\u4e32\u8f6c\u6362\u6210\u6574\u6570\u3001\u6d6e\u70b9\u6570\u3001\u590d\u6570\u7b49\u3002 \u8fd9\u4e9b\u8f6c\u6362\u975e\u5e38\u91cd\u8981\uff0c\u8f93\u5165\u6570\u5b57\u9700\u8981\u4f9d\u8d56\u8fd9\u4e9b\u8f6c\u6362\u7528\u7684\u51fd\u6570\u3002 \u8fd0\u7b97 \u7b26\u53f7 \u7279\u6b8a\u8bf4\u660e \u793a\u4f8b \u6574\u6570\u8f6c\u6362 int(a) \u6d6e\u70b9\u6570\u8f6c\u6362\u6210\u5c0f\u6570\u65f6\u662f\u5411\u96f6\u53d6\u6574 int(-2.5) =-2 \u6d6e\u70b9\u6570\u8f6c\u6362 float(a) float(-1) =-1.0 \u590d\u6570\u8f6c\u6362 complex(re,im) \u6216 complex(string) re\u662f\u5b9e\u90e8\u3001im\u662f\u865a\u90e8\uff1b\u4e5f\u53ef\u4ee5\u76f4\u63a5\u7528a+bj\u5f62\u5f0f\u7684\u5b57\u7b26\u4e32\u8f6c\u6362\u6210\u590d\u6570 complex(1,2) complex(\"1+2j\") \u5b57\u7b26\u4e32\u8f6c\u6362 str(a) str(12345) =\"12345\" \u5e03\u5c14\u503c\u8f6c\u6362 bool(a) \u5bf9\u6574\u6570\u6765\u8bf4\uff0c\u53ea\u8981\u4e0d\u662f0\uff0c\u5c31\u8fd4\u56deTrue\uff1b\u5bf9\u5b57\u7b26\u4e32\u6765\u8bf4\uff0c\u53ea\u8981\u975e\u7a7a\uff0c\u5c31\u8fd4\u56deTrue\uff1b\u5176\u4ed6\u7c7b\u578b\u4e5f\u53ef\u7c7b\u63a8 bool(-1) =True bool(0)=False","title":"\u7c7b\u578b\u8f6c\u6362\u8fd0\u7b97\u51fd\u6570"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_19","text":"\u4e0b\u9762\u7684\u8fd0\u7b97\u7406\u8bba\u4e0a\u5c5e\u4e8e\u4ee3\u6570\u8fd0\u7b97\uff0c\u4f46\u4f7f\u7528\u65f6\u5f62\u5982\u8c03\u7528\u51fd\u6570\uff08\u4e8b\u5b9e\u4e0a\u4ed6\u4eec\u672c\u8d28\u4e0a\u5c31\u662f\u51fd\u6570\uff09\uff0c\u56e0\u6b64\u5355\u72ec\u5217\u51fa\u3002 \u8fd0\u7b97 \u7b26\u53f7 \u7279\u6b8a\u8bf4\u660e \u793a\u4f8b \u4e58\u65b9 pow(a,b) \u6216 a**b \uff08\u4e0a\u6587\u5df2\u6709\u8be6\u7ec6\u8bf4\u660e\uff09 \u7edd\u5bf9\u503c abs(a) abs(-3) =3 \u5e26\u4f59\u9664\u6cd5 divmod(a,b) \u8fd4\u56de\u4e8c\u5143\u7ec4(a//b, a%b) div(4,3) =(1,1)","title":"\u57fa\u672c\u51fd\u6570\u8fd0\u7b97"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_20","text":"\u53c2\u89c1\uff1a https://docs.python.org/zh-cn/3/reference/expressions.html#operator-precedence","title":"\u8fd0\u7b97\u4f18\u5148\u7ea7"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_21","text":"\u7528#\u5f00\u5934\u7684\u4e00\u884c\u4ee3\u7801\u8868\u793a\u6ce8\u91ca\u3002\u4e5f\u53ef\u4ee5\u7528\u5355\u72ec\u7684\u591a\u884c\u5b57\u7b26\u4e32\u8868\u793a\u6ce8\u91ca\u3002 1 2 3 4 5 # note \"\"\" other note \"\"\" \u591a\u884c\u6ce8\u91ca\u4f1a\u5728\u540e\u6587\u7684\u51fd\u6570\u4e2d\u7528\u5230\uff0c\u8d77\u5230\u7c7b\u4f3c\u4e8e\u51fd\u6570\u4f5c\u7528\u6587\u6863\u7684\u4f5c\u7528\u3002 \u5355\u884c\u6ce8\u91ca\u6709\u65f6\u4e5f\u6709\u53e6\u4e00\u4e2a\u4f5c\u7528\u3002\u5982\u679c\u4f60\u5728\u4f60\u7684py\u6587\u4ef6\u5f00\u5934\u52a0\u4e0a\u8fd9\u4e48\u4e00\u53e5\u6ce8\u91ca\uff1a 1 # coding: utf-8 \u90a3\u4e48\u6574\u4e2a\u6587\u4ef6\u5c06\u4f1a\u88ab\u7f16\u7801\u4e3autf-8\u540e\u6267\u884c\u3002 \u4f60\u53ef\u80fd\u4f1a\u89c9\u5f97\u5f88\u4e0d\u81ea\u7136\uff0c\u56e0\u4e3a\u4e00\u822c\u5370\u8c61\u4e2d\u6ce8\u91ca\u9664\u4e86\u7ed9\u4eba\u770b\u4ee5\u5916\u5c31\u6ca1\u4ec0\u4e48\u522b\u7684\u7528\u5904\u4e86\uff0c\u4f46\u5728\u8fd9\u91cc\u5b83\u786e\u5b9e\u5f71\u54cd\u4e86\u7a0b\u5e8f\u7684\u8fd0\u884c\uff08\u4f60\u53ef\u4ee5\u628a\u4e0a\u9762\u7684utf-8\u6362\u6210\u522b\u7684\u968f\u4fbf\u4ec0\u4e48\u4e1c\u897f\uff0c\u7136\u540e\u8fd0\u884c\u7684\u65f6\u5019\u4f1a\u62a5\u9519\uff09\u3002\u4e8b\u5b9e\u4e0a \u5b98\u65b9\u6587\u6863 \u628a\u8fd9\u79cd\u64cd\u4f5c\u53eb\u505aEncoding declarations\uff0c\u5b83\u662f\u901a\u8fc7\u6b63\u5219\u8868\u8fbe\u5f0f\u5339\u914d \u524d\u4e24\u884c \u6ce8\u91ca\u5b9e\u73b0\u7684\uff0c\u4f5c\u7528\u5c31\u662f\u6211\u4eec\u63d0\u5230\u7684\u6539\u53d8\u7f16\u7801\u3002\u4e5f\u5c31\u662f\u8bf4\u8fd9\u79cd\u7279\u6b8a\u7684\u5199\u6cd5\u53ea\u5bf9\u5f00\u5934\u524d\u4e24\u884c\u6ce8\u91ca\u6709\u7528\u3002 \u6709\u6ca1\u6709\u522b\u7684\u7c7b\u4f3c\u5199\u6cd5\u53ef\u4ee5\u4f7f\u5f97\u6ce8\u91ca\u6539\u53d8\u8fd0\u884c\u7684\u884c\u4e3a\u5462\uff1f\u636e\u6211\u6240\u77e5\u4e5f\u5c31\u53ea\u6709\u8fd9\u4e00\u4e2a\u4e86\uff0c\u81f3\u4e8e\u522b\u7684\u6709\u6ca1\u6709\u2026\u2026\u6211\u4e5f\u4e0d\u77e5\u9053\uff08\u9003\uff09 \u53e6\u5916\u6211\u7684\u5199\u6cd5\u5e76\u4e0d\u662f\u5b98\u65b9\u63a8\u8350\u7684\u5199\u6cd5\uff0c\u5982\u679c\u771f\u7684\u8981\u7528\u53ef\u4ee5\u53c2\u8003\u5b98\u65b9\u6587\u6863\uff08\u4e0a\u6587\u7684\u94fe\u63a5\u5df2\u7ecf\u7ed9\u51fa\uff09\u3002","title":"\u6ce8\u91ca"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_22","text":"\u5728\u63a7\u5236\u53f0\u8f93\u5165\u8f93\u51fa\uff0c\u4e3b\u8981\u4f9d\u9760input\u548cprint\u4e24\u4e2a\u51fd\u6570\u3002","title":"\u63a7\u5236\u53f0\u4e0a\u7684\u8f93\u5165\u548c\u8f93\u51fa"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#print","text":"\u53ef\u4ee5\u76f4\u63a5\u8f93\u51fa\u6570\u5b57\u3001\u5b57\u7b26\u4e32\u7b49\u7c7b\u578b\uff1bprint\u51fd\u6570\u4f1a\u628a\u4ed6\u4eec\u81ea\u52a8\u8f6c\u6362\u6210\u5b57\u7b26\u4e32\u7c7b\u578b\u540e\u8f93\u51fa\uff1b \u4e5f\u53ef\u4ee5\u7528\u9017\u53f7\u5206\u9694\u6765\u540c\u65f6\u8f93\u51fa\u591a\u4e2a\u5185\u5bb9\uff0c\u4ed6\u4eec\u4e4b\u95f4\u4f1a\u7528\u7a7a\u683c\u5206\u9694\u3002 print\u9ed8\u8ba4\u4ee5\u4e00\u4e2a\u6362\u884c\u7b26(\\n)\u7ed3\u5c3e\uff0c\u53ef\u4ee5\u6539\u53d8print\u51fd\u6570\u7684 end\u5173\u952e\u5b57\u53c2\u6570 \u4e3a\u53e6\u4e00\u4e2a\u5b57\u7b26\u4e32\u6765\u6539\u53d8\u7ed3\u5c3e\uff0c\u4f8b\u5982\u5c06\u5b83\u6539\u6210\u4e00\u4e2a\u7a7a\u4e32end=''\uff0c\u5c31\u53ef\u4ee5\u8ba9\u5b83\u4e0d\u6362\u884c\u3002 1 2 3 a = b = 15 print ( a , b , \"Yes\" ) print ( a , end = '' )","title":"print"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#input","text":"\u8c03\u7528\u6b64\u51fd\u6570\u540e\uff0c\u5c06\u4f1a\u5728\u63a7\u5236\u53f0\u8bfb\u5165 \u4e00\u884c \u952e\u76d8\u8f93\u5165\uff08\u4e0d\u5305\u62ec\u6362\u884c\u7b26\u53f7\uff09\uff0c\u5e76\u8fd4\u56de\u5b57\u7b26\u4e32\u3002 \u4e5f\u53ef\u4ee5\u7ed9input\u4f20\u5165\u4e00\u4e2a\u5b57\u7b26\u4e32\u4f5c\u4e3a\u53c2\u6570\uff0c\u8fd9\u6837\u5728\u8bfb\u5165\u524d\u4f1a\u5148\u8f93\u51fa\u4e00\u884c\u5b57\u7b26\u4e32\u63d0\u793a\u7528\u6237\u8f93\u5165\u7684\u5185\u5bb9\u3002\uff08\u5927\u591a\u6570\u65f6\u5019\u8fd9\u4e2a\u529f\u80fd\u6bd4\u8f83\u9e21\u808b\u7528\u4e0d\u4e0a\uff09 1 a = input ( '123 \\n ' ) \u8981\u60f3\u8f93\u5165\u6574\u6570\u3001\u6d6e\u70b9\u6570\uff0c\u9700\u8981\u7528\u4e0a\u6587\u63d0\u5230\u7684\u7c7b\u578b\u8f6c\u6362\u51fd\u6570\uff0c\u4ee5\u6574\u6570\u4e3a\u4f8b 1 a = int ( input ()) \u5f53\u7136\u8fd9\u6837\u6bcf\u6b21\u6bcf\u884c\u53ea\u80fd\u8f93\u5165\u4e00\u4e2a\u6570\u3002\u5982\u679c\u4f60\u5e0c\u671b\u6bcf\u884c\u8f93\u5165\u82e5\u5e72\u4e2a\u4ee5\u7a7a\u683c\u5206\u9694\u7684\u6570\uff08\u4f8b\u5982\u4e09\u4e2a\uff09\uff0c\u53ef\u4ee5\u8fd9\u4e48\u5199\uff1a 1 a , b , c = map ( int , input () . split ()) input().split()\u5c06\u4f1a\u628a\u8bfb\u5165\u7684\u5b57\u7b26\u4e32\u6309\u7167\u7a7a\u683c\u5206\u9694\u6210\u82e5\u5e72\u5b57\u7b26\u4e32\uff0c\u6700\u540e\u6309\u987a\u5e8f\u585e\u8fdb\u4e00\u4e2a\u5217\u8868\u4e2d\u5e76\u8fd4\u56de\u6539\u5217\u8868\u3002map\u53ef\u4ee5\u4ee5\u4e00\u4e2a\u51fd\u6570\u4f5c\u4e3a\u53c2\u6570(\u7b2c\u4e00\u4e2a\u53c2\u6570)\uff0c\u5c06\u4e00\u4e2a\u5217\u8868\uff08\u7b2c\u4e8c\u4e2a\u53c2\u6570\uff09\u4e2d\u7684\u6bcf\u4e2a\u5143\u7d20\u8f93\u5165\u5230\u8fd9\u4e2a\u51fd\u6570\u4e2d\uff0c\u8fd4\u56de\u6620\u5c04\u540e\u7684\u7ed3\u679c\uff0c\u6700\u540e\u518d\u901a\u8fc7\u89e3\u5305\u8bed\u6cd5\u9010\u4e2a\u8d4b\u503c\u5230a\u3001b\u3001c\u4e09\u4e2a\u53d8\u91cf\u4e2d\u3002\u5173\u4e8e\u6d89\u53ca\u5230\u7684\u5217\u8868\u3001\u5b57\u7b26\u4e32\u65b9\u6cd5\u7b49\u4e4b\u540e\u4f1a\u8be6\u7ec6\u8bf4\u660e\u3002 \u5982\u679c\u4f60\u60f3\u8bfb\u5165\u6570\u91cf\u4e0d\u5b9a\u7684\u6574\u6570\u5e8f\u5217\uff08\u5e76\u5f97\u5230\u4e00\u4e2a\u5217\u8868\uff09\uff0c\u6709\u4e24\u79cd\u5199\u6cd5\uff1a 1 2 L1 = list ( map ( int , input () . split ())) L2 = [ int ( x ) for x in input () . split ()] \u7b2c\u4e00\u79cd\u505a\u6cd5\u662f\u901a\u8fc7\u5c06map\u5bf9\u8c61\u901a\u8fc7list\u7c7b\u578b\u8f6c\u6362\u51fd\u6570\u8f6c\u6362\u6210\u5217\u8868\u540e\u5b9e\u73b0\u7684\uff08\u6ce8\u610fmap\u8fd9\u4e2a\u51fd\u6570\u8fd4\u56de\u7684\u4e0d\u76f4\u63a5\u662f\u4e00\u4e2a\u5217\u8868\uff0c\u800c\u662f\u4e00\u4e2amap\u5bf9\u8c61\uff09\u3002\u7b2c\u4e8c\u79cd\u505a\u6cd5\u7528\u5230\u4e86\u5217\u8868\u751f\u6210\u5f0f\u7684\u7279\u6027\uff0c\u4e4b\u540e\u4f1a\u8be6\u7ec6\u8bf4\u660e\u3002","title":"input"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_23","text":"","title":"\u6742\u9879"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#pass","text":"\u4f7f\u7528pass\u53ef\u4ee5\u5728\u672c\u5e94\u8f93\u5165\u4ee3\u7801\u7684\u5730\u65b9\u5360\u4f4d\uff0c\u5176\u6ca1\u6709\u5b9e\u9645\u610f\u4e49\u3002\u4f8b\u5982\u4f60\u53ef\u4ee5\u8fd9\u4e48\u5b9a\u4e49\u201c\u7a7a\u51fd\u6570\u201d\uff1a 1 2 def Func (): pass","title":"pass"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_24","text":"\u4f7f\u7528\u5206\u53f7\u53ef\u4ee5\u201c\u538b\u884c\u201d\u2014\u2014\u5c06\u672c\u6765\u9700\u8981\u5199\u6210\u591a\u884c\u7684\u4ee3\u7801\u5199\u5728\u4e00\u884c 1 a = 1 ; b = 2 ; c = 3 ;","title":"\u5206\u53f7"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_25","text":"\u4f7f\u7528\u53cd\u659c\u6760\u53ef\u4ee5\u5c06\u4e00\u884c\u62c6\u6210\u82e5\u5e72\u884c\uff0c\u4f46\u8981\u6ce8\u610f\u53cd\u659c\u6760\u540e\u9762\u4e0d\u80fd\u6709\u522b\u7684\u4e1c\u897f\u3002 1 2 print ( input () . split ( \\ ))","title":"\u53cd\u659c\u6760\u7eed\u884c\u7b26"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_26","text":"","title":"\u5e38\u7528\u6570\u636e\u7ed3\u6784\u7b80\u4ecb"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_27","text":"\u4e0d\u53ef\u53d8\u5bf9\u8c61 \uff1a\u5bf9\u8c61\u4e00\u65e6\u521b\u5efa\uff0c\u5bf9\u8c61\u4e2d\u5185\u5bb9\u5c31\u4e0d\u53ef\u518d\u6539\u53d8\uff0c\u53ea\u80fd\u7528\u8fd9\u4e2a\u5bf9\u8c61\u53bb\u521b\u5efa\u53e6\u4e00\u4e2a\u65b0\u7684\u5bf9\u8c61\u3002\u5982\u6574\u6570\u3001\u5b57\u7b26\u4e32\u7b49\u3002 \u53ef\u53d8\u5bf9\u8c61 \uff1a\u5bf9\u8c61\u4e2d\u7684\u5185\u5bb9\u5728\u521b\u5efa\u540e\u4ecd\u7136\u662f\u53ef\u53d8\u7684\u3002\u5982\u5217\u8868\u3001\u5b57\u5178\u3001\u96c6\u5408\u3002 \u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u6574\u6570\u7684\u8fd0\u7b97\u5176\u5b9e\u662f\u5728\u7b97\u5b8c\u4e4b\u540e\u65b0\u5efa\u4e86\u4e00\u4e2a\u6574\u6570\u5bf9\u8c61\uff0c\u800c\u4e0d\u662f\u5728\u539f\u6709\u5bf9\u8c61\u57fa\u7840\u4e0a\u4fee\u6539\u503c\u3002\u5b57\u7b26\u4e32\u7b49\u4e5f\u540c\u7406\uff0c\u5b57\u7b26\u4e32\u7684\u62fc\u63a5\u7b49\u64cd\u4f5c\u5b9e\u9645\u4e0a\u662f\u65b0\u751f\u6210\u4e86\u53e6\u4e00\u4e2a\u5b57\u7b26\u4e32\u5bf9\u8c61\u3002\u800c\u5bf9\u4e8e\u53ef\u53d8\u5bf9\u8c61\u800c\u8a00\u5c31\u672a\u5fc5\u4e86\uff0c\u53ef\u80fd\u6709\u4e9b\u65b9\u6cd5\u662f\u6539\u53d8\u539f\u6765\u5bf9\u8c61\u7684\uff0c\u53ef\u80fd\u6709\u4e9b\u662f\u8fd4\u56de\u65b0\u5bf9\u8c61\u7684\u3002 \u8981\u60f3\u770b\u4e24\u4e2a\u53d8\u91cf\u6240\u6307\u5411\u7684\u5bf9\u8c61\u662f\u4e0d\u662f \u540c\u4e00\u4e2a \u5bf9\u8c61\uff0c\u53ef\u4ee5\u4f7f\u7528id\u51fd\u6570\u67e5\u770b\u5bf9\u8c61\u7684\u5730\u5740\u3002\u53ea\u6709\u5730\u5740\u5b8c\u5168\u76f8\u540c\uff0c\u4e24\u4e2a\u5bf9\u8c61\u624d\u76f8\u540c\uff0c\u8fd9\u70b9\u5df2\u5728\u4e4b\u524d\u5bf9is\u7684\u8bf4\u660e\u4e2d\u63d0\u5230\u3002","title":"\u53ef\u53d8\u5bf9\u8c61\u3001\u4e0d\u53ef\u53d8\u5bf9\u8c61"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_28","text":"\u5217\u8868\u7c7b\u4f3c\u4e8eC\u4e2d\u7684vector\uff0c\u4e0d\u8fc7\u5b9e\u9645\u4e0a\u5b83\u66f4\u63a5\u8fd1\u5e7f\u4e49\u8868\u3002 \u5217\u8868\u662f \u53ef\u53d8 \u7684\uff1a\u8868\u53ef\u4ee5\u81ea\u7531\u5730\u589e\u52a0\u3001\u5220\u9664\u5143\u7d20\uff0c\u4e5f\u53ef\u4ee5\u6539\u53d8\u5217\u8868\u4e2d\u67d0\u4e2a\u7279\u5b9a\u4f4d\u7f6e\u5143\u7d20\u7684\u503c\uff0c\u957f\u5ea6\u4e0d\u5b9a\u3002 \u8868\u4e2d\u5143\u7d20\u53ef\u4ee5\u662f\u4efb\u4f55\u5bf9\u8c61\uff08\u6bd4\u5982\u6574\u6570\u3001\u6d6e\u70b9\u6570\u3001\u53e6\u4e00\u4e2a\u5217\u8868\u7b49\u7b49\uff09\uff0c\u8868\u4e2d\u5143\u7d20\u751a\u81f3\u53ef\u4ee5\u662f\u81ea\u5df1\u3002","title":"\u5217\u8868"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_29","text":"1 2 3 a = [] #\u7a7a\u5217\u8868 b = [ 1 , 2 , 3 ,[ 4 , 5 , 6 ]] #\u6709\u521d\u59cb\u503c\u7684\u5217\u8868\uff0c\u6700\u540e\u4e00\u4e2a\u5143\u7d20\u662f\u53e6\u4e00\u4e2a\u5217\u8868\uff0c\u56e0\u6b64\u8fd9\u4e2a\u5217\u8868\u662f\u5d4c\u5957\u7684 c = list ( \"abc\" ) #\u4f7f\u7528\u5176\u4ed6\u53ef\u8fed\u4ee3\u5bf9\u8c61\u6784\u9020\u65b0\u5217\u8868 list\u51fd\u6570\u662f\u6784\u9020\u4e00\u4e2a\u65b0\u5217\u8868\u7528\u7684\u51fd\u6570\u3002\u5982\u679c\u4e0d\u4f20\u5165\u53c2\u6570\u90a3\u4e48\u5c06\u4f1a\u8fd4\u56de\u7a7a\u5217\u8868\uff08\u56e0\u6b64 a=list() \u548c a=[] \u6548\u679c\u4e00\u6837\uff09\uff0c\u5982\u679c\u4f20\u5165\u4e86\u53e6\u4e00\u4e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\uff08\u4e4b\u540e\u4f1a\u63d0\u5230\uff09\uff0c\u90a3\u4e48\u5b83\u4f1a\u4ee5\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e2d\u7684\u6bcf\u4e00\u4e2a\u5143\u7d20\u4f5c\u4e3a\u5217\u8868\u4e2d\u7684\u5143\u7d20\u3002 \u5173\u4e8e\u5217\u8868\u7684\u8be6\u7ec6\u65b9\u6cd5\u53c2\u89c1\u4e4b\u540e\u7684\u201c\u5e38\u7528\u6570\u636e\u7ed3\u6784\u65b9\u6cd5\u4e0e\u76f8\u5173\u5e38\u7528\u51fd\u6570\u201d\u3002","title":"\u65b0\u5efa\u5217\u8868"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_30","text":"\u4e0e\u5217\u8868\u7c7b\u4f3c\uff0c\u4f46\u662f\uff0c\u5b83\u7684\u5143\u7d20\u5728\u521d\u59cb\u5316\u5b8c\u6210\u4e4b\u540e\u5c31\u4e0d\u518d\u53ef\u6539\u53d8\u3002 \u5143\u7ec4\u662f \u4e0d\u53ef\u53d8\u7684 \uff1a\u4e0d\u80fd\u5220\u9664\u6216\u8005\u6dfb\u52a0\u5143\u7d20\u3002 \u8868\u4e2d\u5143\u7d20\u53ef\u4ee5\u662f\u4efb\u4f55\u5bf9\u8c61\u3002","title":"\u5143\u7ec4"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_31","text":"1 2 3 4 a = () #\u7a7a\u5143\u7ec4 b = ( 4 , 2 , 3 ,[ 5 , 7 ],( 6 , 1 )) #\u5e26\u6709\u82e5\u5e72\u521d\u59cb\u5143\u7d20\u7684\u5143\u7ec4 c = 4 , 2 , 3 , #\u5728\u6ca1\u6709\u6b67\u4e49\u7684\u60c5\u51b5\u4e0b\uff0c\u7b49\u53f7\u53f3\u503c\u7701\u7565\u62ec\u53f7\u4e5f\u76f8\u5f53\u4e8e\u5143\u7ec4 d = tuple ([ 1 , 2 , 3 ]) #d==(1,2,3) tuple\u540c\u6837\u662f\u7528\u4e8e\u6784\u9020\u4e00\u4e2a\u65b0\u5143\u7ec4\u7528\u7684\u51fd\u6570\u3002","title":"\u65b0\u5efa\u5143\u7ec4"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_32","text":"\u9700\u8981\u6307\u51fa\u7684\u662f\uff0c\u201c\u5143\u7ec4\u662f\u4e0d\u53ef\u53d8\u7684\u201d\u6307\u7684\u662f\u5143\u7ec4\u4e2d\u6240\u5305\u542b\u7684\u201c\u5185\u5bb9\u201d\u4e0d\u80fd\u518d\u66f4\u6539\u4e86\u3002\u4f46\u201c\u5185\u5bb9\u201d\u6307\u7684\u7a76\u7adf\u662f\u4ec0\u4e48\u5462\uff1f \u4e4b\u524d\u7684\u6587\u7ae0\u63d0\u5230\u4e86\u5728python\u4e2d\u53d8\u91cf\u7684\u672c\u8d28\u5b9e\u9645\u4e0a\u662f\u6307\u5411\u5bf9\u8c61\u7684\u201d\u6307\u9488\u201c\uff0c\u56e0\u6b64\uff0c\u5982\u679c\u4f60\u662f\u901a\u8fc7\u8fd9\u4e2a\u6307\u9488\u53bb\u6539\u53d8\u4e86\u4e00\u4e2a\u53ef\u53d8\u5bf9\u8c61\uff0c\u90a3\u4e48\u6240\u6709\u6307\u5411\u8fd9\u4e2a\u5bf9\u8c61\u7684\u6307\u9488\uff08\u4e5f\u5373\u53d8\u91cf\uff09\u6240\u6307\u5411\u7684\u5185\u5bb9\u81ea\u7136\u4e5f\u4f1a\u53d1\u751f\u6539\u53d8\u3002\u4f8b\u5982\uff1a 1 2 3 a = b = [ 1 , 2 , 3 ] a . append ( 4 ) #\u5728\u5217\u8868\u672b\u5c3e\u63d2\u5165\u65b0\u5143\u7d20 print ( a , b ) #[1, 2, 3, 4] [1, 2, 3, 4] \u53ef\u4ee5\u770b\u5230\uff0c\u7531\u4e8ea\u548cb\u6307\u5411\u7684\u662f\u540c\u4e00\u4e2a\u5bf9\u8c61\uff0c\u56e0\u6b64\u5bf9\u8fd9\u4e2a\u5bf9\u8c61\u7684\u64cd\u4f5c\u4f1a\u5f71\u54cd\u5230\u6240\u6709\u6307\u5411\u8fd9\u4e2a\u5bf9\u8c61\u7684\u53d8\u91cf\u3002 \u518d\u770b\u4e00\u4e2a\u5d4c\u5957\u5217\u8868\u7684\u4f8b\u5b50\uff0c\u8fd9\u4e2a\u5217\u8868\u6700\u540e\u4e00\u4e2a\u5143\u7d20\u662f\u53e6\u4e00\u4e2a\u5217\u8868\uff0c\u6211\u4eec\u8bd5\u56fe\u5bf9\u6700\u540e\u8fd9\u4e2a\u5217\u8868\u63d2\u5165\u5143\u7d20\uff1a 1 2 3 4 b = [ 1 , 2 , 3 ,[ 4 , 5 , 6 ]] a = b [ 3 ] #\u53d6\u5f97\u6307\u5411[4,5,6]\u7684\u53d8\u91cf\uff08\u6307\u9488\uff09 a . append ( 4 ) print ( b ) #[1,2,3,[4,5,6,4]] \u7701\u7565\u6389a\u53d8\u91cf\u4f9d\u7136\u80fd\u591f\u6210\u529f\uff1a 1 2 3 b = [ 1 , 2 , 3 ,[ 4 , 5 , 6 ]] b [ 3 ] . append ( 4 ) print ( b ) #[1,2,3,[4,5,6,4]] \u53ef\u4ee5\u770b\u5230b\u4e2d\u663e\u793a\u7684\u5185\u5bb9\u4e5f\u53d1\u751f\u4e86\u6539\u53d8\u3002\u8fd9\u8bf4\u660e\u4e86\u4e00\u4e2a\u95ee\u9898\uff1a \u5217\u8868\u4e2d\u7684\u53e6\u4e00\u4e2a\u5217\u8868 \uff0c\u5b9e\u9645\u4e0a\u5b58\u7684\u4e5f\u662f\u6307\u5411\u8fd9\u4e2a \u53e6\u4e00\u4e2a\u5217\u8868\u7684\u6307\u9488 \uff0c\u6216\u8005\u8bf4\u662f\u4e00\u79cd \u5f15\u7528 \uff0c\u771f\u6b63\u7684\u8fd9\u4e2a\u53e6\u4e00\u4e2a\u5217\u8868\u5176\u5b9e\u5728\u53e6\u4e00\u4e2a\u5730\u65b9\u5b58\u7740\u3002\u53ea\u662f\u5728\u8fd9\u91cc\u5e76\u6ca1\u6709\u4e00\u4e2a\u660e\u663e\u7684\u53d8\u91cf\u8868\u660e\u5b83\u662f\u4e00\u4e2a\u201d\u5f15\u7528\u201c\u3002 \u5982\u679c\u628a\u4e0a\u4f8b\u4e2d\u7684b\u6539\u6210\u5143\u7ec4\u800c\u522b\u7684\u4e0d\u53d8\uff0c\u90a3\u4e48\u53bb\u6539\u53d8\u5217\u8868\u5c31\u4f1a\u5bfc\u81f4b\u6307\u5411\u7684\u5143\u7ec4\u201c\u770b\u4e0a\u53bb\u53d8\u4e86\u201d\uff0c\u4f46\u5b9e\u9645\u4e0a\u5143\u7ec4\u4e2d\u5b58\u7684\u662f\u6307\u5411\u5404\u4e2a\u5bf9\u8c61\u7684\u6307\u9488\uff0c\u5143\u7ec4\u786e\u5b9e\u6ca1\u6709\u6539\u53d8\u3002 1 2 3 b = ( 1 , 2 , 3 ,[ 4 , 5 , 6 ]) b [ 3 ] . append ( 4 ) print ( b ) #(1,2,3,[4,5,6,4])","title":"\u5217\u8868\u548c\u5143\u7ec4\u4e2d\u7684\u5143\u7d20\u95ee\u9898"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_33","text":"\u7c7b\u4f3c\u6570\u5b66\u4e0a\u7684\u96c6\u5408\uff0c\u4e00\u4e2a\u96c6\u5408\u4e2d\u7684\u5143\u7d20\u662f\u552f\u4e00\u7684\u3002\u63d2\u5165\u96c6\u5408\u4e2d\u5df2\u6709\u7684\u5143\u7d20\u540e\uff0c\u96c6\u5408\u4f1a\u81ea\u52a8\u5408\u5e76\u91cd\u590d\u7684\u5143\u7d20\u3002 \u96c6\u5408\u662f \u53ef\u53d8\u7684 \u3002 Python\u4e2d\u7684\u96c6\u5408\u5e95\u5c42\u662f\u7528\u54c8\u5e0c\u5b9e\u73b0\u7684\uff0c\u56e0\u6b64\u63d2\u5165\u6216\u521d\u59cb\u5316\u96c6\u5408\u7684\u5bf9\u8c61\u5fc5\u987b\u8981\u662f \u53ef\u54c8\u5e0c\u7684 \uff08hashable\uff09\u3002\u6570\u3001\u5b57\u7b26\u4e32\u3001\u4e0d\u5305\u542b\u53ef\u53d8\u5bf9\u8c61\u7684\u5143\u7ec4\u90fd\u662f\u53ef\u54c8\u5e0c\u7684\uff0c\u4f46\u53ef\u53d8\u5bf9\u8c61\uff08\u5982\u5217\u8868\uff09\u5c31\u4e0d\u662f\u3002","title":"\u96c6\u5408"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_34","text":"1 2 s = set () s = set ([ 1 , 2 , 5 , 8 , 0 ]) #\u6709\u521d\u503c\u7684\u521d\u59cb\u5316\uff1a{0,1,2,5,8} \u867d\u7136\u96c6\u5408\u5f62\u5982{}\uff0c\u4f46\u662f\u4e0d\u80fd\u7528{}\u65b0\u5efa\u4e00\u4e2a\u7a7a\u96c6\u5408\uff0c\u56e0\u4e3a\u8fd9\u4e48\u5199\u5176\u5b9e\u662f\u5728\u65b0\u5efa\u4e00\u4e2a\u7a7a\u5b57\u5178\u3002","title":"\u65b0\u5efa\u96c6\u5408"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_35","text":"\u5982\u679c\u4f60\u63a5\u89e6\u8fc7json\u6216\u8005C++\u7684map\u7684\u8bdd\u4f60\u5e94\u8be5\u5bf9\u5b57\u5178\u5f88\u719f\u6089\u3002\u5b57\u5178\u4fdd\u5b58\u4e86\u4e00\u7cfb\u5217\u952e\u503c\u5bf9\u7684\u96c6\u5408\uff0c\u5e76\u53ef\u628a\u952e\u7528\u7c7b\u4f3c\u4e8e\u7d22\u5f15\u7684\u65b9\u5f0f\u53d6\u5f97\u503c\u3002 \u5b57\u5178\u662f \u53ef\u53d8\u7684 \u3002 \u952e \u5fc5\u987b\u8981\u662f \u53ef\u54c8\u5e0c\u7684 \uff0c\u548c\u96c6\u5408\u7c7b\u4f3c\u3002\u5b57\u5178\u5e95\u5c42\u4e5f\u662f\u7528\u54c8\u5e0c\u8868\u5b9e\u73b0\u7684\u3002","title":"\u5b57\u5178"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_36","text":"1 2 3 4 5 s = {} #\u7a7a\u5b57\u5178 s = dict () #\u7a7a\u5b57\u5178 s = { 1 : 2 , \"3\" : 4 ,( 5 ):[ 6 , 7 , 8 ]} #\u5e26\u6709\u6574\u6570\u3001\u5b57\u7b26\u4e32\u548c\u5143\u7ec4\u4f5c\u4e3a\u952e\u7684\u5b57\u5178 s [ 1 ] s [ \"3\" ] #\u6309\u7167\u7d22\u5f15\u53d6\u5f97\u503c","title":"\u65b0\u5efa\u5b57\u5178"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_37","text":"\u5b57\u7b26\u4e32\u4e4b\u524d\u5df2\u7ecf\u63d0\u5230\u8fc7\uff0c\u8fd9\u91cc \u5b57\u7b26\u4e32\u662f \u4e0d\u53ef\u53d8\u7684","title":"\u5b57\u7b26\u4e32"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_38","text":"Prefix r R \u539f\u751f\u5b57\u7b26\u4e32\uff0c\u4e0d\u4f1a\u8f6c\u4e49 f F \u683c\u5f0f\u5b57\u7b26\u4e32\uff08\u53c2\u89c1\u683c\u5f0f\u5316\u5b57\u7b26\u4e32\u4e00\u8282\uff09 u U \u9ed8\u8ba4\u7684\u524d\u7f00\uff0c\u8868\u793a\u4ee5Unicode\u65b9\u5f0f\u4fdd\u5b58\u5b57\u7b26\u4e32 b B \u751f\u6210bytes\u7c7b\u578b\uff0c\u5176\u4e2d\u53ea\u5141\u8bb8\u4f7f\u7528ascii\u5b57\u7b26\uff0c\u8d85\u51fa127\u7684\u5b57\u7b26\u9700\u8981\u8f6c\u4e49\u3002\u5e8f\u5217\u4e2d\u7684\u6bcf\u4e2a\u503c\u7684\u5927\u5c0f\u88ab\u9650\u5236\u4e3a 0 <= x < 256 (\u5982\u679c\u8fdd\u53cd\u6b64\u9650\u5236\u5c06\u5f15\u53d1 ValueError )","title":"\u524d\u7f00"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#iterableiterator","text":"\u53ef\u8fed\u4ee3\u5bf9\u8c61 \uff1a\u53ef\u88abfor\u5faa\u73af\uff08\u4e4b\u540e\u4f1a\u63d0\u5230\uff09\u8fed\u4ee3\u7684\u5bf9\u8c61\u7edf\u79f0\u4e3a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u3002\u5217\u8868\u3001\u5b57\u5178\u3001\u5143\u7ec4\u3001\u96c6\u5408\u3001\u5b57\u7b26\u4e32\u7b49\u90fd\u662f\u53ef\u8fed\u4ee3\u5bf9\u8c61\u3002 \u8fed\u4ee3\u5668 \uff1a","title":"\u53ef\u8fed\u4ee3\u5bf9\u8c61(Iterable)\u3001\u8fed\u4ee3\u5668\uff08Iterator\uff09"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_39","text":"","title":"\u6d45\u62f7\u8d1d\u3001\u6df1\u62f7\u8d1d"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_40","text":"","title":"\u5e38\u7528\u6570\u636e\u7ed3\u6784\u65b9\u6cd5\u4e0e\u76f8\u5173\u5e38\u7528\u51fd\u6570"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_41","text":"\u5e8f\u5217\u7c7b\u578b \uff1a\u5217\u8868\u3001\u5143\u7ec4\u3001range\u3001\u5b57\u7b26\u4e32\u7b49","title":"\u5171\u901a\u64cd\u4f5c\u4e0e\u65b9\u6cd5"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_42","text":"\u51e0\u4e4e\u6240\u6709\u5bf9\u8c61\u90fd\u80fd\u7528\uff0c\u5305\u62ec\u5217\u8868\u548c\u5143\u7ec4\u3001\u5b57\u5178\u3001\u96c6\u5408\u3001\u5b57\u7b26\u4e32\u7b49 \u8fd0\u7b97\u3001\u51fd\u6570\u6216\u65b9\u6cd5 \u7b26\u53f7 \u7279\u6b8a\u8bf4\u660e \u793a\u4f8b \u6210\u5458\u68c0\u6d4b\u8fd0\u7b97 a in b \u6216 a not in b \u89c1\u4e0a\u6587\u57fa\u672c\u8fd0\u7b97\u4e00\u8282\uff1b\u7279\u522b\u5730\uff0c\u5bf9\u5b57\u5178\u6765\u8bf4a\u662fb\u7684\u952e\u65f6\u8fd4\u56deTrue \u53d6\u5f97\u957f\u5ea6 len(a) \u53d6\u5f97a\u5bf9\u8c61\u7684\u957f\u5ea6\uff08\u5143\u7d20\u4e2a\u6570\uff09 \u6700\u5c0f\u503c min(a) a\u4e2d\u5143\u7d20\u6700\u5c0f\u503c \u6700\u5927\u503c max(a) a\u4e2d\u5143\u7d20\u6700\u5927\u503c","title":"\u901a\u7528\u64cd\u4f5c"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_43","text":"\u9664\u975e\u6709\u7279\u6b8a\u8bf4\u660e\uff0c\u4e0b\u9762\u7684\u64cd\u4f5c\u53ef\u7528\u4e8e\u5143\u7ec4\u3001\u5217\u8868\u3001\u5b57\u7b26\u4e32\u3002 \u8fd0\u7b97\u3001\u51fd\u6570\u6216\u65b9\u6cd5 \u7b26\u53f7 \u7279\u6b8a\u8bf4\u660e \u793a\u4f8b \u4e32\u63a5 a+b \u9996\u5c3e\u76f8\u63a5\uff0c\u8fd4\u56de\u65b0\u5bf9\u8c61 [1,2]+[3,4] =[1,2,3,4] \u91cd\u590d s*n (n\u662f\u6574\u6570) \u91cd\u590dn\u6b21\u81ea\u5df1\u5bf9\u81ea\u5df1\u7684\u4e32\u63a5\uff0c\u8fd4\u56de\u65b0\u5bf9\u8c61\uff1b\u91cd\u590d\u7684\u5143\u7d20\u5c06\u4f1a\u5f15\u7528\u88ab\u590d\u5236\u7684\u5bf9\u8c61 \"ab\"*3=\"ababab\" \u7d22\u5f15 s[i] \u53d6s\u4e2d\u7b2ci\u4e2a\uff08\u81ea0\u5f00\u59cb\u8ba1\u6570\uff09\u5143\u7d20\uff0c\u53ef\u4ee5\u4e3a\u8d1f\u6570\uff08\u76f8\u5f53\u4e8e\u4e0b\u6807\u53d8\u4e3an-i\uff09\uff1b\u8d8a\u754c\u8bbf\u95ee\u4f1a\u629b\u51faIndexError\u5f02\u5e38 \"ab\"[1] =\"b\" \u5207\u7247 s[i:j] \u53d6s\u4e2d\u7b2ci\u5230j\u4e2a\uff08\u4e0d\u5305\u62ec\u7b2cj\u4e2a\uff09\u5143\u7d20\uff0c\u6b65\u957f\u4e3a1\uff1b\u8d85\u51fa\u8303\u56f4\u7684i\u3001j\u4f1a\u88ab\u81ea\u52a8\u89c4\u7ea6\u52300\u6216len(s)\uff1b\u82e5i\u3001j\u7f3a\u7701\u4f1a\u81ea\u52a8\u8bbe\u5b9a\u62100\u548clen(s) \u201cabcd\u201d[2:4]=\"cd\" s[i:j:k] \u7531\u6ee1\u8db3x=i+nk\u7684\u6240\u6709s[x]\u7ec4\u6210\u7684\u5e8f\u5217\uff0c\u5176\u4e2dn\u662f\u6240\u6709\u6ee1\u8db30<=n<(j-i)/k\u7684\u6574\u6570\uff1b\u8d85\u51fa\u8303\u56f4\u7684i\u3001j\u4f1a\u88ab\u81ea\u52a8\u89c4\u7ea6\uff1b\u7f3a\u7701\u7684i\u3001j\u4f1a\u88ab\u81ea\u52a8\u8bbe\u5b9a\u6210\u5f00\u59cb\u6216\u7ed3\u675f\u4f4d\u7f6e\uff08\u53d6\u51b3\u4e8ek\u7684\u6b63\u8d1f\uff09 \"abcd\"[1:4:2]=\"bd\" \"abcd\"[::-1]=\"dcba\" \u67e5\u627e\u7d22\u5f15 a.index(x) \u5728a\u4e2d\u627e\u5230\u7b2c\u4e00\u6b21\u51fa\u73b0x\u7684\u4e0b\u6807\uff1b\u627e\u4e0d\u5230\u4f1a\u629b\u51faValueError\u5f02\u5e38 [2,3,5,4].index(3) =1 a.index(x,i,j) \u7b49\u4ef7\u4e8e\u5728a[i:j]\u4e2d\u627e\u7b2c\u4e00\u6b21\u51fa\u73b0x\u7684\u5bf9\u5e94\u7684a\u7684\u4e0b\u6807 [2,3,5,4].index(3,1,2) =1 \u8ba1\u6570 a.count(x) \u8fd4\u56dex\u5728a\u4e2d\u51fa\u73b0\u6b21\u6570 [1,1,2,3,5].count(1)=2 \u91cd\u590d\u3001\u5207\u7247\u7b49\u64cd\u4f5c\u662f\u6d45\u62f7\u8d1d","title":"\u5e8f\u5217\u901a\u7528\u64cd\u4f5c"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_44","text":"\u5c31\u76ee\u524d\u800c\u8a00\uff0c\u4e3b\u8981\u662f\u5217\u8868\u4f1a\u7528\u5230\u8fd9\u4e9b\u72ec\u6709\u7684\u64cd\u4f5c\u3002\u5176\u4e2d\u6709\u4e9b\u64cd\u4f5c\u5176\u4ed6\u53ef\u53d8\u7c7b\u578b\uff08\u4f46\u4e0d\u662f\u53ef\u53d8\u5e8f\u5217\u7c7b\u578b\uff09\u4e5f\u53ef\u4f7f\u7528\u3002 \u8fd0\u7b97\u3001\u51fd\u6570\u6216\u65b9\u6cd5 \u7b26\u53f7 \u7279\u6b8a\u8bf4\u660e \u793a\u4f8b \u8d4b\u503c a[i]=x a[i:j]=x a[i:j:k]=x \u5220\u9664 del a[i] del a[i:j] del a[i:j:k] del\u64cd\u4f5c\u8fd8\u53ef\u4ee5\u7528\u5728\u5355\u72ec\u7684\u5bf9\u8c61\u4e0a\uff1b \u5b57\u5178\u53ef\u7528\u5de6\u683c\u5f53\u4e2d\u7684\u7b2c\u4e00\u4e2a\u64cd\u4f5c \u5c3e\u90e8\u63d2\u5165 a.append(x) \u5728\u672b\u5c3e\u63d2\u5165\u65b0\u5143\u7d20 \u6e05\u7a7a a.clear() \u5b57\u5178\u3001\u96c6\u5408\u4e5f\u53ef\u7528 \u6d45\u62f7\u8d1d a.copy() \u5c31\u7ed3\u679c\u7b49\u4e8ea[:]\uff1b \u5b57\u5178\u3001\u96c6\u5408\u4e5f\u53ef\u7528 \u6269\u5c55 a.extend(b) \u76f8\u5f53\u4e8e\u7528\u53ef\u8fed\u4ee3\u5bf9\u8c61b\u8f6c\u6362\u6210\u5bf9\u5e94\u5e8f\u5217\u540e\u518d\u4e32\u63a5\uff1b\u5c31\u7ed3\u679c\u7b49\u4e8ea+=b [1,2].extend((3,4))=[1,2,3,4] \u4e00\u822c\u63d2\u5165 a.insert(i,x) \u5728\u4e0b\u6807i\u4e4b\u540e\u63d2\u5165x\uff0c\u4e4b\u540e\u7684\u5143\u7d20\u90fd\u5411\u540e\u79fb\u52a8\u4e00\u4f4d \u5f39\u51fa a.pop([i]) \u5220\u6389\u7b2ci\u4e2a\u5143\u7d20\uff1b\u5982\u679c\u7701\u7565i\u5219\u9ed8\u8ba4\u5220\u6389\u6700\u540e\u4e00\u4e2a\u5143\u7d20 \u79fb\u9664 a.remove(x) \u5220\u6389\u7b2c\u4e00\u4e2a\u7b49\u4e8ex\u7684\u5143\u7d20 \u53cd\u8f6c a.reverse()","title":"\u53ef\u53d8\u5e8f\u5217\u901a\u7528\u64cd\u4f5c"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_45","text":"\u8fd0\u7b97\u3001\u51fd\u6570\u6216\u65b9\u6cd5 \u7b26\u53f7 \u7279\u6b8a\u8bf4\u660e \u793a\u4f8b \u901a\u7528\u64cd\u4f5c \uff08\u89c1\u4e0a\u6587\uff09 \u5e8f\u5217\u901a\u7528\u64cd\u4f5c \u53ef\u53d8\u5e8f\u5217\u901a\u7528\u64cd\u4f5c \u6784\u9020 list([iterable]) \u53ef\u4f20\u5165\u53ef\u8fed\u4ee3\u5bf9\u8c61\u6784\u9020\u5217\u8868 \u6392\u5e8f a.sort([key=None, reverse=False]) \u9ed8\u8ba4\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\uff1b\u5c06\u5173\u952e\u5b57\u53c2\u6570reverse\u8d4b\u503c\u4e3aTrue\u53ef\u4ece\u5927\u5230\u5c0f\u6392\u5e8f\uff1bkey\u4f20\u5165\u4e00\u4e2a\u51fd\u6570\u5219\u53ef\u81ea\u5b9a\u4e49\u6bd4\u8f83\u89c4\u5219 \u5217\u8868\u751f\u6210\u5f0f\u7279\u6027\u89c1\u4e0b\u6587\u3002","title":"\u5217\u8868"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_46","text":"\u8fd0\u7b97\u3001\u51fd\u6570\u6216\u65b9\u6cd5 \u7b26\u53f7 \u7279\u6b8a\u8bf4\u660e \u793a\u4f8b \u901a\u7528\u64cd\u4f5c \uff08\u89c1\u4e0a\u6587\uff09 \u5e8f\u5217\u901a\u7528\u64cd\u4f5c \u6784\u9020 tuple([iterable]) \u53ef\u4f20\u5165\u53ef\u8fed\u4ee3\u5bf9\u8c61\u6784\u9020\u5143\u7ec4","title":"\u5143\u7ec4"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_47","text":"\u96c6\u5408\u5141\u8bb8\u4e00\u4e9b\u7b80\u5355\u7684\u96c6\u5408\u8fd0\u7b97\u3002 \u8fd0\u7b97\u3001\u51fd\u6570\u6216\u65b9\u6cd5 \u7b26\u53f7 \u7279\u6b8a\u8bf4\u660e \u793a\u4f8b \u901a\u7528\u64cd\u4f5c \uff08\u89c1\u4e0a\u6587\uff09 \u6784\u9020 set([iterable]) \u53ef\u4f20\u5165\u53ef\u8fed\u4ee3\u5bf9\u8c61\u6784\u9020\u96c6\u5408\uff0c\u4f46\u5176\u4e2d\u7684\u5143\u7d20\u5fc5\u987b\u662f\u53ef\u54c8\u5e0c\u7684 \u6d45\u62f7\u8d1d s1.copy() \u6dfb\u52a0\u5143\u7d20 s1.add(x) \u5220\u9664\u5143\u7d20 s1.remove(x) \u4e0d\u5b58\u5728\u5219\u629b\u51faKeyError \u79fb\u9664\u5143\u7d20 s1.discard(x) \u4e0d\u5b58\u5728\u5219\u4ec0\u4e48\u4e5f\u4e0d\u505a \u5f39\u51fa\u5143\u7d20 s1.pop() \u5f39\u51fa\"\u7b2c\u4e00\u4e2a\u5143\u7d20\"\uff1b\u7a7a\u96c6\u5408\u4f1a\u629b\u51faKeyError \u6e05\u7a7a s1.clear() \u4ea4\u96c6 s1 & s2 \u6216\u8005 s1.intersection(s2) \u8fd4\u56de\u4e24\u4e2a\u96c6\u5408\u7684\u4ea4\u96c6 \u5e76\u96c6 s1 | s2 \u6216\u8005 s1.union(s2) \u5bf9\u79f0\u5dee\u96c6\uff08\u5f02\u6216\uff09 s1 ^ s2 \u6216\u8005 s1.symmetric_difference(s2) \u5dee\u96c6 s1 - s2 \u6216\u8005 s1.difference(s2) \u4e0a\u97624\u6761\u64cd\u4f5c\u7684\u66f4\u65b0\u7248\u672c s1 |= s2 , s1&=s2, s1-=s2, s1^=s2 \u5b50\u96c6\u5224\u5b9a s1 <= s2 \u6216 s1.issubset(s2) \u7b26\u5408\u6761\u4ef6\u8fd4\u56deTrue\uff0c\u4e0b\u540c \u771f\u5b50\u96c6\u5224\u5b9a s1 < s2 \u8d85\u96c6\u5224\u5b9a s1>=s2 \u6216 s1.issuperset(s2) \u771f\u8d85\u96c6\u5224\u5b9a s1 > s2 \u76f8\u4ea4\u5224\u5b9a s1.isdisjoint(s2) \u4ea4\u96c6\u7a7a\u5219\u8fd4\u56deTrue","title":"\u96c6\u5408"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_48","text":"\u4e0b\u9762\u4f1a\u5217\u51fa\u5b57\u5178\u7684\u5e38\u7528\u65b9\u6cd5\uff08\u4e0d\u662f\u5168\u90e8\uff09 \u8fd0\u7b97\u3001\u51fd\u6570\u6216\u65b9\u6cd5 \u7b26\u53f7 \u7279\u6b8a\u8bf4\u660e \u793a\u4f8b \u901a\u7528\u64cd\u4f5c \uff08\u89c1\u4e0a\u6587\uff09 \u6784\u9020 dict([(k1:w1),(k2:w2),...]) dict(k1=w1,k2=w2) \u53ef\u4f20\u5165\u5217\u8868\uff08\u5217\u8868\u4e2d\u662f\u82e5\u5e72\u4e24\u4e2a\u503c\u7ec4\u6210\u7684\u5143\u7ec4\uff09\u6784\u9020\u5b57\u5178\uff0c\u4e5f\u53ef\u4f20\u5165\u5173\u952e\u5b57\u53c2\u6570\u6784\u9020\u5b57\u5178\u7b49\u3002\u8be6\u7ec6\u89c1\u5b98\u65b9\u6587\u6863 \u6d45\u62f7\u8d1d d.copy() \u6e05\u7a7a d.clear() \u7d22\u5f15\u548c\u8d4b\u503c d[k] d[k]=x k\u4e0d\u5b58\u5728\u65f6\uff0c\u76f8\u5f53\u4e8e\u63d2\u5165\u65b0\u7684\u952e\u503c\u5bf9\uff1b\u5b57\u5178\u4f1a\u786e\u4fdd\u81ea\u5df1\u7684\u5143\u7d20\u6309\u7167\u63d2\u5165\u987a\u5e8f\u6392\u5217 \u6309\u952e\u53d6\u503c d.get(k,[def=None]) \u8fd4\u56de\u8fd9\u4e2a\u952e\u5bf9\u5e94\u7684\u503c\uff1b\u5982\u679c\u6307\u5b9a\u4e86def\u53c2\u6570\u5219\u4f1a\u5728\u627e\u4e0d\u5230k\u8fd9\u4e2a\u952e\u7684\u65f6\u5019\u8fd4\u56dedef\uff0c\u5426\u5219\u8fd4\u56deNone \u6309\u952e\u5220\u9664 del d[k] \u627e\u4e0d\u5230k\u8fd9\u4e2a\u952e\u5219\u629b\u51faKeyError \u6309\u952e\u5220\u96642 d.pop(k,[def=None]) \u5220\u9664\u952e\u503c\u5bf9\u5e76\u8fd4\u56de\u8fd9\u4e2a\u952e\u5bf9\u5e94\u7684\u503c\uff1b\u5982\u679c\u6307\u5b9a\u4e86def\u53c2\u6570\u5219\u4f1a\u5728\u627e\u4e0d\u5230k\u8fd9\u4e2a\u952e\u7684\u65f6\u5019\u8fd4\u56dedef\uff0c\u5426\u5219\u4f1a\u629b\u51faKeyError \u5f39\u51fa\u5143\u7d20 d.popitem() \u5f39\u51fa\u7b2c\u4e00\u4e2a\u952e\u503c\u5bf9\u5e76\u8fd4\u56de\u4e4b\uff08\u4ee5\u5143\u7ec4\u5f62\u5f0f\uff09 \u8bbe\u7f6e\u9ed8\u8ba4\u503c d.setdefault(k,[def=None]) \u5b57\u5178\u4e2d\u5df2\u5b58\u5728k\u5219\u8fd4\u56ded[k]\uff0c\u5426\u5219d[k]=def\uff0c\u5e76\u8fd4\u56dedef\u7684\u5185\u5bb9 \u66f4\u65b0 d.update([dd]) \u6216 d |= dd \uff08Py3.9\uff09 \u4f7f\u7528dd\uff08\u5b57\u5178\u6216\u7531\u82e5\u5e72\u4e24\u4e2a\u503c\u7ec4\u6210\u7684\u5143\u7ec4\u6784\u6210\u7684\u5217\u8868\uff09\u66f4\u65b0d\u4e2d\u7684\u5185\u5bb9 \u5408\u5e76\uff08py3.9\uff09 d| dd dd\u662f\u53e6\u4e00\u4e2a\u5b57\u5178\uff0c\u5c06\u521b\u5efa\u4e24\u4e2a\u5b57\u5178\u5408\u5e76\u7684\u65b0\u5b57\u5178\u3002\uff08\u4ee5dd\u4e2d\u7684\u952e\u503c\u5bf9\u4f18\u5148\uff09 \u89c6\u56fe\u5bf9\u8c61 d.items() d.keys() d.values() \u83b7\u53d6\u952e\u503c\u5bf9\u3001\u952e\u3001\u503c\u7684\u89c6\u56fe\u5bf9\u8c61\uff0c\u4e3b\u8981\u7528\u4e8e\u8fed\u4ee3","title":"\u5b57\u5178"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_49","text":"\u5b57\u7b26\u4e32\u7684\u65b9\u6cd5\u76f8\u5f53\u591a\uff0c\u8fd9\u91cc\u4e5f\u53ea\u80fd\u5217\u51fa\u6bd4\u8f83\u5e38\u7528\u7684\u65b9\u6cd5 \u8fd0\u7b97\u3001\u51fd\u6570\u6216\u65b9\u6cd5 \u7b26\u53f7 \u7279\u6b8a\u8bf4\u660e \u793a\u4f8b \u901a\u7528\u64cd\u4f5c \uff08\u89c1\u4e0a\u6587\uff09 \u5e8f\u5217\u901a\u7528\u64cd\u4f5c \u6784\u9020 str([iterable]) \u53ef\u4f20\u5165\u53ef\u8fed\u4ee3\u5bf9\u8c61\u6784\u9020\u5b57\u7b26\u4e32 \u8ba1\u6570 s.count(s2,[st,ed]) \u8fd4\u56des2\u5728s[st:ed]\u5185\u7684\u51fa\u73b0\u6b21\u6570 \"abcdeeee\".count(\"e\",5,7)=2 \u67e5\u627e s.find(s2,[st,ed]) \u8fd4\u56des2\u5728s[st:ed]\u5185\u51fa\u73b0\u7684\u6700\u5c0f\u4e0b\u6807;\u627e\u4e0d\u5230\u5219\u8fd4\u56de-1 \"abcdeee\".find(\"e\")=4 \u53cd\u5411\u67e5\u627e s.rfind(s2,[st,ed]) \u540c\u4e0a\uff0c\u4f46\u627e\u7684\u662f\u6700\u5927\u4e0b\u6807 \"abcdeee\".rfind(\"e\")=6 \u5206\u9694 s.partition(s2) \u5728s\u4e2d\u627e\u5230s2\u7b2c\u4e00\u6b21\u51fa\u73b0\u7684\u4f4d\u7f6e\uff0c\u5e76\u5c06s\u62c6\u6210s2\u524d\u3001s2\u548cs2\u540e\u4e09\u4e2a\u4e32\uff0c\u8fd4\u56de\u8fd9\u4e09\u8005\u6784\u6210\u7684\u5143\u7ec4\uff08a\uff0cb\uff0cc\uff09\uff1b\u5982\u679c\u6ca1\u6709\u627e\u5230s2\u5219b\u3001c\u5c06\u4f1a\u662f\u7a7a\u4e32 \"abcdeee\".partition(\"de\") =('abc', 'de', 'ee') \"abcdeee\".partition(\"k\")=('abcdeee', '', '') \u62c6\u5206 s.split(s1=None,maxsplit=-1) \u5c06\u5b57\u7b26\u4e32\u4ee5s1\u4f4d\u5206\u9694\u7b26\u62c6\u5206\u6210\u82e5\u5e72\u5b57\u7b26\u4e32\u5e76\u7ec4\u6210\u5217\u8868\uff1b\uff08\u5982\u679cs1\u7f3a\u7701\u5219\u8868\u660e\u4ee5\u4efb\u610f\u957f\u7a7a\u683c\u4f5c\u4e3a\u5206\u9694\u7b26\u53f7\uff09\uff1b\u6307\u5b9amaxsplit\u4e3a\u6b63\u503c\u5219\u8868\u660e\u6b64\u62c6\u5206\u6700\u591a\u4f1a\u8fdb\u884c\u8fd9\u4e48\u591a\u6b21 \"h e ll o\".split()=['h', 'e', 'll', 'o'] \"wawawawa\".split(\"a\",2)=['w', 'w', 'wawa'] \u66ff\u6362 s.replace(s1,s2,[cnt]) \u5c06s\u4e2d\u51fa\u73b0\u7684s1\u5b50\u4e32\u5168\u90e8\u66ff\u6362\u6210s2\uff1b\u6307\u660ecnt\u8868\u660e\u6700\u591a\u8fdb\u884ccnt\u6b21\u66ff\u6362 'abcabcabc'.replace('abc','d',2)='ddabc' \u62fc\u63a5 s.join(L) \u4ee5\u5b57\u7b26\u4e32s\u4f5c\u4e3a\u5206\u9694\u7b26\u53f7\uff0c\u5c06\u53ef\u8fed\u4ee3\u5bf9\u8c61L\uff08\u5143\u7d20\u5fc5\u987b\u5168\u662f\u5b57\u7b26\u4e32\uff09\u4e2d\u7684\u6240\u6709\u5143\u7d20\u4e32\u63a5 '|'.join([\"L\",\"O\",\"V\",\"E\"])=\"L|O|V|E\" ''.join([\"L\",\"O\",\"V\",\"E\"])=\"LOVE\" \u5c0f\u5199\u5316\u3001\u5927\u5199\u5316 s.lower() s.upper() \u5c06s\u8f6c\u6362\u4e3a\u5168\u5c0f\u5199\u6216\u5168\u5927\u5199 \u5168\u5c0f\u5199\u3001\u5168\u5927\u5199\u5224\u5b9a s.islower() s.isupper() s\u4e2d\u7684\u5b57\u6bcd\u5168\u662f\u5c0f\u5199\u6216\u5927\u5199\u5219\u8fd4\u56deTrue \u7a7a\u683c\u4e32\u5224\u5b9a s.isspace() s\u975e\u7a7a\u4e14\u5168\u662f\u7a7a\u683c\uff0c\u8fd4\u56deTrue \u6570\u5b57\u4e32\u5224\u5b9a s.isdigit() s\u5168\u662f\u963f\u62c9\u4f2f\u6570\u5b57\uff0c\u8fd4\u56deTrue \u7f16\u7801 s.encode(encoding=\"utf-8\") \u6307\u5b9a\u5b57\u7b26\u4e32s\u7684\u7f16\u7801\uff0c\u5728\u5199\u722c\u866b\u7684\u65f6\u5019\u53ef\u80fd\u6709\u7528\uff1b\u9ed8\u8ba4\u7528utf-8\u7f16\u7801 \u683c\u5f0f\u5316 s.format(...) \u6216 s1 % ... \u53c2\u89c1\u4e4b\u540e\u7684\u683c\u5f0f\u5316\u5b57\u7b26\u4e32 \u5b57\u7b26\u4e32\u7684\u4e0a\u8ff0\u6d89\u53ca\u67e5\u627e\u5b50\u4e32\u7684\u64cd\u4f5c\u4f7f\u7528\u7684\u7b97\u6cd5\u662f Boyer-Moore \uff0c\u5e73\u5747\u60c5\u51b5\u4e0b\u590d\u6742\u5ea6\u4e3aO\uff08n\uff09\uff0c\u4f46\u6700\u5dee\u60c5\u51b5\u4e0b\u53ef\u8fbeO\uff08nm\uff09","title":"\u5b57\u7b26\u4e32"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_50","text":"","title":"\u5176\u4ed6\u7279\u6027"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_51","text":"\u5728\u521b\u5efa\u5217\u8868\u3001\u96c6\u5408\u548c\u5b57\u5178\u65f6\uff0c\u53ef\u8ba9\u5217\u8868\u4ee5\u4e00\u5b9a\u7684\u89c4\u5219\u751f\u6210\u5176\u4e2d\u7684\u5143\u7d20\uff0c\u4ee5\u5217\u8868\u4e3a\u4f8b\uff1a 1 L = [ x for x in range ( 1 , 11 )] \u8fd9\u4e2a\u4f8b\u5b50\u4f1a\u628aL=[1,2,3,4,5,6,7,8,9,10]\u3002range\u51fd\u6570\u4f1a\u751f\u62101\u523011-1=10\u517110\u4e2a\u6570\u5b57\u7684\u5e8f\u5217\uff0cfor\u5faa\u73af\u4f1a\u8fed\u4ee3\u8fd9\u4e2a\u7c7b\u578b\uff0c\u5e76\u5c06\u8fed\u4ee3\u5230\u7684\u5143\u7d20\uff08\u7ecf\u8fc7\u4e00\u4e9b\u5904\u7406\u540e\uff09\u9010\u4e2a\u4f5c\u4e3aL\u4e2d\u7684\u5143\u7d20\u3002 \u66f4\u4e00\u822c\u5730\uff0c \u5217\u8868\u63a8\u5bfc\u5f0f\u7684\u8bed\u6cd5 \uff1a\uff08\u6807\u51c6\u7684\u5df4\u79d1\u65af\u8303\u5f0f\u8868\u793a\u6cd5\u89c1 https://docs.python.org/zh-cn/3/reference/expressions.html#grammar-token-comp-for \uff09 1 \u8868\u8fbe\u5f0f for \u53d8\u91cf1 in \u53ef\u8fed\u4ee3\u5bf9\u8c61 [ if \u6761\u4ef6 ] for \u53d8\u91cf2 in \u53ef\u8fed\u4ee3\u5bf9\u8c61 [ if \u6761\u4ef6 ] ... \u53d8\u91cf1\u30012\u3001...\u662f\u5728\u8868\u8fbe\u5f0f\u4e2d\u6d89\u53ca\u5230\u7684\u53d8\u91cf\u3002\u5176\u4e2d\u5404\u4e2a\u53d8\u91cf\u5fc5\u987b\u6ee1\u8db3\u6761\u4ef6\u624d\u4f1a\u88ab\u8003\u8651\uff0c\u4e0d\u6ee1\u8db3\u6761\u4ef6\u5c31\u4f1a\u8df3\u8fc7\u3002 \u4f8b\u5982\uff0c\u4e0b\u9762\u7684\u4ee3\u7801\u4f1a\u751f\u6210[2,4,6,8]\u548c[21,23,25,27,29]\u4e2d\u5143\u7d20\u4e24\u4e24\u76f8\u52a0\u7684\u7ed3\u679c\u7ec4\u6210\u7684\u5217\u8868\uff1a 1 2 [ x + y for x in range ( 1 , 10 ) if x % 2 == 0 for y in range ( 20 , 30 ) if y % 2 == 1 ] #[23, 25, 27, 29, 31, 25, 27, 29, 31, 33, 27, 29, 31, 33, 35, 29, 31, 33, 35, 37] \u628a\u524d\u4e00\u4e2aif\u6761\u4ef6\u62c9\u5230\u540e\u9762\u7684if\u4e2d\uff0c\u8d77\u5230\u7684\u6548\u679c\u662f\u4e00\u6837\u7684 1 2 [ x + y for x in range ( 1 , 10 ) for y in range ( 20 , 30 ) if y % 2 == 1 and x % 2 == 0 ] #[23, 25, 27, 29, 31, 25, 27, 29, 31, 33, 27, 29, 31, 33, 35, 29, 31, 33, 35, 37] \u5bf9 \u96c6\u5408 \u800c\u8a00\uff0c\u53ea\u9700\u8981\u628a\u4e0a\u9762\u7684\u6846\u6362\u6210\u82b1\u62ec\u53f7\u5c31\u80fd\u53d8\u6210\u96c6\u5408\u63a8\u5bfc\u5f0f\u4e86\uff1a 1 2 { x + y for x in range ( 1 , 10 ) for y in range ( 20 , 30 ) if y % 2 == 1 and x % 2 == 0 } #{33, 35, 37, 23, 25, 27, 29, 31} \u5bf9 \u5b57\u5178 \u800c\u8a00\uff0c\u8868\u8fbe\u5f0f\u9700\u8981\u6539\u6210\u7528\u5f15\u53f7\u5206\u9694\u7684\u4e24\u4e2a\u8868\u8fbe\u5f0f\uff0c\u9700\u8981\u6ce8\u610f\u7684\u662f\u4e00\u5f00\u59cb\u7684\u952e\u503c\u5bf9\u53ef\u80fd\u4f1a\u88ab\u540e\u6765\u7684\u8986\u76d6\uff1a 1 2 { x - y : x + y for x in range ( 1 , 10 ) if x % 2 == 0 for y in range ( 20 , 30 ) if y % 2 == 1 } #{-19: 35, -21: 37, -23: 35, -25: 33, -27: 31, -17: 33, -15: 31, -13: 29} \u603b\u7ed3\u4e00\u4e0b\u5c31\u662f\uff1a 1 2 3 4 #\u5217\u8868\u3001\u96c6\u5408\u63a8\u5bfc\u5f0f \u8868\u8fbe\u5f0f for \u53d8\u91cf1 in \u53ef\u8fed\u4ee3\u5bf9\u8c61 [ if \u6761\u4ef6 ] for \u53d8\u91cf2 in \u53ef\u8fed\u4ee3\u5bf9\u8c61 [ if \u6761\u4ef6 ] ... #\u5b57\u5178\u63a8\u5bfc\u5f0f \u8868\u8fbe\u5f0f1 : \u8868\u8fbe\u5f0f2 for \u53d8\u91cf1 in \u53ef\u8fed\u4ee3\u5bf9\u8c61 [ if \u6761\u4ef6 ] for \u53d8\u91cf2 in \u53ef\u8fed\u4ee3\u5bf9\u8c61 [ if \u6761\u4ef6 ] ... \u5f53\u7136\u4e0a\u6587\u4e2d\u6211\u4eec\u53ea\u8ba8\u8bba\u4e86\u4e09\u4e2d\u7c7b\u578b\u7684\u63a8\u5bfc\u5f0f\u3002\u65e2\u7136\u5217\u8868\u90fd\u6709\u63a8\u5bfc\u5f0f\u4e86\uff0c\u90a3\u5143\u7ec4\u5462\uff1f\u5143\u7ec4\u4e8b\u5b9e\u4e0a\u6ca1\u6709\u63a8\u5bfc\u5f0f\u8fd9\u4e2a\u8bf4\u6cd5\uff0c\u5982\u679c\u771f\u7684\u60f3\u8981\u83b7\u5f97\u4e00\u4e2a\u63a8\u5bfc\u5f0f\u63a8\u5bfc\u51fa\u7684\u5143\u7ec4\uff0c\u8bf7\u5148\u4f7f\u7528\u5217\u8868\u63a8\u5bfc\u5f0f\uff0c\u7136\u540e\u4f7f\u7528tuple\u51fd\u6570\u8f6c\u6362\u6210\u5143\u7ec4\u3002 \u7b80\u5355\u5730\u5c06\u63a8\u5bfc\u5f0f\u6700\u5916\u5c42\u7684\u82b1\u62ec\u53f7\u6216\u65b9\u62ec\u53f7\u6362\u6210\u5706\u62ec\u53f7\uff0c\u5f97\u5230\u7684\u5c06\u662f\u751f\u6210\u5668\u63a8\u5bfc\u5f0f\u800c\u4e0d\u518d\u662f\u5143\u7ec4\uff0c\u5176\u884c\u4e3a\u4e5f\u548c\u5e8f\u5217\u5bf9\u8c61\u4e0d\u4e00\u6837\uff0c\u56e0\u6b64\u4ee5\u540e\u6211\u4eec\u518d\u8ba8\u8bba\u5b83\u3002","title":"\u63a8\u5bfc\u5f0f"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_52","text":"\u8fd9\u91cc\u5c06\u6309\u7528\u9014\u7c7b\u578b\u628a\u5e38\u7528\u7684\u5185\u7f6e\u51fd\u6570\uff08\u4e0d\u5305\u62ec\u5185\u7f6e\u6a21\u5757\u91cc\u7684\u51fd\u6570\uff09\u505a\u5212\u5206\u3002","title":"\u5e38\u7528\u51fd\u6570\u603b\u7ed3"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_53","text":"\u8fd9\u4e9b\u51fd\u6570\u5df2\u7ecf\u5728\u524d\u9762\u7684\u201c\u57fa\u672c\u6570\u636e\u7c7b\u578b\u201d\u4e2d\u63d0\u5230\uff0c\u8fd9\u91cc\u5c06\u53ea\u5217\u51fa\u5b83\u4eec\u3002","title":"\u7c7b\u578b\u8f6c\u6362\u51fd\u6570"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#intxbase10-int","text":"\u8f93\u5165x\uff0c\u5c06x\u4ee5base\u8fdb\u5236\u89e3\u6790\u621010\u8fdb\u5236\u540e\u8fd4\u56de\u6574\u6570.","title":"int(x,base=10) -&gt; int"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#floatx-float","text":"","title":"float(x) -&gt;float"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#boolx-bool","text":"","title":"bool(x) -&gt; bool"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#complexx-complex","text":"","title":"complex(x) -&gt; complex"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_54","text":"\u8fd9\u4e9b\u51fd\u6570\u5df2\u7ecf\u5728\u524d\u9762\u7684\u201c\u5e38\u7528\u6570\u636e\u7ed3\u6784\u65b9\u6cd5\u4e0e\u76f8\u5173\u5e38\u7528\u51fd\u6570\u201d\u4e2d\u63d0\u5230\uff0c\u8fd9\u91cc\u5c06\u53ea\u5217\u51fa\u5b83\u4eec\u3002","title":"\u5e38\u7528\u6570\u636e\u7ed3\u6784\u6784\u9020\u51fd\u6570"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#listiterable-list","text":"","title":"list([iterable]) -&gt; list"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#tupleiterable-tuple","text":"","title":"tuple([iterable]) -&gt;tuple"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#striterable-str","text":"","title":"str([iterable]) -&gt; str"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#setiterable-set","text":"","title":"set([iterable]) -&gt; set"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#dict-dict","text":"","title":"dict(...) -&gt; dict"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_55","text":"\u66f4\u591a\u4e0e\u6570\u5b66\u6709\u5173\u7684\u51fd\u6570\u8bf7\u53c2\u8003math\u5e93\u4e2d\u7684\u51fd\u6570\u3002","title":"\u6570\u5b66\u548c\u8fdb\u5236\u8f6c\u6362"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#absx","text":"\u8fd4\u56dex\u7684\u7edd\u5bf9\u503c\u6216\u6a21\uff08\u590d\u6570\uff09","title":"abs(x)"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#maxxy-maxiterable","text":"\u4f20\u5165\u81f3\u5c11\u4e24\u4e2a\u53c2\u6570\u6216\u8005\u4e00\u4e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\uff0c\u5c06\u8fd4\u56de\u8fd9\u4e9b\u53c2\u6570\u6216\u8fd9\u4e2a\u5bf9\u8c61\u4e2d\u7684\uff08\u7b2c\u4e00\u4e2a\uff09\u6700\u5927\u5143\u7d20\u3002","title":"max(x,y,...) \u6216 max([iterable])"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#minxy-miniterable","text":"\u540c\u4e0a\uff0c\u4f46\u8fd4\u56de\uff08\u7b2c\u4e00\u4e2a\uff09\u6700\u5c0f\u5143\u7d20\u3002","title":"min(x,y,...) \u6216 min([iterable])"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#sumiterable","text":"\u4f20\u5165\u53ef\u8fed\u4ee3\u5bf9\u8c61\uff0c\u8fd4\u56de\u5bf9\u8c61\u4e2d\u6240\u6709\u5143\u7d20\u7684\u548c","title":"sum([iterable])"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#powabm","text":"\u8fd4\u56dea\u7684b\u6b21\u5e42\uff0c\u5982\u679c\u6307\u5b9a\u4e86m\uff08\u5fc5\u987b\u662f\u6574\u6570\uff09\uff0c\u90a3\u4e48\u8fd4\u56dea\u7684b\u6b21\u5e42\u5bf9m\u53d6\u4f59\u6570\u7684\u7ed3\u679c\u3002 py3.8\u4e2d\uff0cb\u652f\u6301\u5728\u4f20\u5165m\u7684\u60c5\u51b5\u4e0b\u4f20\u5165\u8d1f\u6570\u4e86\uff0c\u8fd9\u610f\u5473\u7740\u4f60\u53ef\u4ee5\u76f4\u63a5\u7528\u8fd9\u4e2a\u51fd\u6570\u6c42\u4e00\u4e2a\u6570\u7684\u6a21\u9006\u5143\u3002","title":"pow(a,b,[m])"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#divmodab","text":"\u5e26\u4f59\u9664\u6cd5\uff0c\u8fd4\u56de\u4e8c\u5143\u7ec4(a//b, a%b)\u3002","title":"divmod(a,b)"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#roundxd","text":"\u5c06x\u56db\u820d\u4e94\u5165\u5230d\u4f4d\u5c0f\u6570\uff0cd\u672a\u6307\u5b9a\u5219\u8868\u660e\u56db\u820d\u4e94\u5165\u5230\u6574\u6570\u3002 \u4f46\u8981\u6ce8\u610f\uff0c\u7531\u4e8e\u6d6e\u70b9\u6570\u7cbe\u5ea6\u95ee\u9898\uff0c\u67d0\u4e9b\u6570\u503c\u53ef\u80fd\u4f1a\u5728\u8fb9\u754c\u5904\u4ea7\u751f\u53cd\u76f4\u89c9\u7684\u7ed3\u679c\u3002\u4f8b\u5982 1 2 round ( 4.5 ) #4 round ( 5.5 ) #6","title":"round(x,[d])"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#hexx","text":"\u8f93\u5165\u6574\u6570x\uff0c\u8fd4\u56de0x\u5f00\u5934\u768416\u8fdb\u5236\u5b57\u7b26\u4e32\u3002","title":"hex(x)"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#octx","text":"\u540c\u4e0a\uff0c\u8fd4\u56de0o\u5f00\u5934\u76848\u8fdb\u5236\u5b57\u7b26\u4e32\u3002","title":"oct(x)"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#binx","text":"\u540c\u4e0a\uff0c\u8fd4\u56de0b\u5f00\u5934\u76842\u8fdb\u5236\u5b57\u7b26\u4e32\u3002","title":"bin(x)"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_56","text":"","title":"\u8f93\u5165\u548c\u8f93\u51fa"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#inputprompt","text":"\u4ece\u6807\u51c6\u8f93\u5165\u8bfb\u5165\u4e00\u884c\u5b57\u7b26\u4e32\u3002\u6307\u5b9aprompt\u4ee5\u5728\u8bfb\u5165\u524d\u8f93\u51fa\u4e00\u884c\u63d0\u793a\u3002","title":"input([prompt])"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#printobj-sep-endn-filesysstdout-flushfase","text":"\u8f93\u51fa\u82e5\u5e72\u4e2a\u4f20\u5165\u7684obj\u53c2\u6570\uff0c\u6bcf\u4e2a\u53c2\u6570\u4e4b\u95f4\u4ee5sep\u5206\u9694\uff08\u9ed8\u8ba4\u662f\u7a7a\u683c\uff09\uff0c\u8f93\u51fa\u5b8c\u6210\u540e\u518d\u8f93\u51fa\u4e00\u4e2aend\u5b57\u7b26\u4e32\uff08\u9ed8\u8ba4\u662f\u6362\u884c\uff09\u3002 \u6307\u5b9afile\u4ee5\u89c4\u5b9a\u8f93\u51fa\u5230\u4f55\u5904\uff0c\u9ed8\u8ba4\u662f\u6807\u51c6\u8f93\u51fa\u6d41\u3002 \u6307\u5b9aflush\u4e3aTrue\uff0c\u5219\u8f93\u51fa\u5b8c\u6210\u540e\u5c06\u5237\u65b0\u8f93\u51fa\u6d41\uff08\u7acb\u5373\u5c06\u7f13\u51b2\u533a\u7684\u5185\u5bb9\u90fd\u8f93\u51fa\u5230\u6587\u4ef6\u4e2d\uff09\u3002","title":"print(*obj, sep=' ' , end='\\n', file=sys.stdout, flush=Fase)"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#openf-moder","text":"\u6253\u5f00\u6587\u4ef6f\u5e76\u8fd4\u56de\u6587\u4ef6\u5bf9\u8c61\uff0c\u5229\u7528\u8fd9\u4e2a\u6587\u4ef6\u5bf9\u8c61\u53ef\u4ee5\u5411\u91cc\u9762\u8bfb\u5199\u5185\u5bb9\u3002 mode\u6307\u5b9a'r'\u4e3a\u8bfb\u53d6\uff0c\u6307\u5b9a'w'\u4e3a\u5199\u5165\u3002\u5728\u8fd9\u4e4b\u540e\u8ffd\u52a0\u5199'b'\u3001't'\u53ef\u4ee5\u4e8c\u8fdb\u5236\u6a21\u5f0f\uff08\u4f8b\u5982\u8bfb\u5199\u56fe\u7247\uff09\u6216\u6587\u672c\u6a21\u5f0f\uff08\u9ed8\u8ba4\uff09\u8bfb\u5199\uff0c\u8ffd\u5199'a'\u4ee3\u8868\u6587\u4ef6\u5b58\u5728\u65f6\u5728\u672b\u5c3e\u8ffd\u52a0\u8bfb\u5199\u7b49\u3002\u5177\u4f53\u8bf4\u660e\u53c2\u770b\u5b98\u65b9\u6587\u6863\u3002","title":"open(f, mode='r', ...)"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_57","text":"","title":"\u8fed\u4ee3\u76f8\u5173\u51fd\u6570"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#rangestedstep","text":"\u751f\u6210\u4e00\u4e2a\u4ecest\uff08\u9ed8\u8ba4\u4e3a0\uff09\u5230ed\uff08\u4e0d\u5305\u62eced\uff09\uff0c\u6b65\u957f\u4e3astep\uff08\u9ed8\u8ba4\u4e3a1\uff09\u7684range\u5e8f\u5217\u5bf9\u8c61\u3002\u901a\u5e38\u7528\u4e8efor\u5faa\u73af\u8fed\u4ee3\u3002 range\u5bf9\u8c61\u662f\u4e0d\u53ef\u53d8\u7684\u5e8f\u5217\u7c7b\u578b\uff0c\u4e5f\u652f\u6301\u4e00\u4e9b\uff08\u4f46\u4e0d\u662f\u6240\u6709\uff09\u5e8f\u5217\u64cd\u4f5c\uff1a \u8fd0\u7b97\u3001\u51fd\u6570\u6216\u65b9\u6cd5 \u7b26\u53f7 \u7279\u6b8a\u8bf4\u660e \u793a\u4f8b \u901a\u7528\u64cd\u4f5c \uff08\u89c1\u4e0a\u6587\uff09 \u5e8f\u5217\u901a\u7528\u64cd\u4f5c (\u4e32\u63a5\u3001\u91cd\u590d\u9664\u5916) \u6784\u9020 range(...) \u4f7f\u7528range\u5bf9\u8c61\u8fed\u4ee3\u4f1a\u6bd4\u4f7f\u7528\u5217\u8868\u751f\u6210\u5f0f\u751f\u6210\u7684\u4e00\u4e32\u5e8f\u5217\u66f4\u9ad8\u6548\u3002","title":"range([st],ed,[step])"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#iteriterable","text":"\u8fd4\u56de\u53ef\u8fed\u4ee3\u5bf9\u8c61\u7684\u4e00\u4e2a\u8fed\u4ee3\u5668\uff08iterator\uff09\uff08\u4ece\u5934\u5f00\u59cb\uff09\u3002","title":"iter(iterable)"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#reversediterable","text":"\u8fd4\u56de\u53ef\u8fed\u4ee3\u5bf9\u8c61\u7684\u53cd\u5411\u8fed\u4ee3\u5668\uff08for\u5faa\u73af\u65f6\uff0c\u5c06\u4eceL\u7684\u5c3e\u90e8\u5230\u5934\u90e8\u8fed\u4ee3\uff09","title":"reversed(iterable)"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#zipiterables","text":"\u540c\u65f6\u8fed\u4ee3\u591a\u4e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u3002\u5f53\u8fd9\u5f53\u4e2d\u6700\u77ed\u7684\u4e00\u4e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u8fed\u4ee3\u5b8c\u6bd5\u65f6\uff0c\u7ed3\u675f\u8fed\u4ee3\u3002 1 2 3 4 for x , y , z in zip ([ 1 , 2 ],[ 3 , 4 , 5 ],[ 6 , 7 ]): print ( x , y , z ) #1 3 6 #2 4 7","title":"zip(*[iterables])"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#enumerateiterable-start0","text":"\u8fd4\u56de\u53e6\u4e00\u4e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\uff0c\u5bf9\u8c61\u4e2d\u7684\u6bcf\u4e00\u4e2a\u5143\u7d20\u4ee5\u5143\u7ec4(i,v)\u8868\u793a\uff0ci\u8868\u793a\u5176\u662f\u7b2ci\u4e2a\uff08\u4ece0\u5f00\u59cb\u8ba1\u6570\uff09\u5143\u7d20\uff0cv\u8868\u793a\u5143\u7d20\u5185\u5bb9\u3002 1 2 3 4 5 for i , v in enumerate ([ 7 , 8 , 9 ]): print ( i , v ) #0 7 #1 8 #2 9","title":"enumerate(iterable, start=0)"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#nextiteratordef","text":"\u4f20\u5165\u8fed\u4ee3\u5668\uff0c\u8fd4\u56de\u8fed\u4ee3\u5668\u6240\u6307\u5143\u7d20\u5e76\u4ee4\u8fed\u4ee3\u5668\u79fb\u52a8\u5230\u4e0b\u4e00\u4e2a\u4f4d\u7f6e\u3002\u5982\u679c\u8fed\u4ee3\u5b8c\u4e86\u4f1a\u629b\u51faStopIteration\u3002","title":"next(iterator,[def])"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_58","text":"","title":"\u5b57\u7b26"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#chrx","text":"x\u662f\u6574\u6570\uff0c\u8fd4\u56de\u5bf9\u5e94unicode\u503c\u7684\u5355\u4e2a\u5b57\u7b26\u7684\u5b57\u7b26\u4e32\u3002\u4f8b\u5982chr(65)='A'","title":"chr(x)"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#ordx","text":"x\u662f\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\u7684\u5b57\u7b26\u4e32\uff0c\u8fd4\u56de\u5b57\u7b26\u5bf9\u5e94\u7684Unicode\u7801\u3002\u4e0d\u662f\u4e00\u4e2a\u5b57\u7b26\u7684\u5b57\u7b26\u4e32\u4f1a\u629b\u51faTypeError\u3002","title":"ord(x)"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_59","text":"","title":"\u6392\u5e8f"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#sortediterablekeynone-reversefalse","text":"\u8fd4\u56de\u65b0\u7684\u5df2\u6392\u5e8f\u7684\u53ef\u8fed\u4ee3\u5bf9\u8c61\u3002 \u6307\u5b9akey\u4e3a\u51fd\u6570\u53ef\u6539\u53d8\u7528\u4e8e\u6bd4\u8f83\u201c\u5927\u5c0f\u201d\u7684\u89c4\u5219\u3002\u6307\u5b9areverse\u4e3aTrue\u53ef\u4f7f\u5176\u4ece\u5927\u5230\u5c0f\u6392\u5217\u3002\u66f4\u591a\u8bf7\u53c2\u8003\u5b98\u65b9\u6587\u6863\uff1a https://docs.python.org/zh-cn/3/howto/sorting.html#sortinghowto \u3002","title":"sorted([iterable],*,key=None, reverse=False)"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_60","text":"","title":"\u7c7b\u578b\u5224\u5b9a"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#isinstanceobjcls","text":"\u68c0\u6d4bobj\u662f\u5426\u662fcls\u8fd9\u4e2a\u7c7b\u7684\u4e00\u4e2a\u5b9e\u4f8b\u3002 1 2 3 isinstance ([ 1 , 2 , 3 ], list ) #True from collections.abc import Iterable isinstance ([ 1 , 2 , 3 ], Iterable ) #True","title":"isinstance(obj,cls)"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#typeobj","text":"\u8fd4\u56deobj\u7684\u7c7b\u578b\uff08\u4e00\u4e2atype\u5bf9\u8c61\uff09\u3002 1 2 type ( 123 ) # <class 'int'>","title":"type(obj)"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_61","text":"","title":"\u6267\u884c"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#evalobj","text":"\u5c06obj\uff08\u901a\u5e38\u662f\u5b57\u7b26\u4e32\uff09\u5f53\u4f5cpython\u8868\u8fbe\u5f0f\u8fd0\u884c\uff0c\u7136\u540e\u8fd4\u56de\u8fd0\u884c\u7ed3\u679c\u3002\u6709\u8bed\u6cd5\u9519\u8bef\u4f1a\u629b\u51faSyntaxError\u3002","title":"eval(obj,...)"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#execobj","text":"\u5c06obj\uff08\u901a\u5e38\u662f\u5b57\u7b26\u4e32\uff09\u5f53\u4f5cpython\u4ee3\u7801\u6267\u884c\u3002\u8fd4\u56deNone\u3002\u6709\u8bed\u6cd5\u9519\u8bef\u4f1a\u629b\u51faSyntaxError\u3002","title":"exec(obj, ...)"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_62","text":"","title":"\u5e38\u7528\u5185\u7f6e\u5e93\u51fd\u6570\u603b\u7ed3"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#math","text":"Python\u7684\u5185\u7f6e\u6570\u5b66\u5e93 1 import math","title":"math"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_63","text":"","title":"\u6d6e\u70b9\u6570"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#ceilx","text":"\u8fd4\u56dex\u7684\u5411\u4e0a\u53d6\u6574\u503c","title":"ceil(x)"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#floorx","text":"\u8fd4\u56dex\u7684\u5411\u4e0b\u53d6\u6574\u503c","title":"floor(x)"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#iscloseabrel_tol1e-9abs_tol00","text":"\u5224\u65ad\u4e24\u4e2a\u6d6e\u70b9\u6570a\u3001b\u662f\u5426\u8db3\u591f\u76f8\u8fd1\uff0c\u5141\u8bb8\u7684\u8bef\u5dee\u4e3arel_tol\u3002","title":"isclose(a,b,*,rel_tol=1e-9,abs_tol=0.0)"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#fabsx","text":"x\u7684\u7edd\u5bf9\u503c\uff08\u6d6e\u70b9\u6570\uff09","title":"fabs(x)"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#fmodxy","text":"\u9002\u7528\u4e8e\u6d6e\u70b9\u6570\u7684\u53d6\u6a21\u8fd0\u7b97","title":"fmod(x,y)"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_64","text":"","title":"\u7ec4\u5408\u8ba1\u6570\u76f8\u5173"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#combnk","text":"\u7ec4\u5408\u6570 \\(C_{n}^k\\)","title":"comb(n,k)"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#factorialx","text":"\u8fd4\u56dex\u7684\u9636\u4e58\uff0cx\u9700\u8981\u662f\u5927\u4e8e\u7b49\u4e8e0\u7684\u6574\u6570\uff0c\u5426\u5219\u4f1a\u629b\u51fa\u5f02\u5e38\u3002","title":"factorial(x)"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#permnknone","text":"k<=n\uff0c\u8fd4\u56de \\(\\frac{n!}{(n-k)!}\\) \uff1b\u5426\u5219\u8fd4\u56de0","title":"perm(n,k=None)"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_65","text":"","title":"\u6570\u8bba"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#gcdab-gcdints","text":"\u8f93\u5165\u4e24\u4e2a/\u82e5\u5e72\uff08Py3.9\uff09\u6574\u6570\uff0c\u8fd4\u56de\u8fd9\u4e9b\u6570\u7684\u6700\u5927\u516c\u56e0\u6570\u3002\u7279\u522b\u5730\uff0c\u8f93\u5165\u7684\u6570\u5168\u4e3a0\u65f6\uff0c\u8fd4\u56de0\u3002\u8fd9\u548c\u81ea\u5df1\u624b\u5199\u7684gcd\u51fd\u6570\u884c\u4e3a\u76f8\u540c\u3002","title":"gcd(a,b)  /  gcd(*ints)"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#lcmints-py39","text":"\u8f93\u5165\u82e5\u5e72\u6574\u6570\uff0c\u8fd4\u56de\u6700\u5c0f\u516c\u500d\u6570\u3002","title":"lcm(*ints) (Py3.9)"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_66","text":"","title":"\u6c42\u79ef\u4e0e\u6c42\u548c"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#proditerablestart1","text":"\u6c42\u53ef\u8fed\u4ee3\u5bf9\u8c61\u7684\u79ef\uff0c\u521d\u59cb\u503c\u4e3astart\u3002","title":"prod(iterable,*,start=1)"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#fsumiterable","text":"\u8fd4\u56de\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e2d\u7684\u6d6e\u70b9\u503c\u548c\uff08\u7cbe\u786e\u5730\uff09","title":"fsum(iterable)"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_67","text":"","title":"\u7b97\u6570"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#expx","text":"\u6307\u6570\u51fd\u6570","title":"exp(x)"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#logxbase","text":"\u4ee5base\u4e3a\u5e95\u6570\u7684x\u7684\u5bf9\u6570","title":"log(x,[base])"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#log2x-log10x","text":"\u7c7b\u4f3c\u4e0a\u4e00\u51fd\u6570","title":"log2(x)  log10(x)"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#sqrtx","text":"\u7b97\u6570\u5e73\u65b9\u6839","title":"sqrt(x)"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#isqrtx","text":"\u4e0a\u4e00\u51fd\u6570\u7684\u5411\u4e0b\u53d6\u6574\u503c","title":"isqrt(x)"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#sinx-cosx-tanx-asinx-acosx-atanx","text":"\u4e09\u89d2\u51fd\u6570","title":"sin(x) cos(x) tan(x) asin(x) acos(x) atan(x)"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#atan2yx","text":"\u4ee5\u5f27\u5ea6\u4e3a\u5355\u4f4d\u8fd4\u56deatan(y/x)\uff0c\u7ed3\u679c\u5728 \\([-\\pi,\\pi]\\) \u4e4b\u95f4\u3002","title":"atan2(y,x)"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#distpq","text":"p\u3001q\u662f\u53ef\u8fed\u4ee3\u5bf9\u8c61\uff0c\u8fd4\u56de\u4ed6\u4eec\u7684\u6b27\u51e0\u91cc\u5f97\u8ddd\u79bb\u3002","title":"dist(p,q)"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_68","text":"","title":"\u5e38\u6570"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#pi-e-tau2pi","text":"","title":"pi e tau\uff082pi\uff09"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#cmath","text":"\u7528\u4e8e\u590d\u6570\u7b97\u6570\u7684\u5e93","title":"cmath"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#phasex","text":"\u8fd4\u56de\u590d\u6570x\u7684\u76f8\u4f4d\u3002[-pi,pi]\u4e4b\u95f4","title":"phase\uff08x\uff09"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#polarx","text":"\u8fd4\u56de\u590d\u6570x\u5728\u6781\u5750\u6807\u7cfb\u4e2d\u7684\u8868\u793a\u65b9\u5f0f\uff08\u4e8c\u5143\u7ec4\uff09","title":"polar\uff08x\uff09"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#rectrphi","text":"\u901a\u8fc7\u6781\u5750\u6807\u7684\u534a\u5f84\u548c\u89d2\u5ea6\u8fd4\u56de\u5bf9\u5e94\u590d\u6570","title":"rect\uff08r\uff0cphi\uff09"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#random","text":"\u4f2a\u968f\u673a\u6570\u5e93","title":"random"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_69","text":"","title":"\u5e8f\u5217"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#choiceseq","text":"\u4ece\u975e\u7a7a\u5e8f\u5217 seq \u8fd4\u56de\u4e00\u4e2a\u968f\u673a\u5143\u7d20\u3002","title":"choice\uff08seq\uff09"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#shufflexrandom","text":"\u5c06x\u6309\u7167random\u51fd\u6570\u751f\u6210\u7684\u503c\uff08[0.0,1.0)\uff09\u968f\u673a\u6253\u4e71\u3002","title":"shuffle\uff08x\uff0c[random]\uff09"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_70","text":"","title":"\u968f\u673a\u6570"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#random_1","text":"\u8fd4\u56de[0.0,1.0)\u5185\u7684\u968f\u673a\u6570","title":"random()"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#uniformab","text":"\u8fd4\u56dea~b\u5185\u7684\u968f\u673a\u6d6e\u70b9\u6570","title":"uniform\uff08a\uff0cb\uff09"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#randintab","text":"\u8fd4\u56dea~b\u5185\u7684\u968f\u673a\u6574\u6570","title":"randint\uff08a\uff0cb\uff09"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#randrangested-step-randrangeed","text":"\u53c2\u6570\u5f62\u5982range\uff0c\u8fd4\u56de\u8fd9\u4e4b\u4e2d\u7684\u4e00\u4e2a\u6570","title":"randrange(st,ed, [step]) / randrange(ed)"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#statistics","text":"\u7edf\u8ba1\u5b66\u51fd\u6570\u3002\u5982\u65e0\u7279\u6b8a\u8bf4\u660e\uff0c\u4e0b\u6587\u4e2d\u51fd\u6570\u53c2\u6570\u4e3a\u53ef\u8fed\u4ee3\u5bf9\u8c61","title":"statistics"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#meanx","text":"\u7b97\u6570\u5e73\u5747\u6570","title":"mean\uff08x\uff09"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#fmeanx","text":"\u5feb\u901f\u8ba1\u7b97\u7b97\u6570\u5e73\u5747\u6570\uff08\u603b\u662f\u8fd4\u56de\u6d6e\u70b9\u6570\uff09","title":"fmean\uff08x\uff09"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#medianx-median_lowx-median_highx","text":"\u4e2d\u4f4d\u6570/\u9ad8\u4e2d\u4f4d\u6570/\u4f4e\u4e2d\u4f4d\u6570","title":"median(x) / median_low(x) / median_high(x)"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#itertools","text":"\u5305\u62ec\u5404\u7c7b\u7528\u4e8e\u8fed\u4ee3\u5bb9\u5668\u7684\u51fd\u6570","title":"itertools"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#permutationsiterable-rnone","text":"\u8fde\u7eed\u8fd4\u56de\u7531 iterable \u5143\u7d20\u751f\u6210\u957f\u5ea6\u4e3a r \u7684\u6392\u5217\uff08\u8fed\u4ee3\u5668\uff09\u3002","title":"permutations(iterable, r=None)"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#combinationsiterable-r","text":"\u8fd4\u56de\u7531\u8f93\u5165 iterable \u4e2d\u5143\u7d20\u7ec4\u6210\u957f\u5ea6\u4e3a r \u7684\u5b50\u5e8f\u5217\u3002","title":"combinations(iterable, r)"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#combinations_with_replacementiterable-r","text":"\u8fd4\u56de\u7531\u8f93\u5165 iterable \u4e2d\u5143\u7d20\u7ec4\u6210\u7684\u957f\u5ea6\u4e3a r \u7684\u5b50\u5e8f\u5217\uff0c\u5141\u8bb8\u6bcf\u4e2a\u5143\u7d20\u53ef\u91cd\u590d\u51fa\u73b0\u3002","title":"combinations_with_replacement(iterable, r)"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#datetime","text":"","title":"datetime"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#os","text":"","title":"os"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_71","text":"https://docs.python.org/zh-cn/3/tutorial/inputoutput.html#formatted-string-literals","title":"\u5b57\u7b26\u4e32\u683c\u5f0f\u5316"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#sformatargs-kwargs","text":"\u683c\u5f0f\u5316s\u4e2d\u5e26\u6709\u82b1\u62ec\u53f7\u7684\u90e8\u5206\u3002 *args \uff1a \u4f9d\u6b21\u66ff\u6362\uff0c\u6216\u8005\u6839\u636e\u82b1\u62ec\u53f7\u4e2d\u7684\u7d22\u5f15\u66ff\u6362 **kwargs\uff1a\u5b57\u5178\uff0c\u6839\u636e\u82b1\u62ec\u53f7\u4e2d\u7684\u503c\u4f5c\u4e3a\u952e\u6765\u66ff\u6362 1 \"The sum of 1 + 2 is {0} \" . format ( 1 + 2 )","title":"s.format(args, *kwargs)"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_72","text":"\u5927\u6982\u957f\u8fd9\u6837\uff1a 1 { [ \u57df\u540d ] [ ! \u8f6c\u6362\u65d7\u6807 ] [: \u683c\u5f0f\u63a7\u5236\u7b26 ] } \u57df\u540d\uff1a\u5982\u679c\u4e3a\u6570\u5b57\uff0c\u5219\u5b83\u6307\u5411\u4e00\u4e2a\u4f4d\u7f6e\u53c2\u6570\uff0c\u800c\u5982\u679c\u4e3a\u5173\u952e\u5b57\uff0c\u5219\u5b83\u6307\u5411\u4e00\u4e2a\u547d\u540d\u5173\u952e\u5b57\u53c2\u6570\u3002\uff08\u7701\u7565\u5219\u9ed8\u8ba4\u4e3a\u4f4d\u7f6e\u53c2\u6570\u4ece0\u9012\u589e\uff09 \u8f6c\u6362\u65d7\u6807\uff1a a\uff1a\u76f8\u5f53\u4e8e\u5728\u4ee3\u5165\u524d\u5957\u7528\u4e00\u6b21ascii\u51fd\u6570 s\uff1a\u76f8\u5f53\u4e8e\u5728\u4ee3\u5165\u524d\u5957\u7528\u4e00\u6b21str\u51fd\u6570\uff08\u5f71\u54cdprint\u7684\u8f93\u51fa\uff09 r\uff1a\u76f8\u5f53\u4e8e\u5728\u4ee3\u5165\u524d\u5957\u7528\u4e00\u6b21repr\u51fd\u6570\uff08repr\u4f1a\u5f71\u54cd\u5bf9\u8c61\u5728\u63a7\u5236\u53f0\u7684\u8f93\u51fa\uff09 \u5e38\u7528\u7684\u683c\u5f0f\u63a7\u5236\u7b26\uff08\u683c\u5f0f\u89c4\u683c\u8ff7\u4f60\u8bed\u8a00\uff09\uff1a format_spec ::= [[fill]align][sign][#][0][width][grouping_option][.precision][type] \u586b\u5145fill\uff1a\u5982\u679c\u6307\u5b9a\u4e86\u4e00\u4e2a\u6709\u6548\u7684 align \u503c\uff0c\u5219\u53ef\u4ee5\u5728\u8be5\u503c\u524d\u9762\u52a0\u4e00\u4e2a fill \u5b57\u7b26\uff0c\u5b83\u53ef\u4ee5\u4e3a\u4efb\u610f\u5b57\u7b26\uff0c\u5982\u679c\u7701\u7565\u5219\u9ed8\u8ba4\u4e3a\u7a7a\u683c\u7b26\u3002 \u5bf9\u9f50\u9009\u9879align\uff1a< > = ^ \u5206\u522b\u8868\u793a \u5de6\u53f3\u5bf9\u9f50\u3001\u5f3a\u5236\u5c06\u586b\u5145\u653e\u7f6e\u5728\u7b26\u53f7\uff08\u5982\u679c\u6709\uff09\u4e4b\u540e\u4f46\u5728\u6570\u5b57\u4e4b\u524d\u3002\u8fd9\u7528\u4e8e\u4ee5\u201c+000000120\u201d\u5f62\u5f0f\u6253\u5370\u5b57\u6bb5\u3001\u5c45\u4e2d\u3002 width \uff1a\u662f\u4e00\u4e2a\u5b9a\u4e49\u6700\u5c0f\u603b\u5b57\u6bb5\u5bbd\u5ea6\u7684\u5341\u8fdb\u5236\u6574\u6570\uff0c\u5305\u62ec\u4efb\u4f55\u524d\u7f00\u3001\u5206\u9694\u7b26\u548c\u5176\u4ed6\u683c\u5f0f\u5316\u5b57\u7b26\u3002 \u5982\u679c\u672a\u6307\u5b9a\uff0c\u5219\u5b57\u6bb5\u5bbd\u5ea6\u5c06\u7531\u5185\u5bb9\u786e\u5b9a\u3002 precision \uff1a \u662f\u4e00\u4e2a\u5341\u8fdb\u5236\u6570\u5b57\uff0c\u8868\u793a\u5bf9\u4e8e\u4ee5 'f' and 'F' \u683c\u5f0f\u5316\u7684\u6d6e\u70b9\u6570\u503c\u8981\u5728\u5c0f\u6570\u70b9\u540e\u663e\u793a\u591a\u5c11\u4e2a\u6570\u4f4d\uff0c\u6216\u8005\u5bf9\u4e8e\u4ee5 'g' \u6216 'G' \u683c\u5f0f\u5316\u7684\u6d6e\u70b9\u6570\u503c\u8981\u5728\u5c0f\u6570\u70b9\u524d\u540e\u5171\u663e\u793a\u591a\u5c11\u4e2a\u6570\u4f4d\u3002 \u4e00\u4e9b\u4f7f\u7528\u4f8b\u5b50 1 2 3 4 5 6 7 8 9 10 11 12 'X: {0[0]} ; Y: {0[1]} ' . format ( coord ) #coord=(3,5) # 'X: 3; Y: 5' ' {:<30} ' . format ( 'left aligned' ) # 'left aligned ' ' {:^30} ' . format ( 'centered' ) # ' centered ' ' {:*^30} ' . format ( 'centered' ) # use '*' as a fill char #'***********centered***********' 'Correct answers: {:.2%} ' . format ( points / total ) # 'Correct answers: 86.36%'","title":"\u683c\u5f0f\u5b57\u7b26\u4e32\u8bed\u6cd5"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#f-string","text":"1 f ' { variable : format_spec } '","title":"f-string"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_73","text":"1 2 ' %d %5.3f ' % ( 1 , 2 ) # '1 2.000' \u5b57\u7b26\u4e32\u540e\u7684\u767e\u5206\u53f7\u987b\u662f\u5143\u7ec4\u6216\u5b57\u5178\u3002\u82e5\u662f\u5b57\u5178\uff0c\u5b57\u7b26\u4e32\u4e2d\u7684\u767e\u5206\u53f7\u5e94\u8be5\u5199\u6210 %(key)d \u7684\u5f62\u5f0f\u3002\uff08\u800c\u4e14\u5b57\u5178\u952e\u5fc5\u987b\u662f\u5b57\u7b26\u4e32\u624d\u884c\uff09 https://docs.python.org/zh-cn/3/library/stdtypes.html#old-string-formatting","title":"\u65e7\u683c\u5f0f\u5316\u65b9\u6cd5"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_74","text":"","title":"\u89e3\u5305"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#id","text":"","title":"\uff08\u6574\u6570\u7684\uff09id"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_75","text":"","title":"\u6761\u4ef6\u5224\u65ad\u548c\u5faa\u73af"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_76","text":"","title":"\u7b2c\u4e09\u65b9\u5e93"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#request","text":"","title":"Request"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#panda","text":"1 import pandas as pd","title":"Panda"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#dataframe","text":"\u4e8c\u7ef4\u8868\u683c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 df = pd.DataFrame( { \"Name\": [ \"Braund, Mr. Owen Harris\", \"Allen, Mr. William Henry\", \"Bonnell, Miss. Elizabeth\", ], \"Age\": [22, 35, 58], \"Sex\": [\"male\", \"male\", \"female\"], } ) Name Age Sex 0 Braund, Mr. Owen Harris 22 male 1 Allen, Mr. William Henry 35 male 2 Bonnell, Miss. Elizabeth 58 female","title":"Dataframe"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#series","text":"\u6bcf\u4e00\u5217\u5c31\u662f\u4e00\u4e2aSeries 1 2 3 4 5 6 df [ \"Age\" ] 0 22 1 35 2 58 Name : Age , dtype : int64 1 ages = pd . Series ([ 22 , 35 , 58 ], name = \"Age\" )","title":"Series"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#conda","text":"","title":"conda"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#powershell","text":"https://github.com/conda/conda/issues/8428 https://blog.csdn.net/z_dmsd/article/details/107394983 https://zhuanlan.zhihu.com/p/89356758 \u5728powershell\u4e2d\u8fd0\u884c\u8bf7\u5148 1 2 3 4 5 powershell -ExecutionPolicy Bypass Set-ExecutionPolicy -ExecutionPolicy RemoteSigned ... conda init powershell ...","title":"\u5728powershell\u4e0b\u8fd0\u884c"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_77","text":"https://www.jianshu.com/p/f14ac62bef99 1 conda clean -a","title":"\u6e05\u6d01"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_78","text":"\u521b\u5efa\u73af\u5883\u3001\u5220\u9664\u3001\u6fc0\u6d3b\u548c\u9000\u51fa\uff0c\u5b89\u88c5\u5305 1 2 3 4 5 conda create -n ngs python=3.8 conda remove -n ngs --all conda activate ngs conda deactivate conda install package","title":"\u73af\u5883"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#_79","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 # to search for packages conda search [package] # To update all packages conda update --all --yes # List all packages installed conda list [-n env] # conda list environments conda env list # create new env conda create -n [name] package [package] ... # activate env conda activate [name] # deavtivate env conda deactivate # view conda configuration information conda --version conda info conda info --envs","title":"\u5e38\u7528\u547d\u4ee4"},{"location":"old/%E5%AD%A6%E4%B8%8D%E6%9D%A5Python/#pip","text":"1 pip --default-timeout = 100 --no-cache-dir install matplotlib -i https://mirrors.aliyun.com/pypi/simple/ \u6362\u6e90\u53c2\u8003\uff1a https://blog.csdn.net/weixin_41524411/article/details/114191177 \u7f13\u5b58\uff1a https://reality0ne.com/pip-cahce-dir/ \u7f13\u5b58\u4fdd\u5b58\u5728\u5f53\u524d\u7528\u6237home\u4e0b\u7684.cache\u4e2d\u3002\u8981\u907f\u514dcache\u53ef\u4ee5\u7528--no-cache-dir","title":"pip"},{"location":"old/%E8%87%AA%E5%88%B6Template/","text":"\u81ea\u5236Template \u00b6 \u89c4\u8303 \u00b6 \u6570\u636e\u7ed3\u6784\uff1a\u4f7f\u7528namespace+struct\u5c01\u88c5\u3002 \u6563\u88c5\u51fd\u6570\uff1a\u4f7f\u7528namespace\u5c01\u88c5 \u65b9\u6cd5\u3001\u51fd\u6570\u524d\u4f7f\u7528\u6ce8\u91ca\u63cf\u8ff0\u529f\u80fd\u3001\u5f62\u53c2\u8bf4\u660e\u548c\u8fd4\u56de\u503c\u8bf4\u660e namespace \u6700\u5f00\u5934\u662f\u5e38\u91cf\u5b9a\u4e49\uff08\u6bd4\u5982MAXsize\u4e4b\u7c7b\u7684\uff09\uff0c\u7136\u540e\u4f7f\u7528\u7a7a\u884c\u548c\u6ce8\u91ca\u533a\u5206local\u53d8\u91cf\u548cpublic\u53d8\u91cf \u4ec5struct\u6216namespace\u5185\u4f7f\u7528\u7684\u51fd\u6570\u4f7f\u7528\u53cc\u4e0b\u5212\u7ebf\u5f00\u5934 namespace\u4e2d\u7684\u53d8\u91cf\u540d\u4e5f\u8bf7\u4f7f\u7528\u6ce8\u91ca\u7b80\u8981\u8bf4\u660e\u53d8\u91cf\u7528\u9014 \u5f85\u8ba8\u8bba \u00b6 \u56fe\u8bba\uff1a\u90bb\u63a5\u8868\u683c\u5f0f\uff1f [\u7b97\u6cd5\u540d] \u00b6 \u7b97\u6cd5\u63cf\u8ff0\uff1a\u8f93\u5165\u63a5\u53e3\u3001\u8fd0\u884c\u7b97\u6cd5\u9700\u8981\u7684\u64cd\u4f5c\u3001\u8f93\u51fa\u63a5\u53e3\u3001\u65f6\u95f4\u590d\u6742\u5ea6 Funs || Methods Reliance Description Time Complexity Inputs Outputs or Returns \u5b57\u7b26\u4e32 \u00b6 KMP(OLD) \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include <iostream> #include <cstring> using namespace std ; const int N = 1e6 + 10 ; char a [ N ], b [ N ]; int inext [ N ], f [ N ]; void prenext ( int n ) //n: length of A \uff08\u6a21\u5f0f\u4e32\uff09 { inext [ 1 ] = 0 ; for ( int i = 2 , j = 0 ; i <= n ; i ++ ) { while ( j > 0 && a [ i ] != a [ j + 1 ]) j = inext [ j ]; if ( a [ i ] == a [ j + 1 ]) j ++ ; //extendable inext [ i ] = j ; } } void match ( int n , int m ) // n : length of A \uff08 \u6a21\u5f0f\u4e32 \uff09 ; m : length of B \uff08 \u4e3b\u4e32 \uff09 { for ( int i = 1 , j = 0 ; i <= m ; i ++ ) { while ( j > 0 && ( j == n || b [ i ] != a [ j + 1 ])) j = inext [ j ]; if ( b [ i ] == a [ j + 1 ]) j ++ ; f [ i ] = j ; if ( f [ i ] == n ) //Match { cout << i - n + 1 << endl ; } } } int main () { ios :: sync_with_stdio ( false ); a [ 0 ] = b [ 0 ] = '?' ; //cin>>b+1>>a+1; cin >> ( a + 1 ); int la = strlen ( a ) -1 , lb = strlen ( b ) -1 ; prenext ( la ); //match(la,lb); for ( int i = 1 ; i <= la ; i ++ ) { cout << inext [ i ] << \" \" ; } return 0 ; } EXKMP \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <cstdlib> #include <algorithm> #include <string> #include <vector> #include <map> #include <unordered_map> #include <set> #include <unordered_set> #include <queue> using namespace std ; typedef long long ll ; const int Mod = 10007 ; namespace EXKMP { const int N = 2e5 + 10 ; int z [ N ], extend [ N ]; char a [ N ], b [ N ]; int a_len , b_len ; //z,ext:b\u4e32\u5173\u4e8e\u81ea\u5df1\u7684\u6bcf\u4e2a\u4f4d\u7f6e\u7684lcp\uff08\u6700\u957f\u516c\u5171\u524d\u7f00\uff09\u957f\u5ea6\uff0ca\u4e32\u5173\u4e8eb\u4e32\u7684\u6700\u957f\u516c\u5171\u524d\u7f00\u957f\u5ea6 //a\uff0cb\uff1a\u4e32\uff08b\u662f\u6a21\u5f0f\u4e32\uff09 //a_len, b_len\uff1a \u4e32\u957f //\u6c42\u51fab\u7684z\u51fd\u6570\uff081\u53f7\u4f4d\u7f6e\u4e0d\u662f\u826f\u5b9a\u4e49\u7684\uff09 void get_z ( char b [], int n = b_len ) { int l = 1 , r = 1 ; z [ 1 ] = n ; //undefined for ( int i = 2 ; i <= n ; i ++ ) { z [ i ] = 0 ; if ( i <= r ) z [ i ] = min ( z [ i - l + 1 ], r - i + 1 ); //init while ( i + z [ i ] <= n && b [ z [ i ] + 1 ] == b [ i + z [ i ]]) //i+z[i] is next position, so accessible pos is i+z[i]-1 z [ i ] ++ ; if ( i + z [ i ] -1 > r ) l = i , r = i + z [ i ] -1 ; } } //\u6c42\u51faa\u5173\u4e8eb\u7684ext\u6570\u7ec4 void exkmp ( char a [], char b [], int m = a_len , int n = b_len ) { extend [ 1 ] = 0 ; while ( 1 + extend [ 1 ] <= m && a [ 1 + extend [ 1 ]] == b [ 1 + extend [ 1 ]]) extend [ 1 ] ++ ; int l = 1 , r = 1 ; for ( int i = 2 ; i <= m ; i ++ ) { extend [ i ] = 0 ; if ( i <= r ) extend [ i ] = min ( z [ i - l + 1 ], r - i + 1 ); while ( i + extend [ i ] <= m && b [ extend [ i ] + 1 ] == a [ i + extend [ i ]]) extend [ i ] ++ ; if ( i + extend [ i ] -1 > r ) l = i , r = i + extend [ i ] -1 ; } } } using namespace EXKMP ; int T ; int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ), cout . tie ( 0 ); cin >> T ; for ( int _ = 1 ; _ <= T ; _ ++ ) { cin >> b_len ; cin >> b + 1 ; get_z ( b , b_len ); //exkmp(a,b,a_len,b_len) ll ans = 0 ; for ( int i = 1 ; i <= b_len ; i ++ ) { // cout<<z[i]<<\"-\\n\"; ans = ( ans + z [ i ]) % Mod ; } cout << ans << endl ; } return 0 ; } \u6700\u5c0f\u8868\u793a\u6cd5 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include <iostream> using namespace std ; const int N = 6e5 + 7 ; int n , a [ N ]; int minimal_expression () { int i = 1 , j = 2 ; while ( i <= n && j <= n ) { int k = 0 ; for (; k < n && a [ i + k ] == a [ j + k ]; k ++ ); if ( k == n ) break ; if ( a [ i + k ] > a [ j + k ]) { i = i + k + 1 ; i += ( i == j ); } else { j = j + k + 1 ; j += ( i == j ); } } return min ( i , j ); } int main () { ios :: sync_with_stdio ( false ); cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> a [ i ]; a [ n + i ] = a [ i ]; } for ( int i = minimal_expression (), j = 1 ; j <= n ; i ++ , j ++ ) { cout << a [ i ] << \" \" ; } return 0 ; } Manacher\uff08\u5206\u5f00\u6c42\u89e3\u6cd5\uff09 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 //luogu3805 \u9a6c\u62c9\u8f66 \u5206\u5f00\u6c42\u89e3\u6cd5 #include <iostream> #include <cstring> #include <memory.h> using namespace std ; namespace Manacher { const int N = 1.1e7 + 100 ; //public char s [ N ]; int len ; int d1 [ N ], d2 [ N ]; //s:\u539f\u5b57\u7b26\u4e32 //len:s\u7684\u4e32\u957f //d1,d2\uff1a\u5947\u6570\u4f4d\u7f6e\uff0c\u5076\u6570\u4f4d\u7f6e\uff08\u4e24\u4e2a\u5b57\u7b26\u4e2d\u95f4\uff09\u7684\u56de\u6587\u534a\u5f84\u3002 //\u5bf9\u4e8ed2\uff0c\u4e0b\u6807i\u8868\u793a\u7684\u662f\u5939\u5728i~i+1\u4e4b\u95f4\u7684\u4f4d\u7f6e\u4e3a\u4e2d\u5fc3\u7684\u56de\u6587\u534a\u5f84 void get_d1 () { d1 [ 1 ] = 1 ; int l = 1 , r = 1 ; for ( int i = 2 ; i <= len ; i ++ ) { int k = ( i > r ) ? 1 : min ( d1 [ l + r - i ], r - i + 1 ); while ( 1 <= i - k && i + k <= len && s [ i - k ] == s [ i + k ]) k ++ ; d1 [ i ] = k ; if ( i + k - 1 > r ) { r = i + k - 1 ; l = i - k + 1 ; } } } void get_d2 () { d2 [ 0 ] = 0 ; int l = 0 , r = -1 ; for ( int i = 1 ; i <= len ; i ++ ) { int k = ( i >= r ) ? 0 : min ( d2 [ l + r - i - 1 ], r - i ); while ( 1 <= i - k && i + k + 1 <= len && s [ i - k ] == s [ i + k + 1 ]) k ++ ; d2 [ i ] = k ; if ( i + k > r ) { r = i + k ; l = i - k + 1 ; } } } } using namespace Manacher ; int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); cin >> s + 1 ; len = strlen ( s + 1 ); get_d1 (); get_d2 (); int ans = 1 ; for ( int i = 1 ; i <= len ; i ++ ) { ans = max ( ans , d1 [ i ] * 2 - 1 ); ans = max ( ans , d2 [ i ] * 2 ); } cout << ans << endl ; return 0 ; } \u9a6c\u62c9\u8f66\uff08\u63d2\u5165\u4e95\u53f7\u6cd5\uff09 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 //luogu3805 \u9a6c\u62c9\u8f66 \u63d2\u5165\u4e95\u53f7\u6cd5 #include <iostream> #include <cstring> #include <memory.h> using namespace std ; const int N = 1.1e7 + 100 ; char s [ N ], s2 [ N * 2 ]; int n , nn ; int d1 [ N * 2 ]; void get_d1 () { nn = 1 ; s2 [ 0 ] = '$' ; s2 [ 1 ] = '#' ; for ( int i = 1 ; i <= n ; i ++ ) { s2 [ ++ nn ] = s [ i ]; s2 [ ++ nn ] = '#' ; } d1 [ 1 ] = 1 ; int l = 1 , r = 1 ; for ( int i = 2 ; i <= nn ; i ++ ) { int k = ( i > r ) ? 1 : min ( d1 [ l + r - i ], r - i + 1 ); while ( 1 <= i - k && i + k <= nn && s2 [ i - k ] == s2 [ i + k ]) k ++ ; d1 [ i ] = k ; if ( i + k -1 > r ) { r = i + k -1 ; l = i - k + 1 ; } } } int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); cin >> s + 1 ; n = strlen ( s + 1 ); get_d1 (); int ans = 0 ; for ( int i = 1 ; i <= nn ; i ++ ) { ans = max ( ans , d1 [ i ] -1 ); } cout << ans << endl ; return 0 ; } \u540e\u7f00\u6570\u7ec4\uff08SA\uff09 \u00b6 sa\u662f\u5b57\u7b26\u4e32s\u7684\u6bcf\u4e00\u4e2a\u540e\u7f00\u7684\u6392\u540d\u5230\u5b57\u7b26\u4e32s\u4e2d\u7684\u4e0b\u6807\u7684\u6620\u5c04\u6570\u7ec4\u3002rk\u662f\u6bcf\u4e00\u4e2a\u540e\u7f00\u7684\u4e0b\u6807\u5230\u6392\u540d\u7684\u6620\u5c04\u6570\u7ec4\u3002ht\u662f\u7b2ci\u540d\u548c\u7b2ci-1\u540d(\u6ce8\u610f\u662f\u6392\u540d)\u7684\u6700\u957f\u516c\u5171\u524d\u7f00\u957f\u5ea6\u3002 \u8f93\u5165\u5b57\u7b26\u4e32s\u548c\u957f\u5ea6len\uff0c\u8c03\u7528get_sa\u548cget_ht\uff0c\u5f97\u5230\u7684sa\u3001rk\u3001ht\u6570\u7ec4\u3002 Funs || Methods Reliance Time Complexity Inputs Outputs Description get_sa nlogn \u8f93\u5165s\u7684\u957f\u5ea6len\uff1b\u5b57\u7b26\u4e32s\u3002 \u4fee\u6539sa\u3001rk\u6570\u7ec4\u4f5c\u4e3a\u8f93\u51fa\u3002 \u5f97\u5230\u540e\u7f00\u6570\u7ec4sa\u3001rk get_ht get_sa n \u8f93\u5165s\u7684\u957f\u5ea6len\uff1b\u6570\u7ec4sa\u548cht\u3002 \u4fee\u6539\u6570\u7ec4ht\u4f5c\u4e3a\u8f93\u51fa\u3002 \u5f97\u5230\u540e\u7f00\u6570\u7ec4ht 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 #include <iostream> #include <cstdio> #include <cstring> #include <memory.h> using namespace std ; //\u540e\u7f00\u6570\u7ec4\uff1a\u8f93\u5165\u5b57\u7b26\u4e32s\u548c\u5176\u957f\u5ea6len\uff0c\u6267\u884cget_sa\u3001get_ht\uff0c\u8fd4\u56de\u5b57\u7b26\u4e32\u7684sa\u3001rk\u3001ht\u6570\u7ec4\u3002\u590d\u6742\u5ea6nlogn\u3002 namespace SA { const int N = 1e6 + 5 , M = 300 ; //N\uff1a\u957f\u5ea6\u4e0a\u9650 M\uff1a\u5b57\u7b26\u96c6\u5927\u5c0f //public char s [ N ]; //s:\u5b57\u7b26\u4e32 int len ; //len:\u7684\u957f\u5ea6 int sa [ N ], rk [ N ], ht [ N ]; //sa\u3001rk\u3001ht\u6570\u7ec4 //sa: \u6392\u540d -> \u4e0b\u6807 //rk: \u4e0b\u6807 -> \u6392\u540d //local int oldrk [ N * 2 ], id [ N ], px [ N ], cnt [ N ]; //id: (\u6309\u7b2c\u4e8c/\u7b2c\u4e00\u5173\u952e\u5b57\u6392\u5e8f\u540e\u7684)\u6392\u540d->\u4e0b\u6807(\u4e34\u65f6\u6570\u7ec4) //px: rk[id[i]], \u5728\u6309\u7b2c\u4e00\u5173\u952e\u5b57\u6392\u5e8f\u65f6,\u7b49\u4ef7\u4e8e\u7b2c\u4e8c\u5173\u952e\u5b57\u6392\u540d->\u4e0b\u6807-> w-1\u65f6\u8be5\u4e0b\u6807\u5904\u7684\u6392\u540d //ht: height\u6570\u7ec4 //\u5224\u65ad\u65e7rk\u6570\u7ec4\u4e2d\u5bf9\u5e94\u7684\u4e24\u4e2a\u4f4d\u7f6ex\u3001y\u4ee5\u53cax+w\u3001y+w\u662f\u5426\u76f8\u7b49 bool __is_equal ( int x , int y , int w ) { return oldrk [ x ] == oldrk [ y ] && oldrk [ x + w ] == oldrk [ y + w ]; } //\u8f93\u5165s\u7684\u957f\u5ea6len\uff0c\u4fee\u6539sa\u6570\u7ec4\u4f5c\u4e3a\u8f93\u51fa void get_sa ( int len = len ) { //\u8ba1\u6570\u6392\u5e8f //\u7b2c\u4e00\u6b21\u6392\u5e8f\uff08w=0\uff09 int m = M , p = 0 ; for ( int i = 1 ; i <= len ; i ++ ) cnt [ rk [ i ] = s [ i ]] ++ ; for ( int i = 1 ; i <= m ; i ++ ) cnt [ i ] += cnt [ i - 1 ]; //\u524d\u7f00\u548c for ( int i = len ; i >= 1 ; i -- ) sa [ cnt [ rk [ i ]] -- ] = i ; for ( int w = 1 ; w < len ; w <<= 1 , m = p ) { p = 0 ; for ( int i = len ; i > len - w ; i -- ) //\u7b2c\u4e8c\u5173\u952e\u5b57\u65e0\u7a77\u5c0f\u7684\u5148\u653e { id [ ++ p ] = i ; } for ( int i = 1 ; i <= len ; i ++ ) if ( sa [ i ] > w ) id [ ++ p ] = sa [ i ] - w ; // i:\u6392\u540d, sa[i]:\u4e0b\u6807, sa[i]-w \u4e0b\u6807\u504f\u79fb //\u8fd9\u91ccsa\u662fw-1\u65f6\u7684,\u56e0\u6b64sa\u770b\u4f5c\u662fw\u65f6\u7684\u7b2c\u4e8c\u5173\u952e\u5b57\u7684\u6392\u540d->\u4e0b\u6807\u6620\u5c04,\u5219sa[i]-w\u662f\u6b64\u65f6\u7b2c\u4e00\u5173\u952e\u5b57\u7684\u4e0b\u6807 //id\u4e0d\u518d\u8fd4\u5b58\u56desa\u6570\u7ec4\u4e2d memset ( cnt , 0 , sizeof ( cnt )); for ( int i = 1 ; i <= len ; i ++ ) cnt [ px [ i ] = rk [ id [ i ]]] ++ ; for ( int i = 1 ; i <= m ; i ++ ) cnt [ i ] += cnt [ i - 1 ]; for ( int i = len ; i >= 1 ; i -- ) sa [ cnt [ px [ i ]] -- ] = id [ i ]; memcpy ( oldrk , rk , sizeof ( rk )); p = 0 ; for ( int i = 1 ; i <= len ; i ++ ) { rk [ sa [ i ]] = __is_equal ( sa [ i ], sa [ i - 1 ], w ) ? p : ++ p ; } } } //(get_sa)\u5f97\u5230\u540e\u7f00\u6570\u7ec4ht\uff1a\u8f93\u5165s\u7684\u957f\u5ea6len\u3001\u6570\u7ec4sa\u548cht\uff0c\u4fee\u6539\u6570\u7ec4ht\u4e3a\u7ed3\u679c void get_ht ( int len = len ) { int k = 0 ; //\u4e0a\u4e00ht\u503c for ( int i = 1 ; i <= len ; i ++ ) { if ( k ) k -- ; // k>=0 while ( s [ i + k ] == s [ sa [ rk [ i ] - 1 ] + k ]) //\u6839\u636e\u5b9a\u4e49\u66b4\u529b\u6c42 { k ++ ; } ht [ rk [ i ]] = k ; } } } // namespace SA using namespace SA ; int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ), cout . tie ( 0 ); cin >> s + 1 ; len = strlen ( s + 1 ); get_sa (); get_ht (); for ( int i = 1 ; i <= len ; i ++ ) cout << sa [ i ] << \" \" ; return 0 ; } \u5f8c\u7db4\u81ea\u52d5\u6a5f \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u53ea\u5305\u542b\u5c0f\u5199\u5b57\u6bcd\u7684\u5b57\u7b26\u4e32S,\u8bf7\u4f60\u6c42\u51fa S \u7684\u6240\u6709\u51fa\u73b0\u6b21\u6570\u4e0d\u4e3a 1 \u7684\u5b50\u4e32\u7684\u51fa\u73b0\u6b21\u6570\u4e58\u4e0a\u8be5\u5b50\u4e32\u957f\u5ea6\u7684\u6700\u5927\u503c\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 //luogu 3804 #include <iostream> #include <cstdio> #include <memory.h> #include <cstring> #include <queue> using namespace std ; const int N = 2e6 + 5 ; struct SAM_NODE { int inext [ 26 ], len , link , siz ; } sam [ N ]; int total , last ; char s [ N ]; int len ; void sam_init () { sam [ 0 ]. len = sam [ 0 ]. siz = 0 ; sam [ 0 ]. link = -1 ; memset ( sam [ 0 ]. inext , 0 , sizeof ( sam [ 0 ]. inext )); total = last = 0 ; } void sam_extend ( char c ) { int cur =++ total , cc = c - 'a' ; sam [ cur ]. len = sam [ last ]. len + 1 ; int p = last ; while ( p != -1 && ! sam [ p ]. inext [ cc ]) { sam [ p ]. inext [ cc ] = cur ; //\u8fd8\u6ca1\u6709\u5230\u5b57\u7b26c\u7684\u8f6c\u79fb\uff0c\u6211\u4eec\u5c31\u6dfb\u52a0\u4e00\u4e2a\u5230\u72b6\u6001c\u7684\u8f6c\u79fb p = sam [ p ]. link ; } if ( p == -1 ) //\u672a\u627e\u5230\u73b0\u6709\u8f6c\u79fb sam [ cur ]. link = 0 ; else //\u5df2\u7ecf\u627e\u5230\u73b0\u6709\u8f6c\u79fb { int q = sam [ p ]. inext [ cc ]; if ( sam [ p ]. len + 1 == sam [ q ]. len ) //\u8fde\u7eed\u8f6c\u79fb sam [ cur ]. link = q ; else //\u4e0d\u8fde\u7eed\u8f6c\u79fb { int clone =++ total ; sam [ clone ]. len = sam [ p ]. len + 1 ; memcpy ( sam [ clone ]. inext , sam [ q ]. inext , sizeof ( sam [ q ]. inext )); sam [ clone ]. link = sam [ q ]. link ; while ( p != -1 && sam [ p ]. inext [ cc ] == q ) { sam [ p ]. inext [ cc ] = clone ; p = sam [ p ]. link ; } sam [ q ]. link = sam [ cur ]. link = clone ; } } last = cur ; sam [ cur ]. siz = 1 ; // \u6807\u8bb0\u7ec8\u70b9\u8282\u70b9 } void sam_marksuf () { int p = last ; while ( p != -1 ) { //...\u5411\u6807\u8bb0\u6570\u7ec4\u5199\u5165 p = sam [ p ]. link ; } } void sam_traverse ( int x = 0 ) //\u8c03\u8bd5\u7528\uff0c\u8f93\u51fasam\u7ed3\u6784 { cout << x << \":\" ; for ( int i = 0 ; i < 26 ; i ++ ) { //\u8f6c\u79fb\u5b57\u7b26 \u6807\u53f7 if ( sam [ x ]. inext [ i ]) cout << ( char )( 'a' + i ) << sam [ x ]. inext [ i ] << \" \" ; } cout << endl ; for ( int i = 0 ; i < 26 ; i ++ ) if ( sam [ x ]. inext [ i ]) sam_traverse ( sam [ x ]. inext [ i ]); } void sam_tr_suftree () //\u8c03\u8bd5\u7528\uff0c\u8f93\u51fa\u540e\u7f00\u94fe\u63a5\u6811\u7ed3\u6784 { //\u4ece\u53f6\u5b50\u5230\u6839 for ( int i = 1 ; i <= total ; i ++ ) { if ( sam [ i ]. siz ) { int p = i ; while ( p != -1 ) { cout << p << \" \" ; p = sam [ p ]. link ; } cout << endl ; } } } long long ans = 0 ; int deg [ N ]; void get_size () //\u4ece\u53f6\u5b50\u8282\u70b9\u5f00\u59cbbfs\uff0c\u7d2f\u52a0siz\uff0c\u975e\u53f6\u5b50\u8282\u70b9\u7684siz\u503c\u5c31\u662f\u8fd9\u4e2a\u8282\u70b9\u7684\u7ec8\u70b9\u96c6\u5408\u5927\u5c0f\uff0c\u4e5f\u5373\u8fd9\u4e2a\u8282\u70b9\u5bf9\u5e94\u6700\u957f\u4e32\u51fa\u73b0\u7684\u6b21\u6570 { queue < int > q ; for ( int i = 1 ; i <= total ; i ++ ) { deg [ sam [ i ]. link ] ++ ; /*bool flag=true; for(int j=0;j<26;j++) if(sam[i].inext[j]) {flag=false;break;} if(flag) q.push(i);*/ //\u5144\u554a\u8fd9\u4e48\u5199\u6839\u672c\u548clink\u6ca1\u5173\u7cfb\u554a\uff01 } for ( int i = 1 ; i <= total ; i ++ ) if ( deg [ i ] == 0 ) q . push ( i ); while ( q . size ()) { int x = q . front (); q . pop (); sam [ sam [ x ]. link ]. siz += sam [ x ]. siz ; deg [ sam [ x ]. link ] -- ; if ( deg [ sam [ x ]. link ] == 0 ) q . push ( sam [ x ]. link ); } } int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ), cout . tie ( 0 ); cin >> s + 1 ; len = strlen ( s + 1 ); sam_init (); for ( int i = 1 ; i <= len ; i ++ ) sam_extend ( s [ i ]); //sam_traverse(0); //sam_tr_suftree(); get_size (); for ( int i = 1 ; i <= total ; i ++ ) if ( sam [ i ]. siz >= 2 ) ans = max ( ans ,( long long ) sam [ i ]. siz * sam [ i ]. len ); cout << ans << endl ; return 0 ; } \u5b57\u7b26\u4e32\u5468\u671f\uff1f \u00b6 2017-2018 ACM-ICPC, Asia Daejeon Regional Contest \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a\u7ed9\u51fa\u4e00\u4e2a\u957f\u5ea6\u4e3a \\(n\\) \u7684\u5e8f\u5217 \\(a_i\\) \uff0c\u8fd9\u4e2a\u5e8f\u5217\u7b2c \\(k+1\\) \u8d77\u5230\u6700\u540e\u662f\u82e5\u5e72\u4e2a\u5faa\u73af\uff0c\u5468\u671f\u4e3a \\(p\\) \uff0c\u6700\u540e\u4e00\u4e2a\u5faa\u73af\u53ef\u4ee5\u4e0d\u5b8c\u6574\u3002\u6c42 \\(k+p\\) \u6700\u5c0f\u503c\u5bf9\u5e94\u7684 \\(k, p\\) \u3002 solution \u5c06\u5e8f\u5217 \\(a_i\\) \u7ffb\u8f6c\uff0c\u505a\u4e00\u6b21 \\(KMP\\) ( \\(fail[i]\\) )\uff0c\u679a\u4e3e \\(k+1\\) \u7684\u4f4d\u7f6e \\(i\\) \uff0c\u5219\u5468\u671f \\(p=i-fail[i], k=n-i\\) \u3002\u66f4\u65b0\u7b54\u6848\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include <bits/stdc++.h> using namespace std ; int n ; int a [ 1000010 ]; int nnext [ 1000010 ]; int k = 10000000 , p = 10000000 ; void cal_next () { nnext [ 1 ] = 0 ; for ( int i = 2 , j = 0 ; i <= n ; i ++ ) { while ( j > 0 && a [ i ] != a [ j + 1 ]) j = nnext [ j ]; if ( a [ j + 1 ] == a [ i ]) j ++ ; nnext [ i ] = j ; } } int main () { cin >> n ; for ( int i = n ; i >= 1 ; i -- ) scanf ( \"%d\" , & a [ i ]); cal_next (); for ( int i = 1 ; i <= n ; i ++ ) { int tempk = n - i , tempp = i - nnext [ i ] + 1 ; if ( tempk + tempp < k + p ) { k = tempk ; p = tempp ; } } cout << k << \" \" << p -1 ; return 0 ; } 2021 CCPC \u5973\u751f\u8d5b F \u00b6 \u4e0d\u96be\u53d1\u73b0\u884c\u4e0e\u5217\u662f\u4e24\u4e2a\u72ec\u7acb\u7684\u95ee\u9898\uff0c\u56e0\u6b64\u53ea\u9700\u8981\u6c42\u51fa\u884c\u7684\u6700\u77ed\u5faa\u73af\u8282\u7684\u957f\u5ea6\uff0c\u518d\u6c42\u51fa\u5217\u7684 \u6700\u77ed\u5faa\u73af\u8282\u7684\u957f\u5ea6\uff0c\u76f8\u4e58\u5c31\u662f\u7b54\u6848\u3002 \u4ee5\u884c\u4e3a\u4f8b\uff0c\u9996\u5148\u901a\u8fc7 Hash \u5c06\u95ee\u9898\u8f6c\u5316\u4e3a\u4e00\u7ef4\u95ee\u9898\u3002\u4e00\u7ef4\u95ee\u9898\u5219\u662f\u7ecf\u5178\u95ee\u9898\uff0c\u5bf9\u4e8e\u4e00\u4e2a\u957f \u5ea6\u4e3a n \u7684\u5b57\u7b26\u4e32\uff0c\u957f\u5ea6\u4e3a d \u7684\u524d\u7f00\u662f\u5faa\u73af\u8282\u5f53\u4e14\u4ec5\u5f53\u957f\u5ea6\u4e3a n \u2212 d \u7684\u524d\u540e\u7f00\u76f8\u7b49\uff0c\u56e0\u6b64\u9700\u8981\u627e\u5230\u8fd9\u4e2a\u5b57\u7b26\u4e32\u6700\u957f\u7684\u524d\u7f00\uff0c\u6ee1\u8db3\u8be5\u524d\u7f00\u4e5f\u662f\u8be5\u5b57\u7b26\u4e32\u7684\u540e\u7f00\u3002\u53ef\u4ee5\u679a\u4e3e\u6240\u6709\u53ef\u80fd\u7684 d \u7136\u540e\u4f7f\u7528Hash O(1) \u5224\u65ad\uff1b\u4e5f\u53ef\u4ee5\u4f7f\u7528 KMP \u7b97\u6cd5\u6c42\u51fa nxt \u6570\u7ec4\uff0c\u7b54\u6848\u5373\u4e3a n \u2212 nxt[n]\u3002 \u65f6\u95f4\u590d\u6742\u5ea6 O(n^2 + qn)\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 #include <bits/stdc++.h> using namespace std ; string a [ 2010 ]; const int P = 131 ; long long p [ 2010 ]; long long hashrow [ 2010 ][ 2010 ], hashcol [ 2010 ][ 2010 ]; long long drow [ 2010 ], dcol [ 2010 ]; int n , q ; int nex [ 2010 ]; void getnex ( long long s [], long long len ) { int i = 0 ; int j = -1 ; nex [ 0 ] = -1 ; while ( i < len ) { if ( j == -1 || s [ i ] == s [ j ]) { i ++ ; j ++ ; nex [ i ] = j ; } else j = nex [ j ]; } } int main () { cin >> n >> q ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> a [ i ]; a [ i ] = \" \" + a [ i ]; } p [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) p [ i ] = p [ i -1 ] * P ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { hashrow [ i ][ j ] = hashrow [ i -1 ][ j ] * P + a [ i ][ j ] - 'a' ; hashcol [ i ][ j ] = hashcol [ i ][ j -1 ] * P + a [ i ][ j ] - 'a' ; } } for ( int t = 1 ; t <= q ; t ++ ) { long long x1 , y1 , x2 , y2 ; cin >> x1 >> y1 >> x2 >> y2 ; long long ans1 = 0 , ans2 = 0 ; for ( int j = y1 ; j <= y2 ; j ++ ) drow [ j - y1 ] = hashrow [ x2 ][ j ] - hashrow [ x1 -1 ][ j ] * p [ x2 - x1 + 1 ], nex [ j - y1 ] = 0 ; getnex ( drow , y2 - y1 + 1 ); ans1 = y2 - y1 + 1 - nex [ y2 - y1 + 1 ]; for ( int i = x1 ; i <= x2 ; i ++ ) dcol [ i - x1 ] = hashcol [ i ][ y2 ] - hashcol [ i ][ y1 -1 ] * p [ y2 - y1 + 1 ], nex [ i - x1 ] = 0 ; getnex ( dcol , x2 - x1 + 1 ); ans2 = x2 - x1 + 1 - nex [ x2 - x1 + 1 ]; cout << ans1 * ans2 << endl ; } return 0 ; } AC \u81ea\u52a8\u673a \u00b6 luogu 3796 AC\u81ea\u52a8\u673a\uff08\u52a0\u5f3a\u7248\uff09 \u00b6 \u6709N\u4e2a\u7531\u5c0f\u5199\u5b57\u6bcd\u7ec4\u6210\u7684\u6a21\u5f0f\u4e32\u4ee5\u53ca\u4e00\u4e2a\u6587\u672c\u4e32 T\u3002\u6bcf\u4e2a\u6a21\u5f0f\u4e32\u53ef\u80fd\u4f1a\u5728\u6587\u672c\u4e32\u4e2d\u51fa\u73b0\u591a\u6b21\u3002\u4f60\u9700\u8981\u627e\u51fa\u54ea\u4e9b\u6a21\u5f0f\u4e32\u5728\u6587\u672c\u4e32 T \u4e2d\u51fa\u73b0\u7684\u6b21\u6570\u6700\u591a\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 #include <iostream> #include <cstdio> #include <memory.h> #include <queue> using namespace std ; const int N = 1e6 + 10 ; int n ; char s [ 151 ][ 100 ], t [ N ]; int trie [ N ][ 26 ], total , id [ N ], fail [ N ], last [ N ]; int cnt [ N ]; void insert ( char * s , int num ) { int u = 0 ; for ( int i = 1 ; s [ i ]; i ++ ) { int x = s [ i ] - 'a' ; if ( ! trie [ u ][ x ]) trie [ u ][ x ] =++ total ; u = trie [ u ][ x ]; } id [ u ] = num ; } void build () { queue < int > q ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( trie [ 0 ][ i ]) q . push ( trie [ 0 ][ i ]); } while ( q . size ()) { int u = q . front (); q . pop (); for ( int i = 0 ; i < 26 ; i ++ ) { if ( trie [ u ][ i ]) { fail [ trie [ u ][ i ]] = trie [ fail [ u ]][ i ]; last [ trie [ u ][ i ]] = ( id [ fail [ trie [ u ][ i ]]] == 0 ) ? ( last [ fail [ trie [ u ][ i ]]]) : ( fail [ trie [ u ][ i ]]); //\u6709\u6548\u5b57\u7b26\u4e32\u7ed3\u5c3e q . push ( trie [ u ][ i ]); } else trie [ u ][ i ] = trie [ fail [ u ]][ i ]; } } } void query ( char * s ) { int u = 0 ; for ( int i = 1 ; s [ i ]; i ++ ) { int x = s [ i ] - 'a' ; u = trie [ u ][ x ]; for ( int j = u ; j ; j = last [ j ]) { cnt [ id [ j ]] ++ ; } } } int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ), cout . tie ( 0 ); while ( cin >> n && n ) { memset ( trie , 0 , sizeof ( trie )); memset ( fail , 0 , sizeof ( fail )); memset ( last , 0 , sizeof ( last )); memset ( cnt , 0 , sizeof ( cnt )); memset ( id , 0 , sizeof ( id )); for ( int i = 1 ; i <= n ; i ++ ) { cin >> s [ i ] + 1 ; insert ( s [ i ], i ); } build (); cin >> t + 1 ; query ( t ); int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { ans = max ( ans , cnt [ i ]); } cout << ans << endl ; for ( int i = 1 ; i <= n ; i ++ ) if ( ans == cnt [ i ]) cout << s [ i ] + 1 << endl ; } return 0 ; } \u4e8c\u6b21\u52a0\u5f3a\u7248 \u00b6 \u7ed9\u4f60\u4e00\u4e2a\u6587\u672c\u4e32 S \u548c n \u4e2a\u6a21\u5f0f\u4e32 T_{1..n}\uff0c\u8bf7\u4f60\u5206\u522b\u6c42\u51fa\u6bcf\u4e2a\u6a21\u5f0f\u4e32 T_i\u5728 S \u4e2d\u51fa\u73b0\u7684\u6b21\u6570\u3002 \u8be6\u7ec6\u8bf4\u660e\u89c1OI\u6742\u7b14\u8bb0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 //\u4e8c\u6b21\u52a0\u5f3a\u7248 #include <iostream> #include <cstdio> #include <queue> using namespace std ; const int N = 2e5 + 1 , M = 2e6 + 10 ; int n ; char s [ N ], t [ M ]; int trie [ M / 2 ][ 26 ], total , fail [ M / 2 ]; int id [ M / 2 ], node_ [ N ]; //\u7ed3\u70b9\u548c\u5b57\u7b26\u4e32\u7f16\u53f7\u7684\u6620\u5c04 int delta [ M / 2 ], sum [ M / 2 ]; //\u6811\u4e0a\u5dee\u5206\u6570\u7ec4\uff0c\u5dee\u5206\u6c42\u548c struct E { int to , inext ; } edge [ M / 2 ]; int head [ M / 2 ], e_total ; void adde ( int x , int y ) { edge [ ++ e_total ]. to = y ; edge [ e_total ]. inext = head [ x ]; head [ x ] = e_total ; } void insert ( char * s , int num ) { int u = 0 ; for ( int i = 1 ; s [ i ]; i ++ ) { int x = s [ i ] - 'a' ; if ( ! trie [ u ][ x ]) trie [ u ][ x ] =++ total ; //!! u = trie [ u ][ x ]; } if ( ! id [ u ]) id [ u ] = num ; node_ [ num ] = u ; } void build () { queue < int > q ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( trie [ 0 ][ i ]) q . push ( trie [ 0 ][ i ]); } while ( q . size ()) { int u = q . front (); q . pop (); for ( int i = 0 ; i < 26 ; i ++ ) { if ( trie [ u ][ i ]) { fail [ trie [ u ][ i ]] = trie [ fail [ u ]][ i ]; q . push ( trie [ u ][ i ]); } else { trie [ u ][ i ] = trie [ fail [ u ]][ i ]; } } } for ( int i = 1 ; i <= total ; i ++ ) { adde ( fail [ i ], i ); } } void traverse ( char * s ) { int u = 0 ; for ( int i = 1 ; s [ i ]; i ++ ) { int x = s [ i ] - 'a' ; u = trie [ u ][ x ]; delta [ u ] ++ ; } } void dfs ( int u = 0 ) { sum [ u ] = delta [ u ]; for ( int e = head [ u ]; e ; e = edge [ e ]. inext ) { int y = edge [ e ]. to ; dfs ( y ); sum [ u ] += sum [ y ]; } } int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ), cout . tie ( 0 ); cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> s + 1 ; insert ( s , i ); } build (); cin >> t + 1 ; traverse ( t ); dfs ( 0 ); for ( int i = 1 ; i <= n ; i ++ ) { cout << sum [ node_ [ i ]] << endl ; } return 0 ; } \u52a8\u6001\u89c4\u5212 \u00b6 \u2b50\u51e0\u79cd\u5f62\u6001\u7684\u6570\u4f4dDP \u00b6 \u5f62\u614b1\uff1a\u8a18\u61b6\u5316\u641c\u7d22 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 //CFED50 C classy_numbers //\u984c\u610f\uff1a\u6c42\u89e3L~R\u5167\uff0c\u5341\u9032\u5236\u8868\u793a\u4e0b\u4e0d\u8d85\u904e3\u500b\u6578\u662f\u975e0\u6578\u7684\u500b\u6578 #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <cstdlib> #include <algorithm> #include <string> #include <vector> #include <map> #include <unordered_map> #include <set> #include <unordered_set> #include <queue> using namespace std ; typedef long long ll ; const int N = 2e5 + 10 ; //from left to right, the pos-th digit (start from 1) int s [ 30 ], n ; void getdigit ( ll R ) { if ( R == 0 ) { n = 1 ; s [ 1 ] = 0 ; return ; } n = log10 ( R ) + 1 ; for ( int i = n ; i >= 1 ; i -- ) { s [ i ] = R % 10 ; R /= 10 ; } } //1~n ll dp [ 21 ][ 4 ][ 2 ]; //pos,cnt,limit ll dfs ( int pos , int cnt , int limit ) { if ( pos == n + 1 ) { return dp [ pos ][ cnt ][ limit ] = 1 ; } if ( cnt == 3 ) { return dp [ pos ][ cnt ][ limit ] = 1 ; } if ( dp [ pos ][ cnt ][ limit ] != -1 ) return dp [ pos ][ cnt ][ limit ]; ll ans = 0 ; if ( limit ) { for ( int d = 0 ; d <= s [ pos ]; d ++ ) { ans += dfs ( pos + 1 , cnt + ( d > 0 ), ( d == s [ pos ])); } } else { for ( int d = 0 ; d <= 9 ; d ++ ) { ans += dfs ( pos + 1 , cnt + ( d > 0 ), 0 ); } } return dp [ pos ][ cnt ][ limit ] = ans ; } int T ; int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ), cout . tie ( 0 ); cin >> T ; for ( int _ = 1 ; _ <= T ; _ ++ ) { ll L , R ; cin >> L >> R ; getdigit ( R ); memset ( dp , -1 , sizeof ( dp )); ll Rans = dfs ( 1 , 0 , 1 ); getdigit ( L - 1 ); memset ( dp , -1 , sizeof ( dp )); ll Lans = dfs ( 1 , 0 , 1 ); cout << Rans - Lans << endl ; } return 0 ; } \u5f62\u60012 \u8bd5\u586b\u6cd5 \u00b6 \u4e0d\u898162\uff1a\u533a\u95f4\u5185\u6709\u591a\u5c11\u4e2a\u6570\uff0c\u95ee\u5f53\u4e2d\u6709\u591a\u5c11\u4e2a\u6570\u662f\u5e26\u6709\u8fde\u7eed62\u7684 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 #include <iostream> #include <memory.h> #include <cmath> using namespace std ; int f [ 10 ][ 10 ]; void init () { memset ( f , 0 , sizeof ( f )); for ( int k = 0 ; k <= 9 ; k ++ ) { if ( k != 4 ) f [ 1 ][ k ] = 1 ; } for ( int i = 2 ; i <= 7 ; i ++ ) { for ( int j = 0 ; j <= 9 ; j ++ ) { if ( j != 4 ) { for ( int k = 0 ; k <= 9 ; k ++ ) { if ( j != 6 || ( j == 6 && k != 2 )) { f [ i ][ j ] += f [ i -1 ][ k ]; } } } } } } int take_bit ( int x , int i ) { if ( log10 ( x ) + 1 < i ) return -10 ; //no exist for ( int j = 1 ; j <= i -1 ; j ++ ) x /= 10 ; return x %= 10 ; } int fill ( int x ) { if ( x <= 0 ) return 0 ; int ans = 0 ; for ( int i = log10 ( x ); i >= 1 ; i -- ) { for ( int j = 1 ; j <= 9 ; j ++ ) if ( j != 4 ) ans += f [ i ][ j ]; } for ( int i = log10 ( x ) + 1 ; i >= 1 ; i -- ) { for ( int j = (( i == ( int )( log10 ( x ) + 1 )) ? 1 : 0 );( j < take_bit ( x , i ) || ( i == 1 && j <= take_bit ( x , i ))); j ++ ) { if ( j == 4 ) continue ; if ( take_bit ( x , i + 1 ) == 6 && j == 2 ) continue ; if ( i >= 2 ) { for ( int k = 0 ; k <= 9 ; k ++ ) { if ( k == 4 ) continue ; if ( j == 6 && k == 2 ) continue ; ans += f [ i -1 ][ k ]; } } else { ans ++ ; } } if ( take_bit ( x , i ) == 4 ) break ; if ( take_bit ( x , i + 1 ) == 6 && take_bit ( x , i ) == 2 ) break ; } return ans ; } int main () { int n , m ; init (); while ( 1 ) { cin >> n >> m ; if ( n == 0 && m == 0 ) break ; cout << fill ( m ) - fill ( n -1 ) << endl ; } return 0 ; } \u9b54\u9b3c\u6570 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #include <iostream> using namespace std ; long long f [ 30 ][ 4 ]; //f[i][0|1|2]:not beastly number; f[i][3];is beastly number void init () { f [ 0 ][ 0 ] = 1 ; for ( int i = 1 ; i <= 20 ; i ++ ) { f [ i ][ 0 ] = 9 * ( f [ i -1 ][ 0 ] + f [ i -1 ][ 1 ] + f [ i -1 ][ 2 ]); f [ i ][ 1 ] = f [ i -1 ][ 0 ]; f [ i ][ 2 ] = f [ i -1 ][ 1 ]; f [ i ][ 3 ] = 10 * f [ i -1 ][ 3 ] + f [ i -1 ][ 2 ]; } } int main () { init (); int t ; cin >> t ; while ( t -- ) { long long x , cnt = 0 , bit = 1 ; cin >> x ; while ( f [ bit ][ 3 ] < x ) bit ++ ; //find out how many bit it have for ( int i = bit , k = 0 ; i >= 1 ; i -- ) { for ( int j = 0 ; j <= 9 ; j ++ ) { int tempcnt = 0 ; tempcnt += f [ i -1 ][ 3 ]; if ( j == 6 && k >= 0 ) tempcnt += f [ i -1 ][ 2 ]; if ( j == 6 && k >= 1 ) tempcnt += f [ i -1 ][ 1 ]; if ( j == 6 && k >= 2 ) tempcnt += f [ i -1 ][ 0 ]; if ( j != 6 && k >= 3 ) tempcnt += ( f [ i -1 ][ 2 ] + f [ i -1 ][ 1 ] + f [ i -1 ][ 0 ]); if ( cnt + tempcnt < x ) cnt += tempcnt ; else { cout << j ; if ( k < 3 ) { if ( j == 6 ) k ++ ; else k = 0 ; } break ; } } } cout << endl ; } return 0 ; } \u6708\u4e4b\u8c1c\uff08\u540c\u7c7b\u5206\u5e03\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 #include <cstdio> #include <cstring> #include <cstdlib> using namespace std ; // f[\u6a21][\u5269\u4f59\u6570\u5b57\u6570\u76ee][\u5269\u4f59\u6570\u5b57\u7684\u548c][\u5269\u4f59\u4f4d\u7684\u6a21] = \u5408\u6cd5\u65b9\u6848\u6570 // f[S][i][j][k] = \u2211(f[S][i - 1][j - R][(k - pwr[i - 1] * R) mod S], 0\u2264R\u22649) // \u8fb9\u754c\u6761\u4ef6 F[S][0][0][0] = 1 int f [ 82 ][ 10 ][ 82 ][ 82 ], pwr [ 82 ][ 10 ]; inline int modabs ( int a , int mod ) { return (( a % mod ) + mod ) % mod ; } int num [ 10 ]; int count ( int p , int sum , int mod , int s , bool e ) { if ( s - sum < 0 ) return 0 ; else if ( ! e ) return f [ s ][ p + 1 ][ s - sum ][( s - mod ) % s ]; else if ( p == -1 ) { if ( sum == s && mod == 0 ) return 1 ; else return 0 ; } else { int res = 0 ; for ( int d = 0 ; d <= num [ p ]; d ++ ) res += count ( p - 1 , sum + d , ( mod + pwr [ s ][ p ] * d ) % s , s , d == num [ p ]); return res ; } } int fcount ( int tt ) { if ( tt == 0 ) return 0 ; int maxp = 0 ; while ( tt ) num [ maxp ++ ] = tt % 10 , tt /= 10 ; int res = 0 ; for ( int i = 1 ; i <= 81 ; i ++ ) res += count ( maxp - 1 , 0 , 0 , i , true ); return res ; } int main () { freopen ( \"mystery.in\" , \"r\" , stdin ); freopen ( \"mystery.out\" , \"w\" , stdout ); for ( int s = 1 ; s <= 81 ; s ++ ) { memset ( f [ s ], 0 , sizeof f [ s ]); f [ s ][ 0 ][ 0 ][ 0 ] = 1 ; pwr [ s ][ 0 ] = 1 % s ; for ( int i = 1 ; i <= 9 ; i ++ ) pwr [ s ][ i ] = ( pwr [ s ][ i - 1 ] * 10 ) % s ; for ( int i = 1 ; i <= 9 ; i ++ ) { for ( int j = 0 ; j <= i * 9 ; j ++ ) { for ( int k = 0 ; k <= s ; k ++ ) { for ( int d = 0 ; d <= 9 && j - d >= 0 ; d ++ ) f [ s ][ i ][ j ][ k ] += f [ s ][ i - 1 ][ j - d ][ modabs ( k - pwr [ s ][ i - 1 ] * d , s )]; } } } } int l , r ; while ( scanf ( \"%d %d\" , & l , & r ) == 2 ) printf ( \"%d \\n \" , fcount ( r ) - fcount ( l - 1 )); fclose ( stdin ); fclose ( stdout ); return 0 ; } \u60ac\u7ebf\u6cd5 \u00b6 K. Largest Common Submatrix \u00b6 (2019\u94f6\u5ddd\u533a\u57df\u8d5bK\u9898 by hqh) \u9898\u610f:\u7ed9\u4e24\u4e2anm(1000\u4ee5\u5185)\u7684\u77e9\u9635,\u95ee\u8fd9\u4e24\u4e2a\u77e9\u9635\u7684\u6700\u5927\u5b50\u77e9\u9635\u5927\u5c0f,\u5355\u4e2a\u77e9\u9635\u5185\u5143\u7d20\u4e24\u4e24\u4e0d\u540c,\u4e14\u90fd\u57281~nm\u5185. \u89e3\u6cd5:\u5148\u5efa\u7acb\u4e24\u4e2a\u77e9\u9635\u5143\u7d20\u4e4b\u95f4\u7684\u4f4d\u7f6e\u6620\u5c04(\u7528\u4e2a\u6570\u7ec4\u4e4b\u7c7b\u7684\u4fdd\u5b58). \u7136\u540e\u4f7f\u7528\u60ac\u7ebf\u6cd5( https://oi-wiki.org/misc/hoverline/),\u5bf9\u4e8e\u6bcf\u4e2a\u4f4d\u7f6e(i,j)\u6211\u4eec\u5047\u8bbe\u8fd9\u4e2a\u4f4d\u7f6e\u6709\u4e2a\u7ad6\u76f4\u60ac\u7ebf(\u6709\u9ad8\u5ea6\u548c\u5de6\u53f3\u6269\u5c55\u6700\u5927\u8ddd\u79bb\u7b49\u4fe1\u606f),\u6211\u4eec\u6700\u7ec8\u7684\u76ee\u6807\u662f\u8ba9\u60ac\u7ebf\u9ad8\u5ea6\u7b49\u4e8e\u8fd9\u4e00\u5217\u80fd\u6269\u5c55\u7684\u6700\u5927\u9ad8\u5ea6\u7684\u60c5\u51b5\u4e0b,\u8ba9\u60ac\u7ebf\u5411\u5de6\u6216\u8005\u5411\u53f3\u6269\u5c55\u7684\u8ddd\u79bb\u5c3d\u53ef\u80fd\u5927.\u80fd\u6269\u5c55\u5f53\u4e14\u4ec5\u5f53a\u77e9\u9635\u4e2d\u5bf9\u5e94\u7684\u67d0\u4e2a\u6570x\u5728b\u77e9\u9635\u4e2d\u5bf9\u5e94\u7684\u76f8\u5bf9\u4f4d\u7f6e\u4e5f\u7b26\u5408\u8981\u6c42 . \u4f8b\u5982\u77e9\u9635 a= 5 6 1 7 9 3 2 4 8 b= 1 2 3 4 5 6 8 7 9 a\u4e2d\u76847\u5bf9\u5e94b\u4e2d(3,2)\u4f4d\u7f6e,\u5047\u8bbe7\u8fd9\u4e2a\u4f4d\u7f6e\u7684\u60ac\u7ebf\u521d\u59cb\u9ad8\\\u5de6\\\u53f3\u6269\u5c55\u6700\u5927\u4f4d\u7f6e\u5206\u522b\u662fh=1 l=1 \\r=1;\u5148\u66f4\u65b0\u9ad8\u5ea6,a\u4e2d5\u57287\u7684\u4e0a\u9762,b\u4e2d\u4e5f\u662f\u5982\u6b64,\u56e0\u6b64\u9ad8\u5ea6\u4e3a2.\u6b64\u65f6\u4e0d\u80fd\u518d\u6269\u5c55\u4e86.\u5de6\u53f3\u6700\u5927\u8ddd\u79bb\u7684\u66f4\u65b0\u4e5f\u7c7b\u4f3c,\u60ac\u7ebf\u7684\u9ad8\u5ea6\u548c\u5de6\\\u53f3\u6700\u5927\u53ef\u8fbe\u8ddd\u79bb\u662f\u53ef\u88ab\u7ebf\u6027\u66f4\u65b0\u7684. \u6c42\u51fa\u6240\u6709\u60ac\u7ebf\u540e,\u76f4\u63a5\u7528\u60ac\u7ebf\u7684\u4fe1\u606f(r-l)*h\u4f5c\u4e3a\u77e9\u5f62\u7684\u6700\u5927\u9762\u79ef\u66f4\u65b0\u5373\u53ef 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 #include <iostream> #include <cstdio> #include <unordered_map> #include <map> using namespace std ; int n , m ; const int N = 2010 ; struct HOVER { int h , l , r ; } hl [ N ][ N ]; //map<int,pair<int,int>> mp; pair < int , int > mp [ N * N ]; int a [ N ][ N ], b [ N ][ N ]; void do_hoverline () { for ( int i = 1 ; i <= n ; i ++ ) { //L for ( int j = 1 ; j <= m ; j ++ ) { //Height //pair<int,int> iijj=mp[b[i][j]]; pair < int , int > iijj = mp [ b [ i ][ j ]]; //b! \uff08\u4e0d\u662fa if ( b [ i -1 ][ j ] == a [ iijj . first -1 ][ iijj . second ]) { hl [ i ][ j ]. h = hl [ i -1 ][ j ]. h + 1 ; } while ( hl [ i ][ j ]. l > 1 && iijj . second - ( j - ( hl [ i ][ j ]. l -1 )) >= 1 && b [ i ][ hl [ i ][ j ]. l -1 ] == a [ iijj . first ][ iijj . second - ( j - ( hl [ i ][ j ]. l -1 ))] //\u6ce8\u610f\u60ac\u7ebf\u6269\u5c55\u65f6b\u4e5f\u8981\u5339\u914d && hl [ i ][ hl [ i ][ j ]. l -1 ]. h >= hl [ i ][ j ]. h ) { hl [ i ][ j ]. l = hl [ i ][ hl [ i ][ j ]. l -1 ]. l ; } } //R for ( int j = m ; j >= 1 ; j -- ) { pair < int , int > iijj = mp [ b [ i ][ j ]]; //b! while ( hl [ i ][ j ]. r < m && iijj . second + (( hl [ i ][ j ]. r + 1 ) - j ) <= m && b [ i ][ hl [ i ][ j ]. r + 1 ] == a [ iijj . first ][ iijj . second + (( hl [ i ][ j ]. r + 1 ) - j )] //\u6ce8\u610f\u60ac\u7ebf\u6269\u5c55\u65f6b\u4e5f\u8981\u5339\u914d && hl [ i ][ hl [ i ][ j ]. r + 1 ]. h >= hl [ i ][ j ]. h ) { hl [ i ][ j ]. r = hl [ i ][ hl [ i ][ j ]. r + 1 ]. r ; } } } } int main () { //ios::sync_with_stdio(false); //cin.tie(0),cout.tie(0); //cin>>n>>m; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { //cin>>a[i][j]; scanf ( \"%d\" , & a [ i ][ j ]); mp [ a [ i ][ j ]] = { i , j }; hl [ i ][ j ] = { 1 , j , j }; } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { scanf ( \"%d\" , & b [ i ][ j ]); } } do_hoverline (); int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { ans = max ( ans ,( hl [ i ][ j ]. r - hl [ i ][ j ]. l + 1 ) * hl [ i ][ j ]. h ); } } //cout<<ans<<endl; printf ( \"%d \\n \" , ans ); return 0 ; } \u6700\u5927\u5b50\u65b9\u9635 \u00b6 \u9898\u610f\uff1a \u7ed9\u5b9a\u4e00\u4e2a\u75310,1\u7ec4\u6210\u7684n*n\u65b9\u9635\uff08n\u5728\u8fd0\u884c\u65f6\u63d0\u9192\u7528\u6237\u8f93\u5165\uff09\uff0c\u5224\u65ad\u5176\u4e2d\u7531\u51681\u7ec4\u6210\u7684\u6700\u5927\u5b50\u65b9\u9635\u7684\u5de6\u4e0a\u89d2\u4f4d\u7f6e\u548c\u9636\u6570\u3002\u7f16\u5199\u65b9\u6cd5\u5b9e\u73b0\u4e0a\u8ff0\u529f\u80fd\uff0c\u8fd4\u56de\u503c\u662f\u4e00\u4e2a\u5305\u542b3\u4e2a\u5143\u7d20\u7684\u6570\u7ec4\uff0c\u4f9d\u6b21\u8868\u793a\u884c\u4e0b\u6807\uff0c\u5217\u4e0b\u6807\uff0c\u9636\u6570\u3002 \u89e3\u6cd5\uff1a \u76f4\u63a5\u904d\u5386\u6bcf\u4e2a\u65b9\u683c\u5e76\u67e5\u627e\u4ee5\u8fd9\u4e2a\u65b9\u683c\u4e3a\u5de6\u4e0a\u89d2\u9876\u70b9\u7684\u6700\u5927\u5b50\u65b9\u9635\uff0c\u9700\u8981\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO\\left(n 3\\right)\u3002\u4e8b\u5b9e\u4e0a\u6b64\u95ee\u9898\u53ef\u7528\u60ac\u7ebf\u6cd5\u52a8\u6001\u89c4\u5212\u5c06\u65f6\u95f4\u590d\u6742\u5ea6\u4f18\u5316\u5230O\\left(n 2\\right)\u3002 \u5047\u8bbe\u6bcf\u4e2a\u65b9\u683c\u5bf9\u5e94\u4e00\u6761\u4ece\u8be5\u65b9\u683c\u5f00\u59cb\u5230\u8be5\u65b9\u683c\u80fd\u5411\u4e0a\u6269\u5c55\u5230\u7684\u6700\u9ad8\u4f4d\u7f6e\u4e3a\u6b62\u7684\u60ac\u7ebf\uff0c\u5e76\u5c06\u8fd9\u4e2a\u4f4d\u7f6e\u7684\u60ac\u7ebf\u9ad8\u5ea6\u8bb0\u4e0b\u3002\u60ac\u7ebf\u80fd\u5411\u4e0a\u6269\u5c55\uff0c\u5f53\u4e14\u4ec5\u5f53\u60ac\u7ebf\u9876\u90e8\u7684\u4e0a\u65b9\u65b9\u683c\u662f1\u3002\u7279\u522b\u5730\uff0c\u5982\u679c\u8fd9\u4e2a\u65b9\u683c\u5bf9\u5e94\u4f4d\u7f6e\u7684\u503c\u5c31\u662f0\uff0c\u90a3\u4e48\u8fd9\u4e2a\u60ac\u7ebf\u7684\u9ad8\u5ea6\u4e3a0\u3002 \u63a5\u4e0b\u6765\u8003\u8651\u8fd9\u4e2a\u60ac\u7ebf\u5411\u5de6\u6216\u8005\u5411\u53f3\u5e73\u79fb\uff0c\u5e76\u8003\u8651\u5b83\u6269\u5c55\u5230\u7684\u6700\u8fdc\u4f4d\u7f6e\u3002\u60ac\u7ebf\u80fd\u5411\u5de6\u6216\u8005\u5411\u53f3\u6269\u5c55\uff0c\u5f53\u4e14\u4ec5\u5f53\u60ac\u7ebf\u76ee\u524d\u80fd\u5411\u5de6\u6216\u5411\u53f3\u80fd\u6269\u5c55\u5230\u7684\u6700\u8fdc\u4f4d\u7f6e\u7684\u5de6\u8fb9\uff08\u6216\u8005\u53f3\u8fb9\uff09\u5c06\u88ab\u60ac\u7ebf\u8986\u76d6\u65f6\u8986\u76d6\u7684\u6240\u6709\u65b9\u683c\u90fd\u662f1\u3002\u4f8b\u5982\uff0c\u8003\u8651\u4e0b\u9762\u7684\u6570\u636e\u7684\u6700\u4e0b\u9762\u4e00\u884c\u7684\u65b9\u683c\u5bf9\u5e94\u7684\u60ac\u7ebf\uff1a $$ 0110\\ 1111\\ 1111\\ $$ \u7b2c3\u884c\u7b2c4\u5217\u7684\u65b9\u683c\u5bf9\u5e94\u7684\u60ac\u7ebf\u9ad8\u5ea6\u4e3a2\uff08\u56e0\u4e3a\u4ece\u8fd9\u4e2a\u4f4d\u7f6e\u5f00\u59cb\u5411\u4e0a\u80fd\u5230\u8fbe\u7684\u6700\u8fdc\u975e\u96f6\u683c\u662f\u7b2c2\u884c\u7b2c4\u5217\u7684\u65b9\u683c\uff09\uff0c\u80fd\u5411\u5de6\u6269\u5c55\u5230\u7684\u6700\u8fdc\u4f4d\u7f6e\u662f\u7b2c1\u5217\u3002\u800c\u7b2c3\u884c\u7b2c3\u5217\u7684\u65b9\u683c\u5bf9\u5e94\u7684\u60ac\u7ebf\u9ad8\u5ea6\u662f3\uff0c\u5411\u5de6\u80fd\u6269\u5c55\u5230\u7684\u6700\u8fdc\u4f4d\u7f6e\u662f\u7b2c2\u5217\uff08\u4e0d\u80fd\u518d\u5411\u7b2c\u4e00\u5217\u6269\u5c55\u4e86\uff0c\u56e0\u4e3a\u7b2c3\u884c\u7b2c1\u5217\u5bf9\u5e94\u65b9\u683c\u7684\u9ad8\u5ea6\u53ea\u67092\uff0c\u6bd4\u73b0\u5728\u7684\u60ac\u7ebf\u9ad8\u5ea63\u8981\u5c0f\uff09\u3002\u5982\u679c\u80fd\u5982\u6b64\u6c42\u51fa\u8fd9\u4e9b\u65b9\u683c\u7684\u60ac\u7ebf\u9ad8\u5ea6\u4ee5\u53ca\u4ed6\u4eec\u80fd\u5411\u5de6\u6216\u5411\u53f3\u6269\u5c55\u7684\u6700\u5927\u8ddd\u79bb\uff0c\u5c31\u80fd\u6c42\u51fa\u4ee5\u8be5\u60ac\u7ebf\u4e3a\u9ad8\u7684\u6700\u5927\u77e9\u5f62\u9762\u79ef\uff0c\u53d6\u8fd9\u4e9b\u77e9\u5f62\u7684\u957f\u5bbd\u4e2d\u7684\u6700\u5c0f\u503c\u5e76\u8ba1\u7b97\u51fa\u5bf9\u5e94\u7684\u6b63\u65b9\u5f62\u7684\u9762\u79ef\u4ee5\u53ca\u5de6\u4e0a\u89d2\u4f4d\u7f6e\uff0c\u5c31\u53ef\u4ee5\u627e\u5230\u6700\u5927\u5b50\u65b9\u9635\u3002 \u8003\u8651\u5982\u4f55\u6309\u884c\u66f4\u65b0\u6bcf\u4e00\u5217\u65b9\u683c\u7684\u60ac\u7ebf\u9ad8\u5ea6\uff1a\u5982\u679c\u4e0a\u4e00\u884c\u5bf9\u5e94\u4f4d\u7f6e\u7684\u60ac\u7ebf\u9ad8\u5ea6\u662fh\uff0c\u82e5\u5f53\u524d\u884c\u5bf9\u5e94\u65b9\u683c\u662f1\u5219\u5f53\u524d\u884c\u7684\u60ac\u7ebf\u9ad8\u5ea6\u5c31\u662fh+1\uff0c\u5426\u5219\u5c06\u60ac\u7ebf\u9ad8\u5ea6\u6e05\u96f6\u3002 \u8003\u8651\u66f4\u65b0\u60ac\u7ebf\u7684\u5411\u5de6\u6216\u8005\u5411\u53f3\u6269\u5c55\u7684\u6700\u8fdc\u8ddd\u79bb\uff1a\u4ee5\u5411\u5de6\u6269\u5c55\u4e3a\u4f8b\uff0c\u521d\u59cb\u503c\u5c31\u662f\u5f53\u524d\u5217\u3002\u82e5\u5f53\u524d\u60ac\u7ebf\u80fd\u6269\u5c55\u5230\u7684\u6700\u8fdc\u8ddd\u79bb\u7684\u5de6\u4fa7\u4e00\u5217\u7684\u540c\u4e00\u884c\u7684\u60ac\u7ebf\u9ad8\u5ea6\u6bd4\u5f53\u524d\u60ac\u7ebf\u9ad8\u5ea6\u66f4\u9ad8\uff0c\u8bf4\u660e\u90a3\u4e2a\u60ac\u7ebf\u5411\u5de6\u80fd\u6269\u5c55\u5230\u7684\u5730\u65b9\uff0c\u5f53\u524d\u60ac\u7ebf\u4e5f\u4e00\u5b9a\u80fd\u6269\u5c55\u5230\uff0c\u56e0\u6b64\u76f4\u63a5\u4f7f\u7528\u516c\u5f0f \\( \\(l\\left[i\\right]=l\\left[l\\left[i\\right]-1\\right]\\) \\) \u8f6c\u79fb\uff0c\u5176\u4e2dl[i] \u8868\u793a\u8fd9\u4e00\u884c\u7b2ci\u5217\u7684\u60ac\u7ebf\u80fd\u5411\u5de6\u6269\u5c55\u5230\u7684\u6700\u8fdc\u4f4d\u7f6e\u3002\u5982\u6b64\u53cd\u590d\u8fed\u4ee3\u76f4\u5230\u9047\u5230\u60ac\u7ebf\u9ad8\u5ea6\u6bd4\u5f53\u524d\u9ad8\u5ea6\u66f4\u77ee\u6216\u5230\u8fbe\u77e9\u9635\u5c3d\u5934\u4e3a\u6b62\u3002\u5411\u53f3\u80fd\u6269\u5c55\u5230\u7684\u6700\u8fdc\u8ddd\u79bb\u540c\u7406\u3002 \u7a0b\u5e8f\u5728\u5b9e\u73b0\u65f6\uff0c\u4e3a\u6bcf\u4e00\u884c\u7684\u6240\u6709\u5217\u5bf9\u5e94\u7684\u60ac\u7ebf\u5b9e\u73b0\u4e86\u4e00\u4e2aHoverline\u7c7b\uff0c\u5305\u542b\u4e09\u4e2a\u6210\u5458\uff1ah,l,r\uff0c\u5206\u522b\u8868\u793a\u60ac\u7ebf\u9ad8\u5ea6\u3001\u60ac\u7ebf\u80fd\u5411\u5de6\u548c\u5411\u53f3\u6269\u5c55\u5230\u7684\u6700\u8fdc\u4f4d\u7f6e\u3002\u540c\u65f6\u5305\u542binit\u3001update_l\u3001update_r\u4ee5\u53caget_ans\u65b9\u6cd5\uff0c\u5206\u522b\u7528\u4e8e\u521d\u59cb\u5316\u60ac\u7ebf\u7684\u9ad8\u5ea6\u548c\u80fd\u6269\u5c55\u5230\u7684\u6700\u8fdc\u4f4d\u7f6e\u3001\u66f4\u65b0\u5411\u5de6\u548c\u5411\u53f3\u80fd\u6269\u5c55\u5230\u7684\u6700\u8fdc\u4f4d\u7f6e\uff0c\u4ee5\u53ca\u8ba1\u7b97\u60ac\u7ebf\u5bf9\u5e94\u65b9\u9635\u7684\u5927\u5c0f\u548c\u5de6\u4e0a\u89d2\u5750\u6807\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 1. import java.util.Scanner ; 2. import java.util.Arrays ; 3. 4. class Hoverline { 5. public int [] h , l , r ; 6. public int n ; 7. Hoverline ( int n ){ 8. this . n = n ; 9. h = new int [ n ] ; 10. l = new int [ n ] ; 11. r = new int [ n ] ; 12. } 13. //\u7528\u4e8e\u521d\u59cb\u5316\u60ac\u7ebf\u7684\u9ad8\u5ea6\u548c\u80fd\u6269\u5c55\u5230\u7684\u6700\u8fdc\u4f4d\u7f6e 14. public void init ( int [][] m , int line ){ 15. for ( int i = 0 ; i < n ; i ++ ){ 16. h [ i ]= ( m [ line ][ i ]== 0 ) ? 0 :( h [ i ]+ 1 ); 17. l [ i ]= r [ i ]= i ; 18. } 19. } 20. //\u66f4\u65b0\u5411\u5de6\u80fd\u6269\u5c55\u5230\u7684\u6700\u8fdc\u4f4d\u7f6e 21. public void update_l ( int i ){ 22. while ( l [ i ]- 1 >= 0 && h [ l [ i ]- 1 ]>= h [ i ] ){ 23. l [ i ]= l [ l [ i ]- 1 ] ; 24. } 25. } 26. //\u66f4\u65b0\u5411\u5de6\u80fd\u6269\u5c55\u5230\u7684\u6700\u8fdc\u4f4d\u7f6e 27. public void update_r ( int i ){ 28. while ( r [ i ]+ 1 < n && h [ r [ i ]+ 1 ]>= h [ i ] ){ 29. r [ i ]= r [ r [ i ]+ 1 ] ; 30. } 31. } 32. //\u8ba1\u7b97\u60ac\u7ebf\u5bf9\u5e94\u65b9\u9635\u7684\u5927\u5c0f\u548c\u5de6\u4e0a\u89d2\u5750\u6807,\u540c\u65f6\u66f4\u65b0\u7b54\u6848 33. public void get_ans ( int [] ans , int line ){ 34. 35. for ( int i = 0 ; i < n ; i ++ ){ 36. int minval = Math . min ( r [ i ]- l [ i ]+ 1 , h [ i ] ); 37. int tmp_area = minval * minval ; 38. if ( tmp_area > ans [ 2 ] ){ 39. ans [ 0 ]= line - h [ i ]+ 1 ; 40. ans [ 1 ]= l [ i ] ; 41. ans [ 2 ]= tmp_area ; 42. } 43. } 44. } 45. } 46. 47. public class a { 48. 49. public static int [] findLargestBlock ( int [][] m ){ 50. int [] ans = new int [ 3 ] ; 51. 52. int n = m . length ; 53. Hoverline hoverline = new Hoverline ( n ); 54. //\u66f4\u65b0\u60ac\u7ebf 55. for ( int i = 0 ; i < n ; i ++ ){ 56. hoverline . init ( m , i ); 57. for ( int j = 0 ; j < n ; j ++ ) { 58. hoverline . update_l ( j ); 59. } 60. for ( int j = n - 1 ; j >= 0 ; j -- ){ 61. hoverline . update_r ( j ); 62. } 63. hoverline . get_ans ( ans , i ); 64. 65. } 66. 67. return ans ; 68. } 69. 70. // \u8f93\u5165\u77e9\u9635 71. static int [][] read_matrix () { 72. int n ; 73. Scanner sc = new Scanner ( System . in ); 74. System . out . println ( \"Enter matrix size:\" ); 75. n = sc . nextInt (); 76. int [][] m = new int [ n ][ n ] ; 77. for ( int i = 0 ; i < n ; i ++ ){ 78. for ( int j = 0 ; j < n ; j ++ ) 79. m [ i ][ j ]= sc . nextInt (); 80. } 81. return m ; 82. } 83. 84. public static void main ( String [] args ) { 85. 86. var m = read_matrix (); 87. var ans = findLargestBlock ( m ); 88. System . out . println ( \"row_index, column_index, size: \" + Arrays . toString ( ans )); //\u8f93\u51fa\u7b54\u6848 89. } 90. } \u56db\u8fb9\u5f62\u4e0d\u7b49\u5f0f\u51b3\u7b56\u4f18\u5316 \u00b6 \u5c0f\u7c73\u8d5b\u80cc\u5305\u9898 \u00b6 \u9898\u610f\uff1a n\u4e2a\u7269\u54c1\u6709\u91cd\u91cfwi\u548c\u4ef7\u503cvi\uff0c\u6700\u5927\u5316\u4ef7\u503c\u3002\uff08wi\u5728100\u4ee5\u5185\uff0c\u7269\u54c1\u4e2a\u65702e5\uff0c\u80cc\u5305\u5927\u5c0f2e5\uff0c\u4ef7\u503c1e9\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 #include <iostream> #include <cstdio> #include <algorithm> #include <memory.h> using namespace std ; const int N = 2e5 + 10 ; //!2 long long w [ 110 ][ N ], pre [ N ]; //\u4ef7\u503c long long dp [ N ], last [ N ]; int n , m ; struct P { int k , l , r ; } queue [ N ]; int hd , rr ; long long s ( int l ) { return pre [ l ]; } bool is_better ( int x , int k , int u , int i , int p ) //p is better than k for x(p<=x) { return last [ u + p * i ] + s ( x - p ) >= last [ u + k * i ] + s ( x - k ); } int bs ( int u , int i , int p ) { int bs_l = queue [ rr ]. l , bs_r = queue [ rr ]. r ; while ( bs_l < bs_r ) { int mid = ( bs_l + bs_r ) >> 1 ; if ( is_better ( mid , queue [ rr ]. k , u , i , p )) { bs_r = mid ; } else bs_l = mid + 1 ; } if ( bs_l == queue [ rr ]. r && ! is_better ( bs_l , queue [ rr ]. k , u , i , p )) bs_l ++ ; return bs_l ; } int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ), cout . tie ( 0 ); while ( cin >> n >> m ) { //memset(w,0,sizeof(w)); for ( int i = 1 ; i <= 100 ; i ++ ) w [ i ][ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int ww ; cin >> ww ; cin >> w [ ww ][ ++ w [ ww ][ 0 ]]; } for ( int i = 1 ; i <= m ; i ++ ) dp [ i ] = last [ i ] = 0 ; for ( int i = 1 ; i <= 100 ; i ++ ) { if ( w [ i ][ 0 ] == 0 ) { for ( int j = 0 ; j <= m ; j ++ ) last [ j ] = dp [ j ]; continue ; } sort ( w [ i ] + 1 , w [ i ] + w [ i ][ 0 ] + 1 , greater < long long > ()); for ( int j = 1 ; j <= w [ i ][ 0 ]; j ++ ) pre [ j ] = pre [ j -1 ] + w [ i ][ j ]; for ( int u = 0 ; u < i ; u ++ ) { hd = 1 , rr = 0 ; //reset queue int pmax = ( m - u ) / i ; queue [ ++ rr ] = { 0 , 1 , min ( pmax ,( int )( 0 + w [ i ][ 0 ]))}; //k=0 ,l=1, r=k+w[i][0] for ( int p = 1 ; p <= pmax ; p ++ ) { while ( hd <= rr && ( queue [ hd ]. r < p )) hd ++ ; //time out if ( queue [ hd ]. l < p ) queue [ hd ]. l = p ; //can transfer if ( hd <= rr && queue [ hd ]. l <= p && p <= queue [ hd ]. r ) dp [ u + p * i ] = max ( dp [ u + p * i ], last [ u + queue [ hd ]. k * i ] + s ( p - queue [ hd ]. k )); //try to insert new policy (from last[u+p*i]) (p<=queue[rr].l<=queue[rr].r) while ( hd <= rr && is_better ( queue [ rr ]. l , queue [ rr ]. k , u , i , p )) rr -- ; int pos ; if ( hd <= rr ) { pos = bs ( u , i , p ); queue [ rr ]. r = pos -1 ;} //!1 else pos = 1 ; queue [ ++ rr ] = { p , pos , min ( pmax ,( int )( p + w [ i ][ 0 ]))}; } } for ( int j = 0 ; j <= m ; j ++ ) last [ j ] = dp [ j ]; } long long ans = 0 ; for ( int i = 0 ; i <= m ; i ++ ) ans = max ( ans , dp [ i ]); cout << ans << endl ; } return 0 ; } \u6570\u5b66 \u00b6 \u9ad8\u65af\u6d88\u5143 \u00b6 luogu 4035 ball_space_generator \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 #include <iostream> #include <iomanip> #include <cmath> using namespace std ; int n ; double c [ 101 ][ 102 ], a [ 101 ][ 102 ]; void gaussian_elimination () { double sum1 , sum2 ; sum1 = sum2 = 0.0 ; for ( int i = 1 ; i <= n ; i ++ ) { sum1 = sum2 = 0.0 ; for ( int j = 1 ; j <= n ; j ++ ) { sum1 += a [ i ][ j ] * a [ i ][ j ]; sum2 += a [ i + 1 ][ j ] * a [ i + 1 ][ j ]; c [ i ][ j ] = 2 * ( a [ i + 1 ][ j ] - a [ i ][ j ]); } c [ i ][ n + 1 ] = sum2 - sum1 ; } int pos = 1 ; for ( int i = 1 ; i <= n ; i ++ ) //for per line { bool flag_of_find = false ; for ( int j = pos ; j <= n ; j ++ ) { if ( fabs ( c [ i ][ j ]) > 1e-8 ) //c[j][i] ???????? { flag_of_find = true ; for ( int k = 1 ; k <= n + 1 ; k ++ ) { swap ( c [ pos ][ k ], c [ i ][ k ]); } } } if ( ! flag_of_find ) continue ; for ( int j = 1 ; j <= n ; j ++ ) { if ( j == pos ) continue ; double rate = c [ j ][ i ] / c [ pos ][ i ]; for ( int k = 1 ; k <= n + 1 ; k ++ ) { c [ j ][ k ] -= rate * c [ pos ][ k ]; } } pos ++ ; } } int main () { ios :: sync_with_stdio ( false ); cin >> n ; for ( int i = 1 ; i <= n + 1 ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) cin >> a [ i ][ j ]; } gaussian_elimination (); cout << fixed ; for ( int i = 1 ; i <= n ; i ++ ) { cout << setprecision ( 3 ) << c [ i ][ n + 1 ] / c [ i ][ i ] << \" \" ; } return 0 ; } gaussian elimination \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include <iostream> #include <cstdio> #include <cmath> using namespace std ; const int N = 888 ; double c [ N ][ N ]; int n ; int main () { cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n + 1 ; j ++ ) { cin >> c [ i ][ j ]; } } //int i=1; //ps:\u5c06pos\u6539\u6210i\u540e\uff0c\u5f97\u5230\u7684\u77e9\u9635\u5c06\u662f\u5bf9\u89d2\u7ebf\u4e0a\u5168\u662f1\u7684\u77e9\u9635 for ( int i = 1 ; i <= n ; i ++ ) { //find a equation that the coefficient of the x_i is not 0 bool flag_of_find = false ; for ( int j = i ; j <= n ; j ++ ) { if ( fabs ( c [ j ][ i ]) > 1e-8 ) { flag_of_find = true ; for ( int k = 1 ; k <= n + 1 ; k ++ ) { swap ( c [ i ][ k ], c [ j ][ k ]); } } } if ( ! flag_of_find ) continue ; for ( int j = 1 ; j <= n ; j ++ ) { if ( i == j ) continue ; double rate = c [ j ][ i ] / c [ i ][ i ]; for ( int k = 1 ; k <= n + 1 ; k ++ ) { c [ j ][ k ] -= c [ i ][ k ] * rate ; } } //i++; } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n + 1 ; j ++ ) { printf ( \"%.8lf \" , c [ i ][ j ]); } cout << endl ; } return 0 ; } 2020 icpc shenyang A \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <cstdlib> #include <algorithm> #include <string> #include <vector> #include <map> #include <unordered_map> #include <set> #include <unordered_set> #include <queue> using namespace std ; typedef long long ll ; const int N = 310 , Mod = 998244353 ; int n ; int a [ N ][ N ]; int b [ N ][ N ]; int c [ N ][ N ], d [ N ]; ll pow2 [ N ]; void predo () { pow2 [ 0 ] = 1 ; for ( int i = 1 ; i <= 305 ; i ++ ) { pow2 [ i ] = pow2 [ i -1 ] * 2 ; pow2 [ i ] %= Mod ; } } void gauss_elimination ( int c [][ N ], int b [], int n ) { int pos = 1 ; for ( int i = 1 ; i <= n ; i ++ ) // for every x { bool flag_of_find = false ; for ( int j = pos ; j <= n ; j ++ ) { if ( c [ j ][ i ]) { flag_of_find = true ; for ( int k = 1 ; k <= n ; k ++ ) swap ( c [ pos ][ k ], c [ j ][ k ]); swap ( b [ pos ], b [ j ]); } } if ( ! flag_of_find ) continue ; for ( int j = 1 ; j <= n ; j ++ ) //for every equation, execute elimination { if ( j == pos ) continue ; if ( c [ j ][ i ] == 0 ) continue ; //1->0: No need to eliminate for ( int k = 1 ; k <= n ; k ++ ) { c [ j ][ k ] ^= c [ pos ][ k ]; } b [ j ] ^= b [ pos ]; } pos ++ ; } } void work () { ll ans = 1 ; for ( int j = 1 ; j <= n ; j ++ ) { for ( int i = 1 ; i <= n ; i ++ ) { for ( int k = 1 ; k <= n ; k ++ ) { c [ i ][ k ] = 0 ; if ( a [ i ][ k ]) { c [ i ][ k ] = 1 ; } } if ( b [ i ][ j ]) { c [ i ][ i ] ^= 1 ; } } fill ( d , d + n + 1 , 0 ); gauss_elimination ( c , d , n ); int pos = 1 ; int ans2 = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { while ( pos <= n && c [ i ][ pos ] == 0 ) { pos ++ ; } if ( pos <= n ) { ans2 ++ ; } } ans2 = n - ans2 ; ans = ( ans * pow2 [ ans2 ]) % Mod ; } cout << ans << endl ; } int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ), cout . tie ( 0 ); freopen ( \"a_in.txt\" , \"r\" , stdin ); cin >> n ; predo (); for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { cin >> a [ i ][ j ]; } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { cin >> b [ i ][ j ]; } } work (); return 0 ; } \u7ebf\u6027\u57fa \u00b6 \u53ef\u5728\u5bf9\u6570\u65f6\u95f4\u5185\u5b8c\u6210\u63d2\u5165\u3001\u67e5\u8be2\u96c6\u5408\u6700\u5927\u503c\u548c\u6700\u5c0f\u5f02\u6216\u548c\u7684\u64cd\u4f5c\u3002 \u5b8c\u6210\u91cd\u6784\u64cd\u4f5c\u540e\uff08\u82b1\u8d39\u5bf9\u6570\u5e73\u65b9\u7684\u65f6\u95f4\uff09\u53ef\u8f6c\u6362\u4e3a\u5f62\u4f3c\u4e8e\u6700\u7b80\u884c\u9636\u68af\u578b\u77e9\u9635\u7684\u5f62\u5f0f\uff0c\u4e4b\u540e\u53ef\u5728\u5bf9\u6570\u65f6\u95f4\u5185\u67e5\u8be2\u96c6\u5408\u5185\u7b2ck\u5927\u5f02\u6216\u548c\u3002 \u6700\u5927\u503c \uff08restructure\u524d\uff09\u4ece\u5927\u5230\u5c0f\u679a\u4e3e\u6bcf\u4e2a\u6570\u5f02\u6216\u8fdb\u6765\u4f1a\u4e0d\u4f1a\u4f7f\u5f97\u7b54\u6848\u66f4\u5927\uff0c\u5982\u679c\u4f1a\u5c31\u5f02\u6216\u8fdb\u6765\u3002 \u5982\u679c\u9700\u8981\u5728\u5f02\u6216\u521d\u503c\u4e0d\u4e3a\u96f6\u7684\u60c5\u51b5\u4e0b\u53d6\u5f97\u6700\u5927\u503c\uff0c\u53ea\u9700\u8981\u66f4\u6539ans\u7684\u521d\u59cb\u503c\u5373\u53ef\u3002 \u6700\u5c0f\u503c \uff1a \u76f4\u63a5\u8d2a\u5fc3\u62ff\u7ebf\u6027\u57fa\u4e2d\u6700\u5c0f\u7684\u6570\uff08\u5f53\u7136\uff0c\u9700\u8981\u7279\u5224\u7ebf\u6027\u57fa\u662f\u5426\u53ef\u83b7\u5f970\uff09 Funs || Methods Reliance Time Complexity Inputs Outputs Description LB 1 \u6784\u9020\u51fd\u6570 insert log x \u8fd4\u56de\u662f\u5426\u63d2\u5165\u6210\u529f\uff0c\u4e0d\u6210\u529f\u5219\u8868\u660e\u5176\u53ef\u4ee5\u88ab\u7ebf\u6027\u8868\u51fa \u5c06x\u63d2\u5165\u7ebf\u6027\u57fa get_max log ans=0 \u6700\u5927\u503c \u53d6\u5f97\u7ebf\u6027\u57fa\u80fd\u7ebf\u6027\u8868\u51fa\u7684\u6700\u5927\u503c\uff08\u91cd\u6784\u524d\uff09\uff0c\u82e5\u521d\u59cb\u5f02\u6216\u503c\u4e0d\u4e3a0\u5219\u5411ans\u4f20\u9012\u53c2\u6570 get_min log \u6700\u5c0f\u503c \u53d6\u5f97\u7ebf\u6027\u57fa\u4e2d\u80fd\u8868\u51fa\u7684\u6700\u5c0f\u7684\u503c\uff08\u91cd\u6784\u524d\uff09 restructure log^2 \u4fee\u6539p\u6570\u7ec4 \u5bf9\u7ebf\u6027\u57fa\u505a\u884c\u53d8\u6362\u4f7f\u5176\u6210\u4e3a\u7c7b\u4f3c\u4e8e\u9ad8\u65af\u6d88\u5143\u7684\u5f62\u5f0f\uff0c\u4ee5\u4fbf\u80fd\u6c42\u51fa\u6392\u540d kth restructure log k:\u7b2ck\u5c0f\u6570\u7684\u6392\u540dk \u7b2ck\u5c0f\u6570 \u6c42\u51fa\u7b2ck\u5c0f\u7684\u80fd\u88ab\u8868\u51fa\u7684\u6570\uff08\u91cd\u6784\u540e\uff09 operator| log^2 n2\uff1a\u5f85\u5408\u5e76\u7684\u7ebf\u6027\u57fa ret\uff1a\u5408\u5e76\u540e\u7684\u7ebf\u6027\u57fa \u5408\u5e76\u7ebf\u6027\u57fa\uff08\u91cd\u6784\u524d\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 //HDOJ 3949 #include <iostream> #include <cstdio> #include <cstring> #include <memory.h> #include <algorithm> #include <map> #include <vector> #include <queue> #include <cmath> using namespace std ; typedef long long ll ; const int N = 2e5 + 10 ; namespace Linear_Basis { struct LB //linear basis { static const int SZ = 63 ; //local ll p [ SZ ]; //p\uff1a\u7b2ci\u4e2ap\u4fdd\u5b58\u5bf9\u5e94\u6700\u9ad8\u4f4d\u4e3a1\u7684\u6570 bool flag ; //flag:\u662f\u5426\u53ef\u5f02\u6216\u5f97\u52300 (whether can do xor to obtain 0) int cnt ; //cnt\uff1a\u91cd\u6784\u540e\uff08\u9ad8\u65af\u6d88\u5143\uff09\u7684\u57fa\u5927\u5c0f //\u521d\u59cb\u5316 LB () { //for(int i=0;i<SZ;i++) //p[i]=0; memset ( p , 0 , sizeof ( p )); //\u6ca1\u4ec0\u4e48\u592a\u5927\u6027\u80fd\u5f00\u9500 cnt = flag = 0 ; } //\u63d2\u5165x\u5230\u7ebf\u6027\u57fa\u4e2d bool insert ( ll x ) { for ( int j = SZ -1 ; j >= 0 ; j -- ) { if ( x >> j == 0 ) continue ; if ( p [ j ] == 0 ) { p [ j ] = x ; return true ; } x ^= p [ j ]; } flag = true ; return false ; } //\u53d6\u5f97\u7ebf\u6027\u57fa\u80fd\u7ebf\u6027\u8868\u51fa\u7684\u6700\u5927\u503c\uff08\u91cd\u6784\u524d\uff09 ll get_max ( ll ans = 0 ) //ans:\u5f02\u6216\u521d\u503c { for ( int i = SZ -1 ; i >= 0 ; i -- ) { if (( ans ^ p [ i ]) > ans ) ans ^= p [ i ]; } return ans ; } //\u53d6\u5f97\u7ebf\u6027\u57fa\u4e2d\u80fd\u8868\u51fa\u7684\u6700\u5c0f\u7684\u503c\uff08\u91cd\u6784\u524d\uff09 ll get_min () { if ( flag ) return 0 ; for ( int i = 0 ; i < SZ ; i ++ ) { if ( p [ i ]) return p [ i ]; } return 0 ; } //\u5bf9\u7ebf\u6027\u57fa\u505a\u884c\u53d8\u6362\u4f7f\u5176\u6210\u4e3a\u7c7b\u4f3c\u4e8e\u9ad8\u65af\u6d88\u5143\u7684\u5f62\u5f0f void restructure () { for ( int i = SZ -1 ; i >= 0 ; i -- ) { if ( p [ i ]) { for ( int j = i -1 ; j >= 0 ; j -- ) { if ( p [ i ] & ( 1l l << j )) { p [ i ] ^= p [ j ]; } } } } for ( int i = 0 ; i < SZ ; i ++ ) { if ( p [ i ]) { p [ cnt ++ ] = p [ i ]; } } } //\u6c42\u51fa\u7b2ck\u5c0f\u7684\u80fd\u88ab\u8868\u51fa\u7684\u6570\uff08\u91cd\u6784\u540e\uff09 ll kth ( ll k ) //before calling this func, must run restructure func once { //\u5bf9k\u6216k-1\u505a\u4e8c\u8fdb\u5236\u5206\u89e3 if ( flag ) k -- ; if ( k == 0 ) return 0 ; if ( k >= ( 1l l << cnt )) return -1 ; ll ans = 0 ; for ( int i = 0 ; i < cnt ; i ++ ) { if ( k & ( 1l l << i )) { ans ^= p [ i ]; } } return ans ; } //\u5408\u5e76\u7ebf\u6027\u57fa\uff08\u91cd\u6784\u524d\uff09 LB operator | ( const LB & n2 ) //\u5408\u5e76\u7ebf\u6027\u57fa { LB ret = * this ; for ( int i = 0 ; i < SZ ; i ++ ) { if ( n2 . p [ i ]) { ret . insert ( n2 . p [ i ]); } } ret . flag |= n2 . flag ; //? return ret ; } }; } using namespace Linear_Basis ; int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); int T ; cin >> T ; for ( int _ = 1 ; _ <= T ; _ ++ ) { int n ; cin >> n ; LB lb ; for ( int i = 1 ; i <= n ; i ++ ) { ll x ; cin >> x ; lb . insert ( x ); } lb . restructure (); cout << \"Case #\" << _ << \":\" << endl ; int q ; cin >> q ; for ( int i = 1 ; i <= q ; i ++ ) { ll k ; cin >> k ; cout << lb . kth ( k ) << endl ; } } return 0 ; } \u7ebf\u6027\u6c42\u9006\u5143 \u00b6 \u8fd9\u4e2a\u61d2\u5f97\u6574namespace\u4e86\u2026\u2026 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include <iostream> #include <cstdio> #include <cmath> using namespace std ; const int N = 114514 ; long long inv [ N ], p ; void linear_inv ( int n ) //in mod p { inv [ 1 ] = 1 ; //p=ki+j==0 (mod p) -> -kj^-1=i^-1 //k=p/i, j=(p%i)^-1 for ( int i = 2 ; i <= n ; i ++ ) { inv [ i ] = ( long long )( p - p / i ) * inv [ p % i ] % p ; //(p-p/i)==(-p/i) } //if inv[i]=0, inverse not exists. //\u5982\u679c\u6ca1\u6709\u76f8\u5e94\u7684\u9006\u5143\u7684\u65f6\u5019\uff0cinv[i] \u7684\u503c\u662f\u672a\u5b9a\u4e49\u7684 } int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ), cout . tie ( 0 ); return 0 ; } \u7ebf\u6027\u6c42\u4efb\u610f\u7ed9\u5b9an\u4e2a\u6570\u7684\u9006\u5143 \u00b6 luogu 5431 multi_inverse2 \u00b6 \u9898\u610f\uff1a\u7ed9\u5b9an\u4e2a\u6570ai\uff0c\u6c42\u5728mod p\u610f\u4e49\u4e0b\u7684\u9006\u5143\u3002\u7ed9\u5b9a\u5e38\u6570k\uff0c\u8f93\u51fa \\(\\sum_{i=1}^n \\frac{k^i}{a_i} \\% p\\) \u89e3\u6cd5\uff1a \u9996\u5148\u8ba1\u7b97 \\(n\\) \u4e2a\u6570\u7684\u524d\u7f00\u79ef\uff0c\u8bb0\u4e3a \\(s_i\\) \uff0c\u7136\u540e\u4f7f\u7528\u5feb\u901f\u5e42\u6216\u6269\u5c55\u6b27\u51e0\u91cc\u5f97\u6cd5\u8ba1\u7b97 \\(s_n\\) \u7684\u9006\u5143\uff0c\u8bb0\u4e3a \\(sv_n\\) \u3002 \u56e0\u4e3a \\(sv_n\\) \u662f \\(n\\) \u4e2a\u6570\u7684\u79ef\u7684\u9006\u5143\uff0c\u6240\u4ee5\u5f53\u6211\u4eec\u628a\u5b83\u4e58\u4e0a \\(a_n\\) \u65f6\uff0c\u5c31\u4f1a\u548c \\(a_n\\) \u7684\u9006\u5143\u62b5\u6d88\uff0c\u4e8e\u662f\u5c31\u5f97\u5230\u4e86 \\(a_1\\) \u5230 \\(a_{n-1}\\) \u7684\u79ef\u9006\u5143\uff0c\u8bb0\u4e3a \\(sv_{n-1}\\) \u3002 \u540c\u7406\u6211\u4eec\u53ef\u4ee5\u4f9d\u6b21\u8ba1\u7b97\u51fa\u6240\u6709\u7684 \\(sv_i\\) \uff0c\u4e8e\u662f \\(a_i^{-1}\\) \u5c31\u53ef\u4ee5\u7528 \\(s_{i-1} \\times sv_i\\) \u6c42\u5f97\u3002 \u6240\u4ee5\u6211\u4eec\u5c31\u5728 \\(O(n + \\log p)\\) \u7684\u65f6\u95f4\u5185\u8ba1\u7b97\u51fa\u4e86 \\(n\\) \u4e2a\u6570\u7684\u9006\u5143\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 #include <iostream> #include <cstdio> using namespace std ; const int N = 5e6 + 10 ; int n , p , k , kk = 1 , ans = 0 ; int a [ N ], s [ N ], sv [ N ], inv [ N ]; typedef long long ll ; namespace Fast_IO { template < typename T > inline void read ( T & x ) { char c ; int sgn = 1 ; x = 0 ; c = getchar (); while ( c > '9' || c < '0' ) { if ( c == '-' ) sgn = -1 ; c = getchar (); } while ( c <= '9' && c >= '0' ) { x = ( x << 3 ) + ( x << 1 ) + ( c - '0' ); c = getchar (); } x *= sgn ; } // template <typename T> inline void read(T &x){ // x=0; // char ch; // for(ch=getchar();ch<'0'||ch>'9';ch=getchar()); // for(;ch>='0'&&ch<='9';ch=getchar()) // x=(x<<3)+(x<<1)+(ch&15); // } template < typename T > inline void print ( T x ) { if ( x < 0 ) { putchar ( '-' ); x = - x ; } if ( x > 9 ) { print ( x / 10 ); } putchar ( x % 10 + '0' ); } } // namespace Fast_IO using namespace Fast_IO ; // //\u6269\u5c55\u6b27\u51e0\u91cc\u5f97\uff1aax+by=1 // ll exgcd(ll a,ll b,ll &x,ll &y) // { // if(!b) // { // x=1,y=0; // return a; // } // ll d=exgcd(b,a%b,x,y),tempx=x,tempy=y; // x=tempy; // y=tempx-tempy*(a/b); // return d; // } //\u5faa\u73af int ksm ( int a , int b , int Mod ) { int ans = 1 ; while ( b ) { if ( b & 1 ) ans = ( 1l l * ans * a ) % Mod ; a = ( 1l l * a * a ) % Mod ; b >>= 1 ; } return ans ; } void getinv () { // long long x,y; //exgcd(s[n],p,x,y); //get s[n]^-1 (mod p) //sv[n]=(x%p+p)%p; //sv[i]=s[i]^-1 //exgcd(k,p,x,y); int k_inv = ksm ( k , p -2 , p ); sv [ n ] = ksm ( s [ n ], p -2 , p ); for ( int i = n ; i >= 1 ; i -- ) { if ( i < n ) { sv [ i ] = ( 1l l * sv [ i + 1 ] * a [ i + 1 ]) % p ; } inv [ i ] = ( 1l l * sv [ i ] * s [ i -1 ]) % p ; // print(inv[i]); // putchar('\\n'); //custom ans = ( ans + ( 1l l * kk * inv [ i ]) % p ) % p ; kk = ( 1l l * kk * k_inv ) % p ; } print ( ans ); } int main () { read ( n ), read ( p ), read ( k ); s [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { // scanf(\"%d\",&a[i]); read ( a [ i ]); s [ i ] = ( 1l l * s [ i -1 ] * a [ i ]) % p ; kk = ( 1l l * kk * k ) % p ; } getinv (); return 0 ; } \u7ebf\u6027\u8d28\u6570\u7b5b \u4e0e \u57fa\u4e8e\u7b5b\u7684\u56e0\u6570\u5206\u89e3 \u00b6 Funs || Methods Reliance Time Complexity Inputs Outputs Description linear_sieve n n prime,p,v \u7b5b\u51fa\u5230n\u4e3a\u6b62\u7684\u8d28\u6570 \u5206\u89e3k\u7684\u56e0\u6570 linear_sieve <=sqrt k res\uff1a\u4e00\u4e2a\u4fdd\u5b58\u6240\u6709\u56e0\u6570\u7684vector\uff08\u6ca1\u6392\u5e8f\uff09 \u5206\u89e3k\u7684\u56e0\u6570\uff0c\u5b58\u5728vector\u4e2d \u5206\u89e3x\u7684\u8d28\u56e0\u6570 linear_sieve log x res\uff1a\u4fdd\u5b58pair\u7684vector\uff0cpair\u7b2c\u4e00\u4e2a\u6570\u662fprime\uff0c\u7b2c\u4e8c\u4e2a\u6570\u662fcnt \u5206\u89e3x\u7684\u8d28\u56e0\u6570 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 //\u7ebf\u6027\u7b5b+\u5206\u89e3\u56e0\u6570 #include <vector> #include <iostream> using namespace std ; namespace L { const int N = ( int ) 1e7 + 10 ; //local int prime [ N ], p , v [ N ]; //prime\uff1a\u8d28\u6570\u96c6\u5408 //p:\u8d28\u6570\u4e2a\u6570 //v\uff1a\u4e0b\u6807i\u4ee3\u8868\u7684\u6570\u7684\u6700\u5c0f\u8d28\u56e0\u5b50 //\u7b5b\u51fa\u5230n\u4e3a\u6b62\u7684\u8d28\u6570 void linear_sieve ( int n ) { for ( int i = 2 ; i <= n ; i ++ ) { if ( ! v [ i ]) { v [ i ] = i ; prime [ ++ p ] = i ; } for ( int j = 1 ; j <= p && ( long long ) prime [ j ] * i <= n && v [ i ] >= prime [ j ]; j ++ ) { v [ i * prime [ j ]] = prime [ j ]; } } } //\u5206\u89e3k\u7684\u56e0\u6570(\u9700\u8981\u6392\u5e8f\uff01) vector < long long > Div ( long long k ) { vector < long long > res ; res . push_back ( 1 ); for ( long long i = 1 ; prime [ i ] * prime [ i ] <= k ; i ++ ) { if ( k % prime [ i ] == 0 ) { long long now = prime [ i ]; long long len = res . size (); while ( k % prime [ i ] == 0 ) { for ( long long j = 0 ; j < len ; j ++ ) { res . push_back ( res [ j ] * now ); } now *= prime [ i ]; k /= prime [ i ]; } } } if ( k > 1 ) { long long len = res . size (); for ( long long j = 0 ; j < len ; j ++ ) { res . push_back ( res [ j ] * k ); } } return res ; } //\u5206\u89e3x\u7684\u8d28\u56e0\u6570 vector < pair < int , int >> div2 ( int x ) //\u5206\u89e3\u8d28\u56e0\u6570 { vector < pair < int , int >> res ; while ( x > 1 ) { int minprime = v [ x ]; int cnt = 0 ; while ( x % minprime == 0 ) { x /= minprime ; cnt ++ ; } res . push_back ({ minprime , cnt }); } return res ; } } using namespace L ; int main () { linear_sieve ( 1e7 ); int n ; cin >> n ; vector < long long > s = Div ( n ); for ( auto i : s ) cout << i << \" \" ; return 0 ; } \u6b27\u62c9\u51fd\u6570Phi\u7b5b \u00b6 16 th \u9ed1\u9f99\u6c5f\u7701\u8d5b f-function \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <cstdlib> #include <algorithm> #include <string> #include <vector> #include <map> #include <unordered_map> #include <set> #include <unordered_set> #include <queue> using namespace std ; typedef unsigned long long ll ; const int N = 1e7 + 10 ; int phi [ N ]; int pri [ N ]; ll vis [ N ]; int cnt = 0 ; void init () { phi [ 1 ] = 1 ; for ( int i = 2 ; i <= 10000000 ; ++ i ) { if ( ! vis [ i ]) { phi [ i ] = i - 1 ; pri [ cnt ++ ] = i ; } for ( int j = 0 ; j < cnt ; ++ j ) { if ( 1l l * i * pri [ j ] > 10000000 ) break ; vis [ i * pri [ j ]] = pri [ j ]; if ( i % pri [ j ]) { phi [ i * pri [ j ]] = phi [ i ] * ( pri [ j ] - 1 ); } else { // i % pri[j] == 0 // \u6362\u8a00\u4e4b\uff0ci \u4e4b\u524d\u88ab pri[j] \u7b5b\u8fc7\u4e86 // \u7531\u4e8e pri \u91cc\u9762\u8d28\u6570\u662f\u4ece\u5c0f\u5230\u5927\u7684\uff0c\u6240\u4ee5 i \u4e58\u4e0a\u5176\u4ed6\u7684\u8d28\u6570\u7684\u7ed3\u679c\u4e00\u5b9a\u4f1a\u88ab // pri[j] \u7684\u500d\u6570\u7b5b\u6389\uff0c\u5c31\u4e0d\u9700\u8981\u5728\u8fd9\u91cc\u5148\u7b5b\u4e00\u6b21\uff0c\u6240\u4ee5\u8fd9\u91cc\u76f4\u63a5 break // \u6389\u5c31\u597d\u4e86 phi [ i * pri [ j ]] = phi [ i ] * pri [ j ]; break ; } } } } ll cal ( int xx ) { int t = 0 ; int tx = vis [ xx ], txx = xx ; for (;;) { if (( xx / tx ) * tx != xx ) { break ; } t ++ ; xx /= tx ; } ll sum = 0 ; sum = t % 2 == 0 ? t / 2 : t / 2 + 1 ; sum = txx / pow ( tx , sum ); return sum ; } int main () { ll ans = 0 ; init (); int n ; cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) { if ( vis [ i ] == 0 ) { //cout<<\"t\"<<1<<endl; ans += 1 ; continue ; } else { auto tmp = cal ( i ); //cout<<\"t\"<<tmp<<endl; ans += tmp ; } } cout << ans << endl ; return 0 ; } \u83ab\u6bd4\u4e4c\u65af\u51fd\u6570 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 namespace Mo { const int NN = 1e7 + 10 ; int mu [ NN ], v [ NN ], prime [ NN ], prime_tot ; //\u7b5b\u51fa\u8d28\u6570\u4e0e\u83ab\u6bd4\u4e4c\u65af\u51fd\u6570\u7684\u503c void linear_sieve_mo ( int n ) { prime_tot = 0 ; mu [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( ! v [ i ]) { v [ i ] = i ; prime [ ++ prime_tot ] = i ; mu [ i ] = -1 ; } for ( int j = 1 ; j <= prime_tot && 1l l * i * prime [ j ] <= n ; j ++ ) { v [ i * prime [ j ]] = prime [ j ]; if ( i % prime [ j ] == 0 ) { mu [ i * prime [ j ]] = 0 ; break ; } mu [ i * prime [ j ]] = - mu [ i ]; } } } } using namespace Mo ; \u6570\u8bba\u5206\u5757 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <cstdlib> #include <algorithm> #include <string> #include <vector> #include <map> #include <unordered_map> #include <set> #include <unordered_set> #include <queue> using namespace std ; typedef long long ll ; namespace Shulunfenkuai { inline ll ceil ( ll n , ll m ) { return n / m + ( n % m != 0 ); } //\u5411\u4e0a\u53d6\u6574\u6c42\u548c ll calculate1 ( ll k , ll n ) { ll ans = 0 ; for ( ll x = 1 , gx ; x <= n ; x = gx + 1 ) { gx = ( k / x ) ? min ( k / ( k / x ) , n ) : n ; ans += k / x ; } return ans ; } //\u5411\u4e0b\u53d6\u6574\u6c42\u548c : k/m <= i <= (k-1)/(m-1) , (m=ceil(k/i)) //https://www.cnblogs.com/zjjws/p/13393858.html ll calculate2 ( ll k , ll n ) { ll ans = 0 ; for ( ll x = 1 , gx ; x <= n ; x = gx + 1 ) { ll v = ceil ( n , x ); gx = ( v != 1 ) ? min (( k -1 ) / ( v -1 ) , n ) : ( n ); ans += v ; } return ans ; } } using namespace Shulunfenkuai ; int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ), cout . tie ( 0 ); return 0 ; } \u5feb\u901f\u5e42 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 const long long Mod = 10 ; //\u9012\u5f52 long long ksm ( long long a , long long b ) { if ( b == 0 ) return 1 ; if ( b == 1 ) return a % Mod ; long long ans = ksm ( a , b >> 1 ); ans *= ans ; ans %= Mod ; if ( b & 1 ) { ans *= a ; } return ans % Mod ; } //\u5faa\u73af long long ksm ( long long a , long long b , long long Mod ) { long long ans = 1 ; while ( b ) { if ( b & 1 ) ans = ( ans * a ) % Mod ; a = ( a * a ) % Mod ; b >>= 1 ; } return ans ; } //\u5feb\u901f\u4e58\u6cd5\uff08\u7528\u4e8e\u89e3\u51b3\u4e58\u6cd5\u7206longlong\uff09 long long mul ( long long a , long long b , long long Mod ) { long long ans = a ; while ( b ) { if ( b & 1 ) ans = ( ans + a ) % Mod ; a = ( a + a ) % Mod ; b >>= 1 ; } return ans ; } gcd\u4e0eexgcd\u3001\u7ebf\u6027\u540c\u4f59\u65b9\u7a0b \u00b6 Funs || Methods Reliance Time Complexity Inputs Outputs Description gcd log a,b gcd(a,b) gcd exgcd log a,b,x,y \u8fd4\u56degcd(a,b)\uff0c\u4fee\u6539x\u3001y\u4f5c\u4e3a\u7ed3\u679c exgcd\uff1aax+by=1 get_inv log a,p x\uff1aa^-1 \u6c42\u51faa\u5173\u4e8ep\u7684\u9006\u5143\u3002\u4f46\u8981\u6ce8\u610fgcd(a,p)==1\u65f6\u9006\u5143\u624d\u5b58\u5728 solve_linear_equation log a,b,p \u4e00\u4e2a\u89e3x \u6c42\u51fa\u65b9\u7a0bax=b(mod p) \u7684\u89e3\u3002\u4f46\u8981\u6ce8\u610f\u6709\u89e3\u5f53\u4e14\u4ec5\u5f53 gcd(a,p) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 namespace EXGCD { typedef long long ll ; //\u666e\u901a\u7684gcd ll gcd ( ll a , ll b ) { return b ? gcd ( b , a % b ) : a ; } //\u6269\u5c55\u6b27\u51e0\u91cc\u5f97\uff1aax+by=1 ll exgcd ( ll a , ll b , ll & x , ll & y ) { if ( ! b ) { x = 1 , y = 0 ; return a ; } ll d = exgcd ( b , a % b , x , y ), tempx = x , tempy = y ; x = tempy ; y = tempx - tempy * ( a / b ); return d ; } //\u6c42a\u5173\u4e8ep\u7684\u9006\u5143\uff08\u6c42\u540c\u4f59\u65b9\u7a0bax=1(mod p)-> p|(ax-1) -> ax+py=1\uff09 ll get_inv ( ll a , ll p ) { ll x , y ; ll g = exgcd ( a , p , x , y ); //x\u5c31\u662f\u89e3\uff0c\u4f46\u662f\u8981\u6ce8\u610f\u5982\u679c\u5e0c\u671b\u5f97\u5230\u6b63\u6574\u6570\u89e3\u5e94\u8be5\u5bf9x\u53d6\u6a21 return x = ( x % p + p ) % p ; } //\u6c42\u51fa\u65b9\u7a0bax=b(mod p) \u7684\u89e3\u3002\u4f46\u8981\u6ce8\u610f\u6709\u89e3\u5f53\u4e14\u4ec5\u5f53 gcd(a,p)|b ll solve_linear_equation ( ll a , ll b , ll p ) { //ax=b(mod p) -> ax+py=b //\u6709\u89e3\u5f53\u4e14\u4ec5\u5f53 gcd(a,p)|b\uff0c\u6c42\u51faax0+py0\u89e3\u540ex0\u4e58\u4ee5b/gcd(a,m)\u5373\u53ef\u5f97\u539f\u65b9\u7a0b\u7684\u4e00\u4e2a\u89e3 ll x , y ; ll g = exgcd ( a , p , x , y ); if ( b % g != 0 ) return -1 ; x *= ( b / g ); //\u6ce8\u610f\uff1a\u9700\u8981g|b\uff0c\u5426\u5219\u65e0\u89e3 x = ( x % p + p ) % p ; return x ; } } using namespace EXGCD ; \u4e2d\u56fd\u5269\u4f59\u5b9a\u7406 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include <iostream> //Chinese remainder theorem using namespace std ; int congruence_equation_number ; long long m [ 20 ], a [ 20 ], t [ 20 ], M = 1 ; long long exgcd ( long long a , long long b , long long & x , long long & y ) { if ( b == 0 ) { x = 1 ; y = 0 ; return a ; } long long d = exgcd ( b , a % b , x , y ), temp_x = x , temp_y = y ; x = temp_y ; y = temp_x - temp_y * ( a / b ); return d ; } int main () { ios :: sync_with_stdio ( false ); cin >> congruence_equation_number ; for ( int i = 1 ; i <= congruence_equation_number ; i ++ ) { cin >> m [ i ] >> a [ i ]; M *= m [ i ]; } for ( int i = 1 ; i <= congruence_equation_number ; i ++ ) { long long x , y ; exgcd ( M / m [ i ], m [ i ], x , y ); t [ i ] = x ; } long long ans = 0 ; for ( int i = 1 ; i <= congruence_equation_number ; i ++ ) { ans += ( a [ i ] * M / m [ i ] * t [ i ]) % M ; ans %= M ; } cout << ( ans + M ) % M << endl ; return 0 ; } \u6269\u5c55\u6b27\u51e0\u91cc\u5f97\u6c42\u6574\u6570\u70b9\u4e2a\u6570 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <cstdlib> #include <algorithm> #include <string> #include <vector> #include <map> #include <unordered_map> #include <set> #include <unordered_set> #include <queue> using namespace std ; typedef long long ll ; typedef long double ld ; namespace EXGCD { typedef long long ll ; //\u666e\u901a\u7684gcd ll gcd ( ll a , ll b ) { return b ? gcd ( b , a % b ) : a ; } //\u6269\u5c55\u6b27\u51e0\u91cc\u5f97\uff1aax+by=1 ll exgcd ( ll a , ll b , ll & x , ll & y ) { if ( ! b ) { x = 1 , y = 0 ; return a ; } ll d = exgcd ( b , a % b , x , y ), tempx = x , tempy = y ; x = tempy ; y = tempx - tempy * ( a / b ); return d ; } //\u6c42a\u5173\u4e8ep\u7684\u9006\u5143\uff08\u6c42\u540c\u4f59\u65b9\u7a0bax=1(mod p)-> p|(ax-1) -> ax+py=1\uff09 ll get_inv ( ll a , ll p ) { ll x , y ; ll g = exgcd ( a , p , x , y ); //x\u5c31\u662f\u89e3\uff0c\u4f46\u662f\u8981\u6ce8\u610f\u5982\u679c\u5e0c\u671b\u5f97\u5230\u6b63\u6574\u6570\u89e3\u5e94\u8be5\u5bf9x\u53d6\u6a21 return x = ( x % p + p ) % p ; } //\u6c42\u51fa\u65b9\u7a0bax=b(mod p) \u7684\u89e3\u3002\u4f46\u8981\u6ce8\u610f\u6709\u89e3\u5f53\u4e14\u4ec5\u5f53 gcd(a,p)|b ll solve_linear_equation ( ll a , ll b , ll p ) { //ax=b(mod p) -> ax+py=b //\u6709\u89e3\u5f53\u4e14\u4ec5\u5f53 gcd(a,p)|b\uff0c\u6c42\u51faax0+py0\u89e3\u540ex0\u4e58\u4ee5b/gcd(a,m)\u5373\u53ef\u5f97\u539f\u65b9\u7a0b\u7684\u4e00\u4e2a\u89e3 ll x , y ; ll g = exgcd ( a , p , x , y ); x *= ( b / g ); //\u6ce8\u610f\uff1a\u9700\u8981g|b\uff0c\u5426\u5219\u65e0\u89e3 x = ( x % p + p ) % p ; return x ; } } using namespace EXGCD ; namespace Zhengshu_points { //(ai+b)/c=k (k>0,0<=i<=n) // a,b,c>0, n>=0 ll get_zhengshu_points ( ll a , ll b , ll c , ll n ) { ll i0 , k0 ; ll g = exgcd ( a , - c , i0 , k0 ); if ( - b % g != 0 ) return 0 ; //no solution // ll Kr=-b*i0 double Krd = ( - b * i0 ) * ( ld ) 1.0 / c ; double Kld = ( n * g + b * i0 ) * ( ld ) 1.0 / ( - c ); if ( g < 0 ) { swap ( Kld , Krd ); } ll Kr = floor ( Krd ); ll Kl = ceil ( Kld ); return max ( 0l l , Kr - Kl + 1 ); } } using namespace Zhengshu_points ; int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ), cout . tie ( 0 ); ll a , b , c , n ; cin >> a >> b >> c >> n ; cout << get_zhengshu_points ( a , b , c , n ) << endl ; return 0 ; } \u7c7b\u6b27\u51e0\u91cc\u5f97\u7b97\u6cd5 \u00b6 202 ICPC Shenyang \u00b6 \u539f\u9898\u53ef\u8f6c\u5316\u4e3a\u8ba1\u7b97 $$ f(a,b,c,n)=\\sum_{i=0}^n \\lfloor\\frac{ai+b}{c}\\rfloor $$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <cstdlib> #include <algorithm> #include <string> #include <vector> #include <map> #include <unordered_map> #include <set> #include <unordered_set> #include <queue> using namespace std ; typedef long long ll ; typedef long double ld ; typedef __int128 vl ; ll H , M , A ; namespace Like_Euclid { // vl ff ( vl a , vl b , vl c , vl n ) { if ( a == 0 ) return b / c * ( n + 1 ); if ( a >= c || b >= c ) { return ff ( a % c , b % c , c , n ) + ( a / c ) * n * ( n + 1 ) / 2 + ( b / c ) * ( n + 1 ); } vl m = ( a * n + b ) / c ; return n * m - ff ( c , c - b -1 , a , m -1 ); } } using namespace Like_Euclid ; namespace EXGCD { //\u6269\u5c55\u6b27\u51e0\u91cc\u5f97\uff1aax+by=1 vl exgcd ( vl a , vl b , vl & x , vl & y ) { if ( ! b ) { x = 1 , y = 0 ; return a ; } vl d = exgcd ( b , a % b , x , y ), tempx = x , tempy = y ; x = tempy ; y = tempx - tempy * ( a / b ); return d ; } } using namespace EXGCD ; namespace Zhengshu_points { template < typename Ty > Ty fl ( Ty a , Ty b ) { if (( a < 0 && b > 0 ) || ( a > 0 && b < 0 )) { return ( a / b ) - ( a % b != 0 ); } return a / b ; } template < typename Ty > Ty ce ( Ty a , Ty b ) { if (( a < 0 && b > 0 ) || ( a > 0 && b < 0 )) { return ( a / b ); } return ( a / b ) + ( a % b != 0 ); } //(ai+b)/c=k (k>0,0<=i<=n) // a,b,c>0, n>=0 vl get_zhengshu_points ( vl a , vl b , vl c , vl n ) { vl i0 , k0 ; vl g = exgcd ( a , - c , i0 , k0 ); if ( - b % g != 0 ) return 0 ; //no solution // ld Krd=(-b*i0)*(ld)1.0/c; // ld Kld=(n*g+b*i0)*(ld)1.0/(-c); // if(g<0) // { // swap(Kld,Krd); // } // vl Kr= floor(Krd); // vl Kl= ceil(Kld); vl Kr , Kl ; if ( g < 0 ) { // Kl=(-b*i0)/c + ((-b*i0)%c != 0); Kl = ce ( - b * i0 , c ); // Kr=(n*g+b*i0)/(-c); Kr = fl ( n * g + b * i0 , - c ); } else { // Kl=(n*g+b*i0)/(-c) + ((n*g+b*i0)%(-c) != 0); Kl = ce ( n * g + b * i0 , - c ); // Kr=(-b*i0)/c; Kr = fl ( - b * i0 , c ); } return max (( vl ) 0 , Kr - Kl + 1 ); } } using namespace Zhengshu_points ; ll solve ( ll H , ll M , ll A ) { //a=MH,b=A,c=H-1 vl ans = ff ( M * H , A , H -1 , H -2 ); // ld zero_point=A/(M*H); vl z1 = A / ( M * H ); vl z2 = z1 + 1 ; z1 = min ( z1 ,( vl )( H -2 )); vl bb = M * H * z1 - A ; // bb=-bb; bb<=0 ans += ff ( M * H , - bb , H -1 , z1 ); if ( z2 <= H -2 ) { vl bb2 = M * H * z2 - A ; ans -= ff ( M * H , bb2 , H -1 , H -2 - z2 ); ans += get_zhengshu_points ( M * H , bb2 , H -1 , H -2 - z2 ); } // cout<<\"ans:\"<<(ll)ans<<endl; // cout<<\"z1:\"<<(ll)z1<<endl; // cout<<\"a2mh:\"<<(ll)(A*2!=M*H)<<endl; // return ans+z1+(A*2!=M*H); return ans + z1 + 1 ; } int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ), cout . tie ( 0 ); cin >> H >> M >> A ; if ( H * M == A * 2 ) { cout << H * M << endl ; } // else if(A==0) // { // cout<<1<<endl; // } else cout << solve ( H , M , A ) << endl ; return 0 ; } \u7c73\u52d2\u7f57\u5bbe\u8d28\u6570\u5224\u522b\u6cd5 \u4e0e Pollard Rho \u56e0\u6570\u5206\u89e3\u6cd5 \u00b6 \u8bf4\u8d77\u6765\u8fd9\u73a9\u610f\u4f1a\u7528\u5230mt19937\u8fd9\u73a9\u610f\u2026\u2026 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 //pollard Rho & Miller Rabin LUOGU 4718 #include <iostream> #include <cstdio> #include <ctime> #include <map> #include <random> using namespace std ; typedef long long ll ; typedef __int128_t lll ; int T ; ll n ; namespace PR { //local std :: mt19937 rd ( time ( 0 )); ll __a [] = { 2 , 325 , 9375 , 28178 , 450775 , 9780504 , 1795265022 }; //b[]={2,7,61}; (for 2^32) ll gcd ( ll a , ll b ) { return b == 0 ? a : gcd ( b , a % b ); } ll ksm ( ll a , ll b , ll Mod ) //\u6ce8\u610f\uff1a\u4f7f\u7528lll\u9632\u70b8 { ll ans = 1 ; while ( b ) { if ( b & 1 ) ans = (( lll ) ans * a ) % Mod ; a = (( lll ) a * a ) % Mod ; b >>= 1 ; } return ans ; } //\u8d28\u6570\u5224\u522b bool miller_rabin ( ll n ) { if ( n == 2 || n == 3 ) return true ; if ( n < 2 || n % 2 == 0 ) return false ; // n%2==0 spj for even num ll d = n -1 , r = 0 ; while ( d % 2 == 0 ) { r ++ ; d /= 2 ; } for ( int a_p = 0 ; a_p < 7 ; a_p ++ ) { ll aa = __a [ a_p ]; ll x = ksm ( aa , d , n ); //maybe 0, need to special judge x=0 if ( x <= 1 || x == n -1 ) continue ; //a^{d}=1 or -1 for ( int i = 0 ; i < r -1 ; i ++ ) { x = ( lll ) x * x % n ; if ( x == n -1 ) break ; // find a^{2^r d}=-1 (mod n) } if ( x != n -1 ) return false ; //!= } return true ; } //\u8ba1\u7b97x^2+c\uff0c\u4f1a\u88ab\u4e0b\u9762\u7684PR\u51fd\u6570\u7528\u5230 ll __f ( ll x , ll c , ll Mod ) { return (( lll ) x * x + c ) % Mod ; } //\u6c42\u51fan\u7684\u4e00\u4e2a\u56e0\u6570 ll Pollard_Rho ( ll n ) //n must be composite { ll s = 0 , t = 0 ; ll c = ( ll ) rd () % ( n -1 ) + 1 ; ll val = 1 ; for ( ll goal = 1 ;; goal <<= 1 , s = t , val = 1 ) { for ( ll step = 1 ; step <= goal ; step ++ ) { t = __f ( t , c , n ); val = ( lll ) val * abs ( t - s ) % n ; if ( step % 127 == 0 ) { ll d = gcd ( val , n ); if ( d > 1 ) return d ; } } ll d = gcd ( val , n ); if ( d > 1 ) return d ; } } //local ll maxfactor = 0 ; //maxfactor\uff1a\u4fdd\u5b58n\u7684\u6700\u5927\u56e0\u6570 //\u5206\u89e3n\u5e76\u6c42n\u7684\u6700\u5927\u56e0\u6570 void do_div ( ll n ) //maximun prime factor of n { if ( n <= maxfactor || n < 2 ) return ; if ( miller_rabin ( n )) { maxfactor = max ( maxfactor , n ); return ; } ll m = n ; while ( m == n ) { m = Pollard_Rho ( n ); } while ( n % m == 0 ) { n /= m ; } do_div ( n ); do_div ( m ); } map < ll , ll > dv ; //dv\uff1a\u7528\u4e8e\u4fdd\u5b58\u56e0\u6570\u5206\u89e3\u7ed3\u679c //\u5206\u89e3\u56e0\u6570n\uff0c\u5e76\u5c06n\u7684\u6240\u6709\u56e0\u6570\u4fdd\u5b58\u5728dv\u4e2d void do_div2 ( map < ll , ll > & dv , ll n ) { if ( miller_rabin ( n )) { dv [ n ] ++ ; return ; } ll m = n ; while ( m == n ) { m = Pollard_Rho ( n ); } n /= m ; do_div2 ( dv , n ); do_div2 ( dv , m ); } } using namespace PR ; int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ), cout . tie ( 0 ); cin >> T ; while ( T -- ) { maxfactor = 0 ; cin >> n ; do_div ( n ); if ( maxfactor == n ) cout << \"Prime\" << endl ; else cout << maxfactor << endl ; } return 0 ; } BSGS\uff08\u6a21\u610f\u4e49\u4e0b\u53d6\u5bf9\u6570\uff09 \u00b6 \u590d\u6742\u5ea6\u662f\u6839\u53f7\u7ea7\u522b\u7684\uff0c\u7528\u4e8e\u6c42\u89e3 $$ a^x\\equiv b\\pmod p $$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 #include <iostream> #include <unordered_map> #include <cmath> using namespace std ; typedef long long ll ; namespace BSGS { //public long long a , b , p ; //local unordered_map < long long , long long > ha ; //ha:\u7528\u4e8e\u4fdd\u5b58\u4e2d\u9014\u7a77\u4e3e\u7684\u7ed3\u679c //a^x=b(mod p) //a^(it-j)=b (mod p) //a^t^i=ba^j (mod p) long long ksm ( long long a , long long b , long long m ) { if ( b == 0 ) return 1 ; if ( b == 1 ) return a % m ; long long ans = ksm ( a , b / 2 , m ); ans *= ans ; ans %= m ; if ( b % 2 ) { ans *= a ; ans %= m ; } return ans ; } long long bsgs ( long long a , long long b , long long p ) { ha . clear (); long long t = sqrt ( p ); if ( t * t != p ) t ++ ; for ( int j = 0 ; j <= t -1 ; j ++ ) { long long val = ( b % p * ksm ( a , j , p )) % p ; ha [ val ] = j ; } long long at = ksm ( a , t , p ); if ( a == 0 ) return b == 0 ? 1 : -1 ; for ( int i = 0 ; i <= t ; i ++ ) { long long val = ksm ( at , i , p ); int j = ( ha . find ( val ) == ha . end () ? -1 : ha [ val ]); if ( j >= 0 && i * t - j >= 0 ) { return i * t - j ; } } return -1 ; } } using namespace BSGS ; int main () { ios :: sync_with_stdio ( false ); cin >> a >> b >> p ; //b<p cout << bsgs ( a , b , p ) << endl ; return 0 ; } /* 69 5 19260817 15013953 */ \u2b50\u539f\u6839 \u00b6 luogu 6091 \u539f\u6839\u6a21\u7248 \u00b6 \u9898\u610f\uff1a\u7ed9\u5b9a\u6574\u6570 n\uff0c\u6c42\u5b83\u7684\u6240\u6709\u539f\u6839\u3002\u4e3a\u4e86\u51cf\u5c0f\u4f60\u7684\u8f93\u51fa\u91cf\uff0c\u7ed9\u51fa\u8f93\u51fa\u53c2\u6570 d\uff0c\u8bbe n \u7684\u6240\u6709\u539f\u6839\u6709 c \u4e2a\uff0c\u4ece\u5c0f\u5230\u5927\u5206\u522b\u4e3a g1,..,gc, \u53ea\u9700\u8981\u4f9d\u6b21\u6b21\u8f93\u51fag_d,g_2d,...,g_{(c/d)*d} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 //P6091 \u539f\u6839\u6a21\u7248 //\u6709\u5f85\u4f18\u5316\uff08\u4f8b\u5982\u5c06\u6b27\u62c9\u51fd\u6570\u6539\u6210\u7ebf\u6027\u7b5b\u5f62\u5f0f\u3001gcd\u6539\u6210ksm\u9a8c\u8bc1\u4e4b\u7c7b\u7684\uff09 #include <iostream> #include <cstdio> #include <cmath> #include <memory.h> #include <algorithm> using namespace std ; const int N = 1e6 + 5 ; int T , n , d ; int prime_list [ N ], pp , m_phi ; int g_list [ N ], g_p ; int phi ( int n ) { int ans = n ; for ( int i = 2 ; i <= sqrt ( n ); i ++ ) { if ( n % i == 0 ) { ans = ans / i * ( i -1 ); while ( n % i == 0 ) { n /= i ; } } } if ( n > 1 ) ans = ans / n * ( n -1 ); return ans ; } void divide ( int n ) { pp = 0 ; for ( int i = 2 ; i <= sqrt ( n ); i ++ ) { if ( n % i == 0 ) { prime_list [ ++ pp ] = i ; while ( n % i ) { n /= i ; } } } if ( n > 1 ) prime_list [ ++ pp ] = n ; } long long ksm ( long long a , long long b , long long Mod ) { long long ans = 1 ; while ( b ) { if ( b & 1 ) ans = ( ans * a ) % Mod ; a = ( a * a ) % Mod ; b >>= 1 ; } return ans ; } long long gcd ( long long a , long long b ) { return b ? gcd ( b , a % b ) : a ; } int get_min_primitive_root ( int m ) { m_phi = phi ( m ); if ( m == 1 ) return 0 ; if ( m == 2 ) return 1 ; divide ( m_phi ); for ( int g = 2 ; g <= m -1 ; g ++ ) { if ( gcd ( g , m ) != 1 ) continue ; bool flag = true ; for ( int i = 1 ; i <= pp ; i ++ ) { if ( ksm ( g , m_phi / prime_list [ i ], m ) == 1 ) { flag = false ; break ; } } if ( flag ) { return g ; } } return -1 ; } int main () { //ios::sync_with_stdio(false); scanf ( \"%d\" , & T ); //cin>>T; while ( T -- ) { //cin>>n>>d; scanf ( \"%d%d\" , & n , & d ); pp = g_p = 0 ; int g = get_min_primitive_root ( n ); if ( g == -1 ) { printf ( \"0 \\n\\n \" ); //cout<<0<<endl<<endl; continue ; } /*int m_phi_phi=phi(m_phi); //cout<<m_phi_phi<<endl; printf(\"%d\\n\",m_phi_phi);*/ int m_phi_phi = 0 ; for ( int i = 1 ; i <= m_phi ; i ++ ) { if ( gcd ( i , m_phi ) == 1 ) { m_phi_phi ++ ; g_list [ ++ g_p ] = ksm ( g , i , n ); } } sort ( g_list + 1 , g_list + 1 + g_p ); printf ( \"%d \\n \" , m_phi_phi ); //\u6b64\u5904\u7b54\u6848\u4e3aphi(m_phi) for ( int i = d ; i <= m_phi_phi / d * d ; i += d ) //\u8f93\u51fa\u63a7\u5236\uff0c\u53ef\u4ee5\u65e0\u89c6\u8fd9\u90e8\u5206 { //cout<<g_list[i]<<\" \"; printf ( \"%d \" , g_list [ i ]); } printf ( \" \\n \" ); } return 0 ; } \u6c42\u89e3\u4e8c\u6b21\u5269\u4f59\u7684Cipolla \u7b97\u6cd5 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 //Cipolla\u7b97\u6cd5\u6c42\u89e3\u4e00\u4e2a\u6570\u7684\u6a21\u610f\u4e49\u4e0b\u6839\u53f7 #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <cstdlib> #include <algorithm> #include <string> #include <vector> #include <map> #include <unordered_map> #include <set> #include <unordered_set> #include <queue> #include <random> #include <ctime> using namespace std ; typedef long long ll ; const int N = 2e5 + 10 ; mt19937 rd ( time ( 0 )); int T ; namespace Cipolla { //local ll w , p ; //w: i^2 = a*a-n //p: \u6a21\u6570 struct Imagenum { ll x , y ; Imagenum (){} Imagenum ( ll x , ll y ) : x ( x ), y ( y ) {} Imagenum operator * ( const Imagenum & b ) const { return Imagenum ( (( x * b . x % p + y * b . y % p * w % p ) % p + p ) % p , (( x * b . y % p + y * b . x % p ) % p + p ) % p ); } }; //\u5faa\u73af long long ksm ( long long a , long long b , long long Mod ) { long long ans = 1 ; while ( b ) { if ( b & 1 ) ans = ( ans * a ) % Mod ; a = ( a * a ) % Mod ; b >>= 1 ; } return ans ; } Imagenum ksm ( Imagenum a , ll b ) { Imagenum ans ( 1 , 0 ); while ( b ) { if ( b & 1 ) { ans = ans * a ; } a = a * a ; b >>= 1 ; } return ans ; } //cipolla: \u8ba1\u7b97n\u5728mod p\u610f\u4e49\u4e0b\u7684\u5e73\u65b9\u6839\uff0c\u6ce8\u610fp\u4e00\u5b9a\u8981\u662f\u5947\u6570\u8d28\u6570 ll cipolla ( ll n , ll P ) { p = P ; n %= p ; if ( p == 2 ) return n ; if ( ksm ( n ,( p -1 ) / 2 , p ) == p -1 ) return -1 ; //\u52d2\u8ba9\u5fb7\u7b26\u53f7=-1\uff0c\u8868\u660e\u4e0d\u5b58\u5728\u89e3 if ( n == 0 ) return 0 ; //\u5fc5\u8981\u7684\u7279\u5224\uff0c\u5426\u5219\u5e95\u4e0b\u5faa\u73af\u4f1a\u5361\u4f4f ll a ; while ( 1 ) { a = rd () % p ; w = (( a * a % p - n ) % p + p ) % p ; if ( ksm ( w ,( p -1 ) / 2 , p ) == p -1 ) break ; } Imagenum x ( a , 1 ); // (a+i)^((p+1)/2) == n^(1/2) return ksm ( x ,( p + 1 ) / 2 ). x ; // \u5b9e\u90e8\u4e3a\u7b54\u6848\uff0c\u865a\u90e8\u4e00\u5b9a\u4e3a0 } } int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ), cout . tie ( 0 ); cin >> T ; for ( int _ = 1 ; _ <= T ; _ ++ ) { ll n , p ; cin >> n >> p ; auto ans = Cipolla :: cipolla ( n , p ); if ( ans == -1 ) { cout << \"Hola! \\n \" ; } else { auto ans2 = ( p - ans ) % p ; if ( ans > ans2 ) swap ( ans , ans2 ); if ( ans == ans2 ) cout << ans << '\\n' ; else cout << ans << \" \" << ans2 << '\\n' ; } } return 0 ; } FFT \u00b6 Funs || Methods Reliance Time Complexity Inputs Outputs Description getlen1 logn n len \u53d6\u5f97\u6bd4n\u5927\u7684\u5e42\u957flen getlen2 logn len1,len2 len \u53d6\u5f97\u6bd4len1*2\u3001len2*2\u90fd\u5927\u7684\u5e42\u957f fft nlogn \u8f93\u5165\u590d\u6570\u6570\u7ec4y\u3001\u5e42\u957flen\uff082\u7684\u5e42\uff09\u3001ifft=1\u3002 \u4fee\u6539\u6570\u7ec4y\u4f5c\u4e3a\u7ed3\u679c\u3002 \u5f97\u5230\u7531\u7cfb\u6570\u8868\u793a\u6cd5\u8f6c\u6362\u4e3a\u70b9\u503c\u8868\u793a\u6cd5\uff08ifft=-1\u5219\u53cd\u8fc7\u6765\uff09\u7684\u6570\u7ec4\uff1aifft\u4e3a1\u65f6\u505afft\uff0c-1\u5219\u505aifft\u3002 multi n \u8f93\u5165\u590d\u6570\u6570\u7ec4y1\u3001y2\u3001y3\uff0c\u5e42\u957flen \u4fee\u6539\u6570\u7ec4y3\u4f5c\u4e3a\u7ed3\u679c\u3002 \u5bf9\u70b9\u503c\u8868\u793a\u6cd5\u7684\u6570\u7ec4y1\u3001y2\u505a\u4e58\u6cd5\u4fdd\u5b58\u81f3y3\u4e2d\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 //FFT #include <iostream> #include <cmath> #include <complex> #include <cstring> #include <memory.h> using namespace std ; namespace FFT { const int N = 2e6 + 5 ; //N\uff1a\u957f\u5ea6\u4e0a\u9650 const double PI = acos ( -1.0 ); //PI //public complex < double > s1 [ N * 2 ], s2 [ N * 2 ], s3 [ N * 2 ]; //s1,s2,s3\uff1a\u8f93\u5165\u7cfb\u6570\u8868\u793a\u6cd5\u7528\u7684\u6570\u7ec4 int sum [ N * 2 ]; //\u4e58\u6cd5\u5b8c\u6210\u540e\u8ba1\u7b97\u6c42\u548c\u7528\u7684\u6570\u7ec4 char a [ N ], b [ N ]; //a\u3001b:\u8f93\u5165\u7684\u4e24\u4e2a\u6570\u7684\u5b57\u7b26\u4e32\u5f62\u5f0f //local int rev [ N * 2 ]; //rev\uff1a\ud83e\udd8b\u53d8\u6362\u7528\u6570\u7ec4 //\u9884\u5904\u7406\ud83e\udd8b\u53d8\u6362 void __pre_rev ( int len ) { rev [ 0 ] = 0 ; for ( int i = 1 ; i <= len ; i ++ ) { rev [ i ] = rev [ i >> 1 ] >> 1 ; if ( i & 1 ) { rev [ i ] |= len >> 1 ; } } } // \ud83e\udd8b\u53d8\u6362 void __change ( complex < double > y [], int len ) { __pre_rev ( len ); for ( int i = 0 ; i < len ; i ++ ) { if ( i < rev [ i ]) { swap ( y [ i ], y [ rev [ i ]]); } } } //\u53d6\u5f97\u6bd4n\u5927\u7684\u5e42\u957flen int getlen1 ( int n ) { int len = 1 ; while ( len < n ) { len <<= 1 ; } return len ; } //\u53d6\u5f97\u6bd4len1\\*2\u3001len2\\*2\u90fd\u5927\u7684\u5e42\u957f int getlen2 ( int len1 , int len2 ) { int len = 1 ; while ( len < len1 * 2 || len < len2 * 2 ) len <<= 1 ; //*2\uff0c\u4e0d\u7136\u8fdb\u4f4d\u4f1a\u70b8\u6389\uff0c\u5e76\u4e14\ud83e\udd8b\u53d8\u6362\u4f1a\u9519 return len ; } //\u5f97\u5230\u7531\u7cfb\u6570\u8868\u793a\u6cd5\u8f6c\u6362\u4e3a\u70b9\u503c\u8868\u793a\u6cd5\uff08ifft=-1\u5219\u53cd\u8fc7\u6765\uff09\u7684\u6570\u7ec4\uff1a\u8f93\u5165\u590d\u6570\u6570\u7ec4y\u3001\u957f\u5ea6len\uff082\u7684\u5e42\uff09\u3001ifft=1\u3002\u4fee\u6539\u6570\u7ec4y\u4f5c\u4e3a\u7ed3\u679c\u3002ifft\u4e3a1\u65f6\u505afft\uff0c-1\u5219\u505aifft\u3002 void fft ( complex < double > y [], int len , int ifft = 1 ) { __change ( y , len ); for ( int h = 2 ; h <= len ; h <<= 1 ) // \u5408\u5e76\u7684\u957f\u5ea6 { complex < double > w_n ( cos ( 2 * PI / h ), sin ( ifft * 2 * PI / h )); //\u5bf9\u5e94\u957f\u5ea6\u7684\u5355\u4f4d\u590d\u6839 for ( int j = 0 ; j < len ; j += h ) //\u8d77\u59cb\u4f4d\u7f6e { complex < double > w ( 1 , 0 ); //\u521d\u59cb\u7684w_n^k for ( int k = j ; k < j + h / 2 ; k ++ ) // \u904d\u5386\u4f4d\u7f6e { complex < double > u = y [ k ], v = w * y [ k + h / 2 ]; //\u5076\u6570\u9879\u3001\u5947\u6570\u9879 y [ k ] = u + v ; y [ k + h / 2 ] = u - v ; w *= w_n ; } } } if ( ifft == -1 ) { for ( int i = 0 ; i < len ; i ++ ) { y [ i ] /= len ; } } } //\u5bf9\u70b9\u503c\u8868\u793a\u6cd5\u7684\u6570\u7ec4y1\u3001y2\u505a\u4e58\u6cd5\u4fdd\u5b58\u81f3y3\u4e2d\u3002 void multi ( complex < double > y1 [], complex < double > y2 [], complex < double > y3 [], int len ) { for ( int i = 0 ; i < len ; i ++ ) { y3 [ i ] = y1 [ i ] * y2 [ i ]; } } } using namespace FFT ; int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); cin >> a + 1 >> b + 1 ; int len1 = strlen ( a + 1 ), len2 = strlen ( b + 1 ); int len = getlen2 ( len1 , len2 ); //*2\uff0c\u4e0d\u7136\u8fdb\u4f4d\u4f1a\u70b8\u6389\uff0c\u5e76\u4e14\ud83e\udd8b\u53d8\u6362\u4f1a\u9519 //while (len < len1 * 2 || len < len2 * 2) // len <<= 1; for ( int i = 0 , j = len1 ; i < len1 ; i ++ , j -- ) //\u6ce8\u610f\u5012\u7740\u5b58 { s1 [ i ] = {( double )( a [ j ] - '0' ), 0 }; } for ( int i = 0 , j = len2 ; i < len2 ; i ++ , j -- ) { s2 [ i ] = {( double )( b [ j ] - '0' ), 0 }; } for ( int i = len1 ; i < len ; i ++ ) s1 [ i ] = { 0 , 0 }; for ( int i = len2 ; i < len ; i ++ ) s2 [ i ] = { 0 , 0 }; fft ( s1 , len ); fft ( s2 , len ); for ( int i = 0 ; i < len ; i ++ ) // \u4e58\u6cd5\u2026\u2026 s3 [ i ] = s1 [ i ] * s2 [ i ]; fft ( s3 , len , -1 ); //len=len1+len2-1; //len=(len1+len2-1); sum [ len ] = 0 ; //\u6700\u9ad8\u8fdb\u4f4d\u590d\u5199\u4e3a0 for ( int i = 0 ; i < len ; i ++ ) sum [ i ] = round ( real ( s3 [ i ])); for ( int i = 0 ; i < len ; i ++ ) { sum [ i + 1 ] += sum [ i ] / 10 ; sum [ i ] %= 10 ; } while ( sum [ len ] == 0 && len > 0 ) { len -- ; } for ( int i = len ; i >= 0 ; i -- ) cout << sum [ i ]; cout << endl ; return 0 ; } NTT (998244353) \u00b6 Funs || Methods Reliance Time Complexity Inputs Outputs Description getlen1 logn n len \u53d6\u5f97\u6bd4n\u5927\u7684\u5e42\u957flen getlen2 logn len1,len2 len \u53d6\u5f97\u6bd4len1*2\u3001len2*2\u90fd\u5927\u7684\u5e42\u957f ntt nlogn \u8f93\u5165\u590d\u6570\u6570\u7ec4y\u3001\u5e42\u957flen\uff082\u7684\u5e42\uff09\u3001ifft=1\u3002 \u4fee\u6539\u6570\u7ec4y\u4f5c\u4e3a\u7ed3\u679c\u3002 \u5f97\u5230\u7531\u7cfb\u6570\u8868\u793a\u6cd5\u8f6c\u6362\u4e3a\u70b9\u503c\u8868\u793a\u6cd5\uff08ifft=-1\u5219\u53cd\u8fc7\u6765\uff09\u7684\u6570\u7ec4\uff1aifft\u4e3a1\u65f6\u505afft\uff0c-1\u5219\u505aifft\u3002 multi n \u8f93\u5165\u590d\u6570\u6570\u7ec4y1\u3001y2\u3001y3\uff0c\u5e42\u957flen \u4fee\u6539\u6570\u7ec4y3\u4f5c\u4e3a\u7ed3\u679c\u3002 \u5bf9\u70b9\u503c\u8868\u793a\u6cd5\u7684\u6570\u7ec4y1\u3001y2\u505a\u4e58\u6cd5\u4fdd\u5b58\u81f3y3\u4e2d\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 //FFT but use NTT #include <iostream> #include <cmath> #include <complex> #include <cstring> #include <memory.h> using namespace std ; typedef long long ll ; namespace NTT { const int N = 2e6 + 5 , Mod = 998244353 ; //N\uff1a\u957f\u5ea6\u4e0a\u9650, Mod: \u9ed8\u8ba4\u6a21\u6570 const double PI = acos ( -1.0 ); //Pi const int primitive_root = 3 ; //primitive-root: 3 //public ll s1 [ N * 2 ], s2 [ N * 2 ], s3 [ N * 2 ]; //s1,s2,s3\uff1a\u8f93\u5165\u7cfb\u6570\u8868\u793a\u6cd5\u7528\u7684\u6570\u7ec4 //local int rev [ N * 2 ]; //rev\uff1a\ud83e\udd8b\u53d8\u6362\u7528\u6570\u7ec4 //\u5feb\u901f\u5e42 long long __ksm ( long long a , long long b , long long Mod ) { long long ans = 1 ; while ( b ) { if ( b & 1 ) ans = ( ans * a ) % Mod ; a = ( a * a ) % Mod ; b >>= 1 ; } return ans ; } //\u9884\u5904\u7406\ud83e\udd8b\u53d8\u6362 void __pre_rev ( int len ) { rev [ 0 ] = 0 ; for ( int i = 1 ; i <= len ; i ++ ) { rev [ i ] = rev [ i >> 1 ] >> 1 ; if ( i & 1 ) { rev [ i ] |= len >> 1 ; } } } // \ud83e\udd8b\u53d8\u6362 void __change ( ll y [], int len ) { __pre_rev ( len ); for ( int i = 0 ; i < len ; i ++ ) { if ( i < rev [ i ]) { swap ( y [ i ], y [ rev [ i ]]); } } } //\u53d6\u5f97\u6bd4n\u5927\u7684\u5e42\u957flen int getlen1 ( int n ) { int len = 1 ; while ( len < n ) { len <<= 1 ; } return len ; } //\u53d6\u5f97\u6bd4len1\\*2\u3001len2\\*2\u90fd\u5927\u7684\u5e42\u957f int getlen2 ( int len1 , int len2 ) { int len = 1 ; while ( len < len1 * 2 || len < len2 * 2 ) len <<= 1 ; //*2\uff0c\u4e0d\u7136\u8fdb\u4f4d\u4f1a\u70b8\u6389\uff0c\u5e76\u4e14\ud83e\udd8b\u53d8\u6362\u4f1a\u9519 return len ; } //\u5f97\u5230\u7531\u7cfb\u6570\u8868\u793a\u6cd5\u8f6c\u6362\u4e3a\u70b9\u503c\u8868\u793a\u6cd5\uff08ifft=-1\u5219\u53cd\u8fc7\u6765\uff09\u7684\u6570\u7ec4\uff1aifft\u4e3a1\u65f6\u505afft\uff0c-1\u5219\u505aifft\u3002 void ntt ( ll y [], int len , int ifft = 1 ) { __change ( y , len ); for ( int h = 2 ; h <= len ; h <<= 1 ) // \u5408\u5e76\u7684\u957f\u5ea6 { //complex<double> w_n(cos(2 * PI / h), sin(ifft * 2 * PI / h)); //\u5bf9\u5e94\u957f\u5ea6\u7684\u5355\u4f4d\u590d\u6839 ll gn ; if ( ifft == 1 ) gn = __ksm ( primitive_root ,(( ll ) Mod -1 ) / h , Mod ); //gn else gn = __ksm ( primitive_root ,(( ll ) Mod -1 ) / h * ( h -1 ), Mod ); //gn^-1 //else gn=ksm(332748118,(Mod-1)/h,Mod); for ( int j = 0 ; j < len ; j += h ) //\u8d77\u59cb\u4f4d\u7f6e { //complex<double> w(1, 0); //\u521d\u59cb\u7684w_n^k ll g = 1 ; for ( int k = j ; k < j + h / 2 ; k ++ ) // \u904d\u5386\u4f4d\u7f6e { ll u = y [ k ], v = ( g * y [ k + h / 2 ] % Mod ); //\u5076\u6570\u9879\u3001\u5947\u6570\u9879 y [ k ] = ( u + v + Mod ) % Mod ; y [ k + h / 2 ] = ( u - v + Mod ) % Mod ; //w *= w_n; //debug //cout<<k<<\":\"<<y[k]<<endl; //cout<<k+h/2<<\":\"<<y[k+h/2]<<endl; g = ( g * gn ) % Mod ; } } } if ( ifft == -1 ) { ll len_inv = __ksm ( len , Mod -2 , Mod ); for ( int i = 0 ; i < len ; i ++ ) { y [ i ] = y [ i ] * len_inv % Mod ; } } } //\u5bf9\u70b9\u503c\u8868\u793a\u6cd5\u7684\u6570\u7ec4y1\u3001y2\u505a\u4e58\u6cd5\u4fdd\u5b58\u81f3y3\u4e2d\u3002 void multi ( ll y1 [], ll y2 [], ll y3 [], int len ) { for ( int i = 0 ; i < len ; i ++ ) { y3 [ i ] = ( y1 [ i ] * y2 [ i ] % Mod + Mod ) % Mod ; } } } using namespace NTT ; int n , m ; int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); cin >> n >> m ; n ++ , m ++ ; for ( int i = 0 ; i < n ; i ++ ) { cin >> s1 [ i ]; } for ( int i = 0 ; i < m ; i ++ ) { cin >> s2 [ i ]; } int len = getlen2 ( n , m ); //*2\uff0c\u4e0d\u7136\u8fdb\u4f4d\u4f1a\u70b8\u6389\uff0c\u5e76\u4e14\ud83e\udd8b\u53d8\u6362\u4f1a\u9519 ntt ( s1 , len ); ntt ( s2 , len ); multi ( s1 , s2 , s3 , len ); ntt ( s3 , len , -1 ); for ( int i = 0 ; i < ( n -1 ) + ( m -1 ) + 1 ; i ++ ) { cout << s3 [ i ] << \" \" ; } return 0 ; } FWT \u00b6 \u7528\u4e8e\u89e3\u51b3\u4e0e\u4f4d\u8fd0\u7b97\u6709\u5173\u7684\u5377\u79ef\u95ee\u9898\uff1a \\(\\vec c=\\vec a \\oplus \\vec b\\) $$ C_i=\\sum_{i=j|k}A_j B_k $$ \u5176\u4e2d\u7ad6\u7ebf\u8868\u793a\u6216\u3001\u4e0e\u548c\u5f02\u6216\u4e09\u79cd\u8fd0\u7b97\u3002\u7ed3\u679c\u5bf9Mod\u53d6\u6a21\u3002 \u5bf9\u6216\u8fd0\u7b97\u6765\u8bf4\uff0c\u6784\u9020\uff1a $$ A'=FWT[A]:A' i=\\sum A_j $$ \u4e5f\u5373FWT\u53d8\u6362\u540eA'_i\u8868\u793a\u4e8c\u8fdb\u5236\u4e0b\u76841\u662fi\u7684\u5b50\u96c6\u7684Aj\u7684\u603b\u548c\u3002 Funs || Methods Reliance Time Complexity Inputs Outputs Description fwt nlogn \u8f93\u5165\u590d\u6570\u6570\u7ec4y\u3001\u957f\u5ea6len\u3001\u4e09\u79cd\u8fd0\u7b97\u63a7\u5236\u7b26bitcal\u3001ifft=1\u3002 \u4fee\u6539\u6570\u7ec4y\u4f5c\u4e3a\u7ed3\u679c\u3002 \u4f5cFWT\u53d8\u6362\uff08ifft=-1\u5219\u53cd\u8fc7\u6765\uff09\u7684\u6570\u7ec4\uff1aifft\u4e3a1\u65f6\u505afft\uff0c-1\u5219\u505aifft\u3002bitcal\u4e3a1\u30012\u30013\u65f6\u5206\u522b\u8868\u793a\u5bf9or\u3001and\u548cxor\u4e09\u79cd\u8fd0\u7b97\u505aFWT\u3002 multi n \u8f93\u5165\u590d\u6570\u6570\u7ec4y1\u3001y2\u3001y3\uff0c\u5e42\u957flen \u4fee\u6539\u6570\u7ec4y3\u4f5c\u4e3a\u7ed3\u679c\u3002 \u5bf9\u6570\u7ec4y1\u3001y2\u505a\u4e58\u6cd5\uff08\u6a21\u6570\u4e3aMod\uff09\u4fdd\u5b58\u81f3y3\u4e2d\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 //luogu 4717 #include <iostream> #include <cstdio> #include <cstring> #include <memory.h> #include <algorithm> #include <map> #include <vector> #include <queue> #include <cmath> using namespace std ; typedef long long ll ; namespace FWT { const int N = 2e5 + 10 ; //N: \u957f\u5ea6\u4e0a\u9650 const int Mod = 998244353 , inv2 = 499122177 ; //Mod:\u6a21\u6570 inv2: pow(2,998244353-2,998244353) //public ll s1 [ N * 2 ], s2 [ N * 2 ], s3 [ N * 2 ]; //s1,s2,s3\uff1a\u8f93\u5165\u7cfb\u6570\u8868\u793a\u6cd5\u7528\u7684\u6570\u7ec4 //bitcal: 1 or ; 2 and ; 3 xor void fwt ( ll y [], int len , int bitcal , int ifft = 1 ) { for ( int h = 2 ; h <= len ; h <<= 1 ) { for ( int j = 0 ; j < len ; j += h ) //initiative position { for ( int k = j ; k < j + h / 2 ; k ++ ) // traverse { ll u = y [ k ], v = y [ k + h / 2 ]; if ( ifft == 1 ) { if ( bitcal == 3 ) //xor \uff08\u540c\u6216\u5c31\u5bf9\u8c03+-\u7b26\u53f7\uff0c\u4e0b\u540c\uff09 { y [ k ] = ( u + v ) % Mod ; y [ k + h / 2 ] = ( u - v + Mod ) % Mod ; } else if ( bitcal == 1 ) //or { //y[k]=u; y [ k + h / 2 ] = ( u + v ) % Mod ; } else if ( bitcal == 2 ) // and { y [ k ] = ( u + v ) % Mod ; //y[k+h/2]=(v); } } else { if ( bitcal == 3 ) //xor { y [ k ] = ( u + v ) * inv2 % Mod ; y [ k + h / 2 ] = (( u - v ) * inv2 % Mod + Mod ) % Mod ; } else if ( bitcal == 1 ) //or { //y[k]=u; y [ k + h / 2 ] = ( v - u + Mod ) % Mod ; } else if ( bitcal == 2 ) // and { y [ k ] = ( u - v + Mod ) % Mod ; //y[k+h/2]=(v); } } } } } } //\u70b9\u503c\u8868\u793a\u6cd5\u591a\u9879\u5f0f\u7684\u4e58\u6cd5\uff0c\u8f93\u5165y1,y2\u662f\u70b9\u503c\u8868\u793a\u6cd5\u4e0b\u7684\u591a\u9879\u5f0f void multi ( ll y1 [], ll y2 [], ll y3 [], int len ) { for ( int i = 0 ; i < len ; i ++ ) { y3 [ i ] = ( y1 [ i ] * y2 [ i ] % Mod + Mod ) % Mod ; } } } using namespace FWT ; ll A [ N ], B [ N ]; int n ; int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); cin >> n ; n = ( 1 << n ); for ( int i = 0 ; i < n ; i ++ ) { cin >> A [ i ]; } for ( int i = 0 ; i < n ; i ++ ) { cin >> B [ i ]; } int len = n ; //while(len<n) len<<=1; //or memcpy ( s1 , A , sizeof ( A )); memcpy ( s2 , B , sizeof ( B )); fwt ( s1 , len , 1 ); fwt ( s2 , len , 1 ); multi ( s1 , s2 , s3 , len ); fwt ( s3 , len , 1 , -1 ); for ( int i = 0 ; i < n ; i ++ ) cout << s3 [ i ] << \" \" ; cout << endl ; //and memcpy ( s1 , A , sizeof ( A )); memcpy ( s2 , B , sizeof ( B )); fwt ( s1 , len , 2 ); fwt ( s2 , len , 2 ); multi ( s1 , s2 , s3 , len ); fwt ( s3 , len , 2 , -1 ); for ( int i = 0 ; i < n ; i ++ ) cout << s3 [ i ] << \" \" ; cout << endl ; //xor memcpy ( s1 , A , sizeof ( A )); memcpy ( s2 , B , sizeof ( B )); fwt ( s1 , len , 3 ); fwt ( s2 , len , 3 ); multi ( s1 , s2 , s3 , len ); fwt ( s3 , len , 3 , -1 ); for ( int i = 0 ; i < n ; i ++ ) cout << s3 [ i ] << \" \" ; cout << endl ; return 0 ; } \u5206\u6cbbFFT \u00b6 \u53ef\u4ee5\u5feb\u901f\u8ba1\u7b97\u4e0b\u6807\u8303\u56f4\u57280 to n-1\u7684\u5e8f\u5217f\uff1a\u7ed9\u5b9a\u4e0b\u6807\u57281 to n-1 \u7684\u5e8f\u5217g\uff0c\u8ba1\u7b97 $$ f_i=\\sum_{j=1}^if_{i-j}g_{j} $$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 //\u5b9e\u9645\u4e0a\u8981\u7528NTT\u2026\u2026 #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <cstdlib> #include <algorithm> #include <string> #include <vector> #include <map> #include <unordered_map> #include <set> #include <unordered_set> #include <queue> using namespace std ; typedef long long ll ; namespace NTT { const int N = 2e5 + 5 , Mod = 998244353 ; //N\uff1a\u957f\u5ea6\u4e0a\u9650, Mod: \u9ed8\u8ba4\u6a21\u6570 const double PI = acos ( -1.0 ); //Pi const int primitive_root = 3 ; //primitive-root: 3 //public // ll s1[N * 2], s2[N * 2], s3[N * 2]; //s1,s2,s3\uff1a\u8f93\u5165\u7cfb\u6570\u8868\u793a\u6cd5\u7528\u7684\u6570\u7ec4 //local int rev [ N * 2 ]; //rev\uff1a\ud83e\udd8b\u53d8\u6362\u7528\u6570\u7ec4 //\u5feb\u901f\u5e42 long long __ksm ( long long a , long long b , long long Mod ) { long long ans = 1 ; while ( b ) { if ( b & 1 ) ans = ( ans * a ) % Mod ; a = ( a * a ) % Mod ; b >>= 1 ; } return ans ; } //\u9884\u5904\u7406\ud83e\udd8b\u53d8\u6362 void __pre_rev ( int len ) { rev [ 0 ] = 0 ; for ( int i = 1 ; i <= len ; i ++ ) { rev [ i ] = rev [ i >> 1 ] >> 1 ; if ( i & 1 ) { rev [ i ] |= len >> 1 ; } } } // \ud83e\udd8b\u53d8\u6362 void __change ( ll y [], int len ) { __pre_rev ( len ); for ( int i = 0 ; i < len ; i ++ ) { if ( i < rev [ i ]) { swap ( y [ i ], y [ rev [ i ]]); } } } //\u53d6\u5f97\u6bd4n\u5927\u7684\u5e42\u957flen int getlen1 ( int n ) { int len = 1 ; while ( len < n ) { len <<= 1 ; } return len ; } //\u53d6\u5f97\u6bd4len1\\*2\u3001len2\\*2\u90fd\u5927\u7684\u5e42\u957f int getlen2 ( int len1 , int len2 ) { int len = 1 ; while ( len < len1 * 2 || len < len2 * 2 ) len <<= 1 ; //*2\uff0c\u4e0d\u7136\u8fdb\u4f4d\u4f1a\u70b8\u6389\uff0c\u5e76\u4e14\ud83e\udd8b\u53d8\u6362\u4f1a\u9519 return len ; } //\u5f97\u5230\u7531\u7cfb\u6570\u8868\u793a\u6cd5\u8f6c\u6362\u4e3a\u70b9\u503c\u8868\u793a\u6cd5\uff08ifft=-1\u5219\u53cd\u8fc7\u6765\uff09\u7684\u6570\u7ec4\uff1aifft\u4e3a1\u65f6\u505afft\uff0c-1\u5219\u505aifft\u3002 void ntt ( ll y [], int len , int ifft = 1 ) { __change ( y , len ); for ( int h = 2 ; h <= len ; h <<= 1 ) // \u5408\u5e76\u7684\u957f\u5ea6 { //complex<double> w_n(cos(2 * PI / h), sin(ifft * 2 * PI / h)); //\u5bf9\u5e94\u957f\u5ea6\u7684\u5355\u4f4d\u590d\u6839 ll gn ; if ( ifft == 1 ) gn = __ksm ( primitive_root ,(( ll ) Mod -1 ) / h , Mod ); //gn else gn = __ksm ( primitive_root ,(( ll ) Mod -1 ) / h * ( h -1 ), Mod ); //gn^-1 //else gn=ksm(332748118,(Mod-1)/h,Mod); for ( int j = 0 ; j < len ; j += h ) //\u8d77\u59cb\u4f4d\u7f6e { //complex<double> w(1, 0); //\u521d\u59cb\u7684w_n^k ll g = 1 ; for ( int k = j ; k < j + h / 2 ; k ++ ) // \u904d\u5386\u4f4d\u7f6e { ll u = y [ k ], v = ( g * y [ k + h / 2 ] % Mod ); //\u5076\u6570\u9879\u3001\u5947\u6570\u9879 y [ k ] = ( u + v + Mod ) % Mod ; y [ k + h / 2 ] = ( u - v + Mod ) % Mod ; //w *= w_n; //debug //cout<<k<<\":\"<<y[k]<<endl; //cout<<k+h/2<<\":\"<<y[k+h/2]<<endl; g = ( g * gn ) % Mod ; } } } if ( ifft == -1 ) { ll len_inv = __ksm ( len , Mod -2 , Mod ); for ( int i = 0 ; i < len ; i ++ ) { y [ i ] = y [ i ] * len_inv % Mod ; } } } //\u5bf9\u70b9\u503c\u8868\u793a\u6cd5\u7684\u6570\u7ec4y1\u3001y2\u505a\u4e58\u6cd5\u4fdd\u5b58\u81f3y3\u4e2d\u3002 void multi ( ll y1 [], ll y2 [], ll y3 [], int len ) { for ( int i = 0 ; i < len ; i ++ ) { y3 [ i ] = ( y1 [ i ] * y2 [ i ] % Mod + Mod ) % Mod ; } } } using namespace NTT ; namespace CDQ_FFT { int n ; ll ans [ N ]; ll gg [ N * 2 ]; ll g [ N * 2 ], f [ N * 2 ]; //ans\uff1a\u7b54\u6848\u5e8f\u5217f\uff0c\u6c42\u89e3solve(l,r)\u65f6\uff0cl~mid\u7684\u7b54\u6848\u5e8f\u5217f\u5df2\u7ecf\u6c42\u51fa\uff0c\u800cmid+1~r\u4e2d\u4ec5\u4ec5\u4fdd\u5b58\u4e86\u90e8\u5206\u8d21\u732e //gg\uff1a\u8f93\u5165\u7684g\u5e8f\u5217 //g\u3001f:\u7528\u4e8entt\u8ba1\u7b97\u7528\u7684\u5e8f\u5217\uff0c\u5728\u505a\u5206\u6cbb\u65f6\u8981\u53cd\u590d\u5199\u5165 //\u5bf9l~r\u8303\u56f4\u5185\u7684\u5e8f\u5217\u505a\u5206\u6cbbntt //\u6ce8\u610f\uff1a\u4e0d\u53ef\u8c03\u6362\u5b50\u5206\u6cbb\u7684\u8c03\u7528\u987a\u5e8f\uff08\u63d0\u524d\u8c03\u7528\u4f1a\u5bfc\u81f4\u4f7f\u7528\u4e0d\u5b8c\u6574\u7684\u8d21\u732e\u503c\u53bb\u8ba1\u7b97\u65b0\u8d21\u732e\uff09 void solve ( int l , int r ) { if ( l == r ) return ; int mid = ( l + r ) >> 1 ; solve ( l , mid ); //\u5206\u6cbb\u505al~mid\u8303\u56f4\u5185\u7684ntt //\u63a5\u4e0b\u6765\u8ba1\u7b97l~mid\u8303\u56f4\u5185\u7684f(0~mid)\u5bf9mid+1~r\u7684f\u7684\u8d21\u732e\u3002 int len = r - l + 1 ; len = getlen1 ( len ); //copy for ( int i = 0 ; i < len ; i ++ ) { g [ i ] = gg [ i ]; } int j = 0 ; for ( int i = l ; i <= mid ; i ++ , j ++ ) { f [ j ] = ans [ i ]; //\u6620\u5c04\u5173\u7cfb\uff1al->0, l+1->1 } for ( int i = mid + 1 ; i <= l + len -1 ; i ++ , j ++ ) { f [ j ] = 0 ; } ntt ( g , len ); ntt ( f , len ); multi ( g , f , f , len ); ntt ( f , len , -1 ); for ( int i = mid + 1 ; i <= r ; i ++ ) { ans [ i ] = ( ans [ i ] + f [ i - l ]) % Mod ; //\u8fd9\u91cc\u5957\u7528\u4e0a\u9762\u7684\u6620\u5c04\u5173\u7cfb } solve ( mid + 1 , r ); //\u5206\u6cbb\u505amid+1~r\u8303\u56f4\u5185\u7684ntt } } using namespace CDQ_FFT ; int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ), cout . tie ( 0 ); cin >> n ; for ( int i = 1 ; i <= n -1 ; i ++ ) { cin >> gg [ i ]; } ans [ 0 ] = 1 ; solve ( 0 , n -1 ); for ( int i = 0 ; i <= n -1 ; i ++ ) { cout << ans [ i ] << \" \" ; } return 0 ; } \u2b50\u62c9\u683c\u6717\u65e5\u63d2\u503c \u00b6 luogu 4791 lagrange \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 // \u62c9\u683c\u6717\u65e5\u63d2\u503c #include <iostream> #include <cstring> #include <memory.h> #include <cmath> using namespace std ; const int N = 2e3 + 10 ; const int Mod = 998244353 ; long long x [ N ], y [ N ], n , k ; long long ksm ( long long a , long long b , long long Mod ) { long long ans = 1 ; while ( b ) { if ( b & 1 ) ans = ans * a % Mod ; a = ( a * a ) % Mod ; b >>= 1 ; } return ans ; } long long lagrange () { long long fz , fm , temp , ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { fz = fm = 1 ; temp = y [ i ]; for ( int j = 1 ; j <= n ; j ++ ) { if ( j == i ) continue ; fz = ( fz * ( k - x [ j ] + Mod ) % Mod ) % Mod ; fm = ( fm * ( x [ i ] - x [ j ] + Mod ) % Mod ) % Mod ; } temp = ( temp * fz ) % Mod ; temp = ( temp * ksm ( fm , Mod -2 , Mod )) % Mod ; ans = ( ans + temp ) % Mod ; } return ans ; } int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); cin >> n >> k ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> x [ i ] >> y [ i ]; } cout << lagrange () << endl ; return 0 ; } \u89c4\u8303\u7ec4\u5408\u6570 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 long long C ( long long y , long long x ) { if ( y < 0 || x < 0 || y < x ) return 0 ; //No sense y %= Mod ; //x far below than Mod so that x%Mod==x if ( y == 0 && x == 0 ) return 1 ; long long ans = 1 ; for ( long long j = y ; j >= y - x + 1 ; j -- ) { ans *= j ; ans %= Mod ; } ans *= f_inv [ x ]; return ans % Mod ; } \u6570\u636e\u7ed3\u6784 \u00b6 ST\u8868\uff08\u4e00\u7ef4\uff09 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 template < typename T > struct ST_table { static const int N = 2e5 + 10 , M = 25 ; T ma [ N ][ M ], mi [ N ][ M ]; int n , t ; void init ( T a []) { t = log2 ( n ) + 1 ; for ( int i = 1 ; i <= n ; i ++ ) ma [ i ][ 0 ] = ma [ i ][ 0 ] = make_pair ( a [ i ], i ); for ( int k = 1 ; k < t ; k ++ ) { for ( int i = 1 ; i <= n - ( 1 << k ) + 1 ; i ++ ) { ma [ i ][ k ] = max ( ma [ i ][ k - 1 ], ma [ i + ( 1 << ( k - 1 ))][ k - 1 ]); mi [ i ][ k ] = min ( mi [ i ][ k - 1 ], mi [ i + ( 1 << ( k - 1 ))][ k - 1 ]); } } } T ask_mi ( int l , int r ) { int k = ( int ) log2 ( r - l + 1 ); return min ( mi [ l ][ k ], mi [ r - ( 1 << k ) + 1 ][ k ]); } T ask_ma ( int l , int r ) { int k = ( int ) log2 ( r - l + 1 ); return max ( ma [ l ][ k ], ma [ r - ( 1 << k ) + 1 ][ k ]); } }; \u7ebf\u6bb5\u6811 \u00b6 \u540c\u65f6\u652f\u6301\u52a0\u6cd5\u3001\u4e58\u6cd5\u64cd\u4f5c\uff08\u5bf9p\u53d6\u6a21\uff09\u7684\u7ebf\u6bb5\u6811\u3002\u7ebf\u6bb5\u6811\u7684\u6bcf\u4e2a\u8282\u70b9\u4fdd\u5b58\u5176\u6240\u7ef4\u62a4\u7684\u533a\u95f4\u5927\u5c0f\u3002 Funs || Methods Reliance Time Complexity Inputs Outputs Description __tagdown 1 u\uff1a\u6811\u8282\u70b9\u4e0b\u6807\u3002ln:\u5de6\u5b50\u6811\u5bf9\u5e94\u533a\u95f4\u957f\u5ea6\u3002rn\uff1a\u53f3\u5b50\u6811\u5bf9\u5e94\u533a\u95f4\u957f\u5ea6 \u6807\u8bb0\u4e0b\u653e\uff1a\u5148\u66f4\u65b0\u4e58\u6cd5\u6807\u8bb0\u540e\u66f4\u65b0\u52a0\u6cd5\u6807\u8bb0\uff0c\u6700\u540e\u6e05\u7a7au\u7684\u6807\u8bb0\u3002 build_tree nlogn u\uff1a\u6811\u8282\u70b9\u4e0b\u6807\uff08\u521d\u59cb\u8c03\u7528\u65f6u=1\uff09\u3002l\u3001r\uff1a\u8282\u70b9\u7ba1\u8f96\u7684\u5de6\u53f3\u7aef\u70b9 \u521d\u59cb\u5316\u70b9\u6bb5\u6811\uff1a\u66f4\u65b0\u6bcf\u4e2a\u8282\u70b9\u7684val\u503c\u4e3a\u5b69\u5b50val\u503c\u548c\uff0c\u53f6\u5b50\u8282\u70b9\u7684\u503c\u88ab\u8bbe\u4e3aa[l]\u3002 asksum build_tree logn u\uff1a\u6811\u8282\u70b9\u4e0b\u6807\u3002L\u3001R\uff1a\u8be2\u95ee\u533a\u95f4\u3002 \u533a\u95f4\u548c \u8fd4\u56de\u533a\u95f4L\u3001R\u7684\u548c\u3002 segupd build_tree logn u\uff1a\u6811\u8282\u70b9\u4e0b\u6807\uff08\u521d\u59cb\u8c03\u7528\u65f6u=1\uff09\u3002L\u3001R\uff1a\u8be2\u95ee\u533a\u95f4\u3002addval\uff1a\u589e\u52a0\u7684\u503c \u533a\u95f4L,R\u52a0\u6cd5\u66f4\u65b0 segupd2 build_tree logn u\uff1a\u6811\u8282\u70b9\u4e0b\u6807\uff08\u521d\u59cb\u8c03\u7528\u65f6u=1\uff09\u3002L\u3001R\uff1a\u8be2\u95ee\u533a\u95f4\u3002addval\uff1a\u4e58\u6cd5\u7684\u503c \u533a\u95f4L,R\u4e58\u6cd5\u66f4\u65b0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 //Luogu 3373 Segment t 2 (\u4e0b\u6807\u4fdd\u5b58\u7248) #include <iostream> using namespace std ; typedef long long ll ; namespace Segment_tree { const int MAXN = 1e5 + 10 ; //MAXN\uff1a\u7ebf\u6bb5\u6811\u5927\u5c0f\u4e0a\u9650 //public ll n , m , a [ MAXN ], p ; //n:\u957f\u5ea6\uff0c m\uff1a\u8be2\u95ee\u4e2a\u6570\uff0c a\uff1a\u521d\u59cb\u6570\u7ec4\u4e2a\u6570\uff0c p\uff1a\u6a21\u6570 template < typename Ty , int MAXN = MAXN > struct SEGMENT_TREE { struct NODE { Ty val , tagplus , tagmulti ; //val, tagplus, tagmulti\uff1a\u503c\uff0c\u52a0\u6cd5\u6807\u8bb0\uff0c\u4e58\u6cd5\u6807\u8bb0 Ty l , r ; //l\u3001r\uff1a\u7ebf\u6bb5\u6811\u8282\u70b9\u6240\u7ef4\u62a4\u7684\u533a\u95f4 } t [ MAXN * 4 ]; //\u6807\u8bb0\u4e0b\u653e\uff1a\u5148\u66f4\u65b0\u4e58\u6cd5\u6807\u8bb0\u540e\u66f4\u65b0\u52a0\u6cd5\u6807\u8bb0\uff0c\u6700\u540e\u6e05\u7a7au\u7684\u6807\u8bb0\u3002 //ln:\u5de6\u5b50\u6811\u5bf9\u5e94\u533a\u95f4\u957f\u5ea6 rn\uff1a\u53f3\u5b50\u6811\u5bf9\u5e94\u533a\u95f4\u957f\u5ea6 void __tagdown ( Ty u , Ty ln , Ty rn ) { //\u6309\u5f53\u524d\u8282\u70b9\uff08u0\uff09\u6807\u8bb0\u66f4\u65b0\u5de6\u53f3\u513f\u5b50\u7684\u503c t [ u * 2 ]. val = ( t [ u * 2 ]. val * t [ u ]. tagmulti + t [ u ]. tagplus * ln ) % p ; t [ u * 2 + 1 ]. val = ( t [ u * 2 + 1 ]. val * t [ u ]. tagmulti + t [ u ]. tagplus * rn ) % p ; //\u66f4\u65b0\u5de6\u53f3\u513f\u5b50\u4e58\u6cd5\u6807\u8bb0(\u5148\u4e58\u540e\u52a0\u6cd5) t [ u * 2 ]. tagmulti = ( t [ u * 2 ]. tagmulti * t [ u ]. tagmulti ) % p ; t [ u * 2 + 1 ]. tagmulti = ( t [ u * 2 + 1 ]. tagmulti * t [ u ]. tagmulti ) % p ; //\u66f4\u65b0\u5de6\u53f3\u513f\u5b50\u52a0\u6cd5\u6807\u8bb0 t [ u * 2 ]. tagplus = ( t [ u * 2 ]. tagplus * t [ u ]. tagmulti + t [ u ]. tagplus ) % p ; t [ u * 2 + 1 ]. tagplus = ( t [ u * 2 + 1 ]. tagplus * t [ u ]. tagmulti + t [ u ]. tagplus ) % p ; //\u91cd\u8bbe\u6807\u8bb0 t [ u ]. tagplus = 0 ; t [ u ]. tagmulti = 1 ; } //\u521d\u59cb\u5316\u70b9\u6bb5\u6811\uff1a\u66f4\u65b0\u6bcf\u4e2a\u8282\u70b9\u7684val\u503c\u4e3a\u5b69\u5b50val\u503c\u548c\uff0c\u53f6\u5b50\u8282\u70b9\u7684\u503c\u88ab\u8bbe\u4e3aa[l]\u3002 void build_tree ( Ty u , Ty l , Ty r ) { t [ u ]. tagplus = 0 ; t [ u ]. tagmulti = 1 ; t [ u ]. l = l ; t [ u ]. r = r ; if ( l == r ) { t [ u ]. val = a [ l ]; return ; } ll mid = ( l + r ) >> 1 ; build_tree ( u * 2 , l , mid ); build_tree ( u * 2 + 1 , mid + 1 , r ); t [ u ]. val = ( t [ u * 2 ]. val + t [ u * 2 + 1 ]. val ) % p ; } Ty asksum ( Ty u , Ty L , Ty R ) //LR:\u8be2\u95ee lr\uff1a\u8282\u70b9 { if ( L <= t [ u ]. l && t [ u ]. r <= R ) return t [ u ]. val % p ; Ty mid = ( t [ u ]. l + t [ u ]. r ) >> 1 , ans = 0 ; __tagdown ( u , mid - t [ u ]. l + 1 , t [ u ]. r - mid ); if ( L <= mid ) { ans += asksum ( u * 2 , L , R ); ans %= p ; } if ( R > mid ) { ans += asksum ( u * 2 + 1 , L , R ); ans %= p ; } return ans ; } //\u52a0\u6cd5\u66f4\u65b0 void segupd ( Ty u , Ty L , Ty R , Ty addval ) { if ( L <= t [ u ]. l && t [ u ]. r <= R ) { t [ u ]. val = ( t [ u ]. val + addval * ( t [ u ]. r - t [ u ]. l + 1 )) % p ; t [ u ]. tagplus = ( addval + t [ u ]. tagplus ) % p ; return ; } ll mid = ( t [ u ]. l + t [ u ]. r ) >> 1 ; __tagdown ( u , mid - t [ u ]. l + 1 , t [ u ]. r - mid ); if ( L <= mid ) segupd ( u * 2 , L , R , addval ); if ( mid < R ) segupd ( u * 2 + 1 , L , R , addval ); t [ u ]. val = ( t [ u * 2 ]. val + t [ u * 2 + 1 ]. val ) % p ; } //\u4e58\u6cd5\u66f4\u65b0 void segupd2 ( Ty u , Ty L , Ty R , Ty addval ) { if ( L <= t [ u ]. l && t [ u ]. r <= R ) { t [ u ]. tagplus = ( t [ u ]. tagplus * addval ) % p ; t [ u ]. tagmulti = ( t [ u ]. tagmulti * addval ) % p ; t [ u ]. val = ( t [ u ]. val * addval ) % p ; return ; } Ty mid = ( t [ u ]. l + t [ u ]. r ) >> 1 ; __tagdown ( u , mid - t [ u ]. l + 1 , t [ u ]. r - mid ); if ( L <= mid ) segupd2 ( u * 2 , L , R , addval ); if ( mid < R ) segupd2 ( u * 2 + 1 , L , R , addval ); t [ u ]. val = ( t [ u * 2 ]. val + t [ u * 2 + 1 ]. val ) % p ; } }; } // namespace Segment_tree using namespace Segment_tree ; SEGMENT_TREE < ll > tree ; int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); cin >> n >> m >> p ; for ( ll i = 1 ; i <= n ; i ++ ) { cin >> a [ i ]; } tree . build_tree ( 1 , 1 , n ); for ( ll i = 1 ; i <= m ; i ++ ) { ll caozuo , l , r ; cin >> caozuo >> l >> r ; if ( caozuo == 2 ) { ll k ; cin >> k ; tree . segupd ( 1 , l , r , k ); } else if ( caozuo == 1 ) { ll k ; cin >> k ; tree . segupd2 ( 1 , l , r , k ); } else { cout << tree . asksum ( 1 , l , r ) << endl ; } } return 0 ; } \u53ef\u6301\u4e45\u5316\u6743\u503c\u7ebf\u6bb5\u6811 \u00b6 \u9759\u6001\u533a\u95f4\u7b2c k \u5c0f\u3002 \u53ef\u6301\u4e45\u5316\u7ebf\u6bb5\u6811\u7ef4\u62a4\u7684\u662f\u6743\u503c(\u4e5f\u5373\uff0c\u6570\u7ec4\u7d22\u5f15\u4ee3\u8868\u503c\u672c\u8eab\uff0c\u6570\u7ec4\u5bf9\u5e94\u7684\u503c\u8868\u793a\u8fd9\u4e2a\u503c\u6709\u591a\u5c11\u4e2a)\u3002\u539f\u6570\u7ec4\u7684\u533a\u95f4\u5bf9\u5e94\u5230\u53ef\u6301\u4e45\u5316\u7ebf\u6bb5\u6811\u7684\u5e94\u8be5\u662f\u4e0d\u540c\u7248\u672c\u7684\u6811\u6839\u3002 \u8c03\u7528\u524d\u9700\u8981\u624b\u52a8\u8bbe\u5b9arange_upb\u3002 Funs || Methods Reliance Time Complexity Inputs Outputs Description build_tree NlogN l\uff0cr: \u6743\u503c\u5de6\u53f3\u8fb9\u754c \u521d\u59cb\u5316\u6743\u503c\u7ebf\u6bb5\u6811 change build_tree logN u\uff1a\u4e0a\u4e00\u7248\u672c\u6811\u6839\u4e0b\u6807\u3002l\u3001r\uff1a\u6743\u503c\u5de6\u53f3\u8fb9\u754c\u3002pos\uff1a\u4fee\u6539\u6743\u503c\u7684\u4f4d\u7f6e\u3002val(=1)\uff1a\u4fee\u6539\u6743\u503c\u5927\u5c0f \u5f53\u524d\u7248\u672c\u6839\u4e0b\u6807 \u5728\u4e0a\u4e00\u7248\u672c\u7684\u57fa\u7840\u4e0a\uff0c\u7ed9pos\u4f4d\u7f6e\u7684\u4e2a\u6570+1 ask build_tree logN pa\u3001pb\uff1a\u65e7\u7248\u672c\u3001\u65b0\u7248\u672c\u7ebf\u6bb5\u6811\u7684\u6839\u3002l\u3001r\uff1a\u4e8c\u5206\u6743\u503c\u8303\u56f4\uff08\u521d\u59cb\u4e3a1\u548crange_upb\uff09\u3002rnk\uff1a\u7b2crnk\u5c0f\u7684\u6570 \u4ecb\u4e8e\u65e7\u7248\u672c\u3001\u65b0\u7248\u672c\u7ebf\u6bb5\u6811\u4e4b\u95f4\u7684\u7b2crnk\u5c0f\u6570 \u8fd4\u56de\u4ecb\u4e8e\u65e7\u7248\u672c\u3001\u65b0\u7248\u672c\u7ebf\u6bb5\u6811\u4e4b\u95f4\uff08\u5bf9\u5e94\u6570\u7ec4\u533a\u95f4L\u3001R\uff09\u7684\u7b2crnk\u5c0f\u6570\u3002\u5982\u679c\u79bb\u6563\u5316\u4e86\u5219\u8fd9\u4e2a\u8fd4\u56de\u503c\u5e94\u8be5\u8868\u793a\u7d22\u5f15\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 #include <iostream> #include <cstdio> #include <map> #include <algorithm> #include <memory.h> using namespace std ; typedef long long ll ; namespace Chairman_Tree { const int N = 2e5 + 5 ; //public int n , m ; //n:\u6570\u7684\u4e2a\u6570 m:\u8be2\u95ee\u4e2a\u6570 \uff08\u5176\u5b9e\u8fd9\u4e24\u4e2a\u53d8\u91cf\u53ef\u4ee5\u653e\u5230\u5916\u9762\u2026\u2026\uff09 int range_upb ; // range_upb:\u6743\u503c\u8303\u56f4\u4e0a\u9650 //local template < typename Ty > struct CHairman_Tree { //public int root [ N ]; //root: \u4e0d\u540c\u7248\u672c\u7684\u7ebf\u6bb5\u6811\u6811\u6839 //local struct Node { int lc , rc ; //lc\u3001rc\uff1a\u5de6\u53f3\u5b69\u5b50\u7d22\u5f15 Ty cnt ; //cnt: \u6743\u503c\u548c } t [ 20 * N ]; int total ; //total: \u7ebf\u6bb5\u6811\u8282\u70b9\u7684\u4e2a\u6570 //\u521d\u59cb\u5316\u6743\u503c\u7ebf\u6bb5\u6811 int build_tree ( int l , int r ) { int p =++ total ; if ( l == r ) { t [ p ]. cnt = 0 ; return p ; } int mid = ( l + r ) >> 1 ; t [ p ]. lc = build_tree ( l , mid ); t [ p ]. rc = build_tree ( mid + 1 , r ); t [ p ]. cnt = 0 ; return p ; } //\u5728\u4e0a\u4e00\u7248\u672c\u7684\u57fa\u7840\u4e0a\uff0c\u7ed9pos\u4f4d\u7f6e\u7684\u4e2a\u6570+1 int change ( int p , int l , int r , int pos , int val = 1 ) { int q =++ total ; // new node t [ q ] = t [ p ]; // copy if ( l == r ) { t [ q ]. cnt += val ; return q ; } int mid = ( l + r ) >> 1 ; if ( pos <= mid ) t [ q ]. lc = change ( t [ p ]. lc , l , mid , pos , val ); else t [ q ]. rc = change ( t [ p ]. rc , mid + 1 , r , pos , val ); t [ q ]. cnt = t [ t [ q ]. lc ]. cnt + t [ t [ q ]. rc ]. cnt ; return q ; } //\u8fd4\u56de\u4ecb\u4e8e\u65e7\u7248\u672c\u3001\u65b0\u7248\u672c\u7ebf\u6bb5\u6811\u4e4b\u95f4\u7684\u7b2crnk\u5c0f\u6570\u3002\u5982\u679c\u79bb\u6563\u5316\u4e86\u5219\u8fd9\u4e2a\u8fd4\u56de\u503c\u5e94\u8be5\u8868\u793a\u7d22\u5f15\u3002 int ask ( int pa , int pb , int l , int r , int rnk ) // \u83b7\u5f97\u79bb\u6563\u5316\u540e\u7684\u503c\uff08\u5bf9\u503c\u57df\u8fdb\u884c\u4e8c\u5206\uff09 { if ( l == r ) { return l ; } int mid = ( l + r ) >> 1 ; int cnt = t [ t [ pb ]. lc ]. cnt - t [ t [ pa ]. lc ]. cnt ; // Count of [L,mid] if ( cnt >= rnk ) return ask ( t [ pa ]. lc , t [ pb ]. lc , l , mid , rnk ); else return ask ( t [ pa ]. rc , t [ pb ]. rc , mid + 1 , r , rnk - cnt ); } }; } using namespace Chairman_Tree ; namespace Discretization { const int N = 1e6 + 10 ; typedef int Ty ; //public Ty a [ N ], b [ N ]; int dlen ; // \u590d\u5236a\u5230b void copy_to_b () { memcpy ( b , a , sizeof ( a )); } // \u5bf9b\u6392\u5e8f\u3001\u53bb\u91cd\uff0c\u8fd4\u56de\u53bb\u91cd\u540e\u7684\u6570\u7ec4\u957f\u5ea6 int sort_and_unique ( int n ) { sort ( b + 1 , b + 1 + n ); return dlen = unique ( b + 1 , b + 1 + n ) - b -1 ; } // \u8fd4\u56de\u79bb\u6563\u5316\u540e\u7684\u503c\uff081\u5f00\u59cb\u8ba1\u6570\uff09 inline int get_id ( Ty x ) { return lower_bound ( b + 1 , b + 1 + dlen , x ) - b ; } } //using namespace Discretization; CHairman_Tree < int > t ; int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); cin >> n >> m ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> Discretization :: a [ i ]; } //\u79bb\u6563\u5316 Discretization :: copy_to_b (); range_upb = Discretization :: sort_and_unique ( n ); //\u5efa\u6811 t . build_tree ( 1 , range_upb ); //\u4fee\u6539\u5e76\u5efa\u7acb\u5386\u53f2\u7248\u672c for ( int i = 1 ; i <= n ; i ++ ) { int x = Discretization :: get_id ( Discretization :: a [ i ]); t . root [ i ] = t . change ( t . root [ i -1 ], 1 , range_upb , x ); } //\u67e5\u8be2\u533a\u95f4\u7b2ck\u5927\uff1a\u901a\u8fc7\u4e0e\u5386\u53f2\u7248\u672c\u4f5c\u5dee\u5b9e\u73b0\u6743\u503c\u4e8c\u5206 for ( int i = 1 ; i <= m ; i ++ ) { int l , r , k ; cin >> l >> r >> k ; int index = t . ask ( t . root [ l -1 ], t . root [ r ], 1 , range_upb , k ); cout << Discretization :: b [ index ] << endl ; } return 0 ; } CDQ\u5206\u6cbb \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 //Luogu P3810 \u3010\u6a21\u677f\u3011\u4e09\u7ef4\u504f\u5e8f\uff08\u964c\u4e0a\u82b1\u5f00 //\u984c\u610f\uff1a\u6c42\u6eff\u8db3aj<=ai, bj<=bi, cj<=ci (j!=i)\u7684\u9ede\u5c0d\u6578\u91cf\uff0c\u5c0d\u65bcd in [0,n)\uff0c\u6c42f(i)=d\u7684\u6578\u91cf #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <cstdlib> #include <algorithm> #include <string> #include <vector> #include <map> #include <unordered_map> #include <set> #include <unordered_set> #include <queue> using namespace std ; typedef long long ll ; const int N = 4e5 + 10 ; namespace BIT { const int MAXN = 4e5 + 10 ; template < typename Ty > struct Bit { //local Ty t [ MAXN ]; int __lowbit ( int x ) { return x & ( - x ); } void add ( int pos , Ty val = 1 ) { while ( pos < MAXN ) { t [ pos ] += val ; pos += __lowbit ( pos ); } } Ty ask ( int pos ) { Ty ans = 0 ; while ( pos >= 1 ) { ans += t [ pos ]; pos -= __lowbit ( pos ); } return ans ; } }; } using namespace BIT ; int n , k ; struct P { int x , y , z ; int id ; int cnt ; } a [ N ], b [ N ]; int ap ; struct Q { int y , z ; int typ ; //0:op , 1:query int id ; int cnt ; } c [ N ]; int cp ; Bit < int > tree ; int cnt [ N ]; int ans [ N ]; int ans2 [ N ]; int cmpx ( const P & a , const P & b ) { if ( a . x == b . x && a . y == b . y ) return a . z < b . z ; if ( a . x == b . x ) return a . y < b . y ; return a . x < b . x ; } int cmpq ( const Q & a , const Q & b ) { if ( a . y == b . y && a . z == b . z ) return a . typ < b . typ ; if ( a . y == b . y ) return a . z < b . z ; return a . y < b . y ; } void solve ( int l , int r ) { if ( l == r ) { return ; } int mid = ( l + r ) / 2 ; solve ( l , mid ); solve ( mid + 1 , r ); cp = 0 ; for ( int i = l ; i <= mid ; i ++ ) { c [ ++ cp ] = { a [ i ]. y , a [ i ]. z , 0 , a [ i ]. id , a [ i ]. cnt }; } for ( int i = mid + 1 ; i <= r ; i ++ ) { c [ ++ cp ] = { a [ i ]. y , a [ i ]. z , 1 , a [ i ]. id , a [ i ]. cnt }; } sort ( c + 1 , c + 1 + cp , cmpq ); for ( int i = 1 ; i <= cp ; i ++ ) { if ( c [ i ]. typ == 0 ) //op { tree . add ( c [ i ]. z , c [ i ]. cnt ); } else //query { ans [ c [ i ]. id ] += tree . ask ( c [ i ]. z ); } } //undo change of BIT for ( int i = 1 ; i <= cp ; i ++ ) { if ( c [ i ]. typ == 0 ) { tree . add ( c [ i ]. z , - c [ i ]. cnt ); } } } void my_unique () { ap = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( a [ ap ]. x == b [ i ]. x && a [ ap ]. y == b [ i ]. y && a [ ap ]. z == b [ i ]. z ) { a [ ap ]. cnt ++ ; } else { a [ ++ ap ] = b [ i ]; } } } int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ), cout . tie ( 0 ); cin >> n >> k ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> b [ i ]. x ; cin >> b [ i ]. y ; cin >> b [ i ]. z ; b [ i ]. id = i ; b [ i ]. cnt = 1 ; } sort ( b + 1 , b + 1 + n , cmpx ); my_unique (); sort ( a + 1 , a + 1 + ap , cmpx ); for ( int i = 1 ; i <= ap ; i ++ ) { cnt [ a [ i ]. id ] = a [ i ]. cnt ; } solve ( 1 , ap ); for ( int i = 1 ; i <= n ; i ++ ) { ans [ i ] += cnt [ i ] - 1 ; if ( ans [ i ] >= 0 ) ans2 [ ans [ i ]] += cnt [ i ]; // cout<<ans[i]<<endl; } // cout<<endl; for ( int i = 0 ; i < n ; i ++ ) { cout << ans2 [ i ] << endl ; } return 0 ; } //Luogu P3810 \u3010\u6a21\u677f\u3011\u4e09\u7ef4\u504f\u5e8f\uff08\u964c\u4e0a\u82b1\u5f00 //\u984c\u610f\uff1a\u6c42\u6eff\u8db3aj<=ai, bj<=bi, cj<=ci (j!=i)\u7684\u9ede\u5c0d\u6578\u91cf\uff0c\u5c0d\u65bcd in [0,n)\uff0c\u6c42f(i)=d\u7684\u6578\u91cf #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <cstdlib> #include <algorithm> #include <string> #include <vector> #include <map> #include <unordered_map> #include <set> #include <unordered_set> #include <queue> using namespace std ; typedef long long ll ; const int N = 4e5 + 10 ; namespace BIT { const int MAXN = 4e5 + 10 ; template < typename Ty > struct Bit { //local Ty t [ MAXN ]; int __lowbit ( int x ) { return x & ( - x ); } void add ( int pos , Ty val = 1 ) { while ( pos < MAXN ) { t [ pos ] += val ; pos += __lowbit ( pos ); } } Ty ask ( int pos ) { Ty ans = 0 ; while ( pos >= 1 ) { ans += t [ pos ]; pos -= __lowbit ( pos ); } return ans ; } }; } using namespace BIT ; int n , k ; struct P { int x , y , z ; int id ; int cnt ; } a [ N ], b [ N ]; int ap ; struct Q { int y , z ; int typ ; //0:op , 1:query int id ; int cnt ; } c [ N ]; int cp ; Bit < int > tree ; int cnt [ N ]; int ans [ N ]; int ans2 [ N ]; int cmpx ( const P & a , const P & b ) { if ( a . x == b . x && a . y == b . y ) return a . z < b . z ; if ( a . x == b . x ) return a . y < b . y ; return a . x < b . x ; } int cmpq ( const Q & a , const Q & b ) { if ( a . y == b . y && a . z == b . z ) return a . typ < b . typ ; if ( a . y == b . y ) return a . z < b . z ; return a . y < b . y ; } void solve ( int l , int r ) { if ( l == r ) { return ; } int mid = ( l + r ) / 2 ; solve ( l , mid ); solve ( mid + 1 , r ); cp = 0 ; for ( int i = l ; i <= mid ; i ++ ) { c [ ++ cp ] = { a [ i ]. y , a [ i ]. z , 0 , a [ i ]. id , a [ i ]. cnt }; } for ( int i = mid + 1 ; i <= r ; i ++ ) { c [ ++ cp ] = { a [ i ]. y , a [ i ]. z , 1 , a [ i ]. id , a [ i ]. cnt }; } sort ( c + 1 , c + 1 + cp , cmpq ); for ( int i = 1 ; i <= cp ; i ++ ) { if ( c [ i ]. typ == 0 ) //op { tree . add ( c [ i ]. z , c [ i ]. cnt ); } else //query { ans [ c [ i ]. id ] += tree . ask ( c [ i ]. z ); } } //undo change of BIT for ( int i = 1 ; i <= cp ; i ++ ) { if ( c [ i ]. typ == 0 ) { tree . add ( c [ i ]. z , - c [ i ]. cnt ); } } } void my_unique () { ap = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( a [ ap ]. x == b [ i ]. x && a [ ap ]. y == b [ i ]. y && a [ ap ]. z == b [ i ]. z ) { a [ ap ]. cnt ++ ; } else { a [ ++ ap ] = b [ i ]; } } } int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ), cout . tie ( 0 ); cin >> n >> k ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> b [ i ]. x ; cin >> b [ i ]. y ; cin >> b [ i ]. z ; b [ i ]. id = i ; b [ i ]. cnt = 1 ; } sort ( b + 1 , b + 1 + n , cmpx ); my_unique (); sort ( a + 1 , a + 1 + ap , cmpx ); for ( int i = 1 ; i <= ap ; i ++ ) { cnt [ a [ i ]. id ] = a [ i ]. cnt ; } solve ( 1 , ap ); for ( int i = 1 ; i <= n ; i ++ ) { ans [ i ] += cnt [ i ] - 1 ; if ( ans [ i ] >= 0 ) ans2 [ ans [ i ]] += cnt [ i ]; // cout<<ans[i]<<endl; } // cout<<endl; for ( int i = 0 ; i < n ; i ++ ) { cout << ans2 [ i ] << endl ; } return 0 ; } \u6811\u72b6\u6570\u7ec4(BIT) \u00b6 Funs || Methods Reliance Time Complexity Inputs Outputs Description __lowbit 1 x x&-x \u521d\u59cb\u5316\u6743\u503c\u7ebf\u6bb5\u6811 add logn pos\uff1a\u6dfb\u52a0\u7684\u4f4d\u7f6e\u3002val\uff08=1\uff09\uff1a\u6dfb\u52a0\u7684\u503c\u3002 \u5c06pos\u4f4d\u7f6e\u7684\u503c\u52a0\u4e0aval ask logn pos\uff1a\u67e5\u8be2\u7684\u524d\u7f00\u4f4d\u7f6e \u8fd41~pos\u7684\u548c \u8fd4\u56de1~pos\u7684\u548c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include <iostream> using namespace std ; namespace BIT { const int MAXN = 4e5 + 10 ; template < typename Ty > struct Bit { //local Ty t [ MAXN ]; int __lowbit ( int x ) { return x & ( - x ); } void add ( int pos , Ty val = 1 ) { while ( pos < MAXN ) { t [ pos ] += val ; pos += __lowbit ( pos ); } } Ty ask ( int pos ) { Ty ans = 0 ; while ( pos >= 1 ) { ans += t [ pos ]; pos -= __lowbit ( pos ); } return ans ; } }; } using namespace BIT ; \u5e76\u67e5\u96c6\uff08\u6309\u79e9\u5408\u5e76\uff09 \u00b6 Funs || Methods Reliance Time Complexity Inputs Outputs Description init n n\uff1a\u5143\u7d20\u4e2a\u6570 \u521d\u59cb\u5316\u5e76\u67e5\u96c6\u4e2d\u7684\u6bcf\u4e2a\u8282\u70b9\uff0c\u4ee4\u6bcf\u4e2a\u8282\u70b9\u7684\u7236\u4eb2\u4e3a\u5176\u672c\u8eab getfa init 1 x\uff1a\u8282\u70b9 x\u7684\u7236\u4eb2 \u53d6\u5f97\u7236\u4eb2\u5e76\u8def\u5f84\u538b\u7f29 merge init 1 x\u3001y\uff1a\u8282\u70b9 \u5408\u5e76\u540e\u7684\u7236\u4eb2\u8282\u70b9\u3002\u82e5\u4e3a-1\u8868\u660exy\u5df2\u7ecf\u5728\u540c\u4e00\u96c6\u5408 \u5408\u5e76x\u3001y\uff08\u6309\u79e9\u5408\u5e76\uff09 check init 1 x\u3001y\uff1a\u8282\u70b9 \u662f\u5426\u5df2\u7ecf\u5728\u540c\u4e00\u96c6\u5408 \u68c0\u67e5\u662f\u5426\u5728\u540c\u4e00\u96c6\u5408 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <iostream> #include <map> #include <queue> #include <set> #include <string> #include <unordered_map> #include <unordered_set> #include <vector> using namespace std ; typedef long long ll ; namespace Union_find_set { struct Unionfindset { static const int N = 3e5 + 10 ; // local int fa [ N ], sz [ N ]; //fa,sz\uff1a\u7236\u4eb2\u548c\u79e9\u7684\u5927\u5c0f //\u521d\u59cb\u5316\u5e76\u67e5\u96c6 void init ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { fa [ i ] = i ; sz [ i ] = 1 ; } } //\u53d6\u5f97\u7236\u4eb2\u5e76\u8def\u5f84\u538b\u7f29 int getfa ( int x ) { if ( fa [ x ] == x ) return x ; return fa [ x ] = getfa ( fa [ x ]); } //\u5408\u5e76x\u3001y int merge ( int x , int y ) { int x_fa = getfa ( x ), y_fa = getfa ( y ); if ( x_fa == y_fa ) return -1 ; if ( sz [ x_fa ] > sz [ y_fa ]) { swap ( x , y ); swap ( x_fa , y_fa ); } fa [ x_fa ] = y_fa ; sz [ y_fa ] += sz [ x_fa ]; return y_fa ; } //\u68c0\u67e5\u662f\u5426\u5728\u540c\u4e00\u96c6\u5408 bool check ( int x , int y ) { return getfa ( x ) == getfa ( y ); } } ufs ; } // namespace Union_find_set int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ), cout . tie ( 0 ); return 0 ; } KDTree\uff08\u4e8c\u7ef4\uff09 \u00b6 \u26a0\ufe0f\uff1a\u4f7f\u7528\u524d\u9700\u8981\u5148\u5904\u7406\u6811\u4e2d\u7684s\u6570\u7ec4\u548c\u53d8\u91cfn 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <cstdlib> #include <algorithm> #include <string> #include <vector> #include <map> #include <unordered_map> #include <set> #include <unordered_set> #include <queue> using namespace std ; typedef long long ll ; namespace KDTREE { typedef ll Ty ; const int N = 2e5 + 10 ; //\u5e73\u65b9 template < typename T > T sqr ( T x ) { return x * x ; } struct Node { Ty x , y ; Ty L , R , U , D ; int lc , rc ; int d ; //x,y:\u70b9\u7684\u5750\u6807 //LRUD\uff1a\u70b9\u6240\u7ba1\u8f96\u7684\u5b50\u6811\u7684\u6700\u5c0f\u77e9\u5f62\u8986\u76d6 //lc\uff0crc\uff1a\u5de6\u53f3\u5b69\u5b50 // d\uff1a\u8be5\u8282\u70b9\u5b50\u6811\u662f\u6309\u54ea\u4e00\u7ef4\u5212\u5206\u7684\uff0c1\u662f\u6309x\uff0c2\u6309y //\u8ddd\u79bb\u7684\u5e73\u65b9 Ty dis2 ( const Node & b ) const { return sqr ( x - b . x ) + sqr ( y - b . y ); } }; //\u6309x\u8f74\u5750\u6807\u6bd4\u8f83 bool __cmpx ( const Node & a , const Node & b ) { return a . x < b . x ; } //\u6309y\u8f74\u5750\u6807\u6bd4\u8f83 bool __cmpy ( const Node & a , const Node & b ) { return a . y < b . y ; } //\u4e8c\u7ef4kd\u6811\uff0c\u4f7f\u7528\u524d\u9700\u8981\u5148\u6574\u597dn\u548cs\u6570\u7ec4 struct Kdtree { Node s [ N ]; int n ; //s:\u70b9\uff08\u9700\u8981\u9884\u5148\u8bfb\u5165\uff09 //n\uff1a\u70b9\u7684\u4e2a\u6570\uff08\u9700\u8981\u9884\u5148\u8bfb\u5165\uff09 //\u5efa\u6811\u65f6\u7ef4\u62a4\u5b50\u6811 void __upd ( int p ) { s [ p ]. L = s [ p ]. R = s [ p ]. x ; s [ p ]. U = s [ p ]. D = s [ p ]. y ; if ( s [ p ]. lc ) { //\u6ce8\u610f\u8fd9\u91ccmin\u548cmax\u7684\u6b21\u5e8f s [ p ]. L = min ( s [ p ]. L , s [ s [ p ]. lc ]. L ); s [ p ]. R = max ( s [ p ]. R , s [ s [ p ]. lc ]. R ); s [ p ]. U = max ( s [ p ]. U , s [ s [ p ]. lc ]. U ); s [ p ]. D = min ( s [ p ]. D , s [ s [ p ]. lc ]. D ); } if ( s [ p ]. rc ) { s [ p ]. L = min ( s [ p ]. L , s [ s [ p ]. rc ]. L ); s [ p ]. R = max ( s [ p ]. R , s [ s [ p ]. rc ]. R ); s [ p ]. U = max ( s [ p ]. U , s [ s [ p ]. rc ]. U ); s [ p ]. D = min ( s [ p ]. D , s [ s [ p ]. rc ]. D ); } } //\u53d6\u5f97\u65b9\u5dee\u4ee5\u51b3\u5b9a\u5b50\u6811\u5212\u5206\u65b9\u5f0f bool __get_variance ( int l , int r ) { double sumx = 0 , sumy = 0 ; for ( int i = l ; i <= r ; i ++ ) { sumx += s [ i ]. x ; sumy += s [ i ]. y ; } sumx /= r - l + 1 ; sumy /= r - l + 1 ; double vx = 0 , vy = 0 ; for ( int i = l ; i <= r ; i ++ ) { // vx+=(s[i].x-sumx)*(s[i].x-sumx); vx += sqr ( s [ i ]. x - sumx ); // vy+=(s[i].y-sumy)*(s[i].y-sumy); vy += sqr ( s [ i ]. y - sumy ); } if ( vx >= vy ) return true ; return false ; } //\u5efa\u6811 int build ( int l , int r ) { if ( l > r ) return 0 ; if ( l == r ) { __upd ( l ); return l ; } int mid = ( l + r ) / 2 ; bool mark = __get_variance ( l , r ); if ( mark ) { nth_element ( s + l , s + mid , s + r + 1 , __cmpx ); s [ mid ]. d = 1 ; } else { nth_element ( s + l , s + mid , s + r + 1 , __cmpy ); s [ mid ]. d = 2 ; } s [ mid ]. lc = build ( l , mid -1 ); s [ mid ]. rc = build ( mid + 1 , r ); __upd ( mid ); return mid ; } //\u4e0b\u6807\u4e3ap\u7684\u70b9\u5230\u4e0b\u6807\u4e3ab\u7684\u70b9\u6240\u7ef4\u62a4\u7684\u77e9\u5f62\u7684\u8ddd\u79bb Ty __to_rectangle_dis ( int p , int b ) { Ty ans = 0 ; if ( s [ b ]. L > s [ p ]. x ) { // ans+=(s[b].L-s[p].x)*(s[b].L-s[p].x); ans += sqr ( s [ b ]. L - s [ p ]. x ); } if ( s [ b ]. R < s [ p ]. x ) { ans += sqr ( s [ b ]. R - s [ p ]. x ); } if ( s [ b ]. U < s [ p ]. y ) { ans += sqr ( s [ b ]. U - s [ p ]. y ); } if ( s [ b ]. D > s [ p ]. y ) { ans += sqr ( s [ b ]. D - s [ p ]. y ); } return ans ; } // \u8be2\u95ee\u4e0b\u6807\u4e3aindex\u7684\u70b9\u5230\u6811\u4e0a\u9664\u4e86\u81ea\u5df1\u5916\u6700\u8fd1\u70b9\u7684\u8ddd\u79bb void query ( int l , int r , int index , Ty & ans ) { if ( l > r ) { return ; } int mid = ( l + r ) / 2 ; if ( mid != index ) { ans = min ( ans , s [ mid ]. dis2 ( s [ index ])); } if ( l == r ) return ; Ty dis1 = __to_rectangle_dis ( index , s [ mid ]. lc ); Ty dis2 = __to_rectangle_dis ( index , s [ mid ]. rc ); if ( dis1 < dis2 ) { if ( dis1 < ans ) query ( l , mid -1 , index , ans ); if ( dis2 < ans ) query ( mid + 1 , r , index , ans ); } else { if ( dis2 < ans ) query ( mid + 1 , r , index , ans ); if ( dis1 < ans ) query ( l , mid -1 , index , ans ); } /* if(dis1<ans && dis2<ans) { if(dis1<dis2) { if(dis1<ans) query(l,mid-1,index,ans); if(dis2<ans) query(mid+1,r,index,ans); } else { if(dis2<ans) query(mid+1,r,index,ans); if(dis1<ans) query(l,mid-1,index,ans); } } else { if(dis1<ans) query(l,mid-1,index,ans); if(dis2<ans) query(mid+1,r,index,ans); }*/ } } kdt ; } using namespace KDTREE ; int main () { //ios::sync_with_stdio(false); //cin.tie(0),cout.tie(0); scanf ( \"%d\" , & kdt . n ); for ( int i = 1 ; i <= kdt . n ; i ++ ) { Ty x , y ; scanf ( \"%lld%lld\" , & x , & y ); kdt . s [ i ]. x = x ; kdt . s [ i ]. y = y ; } kdt . build ( 1 , kdt . n ); Ty ans = 5e18 ; for ( int i = 1 ; i <= kdt . n ; i ++ ) { kdt . query ( 1 , kdt . n , i , ans ); } printf ( \"%.4lf \\n \" , sqrt ( ans )); return 0 ; } Finding Hotels 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <cstdlib> #include <algorithm> #include <string> #include <vector> #include <map> #include <unordered_map> #include <set> #include <unordered_set> #include <queue> using namespace std ; typedef long long ll ; namespace KDTREE { typedef ll Ty ; const int N = 1e6 + 10 ; //\u5e73\u65b9 template < typename T > T sqr ( T x ) { return x * x ; } struct Node { Ty x , y ; Ty L , R , U , D ; int lc , rc ; int d ; //x,y:\u70b9\u7684\u5750\u6807 //LRUD\uff1a\u70b9\u6240\u7ba1\u8f96\u7684\u5b50\u6811\u7684\u6700\u5c0f\u77e9\u5f62\u8986\u76d6 //lc\uff0crc\uff1a\u5de6\u53f3\u5b69\u5b50 // d\uff1a\u8be5\u8282\u70b9\u5b50\u6811\u662f\u6309\u54ea\u4e00\u7ef4\u5212\u5206\u7684\uff0c1\u662f\u6309x\uff0c2\u6309y int c ; int cc ; int id ; //\u8ddd\u79bb\u7684\u5e73\u65b9 Ty dis2 ( const Node & b ) const { return sqr ( x - b . x ) + sqr ( y - b . y ); } }; //\u6309x\u8f74\u5750\u6807\u6bd4\u8f83 bool __cmpx ( const Node & a , const Node & b ) { return a . x < b . x ; } //\u6309y\u8f74\u5750\u6807\u6bd4\u8f83 bool __cmpy ( const Node & a , const Node & b ) { return a . y < b . y ; } //\u4e8c\u7ef4kd\u6811\uff0c\u4f7f\u7528\u524d\u9700\u8981\u5148\u6574\u597dn\u548cs\u6570\u7ec4 struct Kdtree { Node s [ N ]; int n ; //s:\u70b9\uff08\u9700\u8981\u9884\u5148\u8bfb\u5165\uff09 //n\uff1a\u70b9\u7684\u4e2a\u6570\uff08\u9700\u8981\u9884\u5148\u8bfb\u5165\uff09 //\u5efa\u6811\u65f6\u7ef4\u62a4\u5b50\u6811 void __upd ( int p ) { s [ p ]. L = s [ p ]. R = s [ p ]. x ; s [ p ]. U = s [ p ]. D = s [ p ]. y ; s [ p ]. cc = s [ p ]. c ; if ( s [ p ]. lc ) { //\u6ce8\u610f\u8fd9\u91ccmin\u548cmax\u7684\u6b21\u5e8f s [ p ]. L = min ( s [ p ]. L , s [ s [ p ]. lc ]. L ); s [ p ]. R = max ( s [ p ]. R , s [ s [ p ]. lc ]. R ); s [ p ]. U = max ( s [ p ]. U , s [ s [ p ]. lc ]. U ); s [ p ]. D = min ( s [ p ]. D , s [ s [ p ]. lc ]. D ); s [ p ]. cc = min ( s [ p ]. cc , s [ s [ p ]. lc ]. cc ); } if ( s [ p ]. rc ) { s [ p ]. L = min ( s [ p ]. L , s [ s [ p ]. rc ]. L ); s [ p ]. R = max ( s [ p ]. R , s [ s [ p ]. rc ]. R ); s [ p ]. U = max ( s [ p ]. U , s [ s [ p ]. rc ]. U ); s [ p ]. D = min ( s [ p ]. D , s [ s [ p ]. rc ]. D ); s [ p ]. cc = min ( s [ p ]. cc , s [ s [ p ]. rc ]. cc ); } } //\u53d6\u5f97\u65b9\u5dee\u4ee5\u51b3\u5b9a\u5b50\u6811\u5212\u5206\u65b9\u5f0f bool __get_variance ( int l , int r ) { double sumx = 0 , sumy = 0 ; for ( int i = l ; i <= r ; i ++ ) { sumx += s [ i ]. x ; sumy += s [ i ]. y ; } sumx /= r - l + 1 ; sumy /= r - l + 1 ; double vx = 0 , vy = 0 ; for ( int i = l ; i <= r ; i ++ ) { // vx+=(s[i].x-sumx)*(s[i].x-sumx); vx += sqr ( s [ i ]. x - sumx ); // vy+=(s[i].y-sumy)*(s[i].y-sumy); vy += sqr ( s [ i ]. y - sumy ); } if ( vx >= vy ) return true ; return false ; } //\u5efa\u6811 int build ( int l , int r , bool mark ) { if ( l > r ) return 0 ; if ( l == r ) { __upd ( l ); return l ; } int mid = ( l + r ) / 2 ; // bool mark=__get_variance(l,r); mark = __get_variance ( l , r ); if ( mark ) { nth_element ( s + l , s + mid , s + r + 1 , __cmpx ); s [ mid ]. d = 1 ; } else { nth_element ( s + l , s + mid , s + r + 1 , __cmpy ); s [ mid ]. d = 2 ; } s [ mid ]. lc = build ( l , mid -1 ,(( mark ) ? ( 0 ) : ( 1 ))); s [ mid ]. rc = build ( mid + 1 , r ,(( mark ) ? ( 0 ) : ( 1 ))); __upd ( mid ); return mid ; } Ty __to_rectangle_dis ( Node & nd , Node & b ) { Ty ans = 0 ; if ( b . L > nd . x ) { // ans+=(s[b].L-s[p].x)*(s[b].L-s[p].x); ans += sqr ( b . L - nd . x ); } if ( b . R < nd . x ) { ans += sqr ( b . R - nd . x ); } if ( b . U < nd . y ) { ans += sqr ( b . U - nd . y ); } if ( b . D > nd . y ) { ans += sqr ( b . D - nd . y ); } return ans ; } //\u4ee5\u70b9\u641c\u6700\u8fd1\u70b9 void query ( int l , int r , Node & nd , Ty & ans , Node & ans2 ) { if ( l > r ) return ; int mid = ( l + r ) / 2 ; if ( s [ mid ]. c <= nd . c ) { // ans=min(ans,nd.dis2(s[mid])); Ty dis = nd . dis2 ( s [ mid ]); if ( ans > dis ) { ans = dis ; ans2 = s [ mid ]; } else if ( ans == dis ) { if ( ans2 . id > s [ mid ]. id ) { ans = dis ; ans2 = s [ mid ]; } } } if ( l == r ) return ; //\u526a\u679d\u5224\u636e\u2026\u2026 Ty dis1 = __to_rectangle_dis ( nd , s [ s [ mid ]. lc ]); Ty dis2 = __to_rectangle_dis ( nd , s [ s [ mid ]. rc ]); //... if ( dis1 < dis2 ) { if ( dis1 <= ans && s [ s [ mid ]. lc ]. cc <= nd . c ) query ( l , mid -1 , nd , ans , ans2 ); if ( dis2 <= ans && s [ s [ mid ]. rc ]. cc <= nd . c ) query ( mid + 1 , r , nd , ans , ans2 ); } else { if ( dis2 <= ans && s [ s [ mid ]. rc ]. cc <= nd . c ) query ( mid + 1 , r , nd , ans , ans2 ); if ( dis1 <= ans && s [ s [ mid ]. lc ]. cc <= nd . c ) query ( l , mid -1 , nd , ans , ans2 ); } } } kdt ; } using namespace KDTREE ; int T ; int n1 , n2 ; int main () { scanf ( \"%d\" , & T ); while ( T -- ) { scanf ( \"%d\" , & n1 ); scanf ( \"%d\" , & n2 ); kdt . n = n1 ; for ( int i = 1 ; i <= n1 ; i ++ ) { kdt . s [ i ] = kdt . s [ 0 ]; int x , y , c ; scanf ( \"%d%d%d\" , & x , & y , & c ); kdt . s [ i ]. x = x ; kdt . s [ i ]. y = y ; kdt . s [ i ]. c = c ; kdt . s [ i ]. id = i ; } kdt . build ( 1 , kdt . n , 1 ); for ( int i = 1 ; i <= n2 ; i ++ ) { int x , y , c ; scanf ( \"%d%d%d\" , & x , & y , & c ); Node nd , ans2 ; ll ans = 1e18 ; nd . x = x ; nd . y = y ; nd . c = c ; kdt . query ( 1 , kdt . n , nd , ans , ans2 ); printf ( \"%lld %lld %d \\n \" , ans2 . x , ans2 . y , ans2 . c ); } } return 0 ; } \u6811\u4e0a\u542f\u53d1\u5f0f\u5408\u5e76 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 // CF600E Lomsat gelral //\u6811\u4e0a\u542f\u53d1\u5f0f\u5408\u5e76\u3002\u9898\u610f\u7ffb\u8bd1\uff1a\u6811\u7684\u8282\u70b9\u6709\u989c\u8272\uff0c\u4e00\u79cd\u989c\u8272\u5360\u9886\u4e86\u4e00\u4e2a\u5b50\u6811\uff0c\u5f53\u4e14\u4ec5\u5f53\u6ca1\u6709\u5176\u4ed6\u989c\u8272\u5728\u8fd9\u4e2a\u5b50\u6811\u4e2d\u51fa\u73b0\u5f97\u6bd4\u5b83\u591a\u3002\u6c42\u5360\u9886\u6bcf\u4e2a\u5b50\u6811\u7684\u6240\u6709\u989c\u8272\u4e4b\u548c\u3002 #include <iostream> #include <cstdio> #include <cstring> #include <memory.h> #include <algorithm> #include <map> #include <vector> #include <queue> #include <cmath> using namespace std ; typedef long long ll ; const int N = 2e5 + 10 ; int n ; struct E { int to , inext ; } edge [ N * 2 ]; struct NODE { int sz , color , heavy_son ; //\u5b50\u6811\u5927\u5c0f\uff0c\u70b9\u7684\u989c\u8272\uff0c\u91cd\u513f\u5b50 } node [ N ]; int head [ N ], total ; void adde ( int x , int y ) { edge [ ++ total ]. to = y ; edge [ total ]. inext = head [ x ]; head [ x ] = total ; } namespace dsu_on_tree { int cnt [ N ]; ll sum = 0 , maxval = -1 ; //sum\uff0cmaxval\uff1a\u5f71\u54cd\u90e8\u5206\uff0csum\u8868\u793a\u6570\u91cf\u6700\u591a\u7684\u90a3\u4e2a\u989c\u8272\u7684\u4e2a\u6570\uff0cmaxval\u8868\u793a\u6570\u91cf\u6700\u591a\u7684\u90a3\u4e2a\u989c\u8272\u7684\u6807\u53f7 ll ans [ N ]; //\u7b54\u6848\u90e8\u5206\uff1a\u6bcf\u4e2a\u70b9\u7684\u7b54\u6848\u4fdd\u5b58\u5728\u6b64 //\u7edf\u8ba1\u67d0\u4e2a\u5b50\u6811\u4e0b\uff08\u9664\u4e86heavy_son\u7684\u5b50\u6811\u56e0\u4e3a\u5df2\u7ecf\u7edf\u8ba1\u8fc7\u4e86\uff09\u5bf9\u7b54\u6848\u9020\u6210\u7684\u5f71\u54cd void addans ( int x , int fa , int heavy_son , int val ) { //\u66b4\u529b\u600e\u4e48\u5199\u4e0b\u9762\u5c31\u600e\u4e48\u5199 cnt [ node [ x ]. color ] += val ; if ( cnt [ node [ x ]. color ] > maxval ) { maxval = cnt [ node [ x ]. color ]; sum = node [ x ]. color ; } else if ( cnt [ node [ x ]. color ] == maxval ) sum += ( ll ) node [ x ]. color ; for ( int e = head [ x ]; e ; e = edge [ e ]. inext ) { int y = edge [ e ]. to ; if ( y == fa || y == heavy_son ) continue ; addans ( y , x , heavy_son , val ); } } //\u7b2c\u4e00\u6b21\u904d\u5386\uff0c\u5f97\u5230\u5b50\u6811size\u548cheavy_son void dfs ( int x , int fa ) { node [ x ]. sz = 1 ; node [ x ]. heavy_son = 0 ; int maxsz = 0 ; for ( int e = head [ x ]; e ; e = edge [ e ]. inext ) { int y = edge [ e ]. to ; if ( y == fa ) continue ; dfs ( y , x ); node [ x ]. sz += node [ y ]. sz ; if ( node [ y ]. sz > maxsz ) { maxsz = node [ y ]. sz ; node [ x ]. heavy_son = y ; } } } //\u7b2c\u4e8c\u6b21\u904d\u5386\uff0c\u7edf\u8ba1\u7b54\u6848 void dfs2 ( int x , int fa , bool sv ) //sv:\u662f\u5426\u4fdd\u7559 { //\u8f7b\u513f\u5b50\uff08\u9012\u5f52\uff09 for ( int e = head [ x ]; e ; e = edge [ e ]. inext ) { int y = edge [ e ]. to ; if ( y == fa || y == node [ x ]. heavy_son ) continue ; //\u8df3\u8fc7\u7236\u4eb2\u548c\u91cd\u513f\u5b50 dfs2 ( y , x , 0 ); } //\u91cd\u513f\u5b50\uff08\u9012\u5f52\uff09 if ( node [ x ]. heavy_son ) { dfs2 ( node [ x ]. heavy_son , x , 1 ); } //\u8f7b\u513f\u5b50\uff08\u66b4\u529b\uff09 addans ( x , fa , node [ x ]. heavy_son , 1 ); ans [ x ] = sum ; //update ans if ( sv == 0 ) //\u64a4\u9500\u5b50\u6811\u4e0b\u7684\u6240\u6709\u5f71\u54cd { addans ( x , fa , 0 , -1 ); sum = 0 ; maxval = -1 ; } } } // namespace dsu_on_tree using namespace dsu_on_tree ; int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> node [ i ]. color ; } for ( int i = 1 ; i <= n - 1 ; i ++ ) { int x , y ; cin >> x >> y ; adde ( x , y ); adde ( y , x ); } dfs ( 1 , 0 ); //root is 1, predo:heavy_son dfs2 ( 1 , 0 , 0 ); for ( int i = 1 ; i <= n ; i ++ ) { cout << ans [ i ] << \" \" ; } return 0 ; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 /** * 2021\u725b\u5ba2\u591a\u68219 E Eyjafjalla \u9898\u610f\uff1a\u7ed9\u5b9a\u4e00\u4e2a\u4ee5 1 \u4e3a\u6839\u7684\u6709\u6839\u6811\uff0c\u5b69\u5b50\u7684\u70b9\u6743\u5c0f\u4e8e\u7236\u4eb2\u7684\u70b9\u6743\u3002\u591a\u6b21\u8be2\u95ee\uff0c\u6bcf\u6b21\u8be2\u95ee\u5305\u542b x \u8282\u70b9\u7684\u6743\u503c\u8303\u56f4\u4e3a [l, r] \u7684\u6781\u5927\u8fde\u901a\u7684\u5927\u5c0f\u3002 \u505a\u6cd5\uff1a\u79bb\u7ebf\u7136\u540e\u79bb\u6563\u5316\uff0c\u4e4b\u540e\u7528\u4e2a\u6811\u72b6\u6570\u7ec4\u7edf\u8ba1\u6bcf\u4e2a\u8be2\u95ee\u5728\u5b50\u6811\u4e2d\u7684\u7b54\u6848\u3002 **/ #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <cstdlib> #include <algorithm> #include <string> #include <vector> #include <map> #include <unordered_map> #include <set> #include <unordered_set> #include <queue> using namespace std ; typedef long long ll ; const int N = 2e5 + 10 ; namespace BIT { const int MAXN = 4e5 + 10 ; template < typename Ty > struct Bit { //local Ty t [ MAXN ]; int __lowbit ( int x ) { return x & ( - x ); } void add ( int pos , Ty val = 1 ) { while ( pos < MAXN ) { t [ pos ] += val ; pos += __lowbit ( pos ); } } Ty ask ( int pos ) { Ty ans = 0 ; while ( pos >= 1 ) { ans += t [ pos ]; pos -= __lowbit ( pos ); } return ans ; } }; } using namespace BIT ; Bit < int > bit ; //... int n ; int w [ N ]; int ww [ N * 2 ], ww_p ; unordered_map < int , int > mp ; struct Q { int x , l , r ; int ans ; } query [ N ]; int q ; struct E { int to , inext ; } edge [ N * 2 ]; int head [ N ], total ; int f [ N ][ 30 ]; int vis [ N ]; struct Node { vector < int > qid ; int sz ; int heavy_son ; } node [ N ]; //... void adde ( int x , int y ) { edge [ ++ total ]. to = y ; edge [ total ]. inext = head [ x ]; head [ x ] = total ; } int upb ; //bfs\uff0c\u4f7f\u5f97\u80fd\u6811\u4e0a\u500d\u589e void predo ( int rt = 1 ) { queue < int > q ; q . push ( rt ); vis [ rt ] = 1 ; while ( q . size ()) { int x = q . front (); q . pop (); for ( int e = head [ x ]; e ; e = edge [ e ]. inext ) { int y = edge [ e ]. to ; if ( vis [ y ] == 0 ) { vis [ y ] = vis [ x ] + 1 ; f [ y ][ 0 ] = x ; for ( int k = 1 ; k <= upb ; k ++ ) { f [ y ][ k ] = f [ f [ y ][ k -1 ]][ k -1 ]; } q . push ( y ); } } } } //\u9884\u5904\u7406\u79bb\u7ebf\u7b54\u6848 void predo2 ( int i ) { int x = query [ i ]. x ; int r = query [ i ]. r ; int l = query [ i ]. l ; // int tmpans=x; if ( l <= w [ x ] && w [ x ] <= r ) { for ( int k = upb ; k >= 0 ; k -- ) { if ( f [ x ][ k ] != 0 && w [ f [ x ][ k ]] <= r ) { x = f [ x ][ k ]; } } node [ x ]. qid . emplace_back ( i ); } else { query [ i ]. ans = 0 ; } } //dsu on tree void dfs1 ( int x , int fa ) { node [ x ]. sz = 1 ; node [ x ]. heavy_son = 0 ; int maxsz = 0 ; for ( int e = head [ x ]; e ; e = edge [ e ]. inext ) { int y = edge [ e ]. to ; if ( y == fa ) continue ; dfs1 ( y , x ); node [ x ]. sz += node [ y ]. sz ; if ( node [ y ]. sz > maxsz ) { maxsz = node [ y ]. sz ; node [ x ]. heavy_son = y ; } } } void addans ( int x , int fa , int heavy_son , int val = 1 ) { bit . add ( mp [ w [ x ]], val ); for ( int e = head [ x ]; e ; e = edge [ e ]. inext ) { int y = edge [ e ]. to ; if ( y == fa || y == heavy_son ) continue ; addans ( y , x , heavy_son , val ); } } //dsu on tree\uff0c\u6811\u4e0a\u542f\u53d1\u5f0f void dfs2 ( int x , int fa , bool sv ) { for ( int e = head [ x ]; e ; e = edge [ e ]. inext ) { int y = edge [ e ]. to ; if ( y == fa || y == node [ x ]. heavy_son ) continue ; dfs2 ( y , x , 0 ); } if ( node [ x ]. heavy_son ) { dfs2 ( node [ x ]. heavy_son , x , 1 ); } addans ( x , fa , node [ x ]. heavy_son , 1 ); //getans for ( auto v : node [ x ]. qid ) { int l = query [ v ]. l ; query [ v ]. ans = node [ x ]. sz - bit . ask ( mp [ l ] -1 ); } if ( sv == 0 ) { addans ( x , fa , 0 , -1 ); //\u91cd\u8981\uff1a\u5220\u9664\u5b50\u6811\u5f71\u54cd\u7684heavy_son\u4e00\u5b9a\u8981\u662f0\uff0c\u4e0d\u80fd\u548c\u4e4b\u524d\u90a3\u4e2a\u7528addans\u7684\u4e00\u6837 } } int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ), cout . tie ( 0 ); cin >> n ; upb = log2 ( n ) + 1 ; for ( int i = 1 ; i <= n -1 ; i ++ ) { int x , y ; cin >> x >> y ; adde ( x , y ); adde ( y , x ); } for ( int i = 1 ; i <= n ; i ++ ) { cin >> w [ i ]; ww [ ++ ww_p ] = w [ i ]; } cin >> q ; for ( int i = 1 ; i <= q ; i ++ ) { cin >> query [ i ]. x ; cin >> query [ i ]. l ; cin >> query [ i ]. r ; ww [ ++ ww_p ] = query [ i ]. l ; ww [ ++ ww_p ] = query [ i ]. r ; } sort ( ww + 1 , ww + 1 + ww_p ); for ( int i = 1 ; i <= ww_p ; i ++ ) { mp [ ww [ i ]] = i ; } //bfs predo (); //\u9884\u5904\u7406\u79bb\u7ebf\u7b54\u6848 for ( int i = 1 ; i <= q ; i ++ ) { predo2 ( i ); } dfs1 ( 1 , 0 ); dfs2 ( 1 , 0 , 0 ); for ( int i = 1 ; i <= q ; i ++ ) { cout << query [ i ]. ans << '\\n' ; } return 0 ; } \u2b50Splay \u4f38\u5c55\u6a39 \u00b6 \uff08\u9644\u8a3b\uff1a\u53ef\u80fd\u9019\u500b\u7248\u672c\u7684Splay\u6709\u9ede\u554f\u984c\uff0c\u5230\u6642\u5019\u5f97\u63db\u6389\uff09\uff08\u5c1a\u672a\u6574\u7406\uff09 \u666e\u901a\u5e73\u8861\u6811 \u00b6 \u60a8\u9700\u8981\u5199\u4e00\u79cd\u6570\u636e\u7ed3\u6784\uff08\u53ef\u53c2\u8003\u9898\u76ee\u6807\u9898\uff09\uff0c\u6765\u7ef4\u62a4\u4e00\u4e9b\u6570\uff0c\u5176\u4e2d\u9700\u8981\u63d0\u4f9b\u4ee5\u4e0b\u64cd\u4f5c\uff1a \u63d2\u5165 xx \u6570 \u5220\u9664 xx \u6570(\u82e5\u6709\u591a\u4e2a\u76f8\u540c\u7684\u6570\uff0c\u56e0\u53ea\u5220\u9664\u4e00\u4e2a) \u67e5\u8be2 xx \u6570\u7684\u6392\u540d(\u6392\u540d\u5b9a\u4e49\u4e3a\u6bd4\u5f53\u524d\u6570\u5c0f\u7684\u6570\u7684\u4e2a\u6570 +1+1 ) \u67e5\u8be2\u6392\u540d\u4e3a xx \u7684\u6570 \u6c42 xx \u7684\u524d\u9a71(\u524d\u9a71\u5b9a\u4e49\u4e3a\u5c0f\u4e8e xx\uff0c\u4e14\u6700\u5927\u7684\u6570) \u6c42 xx \u7684\u540e\u7ee7(\u540e\u7ee7\u5b9a\u4e49\u4e3a\u5927\u4e8e xx\uff0c\u4e14\u6700\u5c0f\u7684\u6570) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 #include <iostream> #include <memory.h> using namespace std ; namespace SPLAY { const int N = 114514 ; using Ty = int ; const Ty Inf = 1 << 30 ; //Inf\uff1a\u8bb0\u5f97longlong\u7684\u8bdd\u8981\u6539\u8fd9\u91cc\uff01 //\u6ce8\u610f\uff1aInf\u4e0d\u5e94\u8be5\u4e0e\u4efb\u4f55\u53ef\u80fd\u7684\u503c\u76f8\u7b49\uff0c\u5426\u5219\u4f60\u9700\u8981\u8003\u8651\u522b\u7684\u65b9\u5f0f struct Splay { struct Node { int fa , ch [ 2 ]; Ty val ; //val\uff1a\u8981\u7ef4\u62a4\u7684\u503c Ty cnt , size ; //cnt\u3001size\uff1a\u56fa\u5b9a\uff0c\u6bcf\u4e2a\u8282\u70b9\u7684\u4e2a\u6570\u548c\u5b50\u6811\u5927\u5c0f } t [ N ]; //root:\u6839\u8282\u70b9\u4e0b\u6807 //total:\u603b\u8282\u70b9\u6570 int root , total ; //\u66f4\u65b0\u8282\u70b9p\u7684\u4fe1\u606f void __upd ( int p ) { if ( p == 0 ) return ; t [ p ]. size = t [ t [ p ]. ch [ 0 ]]. size + t [ t [ p ]. ch [ 1 ]]. size + t [ p ]. cnt ; } //\u5224\u65adp\u662f\u5426\u662f\u5728\u53f3\u513f\u5b50\u4f4d\u7f6e judge whether p is father's R-child bool __get ( int p ) { return p == t [ t [ p ]. fa ]. ch [ 1 ]; } //\u5728\u5185\u5b58\u8282\u70b9\u6c60\u4e2d\u5206\u914d\u4e00\u4e2a\u65b0\u7684\u503c\uff0c\u5e76\u8fd4\u56de\u5b83\u7684\u4e0b\u6807 int __add ( Ty val ) { t [ ++ total ]. val = val ; t [ total ]. cnt = t [ total ]. size = 1 ; t [ total ]. fa = 0 ; t [ total ]. ch [ 0 ] = t [ total ]. ch [ 1 ] = 0 ; return total ; } void init () { root = 1 ; total = 0 ; __add ( - Inf ); //1 __add ( Inf ); //2 t [ 1 ]. ch [ 1 ] = 2 ; t [ 2 ]. fa = 1 ; __upd ( root ); } //zip or zap (depending on [whether p is father's R-child]) void __rotate ( int p ) { // z->y->p int y = t [ p ]. fa , z = t [ y ]. fa , chk = __get ( p ); //!!!You must use previous version Get(p) if ( y == 0 || p == 0 ) return ; // Modify p's R(L)Child as y's L(R)Child t [ y ]. ch [ chk ] = t [ p ]. ch [ chk ^ 1 ]; if ( t [ p ]. ch [ chk ^ 1 ]) t [ t [ p ]. ch [ chk ^ 1 ]]. fa = y ; // Then change p's Child t [ p ]. ch [ chk ^ 1 ] = y ; t [ y ]. fa = p ; // Finally change p's father as z (which was y's father) t [ p ]. fa = z ; if ( z ) t [ z ]. ch [ y == t [ z ]. ch [ 1 ]] = p ; __upd ( y ); __upd ( p ); } //\u4f38\u5c55\u64cd\u4f5c : // \u5982\u679c p \u7684\u7236\u4eb2\u662f\u6839\u8282\u70b9\uff0c\u76f4\u63a5\u5c06 p \u5de6\u65cb\u6216\u53f3\u65cb // \u5982\u679c p \u7684\u7236\u4eb2\u4e0d\u662f\u6839\u8282\u70b9\uff0c\u4e14 p \u548c\u7236\u4eb2\u7684\u513f\u5b50\u7c7b\u578b\u76f8\u540c\uff0c\u9996\u5148\u5c06\u5176\u7236\u4eb2\u5de6\u65cb\u6216\u53f3\u65cb\uff0c\u7136\u540e\u5c06 p \u53f3\u65cb\u6216\u5de6\u65cb // \u5982\u679c p \u7684\u7236\u4eb2\u4e0d\u662f\u6839\u8282\u70b9\uff0c\u4e14 p \u548c\u7236\u4eb2\u7684\u513f\u5b50\u7c7b\u578b\u4e0d\u540c\uff0c\u5c06 p \u5de6\u65cb\u518d\u53f3\u65cb\u3001\u6216\u8005\u53f3\u65cb\u518d\u5de6\u65cb void __splay ( int p ) { for ( int f = t [ p ]. fa ; f = t [ p ]. fa ; __rotate ( p )) { if ( t [ f ]. fa ) __rotate ( __get ( p ) == __get ( f ) ? f : p ); //Case 3,4:(p,y,z at the same line) | 5,6:(else) } root = p ; } //\u63d2\u5165\u4e00\u4e2a\u503c\u4e3aval\u7684\u5143\u7d20 void insert ( Ty val ) { if ( root == 0 ) { root = __add ( val ); __upd ( root ); return ; } int p = root , f = 0 ; while ( true ) { if ( t [ p ]. val == val ) { t [ p ]. cnt ++ ; __upd ( p ); __upd ( f ); __splay ( p ); return ; } f = p ; //f!=0; p = t [ p ]. ch [ t [ p ]. val < val ]; if ( ! p ) //Child does not exist { t [ f ]. ch [ t [ f ]. val < val ] = __add ( val ); t [ total ]. fa = f ; __upd ( total ); __upd ( f ); __splay ( total ); return ; } } } //\u53d6\u5f97>=val\u7684\u8282\u70b9\u6700\u5c0f\u6392\u540d\uff08\u4ece1\u8ba1\u6570\uff09\u548c\u4e0b\u6807\uff0c\u76f8\u5f53\u4e8elower_bound //\u6ce8\u610f\u8fd9\u51e0\u4e2a\u64cd\u4f5c\u4f1a\u7acb\u5373\u4f7f\u5f97\u88ab\u627e\u5230\u7684\u8282\u70b9\u88absplay\u5230\u6839\u8282\u70b9\uff0c\u4e0d\u8fc7\u4e0b\u6807\u4ecd\u7136\u662f\u6709\u6548\u7684 pair < Ty , int > get_rank_by_val ( Ty val ) { int p = root ; if ( p == 0 ) return { t [ root ]. size + 1 , -1 }; int sum = 0 ; //\u5f53\u524d < val \u7684\u8282\u70b9cnt\u4e4b\u548c int ans = t [ root ]. size + 1 ; //ans:\u5f53\u524d\u6700\u597d\u6392\u540d int cur = -1 ; //cur\uff1a\u5f53\u524d\u7b54\u6848\u7684\u4e0b\u6807 while ( p ) { if ( t [ p ]. val < val ) // < { sum += t [ p ]. cnt ; if ( t [ p ]. ch [ 0 ]) sum += t [ t [ p ]. ch [ 0 ]]. size ; p = t [ p ]. ch [ 1 ]; } else // >= { int tmpans = sum + 1 + (( t [ p ]. ch [ 0 ]) ? ( t [ t [ p ]. ch [ 0 ]]. size ) : ( 0 )); if ( tmpans < ans ) { ans = tmpans ; cur = p ; } p = t [ p ]. ch [ 0 ]; } } // *\u5982\u679c\u4e0d\u9009\u62e9\u5728init\u65f6\u63d2\u5165\u4e24\u4e2a\u521d\u59cb\u65e0\u7a77\u5927\u503c\uff0c\u5219\u8bf7\u5728\u8fd9\u91cc\u79fb\u9664\u8fd9\u6bb5\u4ee3\u7801 ans -= 1 ; // *\u79fb\u9664\u4ee3\u7801\u6bb5\u7ed3\u675f if ( cur != -1 ) __splay ( cur ); return { ans , cur }; } //\u6839\u636e\u6392\u540d\uff08\u4ece1\u5f00\u59cb\uff09\u53d6\u5f97\u503c\u548c\u4e0b\u6807 //\u6ce8\u610f\u8fd9\u51e0\u4e2a\u64cd\u4f5c\u4f1a\u7acb\u5373\u4f7f\u5f97\u88ab\u627e\u5230\u7684\u8282\u70b9\u88absplay\u5230\u6839\u8282\u70b9\uff0c\u4e0d\u8fc7\u4e0b\u6807\u4ecd\u7136\u662f\u6709\u6548\u7684 pair < Ty , int > get_val_by_rank ( int rank ) { // *\u5982\u679c\u4e0d\u9009\u62e9\u5728init\u65f6\u63d2\u5165\u4e24\u4e2a\u521d\u59cb\u65e0\u7a77\u5927\u503c\uff0c\u5219\u8bf7\u5728\u8fd9\u91cc\u79fb\u9664\u8fd9\u6bb5\u4ee3\u7801 rank += 1 ; // *\u79fb\u9664\u4ee3\u7801\u6bb5\u7ed3\u675f int p = root ; while ( true ) { if ( t [ p ]. ch [ 0 ] && t [ t [ p ]. ch [ 0 ]]. size >= rank ) { p = t [ p ]. ch [ 0 ]; } else { rank -= t [ p ]. cnt + t [ t [ p ]. ch [ 0 ]]. size ; if ( rank <= 0 ) { __splay ( p ); return { t [ p ]. val , p }; } p = t [ p ]. ch [ 1 ]; } } } //\u6839\u636eval\u7684\u503c\uff0c\u5bfb\u627e\u5bf9\u5e94\u8282\u70b9\u7684\u540e\u7ee7\uff0c\u8fd4\u56de\u8282\u70b9\u4e0b\u6807 //\u6ce8\u610f\uff1a1.\u4e00\u5b9a\u8981\u4fdd\u8bc1\u8282\u70b9\u5b58\u5728\uff0c 2.\u4e00\u5b9a\u8981\u4fdd\u8bc1\u6811\u4e2d\u6709\u65e0\u7a77\u5c0f\u548c\u65e0\u7a77\u5927\u4e24\u4e2a\u8282\u70b9\uff0c\u4e14\u4e0b\u6807\u5206\u522b\u662f1\u30012 int get_next_index ( Ty val ) { int ans = 2 , p = root ; //t[ans].val== Inf (INIT) while ( p ) { if ( val == t [ p ]. val ) //search success { if ( t [ p ]. ch [ 1 ]) { p = t [ p ]. ch [ 1 ]; while ( t [ p ]. ch [ 0 ]) p = t [ p ]. ch [ 0 ]; ans = p ; } break ; } //else update ans using path if ( t [ p ]. val > val && t [ p ]. val < t [ ans ]. val ) ans = p ; p = ( t [ p ]. val < val ) ? t [ p ]. ch [ 1 ] : t [ p ]. ch [ 0 ]; } return ans ; //Notice that return value is subscript } //\u6839\u636eval\u7684\u503c\uff0c\u5bfb\u627e\u5bf9\u5e94\u8282\u70b9\u7684\u524d\u9a71\uff0c\u8fd4\u56de\u8282\u70b9\u4e0b\u6807 //\u6ce8\u610f\uff1a1.\u4e00\u5b9a\u8981\u4fdd\u8bc1\u8282\u70b9\u5b58\u5728\uff0c 2.\u4e00\u5b9a\u8981\u4fdd\u8bc1\u6811\u4e2d\u6709\u65e0\u7a77\u5c0f\u548c\u65e0\u7a77\u5927\u4e24\u4e2a\u8282\u70b9\uff0c\u4e14\u4e0b\u6807\u5206\u522b\u662f1\u30012 int get_pre_index ( Ty val ) { int ans = 1 , p = root ; //t[ans].val== -Inf (INIT) while ( p ) { if ( val == t [ p ]. val ) //search success { if ( t [ p ]. ch [ 0 ]) { p = t [ p ]. ch [ 0 ]; while ( t [ p ]. ch [ 1 ]) p = t [ p ]. ch [ 1 ]; ans = p ; } break ; } //else update ans using path if ( t [ p ]. val < val && t [ p ]. val > t [ ans ]. val ) ans = p ; p = ( t [ p ]. val < val ) ? t [ p ]. ch [ 1 ] : t [ p ]. ch [ 0 ]; } return ans ; //Notice that return value is subscript } //\u6839\u636eval\u5220\u53bb\u8282\u70b9\uff1a\u5148\u901a\u8fc7lower_bound\u627e\u5230\u7b2c\u4e00\u4e2a\u7b49\u4e8eval\u7684\u8282\u70b9\uff0c\u628a\u4ed6splay\u5230\u6839\uff0c\u7136\u540e\u5220\u9664\u4e4b //\u6ce8\u610f\uff1a\u6811\u4e2d\u4e00\u5b9a\u8981\u6709\u7b49\u4e8eval\u503c\u7684\u8282\u70b9\uff01 void del ( Ty val ) { if ( get_rank_by_val ( val ). second == -1 ) return ; if ( t [ root ]. cnt > 1 ) { t [ root ]. cnt -- ; __upd ( root ); return ; } int p = root ; int q = get_pre_index ( val ); __splay ( q ); t [ t [ p ]. ch [ 1 ]]. fa = q ; t [ q ]. ch [ 1 ] = t [ p ]. ch [ 1 ]; } } splay_tree ; } int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); SPLAY :: splay_tree . init (); int n ; cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) { int op , x ; cin >> op >> x ; if ( op == 1 ) SPLAY :: splay_tree . insert ( x ); else if ( op == 2 ) SPLAY :: splay_tree . del ( x ); else if ( op == 3 ) cout << SPLAY :: splay_tree . get_rank_by_val ( x ). first << endl ; else if ( op == 4 ) cout << SPLAY :: splay_tree . get_val_by_rank ( x ). first << endl ; else if ( op == 5 ) cout << SPLAY :: splay_tree . t [ SPLAY :: splay_tree . get_pre_index ( x )]. val << endl ; else cout << SPLAY :: splay_tree . t [ SPLAY :: splay_tree . get_next_index ( x )]. val << endl ; } return 0 ; } /* \u65e7\u7684\u64cd\u4f5c int Get_Rank_By_Val(int x) { int ans=0,p=root; while (true) { if(x<t[p].val) { p=t[p].ch[0]; } else { ans+=t[t[p].ch[0]].size; if(x==t[p].val) { Splay(p); return ans+1; } ans+=t[p].cnt; p=t[p].ch[1]; } } } */ \u6587\u827a\u5e73\u8861\u6811 \u00b6 \u60a8\u9700\u8981\u5199\u4e00\u79cd\u6570\u636e\u7ed3\u6784\uff08\u53ef\u53c2\u8003\u9898\u76ee\u6807\u9898\uff09\uff0c\u6765\u7ef4\u62a4\u4e00\u4e2a\u6709\u5e8f\u6570\u5217\u3002 \u5176\u4e2d\u9700\u8981\u63d0\u4f9b\u4ee5\u4e0b\u64cd\u4f5c\uff1a\u7ffb\u8f6c\u4e00\u4e2a\u533a\u95f4\uff0c\u4f8b\u5982\u539f\u6709\u5e8f\u5e8f\u5217\u662f 5 4 3 2 1\uff0c\u7ffb\u8f6c\u533a\u95f4\u662f [2,4][2,4] \u7684\u8bdd\uff0c\u7ed3\u679c\u662f 5 2 3 4 1\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 #include <iostream> using namespace std ; const int N = 114514 ; namespace SPLAY { const int N = 114514 ; using Ty = int ; const Ty Inf = 1 << 30 ; //Inf\uff1a\u8bb0\u5f97longlong\u7684\u8bdd\u8981\u6539\u8fd9\u91cc\uff01 //\u6ce8\u610f\uff1aInf\u4e0d\u5e94\u8be5\u4e0e\u4efb\u4f55\u53ef\u80fd\u7684\u503c\u76f8\u7b49\uff0c\u5426\u5219\u4f60\u9700\u8981\u8003\u8651\u522b\u7684\u65b9\u5f0f struct Splay { struct Node { int fa , ch [ 2 ]; Ty val ; //val\uff1a\u8981\u7ef4\u62a4\u7684\u503c Ty cnt , size ; //cnt\u3001size\uff1a\u56fa\u5b9a\uff0c\u6bcf\u4e2a\u8282\u70b9\u7684\u4e2a\u6570\u548c\u5b50\u6811\u5927\u5c0f int T ; //T:\u53cd\u8f6c\u6807\u8bb0 } t [ N ]; //root:\u6839\u8282\u70b9\u4e0b\u6807 //total:\u603b\u8282\u70b9\u6570 int root , total ; //\u66f4\u65b0\u8282\u70b9p\u7684\u4fe1\u606f void __upd ( int p ) { if ( p == 0 ) return ; t [ p ]. size = t [ t [ p ]. ch [ 0 ]]. size + t [ t [ p ]. ch [ 1 ]]. size + t [ p ]. cnt ; } //\u5224\u65adp\u662f\u5426\u662f\u5728\u53f3\u513f\u5b50\u4f4d\u7f6e judge whether p is father's R-child bool __get ( int p ) { return p == t [ t [ p ]. fa ]. ch [ 1 ]; } //\u5728\u5185\u5b58\u8282\u70b9\u6c60\u4e2d\u5206\u914d\u4e00\u4e2a\u65b0\u7684\u503c\uff0c\u5e76\u8fd4\u56de\u5b83\u7684\u4e0b\u6807 int __add ( Ty val ) { t [ ++ total ]. val = val ; t [ total ]. cnt = t [ total ]. size = 1 ; t [ total ]. fa = 0 ; t [ total ]. ch [ 0 ] = t [ total ]. ch [ 1 ] = 0 ; t [ total ]. T = 0 ; return total ; } void init () { root = 1 ; total = 0 ; __add ( - Inf ); //1 __add ( Inf ); //2 t [ 1 ]. ch [ 1 ] = 2 ; t [ 2 ]. fa = 1 ; __upd ( root ); } //\u4e0b\u4f20\u53cd\u8f6c\u6807\u8bb0 void __spread ( int p ) { if ( t [ p ]. T ) { swap ( t [ t [ p ]. ch [ 0 ]]. ch [ 0 ], t [ t [ p ]. ch [ 0 ]]. ch [ 1 ]); //LChild swap ( t [ t [ p ]. ch [ 1 ]]. ch [ 0 ], t [ t [ p ]. ch [ 1 ]]. ch [ 1 ]); //RChild t [ t [ p ]. ch [ 0 ]]. T ^= 1 ; t [ t [ p ]. ch [ 1 ]]. T ^= 1 ; t [ p ]. T = 0 ; } } //zip or zap (depending on [whether p is father's R-child]) void __rotate ( int p ) { __spread ( p ); // z->y->p int y = t [ p ]. fa , z = t [ y ]. fa , chk = __get ( p ); //!!!You must use previous version Get(p) if ( y == 0 || p == 0 ) return ; // Modify p's R(L)Child as y's L(R)Child t [ y ]. ch [ chk ] = t [ p ]. ch [ chk ^ 1 ]; if ( t [ p ]. ch [ chk ^ 1 ]) t [ t [ p ]. ch [ chk ^ 1 ]]. fa = y ; // Then change p's Child t [ p ]. ch [ chk ^ 1 ] = y ; t [ y ]. fa = p ; // Finally change p's father as z (which was y's father) t [ p ]. fa = z ; if ( z ) t [ z ]. ch [ y == t [ z ]. ch [ 1 ]] = p ; __upd ( y ); __upd ( p ); } //\u4f38\u5c55\u64cd\u4f5c : // \u5982\u679c p \u7684\u7236\u4eb2\u662f\u6839\u8282\u70b9\uff0c\u76f4\u63a5\u5c06 p \u5de6\u65cb\u6216\u53f3\u65cb // \u5982\u679c p \u7684\u7236\u4eb2\u4e0d\u662f\u6839\u8282\u70b9\uff0c\u4e14 p \u548c\u7236\u4eb2\u7684\u513f\u5b50\u7c7b\u578b\u76f8\u540c\uff0c\u9996\u5148\u5c06\u5176\u7236\u4eb2\u5de6\u65cb\u6216\u53f3\u65cb\uff0c\u7136\u540e\u5c06 p \u53f3\u65cb\u6216\u5de6\u65cb // \u5982\u679c p \u7684\u7236\u4eb2\u4e0d\u662f\u6839\u8282\u70b9\uff0c\u4e14 p \u548c\u7236\u4eb2\u7684\u513f\u5b50\u7c7b\u578b\u4e0d\u540c\uff0c\u5c06 p \u5de6\u65cb\u518d\u53f3\u65cb\u3001\u6216\u8005\u53f3\u65cb\u518d\u5de6\u65cb void __splay ( int p ) { __spread ( p ); for ( int f = t [ p ]. fa ; f = t [ p ]. fa ; __rotate ( p )) { if ( t [ f ]. fa ) __rotate ( __get ( p ) == __get ( f ) ? f : p ); //Case 3,4:(p,y,z at the same line) | 5,6:(else) } root = p ; } //\u5c06p\u4e0d\u65ad\u65cb\u8f6c\u5230\u6839\u524d\u4e3a\u6b62 void __splay2 ( int p ) { __spread ( p ); for ( int f = t [ p ]. fa ; f = t [ p ]. fa , f != root ; __rotate ( p )) { if ( t [ f ]. fa != root ) __rotate ( __get ( p ) == __get ( f ) ? f : p ); //Case 3,4:(p,y,z at the same line) | 5,6:(else) } } //\u63d2\u5165\u4e00\u4e2a\u503c\u4e3aval\u7684\u5143\u7d20 void insert ( Ty val ) { if ( root == 0 ) { root = __add ( val ); __upd ( root ); return ; } int p = root , f = 0 ; while ( true ) { if ( t [ p ]. val == val ) { t [ p ]. cnt ++ ; __upd ( p ); __upd ( f ); __splay ( p ); return ; } f = p ; //f!=0; p = t [ p ]. ch [ t [ p ]. val < val ]; if ( ! p ) //Child does not exist { t [ f ]. ch [ t [ f ]. val < val ] = __add ( val ); t [ total ]. fa = f ; __upd ( total ); __upd ( f ); __splay ( total ); return ; } } } //\u6839\u636e\u6392\u540d\uff08\u4ece1\u5f00\u59cb\uff09\u53d6\u5f97\u503c\u548c\u4e0b\u6807 //\u6ce8\u610f\u8fd9\u51e0\u4e2a\u64cd\u4f5c\u4f1a\u7acb\u5373\u4f7f\u5f97\u88ab\u627e\u5230\u7684\u8282\u70b9\u88absplay\u5230\u6839\u8282\u70b9\uff0c\u4e0d\u8fc7\u4e0b\u6807\u4ecd\u7136\u662f\u6709\u6548\u7684 pair < Ty , int > get_val_by_rank ( int rank , bool root_RChild_rotate ) { // *\u5982\u679c\u4e0d\u9009\u62e9\u5728init\u65f6\u63d2\u5165\u4e24\u4e2a\u521d\u59cb\u65e0\u7a77\u5927\u503c\uff0c\u5219\u8bf7\u5728\u8fd9\u91cc\u79fb\u9664\u8fd9\u6bb5\u4ee3\u7801 rank += 1 ; // *\u79fb\u9664\u4ee3\u7801\u6bb5\u7ed3\u675f int p = root ; while ( true ) { __spread ( p ); if ( t [ p ]. ch [ 0 ] && t [ t [ p ]. ch [ 0 ]]. size >= rank ) { p = t [ p ]. ch [ 0 ]; } else { rank -= t [ p ]. cnt + t [ t [ p ]. ch [ 0 ]]. size ; if ( rank <= 0 ) { if ( root_RChild_rotate ) __splay2 ( p ); else __splay ( p ); return { t [ p ]. val , p }; } p = t [ p ]. ch [ 1 ]; } } } void reverse ( int l , int r ) { get_val_by_rank ( l -1 , 0 ); //l-1 is root get_val_by_rank ( r + 1 , 1 ); //r+1 is rchild of l-1 now //now r+1's lchild is the range needed to be reversed. int p = root ; __spread ( p ); p = t [ p ]. ch [ 1 ]; __spread ( p ); p = t [ p ]. ch [ 0 ]; __spread ( p ); swap ( t [ p ]. ch [ 0 ], t [ p ]. ch [ 1 ]); t [ p ]. T ^= 1 ; } void output ( int p ) { __spread ( p ); if ( t [ p ]. ch [ 0 ]) { output ( t [ p ]. ch [ 0 ]); } if ( p && p != 1 && p != 2 ) { cout << t [ p ]. val << \" \" ; } if ( t [ p ]. ch [ 1 ]) { output ( t [ p ]. ch [ 1 ]); } } } splay_tree ; } int n , m ; int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); cin >> n >> m ; SPLAY :: splay_tree . init (); for ( int i = 1 ; i <= n ; i ++ ) { SPLAY :: splay_tree . insert ( i ); } for ( int i = 1 ; i <= m ; i ++ ) { int l , r ; cin >> l >> r ; SPLAY :: splay_tree . reverse ( l , r ); } SPLAY :: splay_tree . output ( SPLAY :: splay_tree . root ); return 0 ; } \u5409\u5982\u4e00\u7ebf\u6bb5\u6811 \u00b6 \u533a\u95f4\u53d6\u6700\u5c0f\u503c+\u7ef4\u62a4\u533a\u95f4\u6700\u5927\u503c\u4e0e\u548c \u00b6 \uff08\u4eceOI-wiki\u6284\u7684\uff09 \u533a\u95f4\u53d6 min\uff0c\u610f\u5473\u7740\u53ea\u5bf9\u90a3\u4e9b\u5927\u4e8e \\(t\\) \u7684\u6570\u6709\u66f4\u6539\u3002\u56e0\u6b64\u8fd9\u4e2a\u64cd\u4f5c\u7684\u5bf9\u8c61\u4e0d\u518d\u662f\u6574\u4e2a\u533a\u95f4\uff0c\u800c\u662f\u201c\u8fd9\u4e2a\u533a\u95f4\u4e2d\u5927\u4e8e \\(t\\) \u7684\u6570\u201d\u3002\u4e8e\u662f\u6211\u4eec\u53ef\u4ee5\u6709\u8fd9\u6837\u7684\u601d\u8def\uff1a\u6bcf\u4e2a\u7ed3\u70b9\u7ef4\u62a4\u8be5\u533a\u95f4\u7684\u6700\u5927\u503c \\(Max\\) \u3001\u6b21\u5927\u503c \\(Se\\) \u3001\u533a\u95f4\u548c \\(Sum\\) \u4ee5\u53ca\u6700\u5927\u503c\u7684\u4e2a\u6570 \\(Cnt\\) \u3002\u63a5\u4e0b\u6765\u6211\u4eec\u8003\u8651\u533a\u95f4\u5bf9 \\(t\\) \u53d6 \\(\\min\\) \u7684\u64cd\u4f5c\u3002 \u5982\u679c \\(Max\\le t\\) \uff0c\u663e\u7136\u8fd9\u4e2a \\(t\\) \u662f\u6ca1\u6709\u610f\u4e49\u7684\uff0c\u76f4\u63a5\u8fd4\u56de\uff1b \u5982\u679c \\(Se<t\\le Max\\) \uff0c\u90a3\u4e48\u8fd9\u4e2a \\(t\\) \u5c31\u80fd\u66f4\u65b0\u5f53\u524d\u533a\u95f4\u4e2d\u7684\u6700\u5927\u503c\u3002\u4e8e\u662f\u6211\u4eec\u8ba9\u533a\u95f4\u548c\u52a0\u4e0a \\(Cnt(t-Max)\\) \uff0c\u7136\u540e\u66f4\u65b0 \\(Max\\) \u4e3a \\(t\\) \uff0c\u5e76\u6253\u4e00\u4e2a\u6807\u8bb0\u3002 \u5982\u679c \\(t\\le Se\\) \uff0c\u90a3\u4e48\u8fd9\u65f6\u4f60\u53d1\u73b0\u4f60\u4e0d\u77e5\u9053\u6709\u591a\u5c11\u4e2a\u6570\u6d89\u53ca\u5230\u66f4\u65b0\u7684\u95ee\u9898\u3002\u4e8e\u662f\u6211\u4eec\u7684\u7b56\u7565\u5c31\u662f\uff0c\u66b4\u529b\u9012\u5f52\u5411\u4e0b\u64cd\u4f5c\u3002\u7136\u540e\u4e0a\u4f20\u4fe1\u606f\u3002 \u8fd9\u4e2a\u7b97\u6cd5\u7684\u590d\u6742\u5ea6\u5982\u4f55\uff1f\u4f7f\u7528\u52bf\u80fd\u5206\u6790\u6cd5\u53ef\u4ee5\u5f97\u5230\u590d\u6742\u5ea6\u662f \\(O(m\\log n)\\) \u7684\u3002\u5177\u4f53\u5206\u6790\u8fc7\u7a0b\u89c1\u8bba\u6587\u3002 5306_Gorgeous_Sequence3_myfastio 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <cstdlib> #include <algorithm> #include <string> #include <vector> #include <map> #include <unordered_map> #include <set> #include <unordered_set> #include <queue> using namespace std ; typedef long long ll ; int T ; namespace JSJSEgmentTree { using Ty = ll ; const int MAXN = 2e6 + 10 ; const Ty Inf = 1e17 ; int n , m ; Ty a [ MAXN ]; struct JSJSegmentTree { struct Node { Ty maxval , sec_maxval , maxval_cnt ; Ty mintag ; Ty sum ; int l , r ; } t [ MAXN * 4 ]; void __upd ( int p ) { t [ p ]. sum = t [ p * 2 ]. sum + t [ p * 2 + 1 ]. sum ; if ( t [ p * 2 ]. maxval == t [ p * 2 + 1 ]. maxval ) { t [ p ]. maxval = t [ p * 2 ]. maxval ; t [ p ]. maxval_cnt = t [ p * 2 ]. maxval_cnt + t [ p * 2 + 1 ]. maxval_cnt ; t [ p ]. sec_maxval = max ( t [ p * 2 ]. sec_maxval , t [ p * 2 + 1 ]. sec_maxval ); } else if ( t [ p * 2 ]. maxval > t [ p * 2 + 1 ]. maxval ) { t [ p ]. maxval = t [ p * 2 ]. maxval ; t [ p ]. maxval_cnt = t [ p * 2 ]. maxval_cnt ; t [ p ]. sec_maxval = max ( t [ p * 2 ]. sec_maxval , t [ p * 2 + 1 ]. maxval ); } else { t [ p ]. maxval = t [ p * 2 + 1 ]. maxval ; t [ p ]. maxval_cnt = t [ p * 2 + 1 ]. maxval_cnt ; t [ p ]. sec_maxval = max ( t [ p * 2 ]. maxval , t [ p * 2 + 1 ]. sec_maxval ); } } void __tagpush ( int p , Ty mintag ) { if ( t [ p ]. maxval > mintag ) { t [ p ]. sum += ( mintag - t [ p ]. maxval ) * t [ p ]. maxval_cnt ; t [ p ]. maxval = mintag ; // mintag < t[p].maxval <= t[p].mintag always hold t [ p ]. mintag = mintag ; } } void __tagdown ( int p ) { if ( t [ p ]. mintag != Inf ) { __tagpush ( p * 2 , t [ p ]. mintag ); __tagpush ( p * 2 + 1 , t [ p ]. mintag ); t [ p ]. mintag = Inf ; } } void build_tree ( int p , int l , int r ) { t [ p ]. mintag = Inf ; t [ p ]. l = l ; t [ p ]. r = r ; if ( l == r ) { t [ p ]. sum = t [ p ]. maxval = a [ l ]; t [ p ]. maxval_cnt = 1 ; t [ p ]. sec_maxval = - Inf ; return ; } int mid = ( l + r ) / 2 ; build_tree ( p * 2 , l , mid ); build_tree ( p * 2 + 1 , mid + 1 , r ); __upd ( p ); } void modify_min ( int p , int L , int R , Ty val ) { if ( t [ p ]. maxval > val ) { if ( L <= t [ p ]. l && t [ p ]. r <= R && t [ p ]. sec_maxval < val ) { return __tagpush ( p , val ); } __tagdown ( p ); int mid = ( t [ p ]. l + t [ p ]. r ) / 2 ; if ( L <= mid ) { modify_min ( p * 2 , L , R , val ); } if ( mid < R ) { modify_min ( p * 2 + 1 , L , R , val ); } __upd ( p ); } } Ty query_sum ( int p , int L , int R ) { if ( L <= t [ p ]. l && t [ p ]. r <= R ) { return t [ p ]. sum ; } __tagdown ( p ); int mid = ( t [ p ]. l + t [ p ]. r ) / 2 ; Ty ans = 0 ; if ( L <= mid ) { ans += query_sum ( p * 2 , L , R ); } if ( mid < R ) { ans += query_sum ( p * 2 + 1 , L , R ); } return ans ; } Ty query_max ( int p , int L , int R ) { if ( L <= t [ p ]. l && t [ p ]. r <= R ) { return t [ p ]. maxval ; } __tagdown ( p ); int mid = ( t [ p ]. l + t [ p ]. r ) / 2 ; Ty ans =- Inf ; if ( L <= mid ) { ans = max ( query_max ( p * 2 , L , R ), ans ); } if ( mid < R ) { ans = max ( query_max ( p * 2 + 1 , L , R ), ans ); } return ans ; } }; } using namespace JSJSEgmentTree ; JSJSegmentTree t ; namespace Fast_IO { char __nc () { static char buf [ 1000000 ], * p = buf , * q = buf ; return p == q && ( q = ( p = buf ) + fread ( buf , 1 , 1000000 , stdin ), p == q ) ? EOF : * p ++ ; } template < typename T > inline void read ( T & x ) { char c ; int sgn = 1 ; x = 0 ; c = __nc (); while ( c > '9' || c < '0' ) { if ( c == '-' ) sgn = -1 ; c = __nc (); } while ( c <= '9' && c >= '0' ) { x = ( x << 3 ) + ( x << 1 ) + ( c - '0' ); c = __nc (); } x *= sgn ; } template < typename T > inline void print ( T x ) { if ( x < 0 ) { putchar ( '-' ); x = - x ; } if ( x > 9 ) { print ( x / 10 ); } putchar ( x % 10 + '0' ); } } // namespace Fast_IO using namespace Fast_IO ; int main () { read ( T ); for ( int _ = 1 ; _ <= T ; _ ++ ) { read ( n ); read ( m ); for ( int i = 1 ; i <= n ; i ++ ) { read ( a [ i ]); } t . build_tree ( 1 , 1 , n ); for ( int i = 1 ; i <= m ; i ++ ) { int op ; read ( op ); if ( op == 0 ) { int l , r ; ll val ; read ( l ); read ( r ); read ( val ); t . modify_min ( 1 , l , r , val ); } else if ( op == 1 ) //get maxval { int l , r ; read ( l ); read ( r ); printf ( \"%lld \\n \" , t . query_max ( 1 , l , r )); } else //op==2: get sum { int l , r ; read ( l ); read ( r ); printf ( \"%lld \\n \" , t . query_sum ( 1 , l , r )); } } } return 0 ; } BZOJ4695 \u6700\u5047\u5973\u9009\u624b \u00b6 \u957f\u5ea6\u4e3a \\(n\\) \u7684\u5e8f\u5217\uff0c\u652f\u6301\u533a\u95f4\u52a0 \\(x\\) /\u533a\u95f4\u5bf9 \\(x\\) \u53d6 \\(\\max\\) /\u533a\u95f4\u5bf9 \\(x\\) \u53d6 \\(\\min\\) /\u6c42\u533a\u95f4\u548c/\u6c42\u533a\u95f4\u6700\u5927\u503c/\u6c42\u533a\u95f4\u6700\u5c0f\u503c\u3002 \\(N,M\\le 5\\times 10^5,|A_i|\\le 10^8\\) \u3002 \u540c\u6837\u7684\u65b9\u6cd5\uff0c\u6211\u4eec\u7ef4\u62a4\u6700\u5927\u3001\u6b21\u5927\u3001\u6700\u5927\u4e2a\u6570\u3001\u6700\u5c0f\u3001\u6b21\u5c0f\u3001\u6700\u5c0f\u4e2a\u6570\u3001\u533a\u95f4\u548c\u3002\u9664\u4e86\u8fd9\u4e9b\u4fe1\u606f\uff0c\u6211\u4eec\u8fd8\u9700\u8981\u7ef4\u62a4\u533a\u95f4 \\(\\max\\) \u3001\u533a\u95f4 \\(\\min\\) \u3001\u533a\u95f4\u52a0\u7684\u6807\u8bb0\u3002\u76f8\u6bd4\u4e0a\u4e00\u9053\u9898\uff0c\u8fd9\u5c31\u6d89\u53ca\u5230\u6807\u8bb0\u4e0b\u4f20\u7684\u987a\u5e8f\u95ee\u9898\u4e86\u3002\u6211\u4eec\u91c7\u7528\u8fd9\u6837\u7684\u7b56\u7565\uff1a \u6211\u4eec\u8ba4\u4e3a\u533a\u95f4\u52a0\u7684\u6807\u8bb0\u662f\u6700\u4f18\u5148\u7684\uff0c\u5176\u4f59\u4e24\u79cd\u6807\u8bb0\u5730\u4f4d\u5e73\u7b49\u3002 \u5bf9\u4e00\u4e2a\u7ed3\u70b9\u52a0\u4e0a\u4e00\u4e2a \\(v\\) \u6807\u8bb0\uff0c\u9664\u4e86\u7528 \\(v\\) \u66f4\u65b0\u536b\u661f\u4fe1\u606f\u548c\u5f53\u524d\u7ed3\u70b9\u7684\u533a\u95f4\u52a0\u6807\u8bb0\u5916\uff0c\u6211\u4eec\u7528\u8fd9\u4e2a v \u66f4\u65b0\u533a\u95f4 \\(\\max\\) \u548c\u533a\u95f4 \\(\\min\\) \u7684\u6807\u8bb0\u3002 \u5bf9\u4e00\u4e2a\u7ed3\u70b9\u53d6 \\(v\\) \u7684 \\(\\min\\) \uff08\u8fd9\u91cc\u5ffd\u7565\u66b4\u641c\u7684\u8fc7\u7a0b\uff0c\u5047\u5b9a\u6807\u8bb0\u6ee1\u8db3\u6dfb\u52a0\u7684\u6761\u4ef6\uff09\uff0c\u9664\u4e86\u66f4\u65b0\u536b\u661f\u4fe1\u606f\uff0c\u6211\u4eec\u8981\u4e0e\u533a\u95f4 \\(\\max\\) \u7684\u6807\u8bb0\u505a\u6bd4\u8f83\u3002\u5982\u679c \\(v\\) \u5c0f\u4e8e\u533a\u95f4 \\(\\max\\) \u7684\u6807\u8bb0\uff0c\u5219\u6240\u6709\u7684\u6570\u6700\u540e\u90fd\u4f1a\u53d8\u6210 v\uff0c\u90a3\u4e48\u628a\u533a\u95f4 \\(\\max\\) \u7684\u6807\u8bb0\u4e5f\u53d8\u6210 \\(v\\) \u3002\u5426\u5219\u4e0d\u7ba1\u3002 \u533a\u95f4\u53d6 v \u7684 \\(\\max\\) \u540c\u7406\u3002 \u53e6\u5916\uff0cBZOJ \u8fd9\u9053\u9898\u5361\u5e38\u2026\u2026\u591a\u6570\u7ec4\u7ebf\u6bb5\u6811\u7684\u5e38\u6570\u6bd4\u7ed3\u6784\u4f53\u7ebf\u6bb5\u6811\u7684\u5e38\u6570\u5927\u2026\u2026\u5728\u7ef4\u62a4\u4fe1\u606f\u7684\u65f6\u4faf\uff0c\u5f53\u53ea\u6709\u4e00\u4e24\u4e2a\u6570\u7684\u65f6\u4faf\u53ef\u80fd\u53d1\u751f\u6570\u96c6\u91cd\u5408\uff0c\u6bd4\u5982\u4e00\u4e2a\u6570\u65e2\u662f\u6700\u5927\u503c\u53c8\u662f\u6b21\u5c0f\u503c\u3002\u8fd9\u79cd\u8981\u7279\u5224\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <cstdlib> #include <algorithm> #include <string> #include <vector> #include <map> #include <unordered_map> #include <set> #include <unordered_set> #include <queue> using namespace std ; typedef long long ll ; namespace JSJSEgmentTree { using Ty = ll ; const int MAXN = 5e5 + 10 ; const Ty Inf = 1e17 ; int n , m ; Ty a [ MAXN ]; struct JSJSegmentTree { struct Node { Ty maxval , sec_maxval , maxval_cnt ; Ty minval , sec_minval , minval_cnt ; Ty mintag , maxtag , addtag ; Ty sum ; int l , r ; } t [ MAXN * 4 ]; void __upd ( int p ) { t [ p ]. sum = t [ p * 2 ]. sum + t [ p * 2 + 1 ]. sum ; if ( t [ p * 2 ]. maxval == t [ p * 2 + 1 ]. maxval ) { t [ p ]. maxval = t [ p * 2 ]. maxval ; t [ p ]. maxval_cnt = t [ p * 2 ]. maxval_cnt + t [ p * 2 + 1 ]. maxval_cnt ; t [ p ]. sec_maxval = max ( t [ p * 2 ]. sec_maxval , t [ p * 2 + 1 ]. sec_maxval ); } else if ( t [ p * 2 ]. maxval > t [ p * 2 + 1 ]. maxval ) { t [ p ]. maxval = t [ p * 2 ]. maxval ; t [ p ]. maxval_cnt = t [ p * 2 ]. maxval_cnt ; t [ p ]. sec_maxval = max ( t [ p * 2 ]. sec_maxval , t [ p * 2 + 1 ]. maxval ); } else { t [ p ]. maxval = t [ p * 2 + 1 ]. maxval ; t [ p ]. maxval_cnt = t [ p * 2 + 1 ]. maxval_cnt ; t [ p ]. sec_maxval = max ( t [ p * 2 ]. maxval , t [ p * 2 + 1 ]. sec_maxval ); } if ( t [ p * 2 ]. minval == t [ p * 2 + 1 ]. minval ) { t [ p ]. minval = t [ p * 2 ]. minval ; t [ p ]. minval_cnt = t [ p * 2 ]. minval_cnt + t [ p * 2 + 1 ]. minval_cnt ; t [ p ]. sec_minval = min ( t [ p * 2 ]. sec_minval , t [ p * 2 + 1 ]. sec_minval ); } else if ( t [ p * 2 ]. minval < t [ p * 2 + 1 ]. minval ) { t [ p ]. minval = t [ p * 2 ]. minval ; t [ p ]. minval_cnt = t [ p * 2 ]. minval_cnt ; t [ p ]. sec_minval = min ( t [ p * 2 ]. sec_minval , t [ p * 2 + 1 ]. minval ); } else { t [ p ]. minval = t [ p * 2 + 1 ]. minval ; t [ p ]. minval_cnt = t [ p * 2 + 1 ]. minval_cnt ; t [ p ]. sec_minval = min ( t [ p * 2 ]. minval , t [ p * 2 + 1 ]. sec_minval ); } } void __tagpush_add ( int p , Ty val ) { t [ p ]. sum += ( t [ p ]. r - t [ p ]. l + 1l l ) * val ; t [ p ]. maxval += val ; t [ p ]. minval += val ; if ( t [ p ]. sec_maxval != - Inf ) t [ p ]. sec_maxval += val ; if ( t [ p ]. sec_minval != Inf ) t [ p ]. sec_minval += val ; if ( t [ p ]. maxtag != - Inf ) t [ p ]. maxtag += val ; if ( t [ p ]. mintag != Inf ) t [ p ]. mintag += val ; t [ p ]. addtag += val ; } void __tagpush_min ( int p , Ty val ) { if ( t [ p ]. maxval > val ) { t [ p ]. sum += ( 1l l * val - t [ p ]. maxval ) * t [ p ]. maxval_cnt ; if ( t [ p ]. sec_minval == t [ p ]. maxval ) t [ p ]. sec_minval = val ; if ( t [ p ]. minval == t [ p ]. maxval ) t [ p ]. minval = val ; if ( t [ p ]. maxtag > val ) t [ p ]. maxtag = val ; t [ p ]. maxval = t [ p ]. mintag = val ; } } void __tagpush_max ( int p , Ty val ) { if ( t [ p ]. minval < val ) { t [ p ]. sum += ( 1l l * val - t [ p ]. minval ) * t [ p ]. minval_cnt ; if ( t [ p ]. sec_maxval == t [ p ]. minval ) t [ p ]. sec_maxval = val ; if ( t [ p ]. maxval == t [ p ]. minval ) t [ p ]. maxval = val ; if ( t [ p ]. mintag < val ) t [ p ]. mintag = val ; t [ p ]. minval = t [ p ]. maxtag = val ; } } void __tagdown ( int p ) { if ( t [ p ]. addtag ) { __tagpush_add ( p * 2 , t [ p ]. addtag ); __tagpush_add ( p * 2 + 1 , t [ p ]. addtag ); t [ p ]. addtag = 0 ; } if ( t [ p ]. maxtag !=- Inf ) { __tagpush_max ( p * 2 , t [ p ]. maxtag ); __tagpush_max ( p * 2 + 1 , t [ p ]. maxtag ); t [ p ]. maxtag =- Inf ; } if ( t [ p ]. mintag != Inf ) { __tagpush_min ( p * 2 , t [ p ]. mintag ); __tagpush_min ( p * 2 + 1 , t [ p ]. mintag ); t [ p ]. mintag = Inf ; } } void build_tree ( int p , int l , int r ) { t [ p ]. mintag = Inf ; t [ p ]. maxtag =- Inf ; t [ p ]. l = l ; t [ p ]. r = r ; if ( l == r ) { t [ p ]. sum = t [ p ]. maxval = t [ p ]. minval = a [ l ]; t [ p ]. maxval_cnt = t [ p ]. minval_cnt = 1 ; t [ p ]. sec_maxval = - Inf ; t [ p ]. sec_minval = Inf ; return ; } int mid = ( l + r ) / 2 ; build_tree ( p * 2 , l , mid ); build_tree ( p * 2 + 1 , mid + 1 , r ); __upd ( p ); } void modify_add ( int p , int L , int R , Ty val ) { if ( L <= t [ p ]. l && t [ p ]. r <= R ) { return __tagpush_add ( p , val ); } __tagdown ( p ); int mid = ( t [ p ]. l + t [ p ]. r ) / 2 ; if ( L <= mid ) modify_add ( p * 2 , L , R , val ); if ( mid < R ) modify_add ( p * 2 + 1 , L , R , val ); __upd ( p ); } void modify_min ( int p , int L , int R , Ty val ) { if ( t [ p ]. maxval > val ) { if ( L <= t [ p ]. l && t [ p ]. r <= R && t [ p ]. sec_maxval < val ) { return __tagpush_min ( p , val ); } __tagdown ( p ); int mid = ( t [ p ]. l + t [ p ]. r ) / 2 ; if ( L <= mid ) { modify_min ( p * 2 , L , R , val ); } if ( mid < R ) { modify_min ( p * 2 + 1 , L , R , val ); } __upd ( p ); } } void modify_max ( int p , int L , int R , Ty val ) { if ( t [ p ]. minval < val ) { if ( L <= t [ p ]. l && t [ p ]. r <= R && t [ p ]. sec_minval > val ) { return __tagpush_max ( p , val ); } __tagdown ( p ); int mid = ( t [ p ]. l + t [ p ]. r ) / 2 ; if ( L <= mid ) { modify_max ( p * 2 , L , R , val ); } if ( mid < R ) { modify_max ( p * 2 + 1 , L , R , val ); } __upd ( p ); } } Ty query_sum ( int p , int L , int R ) { if ( L <= t [ p ]. l && t [ p ]. r <= R ) { return t [ p ]. sum ; } __tagdown ( p ); int mid = ( t [ p ]. l + t [ p ]. r ) / 2 ; Ty ans = 0 ; if ( L <= mid ) { ans += query_sum ( p * 2 , L , R ); } if ( mid < R ) { ans += query_sum ( p * 2 + 1 , L , R ); } return ans ; } Ty query_max ( int p , int L , int R ) { if ( L <= t [ p ]. l && t [ p ]. r <= R ) { return t [ p ]. maxval ; } __tagdown ( p ); int mid = ( t [ p ]. l + t [ p ]. r ) / 2 ; Ty ans =- Inf ; if ( L <= mid ) { ans = max ( query_max ( p * 2 , L , R ), ans ); } if ( mid < R ) { ans = max ( query_max ( p * 2 + 1 , L , R ), ans ); } return ans ; } Ty query_min ( int p , int L , int R ) { if ( L <= t [ p ]. l && t [ p ]. r <= R ) { return t [ p ]. minval ; } __tagdown ( p ); int mid = ( t [ p ]. l + t [ p ]. r ) / 2 ; Ty ans = Inf ; if ( L <= mid ) { ans = min ( query_min ( p * 2 , L , R ), ans ); } if ( mid < R ) { ans = min ( query_min ( p * 2 + 1 , L , R ), ans ); } return ans ; } }; } using namespace JSJSEgmentTree ; JSJSegmentTree t ; namespace Fast_IO { char __nc () { static char buf [ 1000000 ], * p = buf , * q = buf ; return p == q && ( q = ( p = buf ) + fread ( buf , 1 , 1000000 , stdin ), p == q ) ? EOF : * p ++ ; } template < typename T > inline void read ( T & x ) { char c ; int sgn = 1 ; x = 0 ; c = __nc (); while ( c > '9' || c < '0' ) { if ( c == '-' ) sgn = -1 ; c = __nc (); } while ( c <= '9' && c >= '0' ) { x = ( x << 3 ) + ( x << 1 ) + ( c - '0' ); c = __nc (); } x *= sgn ; } template < typename T > inline void print ( T x ) { if ( x < 0 ) { putchar ( '-' ); x = - x ; } if ( x > 9 ) { print ( x / 10 ); } putchar ( x % 10 + '0' ); } } // namespace Fast_IO using namespace Fast_IO ; int main () { read ( n ); for ( int i = 1 ; i <= n ; i ++ ) read ( a [ i ]); t . build_tree ( 1 , 1 , n ); read ( m ); for ( int i = 1 ; i <= m ; i ++ ) { int op , l , r ; ll val ; read ( op ), read ( l ), read ( r ); if ( op <= 3 ) read ( val ); if ( op == 1 ) //add { t . modify_add ( 1 , l , r , val ); } else if ( op == 2 ) //max { t . modify_max ( 1 , l , r , val ); } else if ( op == 3 ) //min { t . modify_min ( 1 , l , r , val ); } else if ( op == 4 ) //sum { print ( t . query_sum ( 1 , l , r )); putchar ( '\\n' ); } else if ( op == 5 ) //max { print ( t . query_max ( 1 , l , r )); putchar ( '\\n' ); } else //min { print ( t . query_min ( 1 , l , r )); putchar ( '\\n' ); } } return 0 ; } \u56fe\u8bba \u00b6 \u90bb\u63a5\u8868 \u00b6 \u56fe\u8bba\u7b97\u6cd5\u7684\u5b9e\u73b0\u4e3b\u8981\u4f9d\u8d56\u4e8e\u6b64\u3002\u9664\u975e\u6709\u7279\u6b8a\u8bf4\u660e\uff0c\u5426\u5219\u5927\u90e8\u5206\u56fe\u8bba\u7b97\u6cd5\u7684\u9ed8\u8ba4\u8f93\u5165\u63a5\u53e3\u5305\u62ec\u6b64\u6bb5\u6240\u8ff0\u7684\u90bb\u63a5\u8868\u3002 \ud83d\udd25\uff1atotal\u3001head\u3002 \u5e26\u8fb9\u6743\u7684\u7248\u672c \u00b6 Funs || Methods Reliance Time Complexity Inputs Outputs Description adde 1 x,y,w: x\u5230y\u7684\u8fb9\u6743\u4e3aw\u7684\u8fb9 edge, total \u6dfb\u52a0\u8fb9 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 namespace Edges { typedef int Ty ; const int N = 1e4 + 10 , M = 2e5 + 100 ; //public int n , m ; //n,m: \u70b9\u3001\u8fb9\u6570\u91cf struct E { int from , to , inext ; Ty w ; } edge [ M ]; int head [ N ], total ; void adde ( int x , int y , Ty w ) { edge [ ++ total ]. from = x ; edge [ total ]. to = y ; edge [ total ]. w = w ; edge [ total ]. inext = head [ x ]; head [ x ] = total ; } } using namespace Edges ; LCA \u00b6 \u500d\u589e\u6cd5\u3002 \ud83d\udd25\uff1atotal\uff0chead\uff0cd\uff0cdist 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 #include <iostream> #include <cmath> // #include <memory.h> #include <queue> #include <cstdio> #include <cstring> using namespace std ; typedef long long ll ; int T ; namespace Edges { const int N = 20010 ; typedef long long Ty ; //public struct E { int to , inext ; Ty w ; } edge [ N * 2 ]; int head [ N ], total ; int n , m ; void adde ( int x , int y , Ty w ) { edge [ ++ total ]. to = y ; edge [ total ]. w = w ; edge [ total ]. inext = head [ x ]; head [ x ] = total ; } } using namespace Edges ; namespace LCA { //local int d [ N ], f [ N ][ 20 ], dist [ N ], t ; //d:\u6df1\u5ea6 //f\uff1a\u500d\u589e\u6570\u7ec4 //dist:\u6839\u5230\u7b2cx\u4e2a\u70b9\u7684\u5e26\u6743\u8ddd\u79bb //t: t=log2(n)+1 //bfs\u5e76\u9884\u5904\u7406\u500d\u589e\u6570\u7ec4f void bfs ( int rt = 1 ) //init { t = int ( log2 ( n )) + 1 ; queue < int > q ; q . push ( rt ); d [ rt ] = 1 ; while ( q . size ()) { int x = q . front (); q . pop (); for ( int i = head [ x ]; i ; i = edge [ i ]. inext ) { int y = edge [ i ]. to ; if ( d [ y ] == 0 ) { d [ y ] = d [ x ] + 1 ; dist [ y ] = dist [ x ] + edge [ i ]. w ; f [ y ][ 0 ] = x ; for ( int k = 1 ; k <= t ; k ++ ) { f [ y ][ k ] = f [ f [ y ][ k -1 ]][ k -1 ]; } q . push ( y ); } } } } //\u901a\u8fc7\u500d\u589e\u6570\u7ec4\u5f97\u5230LCA int lca ( int x , int y ) { if ( d [ x ] > d [ y ]) swap ( x , y ); //d[x]<=d[y] //make d[y]=d[x] for ( int k = t ; k >= 0 ; k -- ) { if ( d [ f [ y ][ k ]] >= d [ x ]) y = f [ y ][ k ]; } if ( x == y ) return x ; //then climb together for ( int k = t ; k >= 0 ; k -- ) { if ( f [ x ][ k ] != f [ y ][ k ]) x = f [ x ][ k ], y = f [ y ][ k ]; } return f [ x ][ 0 ]; } } using namespace LCA ; int indegree [ N ]; int main () { ios :: sync_with_stdio ( false ); // cin>>T; scanf ( \"%d\" , & T ); while ( T -- ) { total = 0 ; memset ( head , 0 , sizeof ( head )); memset ( d , 0 , sizeof ( d )); memset ( dist , 0 , sizeof ( dist )); memset ( f , 0 , sizeof ( f )); memset ( indegree , 0 , sizeof ( indegree )); // cin>>n>>m; scanf ( \"%d\" , & n ); // scanf(\"%d\",&m); t = int ( log2 ( n )) + 1 ; // t=(int)(log(n*1.0)/log(2.0))+1; for ( int i = 1 ; i <= n -1 ; i ++ ) { int x , y ; // cin>>x>>y; scanf ( \"%d\" , & x ); scanf ( \"%d\" , & y ); adde ( x , y , 0 ); indegree [ y ] ++ ; } for ( int i = 1 ; i <= n ; i ++ ) { if ( indegree [ i ] == 0 ) { bfs ( i ); break ; } } int x , y ; scanf ( \"%d\" , & x ); scanf ( \"%d\" , & y ); printf ( \"%d \\n \" , lca ( x , y )); } return 0 ; } \u6811\u94fe\u5256\u5206HLD \u00b6 \u901a\u8fc7\u4e24\u6b21dfs\u5b9e\u73b0\uff0c\u7b2c\u4e00\u6b21dfs\u6807\u8bb0\u91cd\u5b50\u8282\u70b9\u3001\u6df1\u5ea6\u3001\u7236\u4eb2\u3001\u5b50\u6811\u5927\u5c0f\uff1b\u7b2c\u4e8c\u6b21\u6807\u8bb0dfn\uff08\u91cd\u8fb9\u4f18\u5148\u904d\u5386\uff09\u3001rnk\uff08dfn\u7684\u53cd\u51fd\u6570\uff0c\u4e5f\u5373\u901a\u8fc7dfn\u83b7\u5f97\u8282\u70b9\u539f\u6807\u53f7\uff09\u3001top\uff08\u6240\u5728\u91cd\u94fe\u94fe\u9876\uff09\u3002\u4f7f\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u94fe\u4e0adfn\u4fe1\u606f\u3002 \u8def\u5f84\u4e0a\u7ef4\u62a4 \uff1a\u6bcf\u6b21\u9009\u62e9\u6df1\u5ea6\u8f83\u5927\u7684\u94fe\u5f80\u4e0a\u8df3\uff0c\u76f4\u5230\u4e24\u70b9\u5728\u540c\u4e00\u6761\u94fe\u4e0a\u3002 \u5b50\u6811\u7ef4\u62a4 \uff1a\u8bb0\u5f55\u6240\u5728\u5b50\u6811\u8fde\u7eed\u533a\u95f4\u672b\u7aef\u7684\u7ed3\u70b9\uff08\u4ed6\u55b5\u7684\u4e0d\u662f\u76f4\u63a5\u8bb0\u5f55\u5b50\u6811dfn\u6700\u5927\u662f\u8c01\u5c31\u884c\u4e86\u5417\uff08\uff09\uff09 LCA \uff1a\u548c\u8def\u5f84\u4e0a\u7ef4\u62a4\u76f8\u4f3c\uff0c\u4e0d\u8fc7\u5f53\u4e24\u4e2a\u8282\u70b9\u8df3\u5230\u540c\u4e00\u94fe\u65f6\uff0c\u53d6\u6df1\u5ea6\u8f83\u5c0f\u8282\u70b9\u4f5c\u4e3aLCA \ud83e\udd2b\uff1adfs\u3001dfs2\u3001init_wdfn\u3001build_tree \ud83d\udd25\uff1atotal\u3001head\u3001dfn\u3001node\u3001w_dfn \u6ce8\u610f\u7ebf\u6bb5\u6811\u4e0a\u53ef\u80fd\u4e5f\u8981\u6e05\u7a7a\uff081~4n\uff0c\u6211\u4e0d\u77e5\u9053\u662f\u4ec0\u4e48\u60c5\u51b5\u2026\u2026\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 //HLD [P2590 [ZJOI2008\\]\u6811\u7684\u7edf\u8ba1] #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <cstdlib> #include <algorithm> #include <string> #include <vector> #include <map> #include <unordered_map> #include <set> #include <unordered_set> #include <queue> using namespace std ; typedef long long ll ; namespace Edges { typedef int Ty ; const int N = 5e5 + 10 , M = 2e5 + 10 ; //public int n , m ; //n,m: \u70b9\u3001\u8fb9\u6570\u91cf struct E { int to , inext ; // Ty w; } edge [ M ]; int head [ N ], total ; void adde ( int x , int y ) { edge [ ++ total ]. to = y ; // edge[total].w = w; edge [ total ]. inext = head [ x ]; head [ x ] = total ; } } using namespace Edges ; namespace SEGMENT_TREE { typedef int Ty ; const Ty INF = 1145141919 ; Ty w_dfn [ N ]; //w_dfn: \u7531dfn\u5230\u6743\u503c\u7684\u6620\u5c04 //\u7ef4\u62a4dfn\u7528\u7684\u7ebf\u6bb5\u6811 struct Segment_tree { struct SEGMENT_TREE { Ty maxval , sum ; int l , r ; } t [ N * 4 ]; //\u7ef4\u62a4\u5173\u4e8edfn\u7684\u4fe1\u606f void __upd ( int p ) { t [ p ]. maxval = max ( t [ p * 2 ]. maxval , t [ p * 2 + 1 ]. maxval ); t [ p ]. sum = t [ p * 2 ]. sum + t [ p * 2 + 1 ]. sum ; } //\u5efa\u6811 void build_tree ( int p , int l , int r ) { t [ p ]. l = l ; t [ p ]. r = r ; if ( l == r ) { t [ p ]. maxval = t [ p ]. sum = w_dfn [ l ]; return ; } int mid = ( l + r ) / 2 ; build_tree ( p * 2 , l , mid ); build_tree ( p * 2 + 1 , mid + 1 , r ); __upd ( p ); } //\u5355\u70b9\u4fee\u6539 void singlechange ( int p , int pos , Ty val ) { if ( t [ p ]. l == t [ p ]. r ) { w_dfn [ t [ p ]. l ] = val ; t [ p ]. maxval = t [ p ]. sum = w_dfn [ t [ p ]. l ]; return ; } int mid = ( t [ p ]. l + t [ p ]. r ) / 2 ; if ( pos <= mid ) singlechange ( p * 2 , pos , val ); else singlechange ( p * 2 + 1 , pos , val ); __upd ( p ); } //\u8be2\u95ee\u533a\u95f4\u6700\u5927\u503c int ask_maxval ( int p , int l , int r ) { if ( l <= t [ p ]. l && t [ p ]. r <= r ) { return t [ p ]. maxval ; } Ty ans =- INF ; int mid = ( t [ p ]. l + t [ p ]. r ) / 2 ; if ( l <= mid ) ans = max ( ans , ask_maxval ( p * 2 , l , r )); if ( mid < r ) ans = max ( ans , ask_maxval ( p * 2 + 1 , l , r )); return ans ; } //\u8be2\u95ee\u533a\u95f4\u548c int ask_sum ( int p , int l , int r ) { if ( l <= t [ p ]. l && t [ p ]. r <= r ) { return t [ p ]. sum ; } Ty ans = 0 ; int mid = ( t [ p ]. l + t [ p ]. r ) / 2 ; if ( l <= mid ) ans += ask_sum ( p * 2 , l , r ); if ( mid < r ) ans += ask_sum ( p * 2 + 1 , l , r ); return ans ; } } tree ; } using namespace SEGMENT_TREE ; namespace HLD { typedef int Ty ; struct NODE { int fa , hson , top , size , depth , dfn ; Ty w ; } node [ N ]; //local int dfn = 0 ; //dfn:\u7b2c\u4e8c\u6b21dfs\u9700\u8981\u4f7f\u7528dfn //\u7b2c\u4e00\u6b21dfs\uff1a\u6807\u8bb0\u91cd\u5b50\u8282\u70b9\u3001\u6df1\u5ea6\u3001\u7236\u4eb2\u3001\u5b50\u6811\u5927\u5c0f void dfs ( int x , int depth ) { node [ x ]. depth = depth ; node [ x ]. hson = 0 ; node [ x ]. size = 1 ; for ( int e = head [ x ]; e ; e = edge [ e ]. inext ) { int y = edge [ e ]. to ; if ( y == node [ x ]. fa ) continue ; node [ y ]. fa = x ; dfs ( y , depth + 1 ); node [ x ]. size += node [ y ]. size ; if ( node [ x ]. hson == 0 || node [ node [ x ]. hson ]. size < node [ y ]. size ) { node [ x ]. hson = y ; } } } //\u7b2c\u4e8c\u6b21dfs\uff1a\u6807\u8bb0dfn\uff08\u91cd\u8fb9\u4f18\u5148\u904d\u5386\uff09\u3001rnk\uff08dfn\u7684\u53cd\u51fd\u6570\uff0c\u4e5f\u5373\u901a\u8fc7dfn\u83b7\u5f97\u8282\u70b9\u539f\u6807\u53f7\uff09\u3001top\uff08\u6240\u5728\u91cd\u94fe\u94fe\u9876\uff09 void dfs2 ( int x , int top ) { node [ x ]. top = top ; dfn ++ ; node [ x ]. dfn = dfn ; if ( node [ x ]. hson ) { dfs2 ( node [ x ]. hson , top ); for ( int e = head [ x ]; e ; e = edge [ e ]. inext ) { int y = edge [ e ]. to ; if ( y == node [ x ]. fa || y == node [ x ]. hson ) continue ; dfs2 ( y , y ); } } } //\u53d6\u5f97x\u3001y\u8def\u5f84\u4e0a\u7684\u548c Ty get_sum ( int x , int y ) { Ty ans = 0 ; while ( node [ x ]. top != node [ y ]. top ) { if ( node [ node [ x ]. top ]. depth < node [ node [ y ]. top ]. depth ) { swap ( x , y ); } ans += tree . ask_sum ( 1 , node [ node [ x ]. top ]. dfn , node [ x ]. dfn ); x = node [ node [ x ]. top ]. fa ; } if ( node [ x ]. depth < node [ y ]. depth ) swap ( x , y ); ans += tree . ask_sum ( 1 , node [ y ]. dfn , node [ x ]. dfn ); return ans ; } //\u53d6\u5f97x\u3001y\u8def\u5f84\u4e0a\u7684\u6700\u5927\u503c Ty get_max ( int x , int y ) { Ty ans =- INF ; while ( node [ x ]. top != node [ y ]. top ) { if ( node [ node [ x ]. top ]. depth < node [ node [ y ]. top ]. depth ) swap ( x , y ); ans = max ( tree . ask_maxval ( 1 , node [ node [ x ]. top ]. dfn , node [ x ]. dfn ), ans ); //!! x = node [ node [ x ]. top ]. fa ; } if ( node [ x ]. depth < node [ y ]. depth ) swap ( x , y ); ans = max ( tree . ask_maxval ( 1 , node [ y ]. dfn , node [ x ]. dfn ), ans ); return ans ; } //\u9884\u5b58\u70b9\u6743\u5230dfn\u6743\u4e0a void init_wdfn () { for ( int i = 1 ; i <= n ; i ++ ) { w_dfn [ node [ i ]. dfn ] = node [ i ]. w ; } // tree.build_tree(1,1,n); } } using namespace HLD ; int main () { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n -1 ; i ++ ) { int x , y ; scanf ( \"%d%d\" , & x , & y ); adde ( x , y ); adde ( y , x ); } dfs ( 1 , 1 ); dfs2 ( 1 , 1 ); for ( int i = 1 ; i <= n ; i ++ ) { //Ty scanf ( \"%d\" , & node [ i ]. w ); } init_wdfn (); tree . build_tree ( 1 , 1 , n ); int q ; scanf ( \"%d\" , & q ); for ( int i = 1 ; i <= q ; i ++ ) { char op [ 10 ]; int x , y ; scanf ( \"%s\" , op ); scanf ( \"%d%d\" , & x , & y ); if ( op [ 0 ] == 'C' ) { tree . singlechange ( 1 , node [ x ]. dfn , y ); } else if ( op [ 1 ] == 'M' ) { // cout<<get_max(x,y)<<endl; printf ( \"%d \\n \" , get_max ( x , y )); } else if ( op [ 1 ] == 'S' ) { // cout<<get_sum(x,y)<<endl; printf ( \"%d \\n \" , get_sum ( x , y )); } } return 0 ; } \u65e0\u5411\u56feEDCC \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 //\u65e0\u5411\u56fe\u7684\u6865\u3001\u8fb9\u53cc\u8054\u901a\u5206\u91cf // POJ 3694 #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <cstdlib> #include <algorithm> #include <string> #include <vector> #include <map> #include <unordered_map> #include <set> #include <unordered_set> #include <queue> using namespace std ; typedef long long ll ; namespace Edges { typedef int Ty ; const int N = 1e5 + 10 , M = 4e5 + 10 ; //public int n , m ; //n,m: \u70b9\u3001\u8fb9\u6570\u91cf struct E { int to , inext ; bool is_cut ; // is_cut: \u662f\u5426\u4e3a\u5272\u8fb9 } edge [ M ]; int head [ N ], total = 1 ; //\u26a0\ufe0f\u6ce8\u610f\uff1a\u4ece1\u5f00\u59cb\u8ba1\u6570\uff01 //\u65b0\u56fe\u4e2d\u7684\u8fb9 E edge_c [ M ]; int head_c [ N ], total_c ; void adde ( int x , int y ) { edge [ ++ total ]. to = y ; edge [ total ]. is_cut = false ; edge [ total ]. inext = head [ x ]; head [ x ] = total ; } void adde_c ( int x , int y ) { edge_c [ ++ total_c ]. to = y ; edge_c [ total_c ]. inext = head_c [ x ]; head_c [ x ] = total_c ; } } using namespace Edges ; namespace EDCC { struct Node { int dfn , low , c ; //dfn,low\uff1adfn\u548c\u6700\u5c0f\u53ef\u8ffd\u6eaf\u503c //c: \u70b9\u6240\u5c5e\u7684edcc\u7f16\u53f7 } node [ N ]; //public int dfn = 0 ; int edcc_cnt = 0 ; //dfn:\u5168\u5c40dfn\u7f16\u53f7\u8ba1\u6570\u5668 //edcc_cnt\uff1a\u5728\u7b2c\u4e8c\u6b21dfs\u8fc7\u7a0b\u4e2d\u8ba1\u7b97edcc\u6570\u76ee //tarjan\u6c42\u51fa\u6865. in_edge:\u8fdb\u5165\u70b9x\u7684\u8fb9\u5728\u539f\u56fe\u4e2d\u7684\u4e0b\u6807\uff0c\u7528\u4e8e\u963b\u6b62\u904d\u5386\u53cd\u5411\u8fb9 void tarjan ( int x , int in_edge ) { node [ x ]. dfn = node [ x ]. low =++ dfn ; for ( int e = head [ x ]; e ; e = edge [ e ]. inext ) { int y = edge [ e ]. to ; if ( ! node [ y ]. dfn ) { tarjan ( y , e ); node [ x ]. low = min ( node [ x ]. low , node [ y ]. low ); if ( node [ y ]. low > node [ x ]. dfn ) { edge [ e ]. is_cut = edge [ e ^ 1 ]. is_cut = true ; } } else if ( e != ( in_edge ^ 1 )) { node [ x ]. low = min ( node [ x ]. low , node [ y ]. dfn ); } } } //\u5bf9\u6240\u6709\u70b9\u505a\u4e00\u6b21tarjan void tarjan_forall ( int n = n ) { for ( int i = 1 ; i <= n ; i ++ ) { if ( node [ i ]. dfn == 0 ) { tarjan ( i , -1 ); } } } //int edcc_cnt=0; //dfs\u6807\u8bb0\u5404\u70b9\u6240\u5c5e\u7684edcc void __edcc_dfs ( int x ) { node [ x ]. c = edcc_cnt ; for ( int e = head [ x ]; e ; e = edge [ e ]. inext ) { if ( edge [ e ]. is_cut ) continue ; int y = edge [ e ]. to ; if ( node [ y ]. c ) continue ; __edcc_dfs ( y ); } } //dfs\u6807\u8bb0\u5404\u70b9\u6240\u5c5e\u7684edcc\uff08\u5bf9\u6240\u6709\u70b9\uff09 void edcc_forall ( int n = n ) { for ( int i = 1 ; i <= n ; i ++ ) { if ( node [ i ]. c ) { edcc_cnt ++ ; __edcc_dfs ( i ); } } } //edcc\u7f29\u70b9\uff1a\u5728\u65b0\u56fe\u4e0a\u5efa\u56fe void edcc_suodian () { for ( int i = 2 ; i <= total ; i ++ ) //\u6ce8\u610f\u8fd9\u91cc\u904d\u5386\u7684\u662f\u8fb9 { int x = edge [ i ]. to , y = edge [ i ^ 1 ]. to ; if ( node [ x ]. c == node [ y ]. c ) continue ; adde_c ( node [ x ]. c , node [ y ]. c ); } } } using namespace EDCC ; int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ), cout . tie ( 0 ); return 0 ; } \u65e0\u5411\u56feVDCC\uff08\u70b9\u53cc\uff09 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <cstdlib> #include <algorithm> #include <string> #include <vector> #include <map> #include <unordered_map> #include <set> #include <unordered_set> #include <queue> using namespace std ; typedef long long ll ; namespace Edges { typedef int Ty ; const int N = 6e5 + 10 , M = 6e5 + 10 ; //public int n , m ; //n,m: \u70b9\u3001\u8fb9\u6570\u91cf struct E { int to , inext ; } edge [ M ]; int head [ N ], total = 1 ; //\u26a0\ufe0f\u6ce8\u610f\uff1a\u4ece1\u5f00\u59cb\u8ba1\u6570\uff01 //\u65b0\u56fe\u4e2d\u7684\u8fb9 E edge_c [ M ]; int head_c [ N ], total_c ; void adde ( int x , int y ) { edge [ ++ total ]. to = y ; edge [ total ]. inext = head [ x ]; head [ x ] = total ; } void adde_c ( int x , int y ) { edge_c [ ++ total_c ]. to = y ; edge_c [ total_c ]. inext = head_c [ x ]; head_c [ x ] = total_c ; } } using namespace Edges ; namespace VDCC { struct Node { int dfn , low ; int c ; bool is_cutpoint ; //dfn,low\uff1adfn\u548c\u6700\u5c0f\u53ef\u8ffd\u6eaf\u503c //is_cutpoint: \u662f\u5272\u70b9\u6807\u8bb0 //c: \u4e00\u822c\u70b9\u6240\u5c5e\u7684edcc\u7f16\u53f7 / \u5272\u70b9\u5728\u65b0\u56fe\u4e2d\u6240\u5c5e\u7684\u70b9\u7684\u7f16\u53f7 } node [ N ]; //public int dfn = 0 ; int vdcc_cnt = 0 ; vector < int > vdcc [ N ]; //dfn:\u5168\u5c40dfn\u7f16\u53f7\u8ba1\u6570\u5668 //vdcc_cnt\uff1a\u5728\u7b2c\u4e8c\u6b21dfs\u8fc7\u7a0b\u4e2d\u8ba1\u7b97vdcc\u6570\u76ee //vdcc: \u4fdd\u5b58\u6240\u6709vdcc\u4e2d\u70b9\u7684\u7f16\u53f7\u7684vector\u96c6\u5408 //local int st [ N ], st_p ; //st:\u6808 //tarjan\u6c42\u51fa\u5272\u70b9\uff0c\u540c\u65f6\u987a\u5e26\u6c42\u51favdcc void tarjan ( int x , int root ) //for vdcc { node [ x ]. dfn = node [ x ]. low =++ dfn ; if ( x == root && head [ x ] == 0 ) { vdcc [ ++ vdcc_cnt ]. push_back ( x ); // single[x]=true; return ; } st [ ++ st_p ] = x ; int flag = 0 ; for ( int e = head [ x ]; e ; e = edge [ e ]. inext ) { int y = edge [ e ]. to ; if ( ! node [ y ]. dfn ) { tarjan ( y , root ); node [ x ]. low = min ( node [ x ]. low , node [ y ]. low ); if ( node [ x ]. dfn <= node [ y ]. low ) { flag ++ ; if ( x != root || flag > 1 ) node [ x ]. is_cutpoint = true ; vdcc_cnt ++ ; int z ; do { z = st [ st_p -- ]; vdcc [ vdcc_cnt ]. push_back ( z ); } while ( z != y ); vdcc [ vdcc_cnt ]. push_back ( x ); } } else node [ x ]. low = min ( node [ x ]. low , node [ y ]. dfn ); } } //\u4e00\u822c\u7684\u6c42\u5272\u70b9\uff0c\u4e0d\u6c42\u51favdcc void tarjan2 ( int x , int root , int in_edge = -1 ) { node [ x ]. dfn = node [ x ]. low =++ dfn ; int flag = 0 ; for ( int e = head [ x ]; e ; e = edge [ e ]. inext ) { int y = edge [ e ]. to ; if ( ! node [ y ]. dfn ) { tarjan2 ( y , root , in_edge ); node [ x ]. low = min ( node [ x ]. low , node [ y ]. low ); if ( node [ x ]. dfn <= node [ y ]. low ) { flag ++ ; if (( x == root && flag >= 2 ) || ( x != root )) { node [ x ]. is_cutpoint = true ; } } } else if ( e != ( in_edge ^ 1 )) //\u6216\u8005\u76f4\u63a5else node [ x ]. low = min ( node [ x ]. low , node [ y ]. dfn ); } } //tarjan\u6c42\u51fa\u5272\u70b9\u548cvdcc\uff08\u5bf9\u6240\u6709\u70b9\uff09 void tarjan_forall ( int n = n ) { for ( int i = 1 ; i <= n ; i ++ ) { if ( node [ i ]. dfn == 0 ) { tarjan ( i , i ); } } } //vdcc\u7f29\u70b9\uff1a\u5728\u65b0\u56fe\u4e0a\u5efa\u56fe //\u4e3a\u6240\u6709\u5272\u70b9\u7684c\u65b0\u5206\u914d\u7f16\u53f7(vdcc_cnt+1 ~ vdcc_cnt*2)\uff0c\u5176\u4ed6\u70b9\u7684c\u4fdd\u5b58\u81ea\u5df1\u6240\u5c5e\u7684vdcc\u7f16\u53f7 //\u65b0\u7684\u56fe\u4f1a\u662f\u4ee5\u5404\u4e2a\u5272\u70b9\u4e3a\u4e2d\u5fc3\u8fde\u63a5\u5230\u5404\u4e2avdcc\u7f29\u6210\u7684\u70b9\uff08\u7528vdcc\u7f16\u53f7\u8868\u793a\uff09\u7684\u56fe\u3002 void vdcc_suodian () { int num = vdcc_cnt ; for ( int i = 1 ; i <= n ; i ++ ) { if ( node [ i ]. is_cutpoint ) node [ i ]. c =++ num ; // node[i].new_id } total_c = 1 ; for ( int i = 1 ; i <= vdcc_cnt ; i ++ ) { for ( auto x : vdcc [ i ]) { if ( node [ x ]. is_cutpoint ) { adde_c ( i , node [ x ]. c ); adde_c ( node [ x ]. c , i ); } else node [ x ]. c = i ; } } } } using namespace VDCC ; int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ), cout . tie ( 0 ); return 0 ; } \u6709\u5411\u56fetarjan\u7f29\u70b9 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 // LUOGU 3387 \u7f29\u70b9 (\u6709\u5411\u56fetarjan\u7f29\u70b9) #include <iostream> #include <vector> #include <queue> using namespace std ; const int N = 2e4 + 5 , M = 2e5 + 5 ; struct E { int to , inext ; } edge [ M ], edge_c [ M ]; int head [ N ], total ; int head_c [ N ], total_c ; int n , m , a [ N ]; //vector<int> scc[N]; int st [ N ], st_p , cnt , c [ N ], sum [ N ]; //stack, scc_count, scc_sum int dfn [ N ], low [ N ], dfn_cnt ; bool inst [ N ]; //in stack int in_degree [ N ]; void adde ( int x , int y ) { edge [ ++ total ]. to = y ; edge [ total ]. inext = head [ x ]; head [ x ] = total ; } void adde_c ( int x , int y ) { edge_c [ ++ total_c ]. to = y ; edge_c [ total_c ]. inext = head_c [ x ]; head_c [ x ] = total_c ; } void tarjan ( int x ) { dfn [ x ] = low [ x ] =++ dfn_cnt ; st [ ++ st_p ] = x ; inst [ x ] = true ; for ( int e = head [ x ]; e ; e = edge [ e ]. inext ) { int y = edge [ e ]. to ; if ( ! dfn [ y ]) { tarjan ( y ); low [ x ] = min ( low [ x ], low [ y ]); } else if ( inst [ y ]) low [ x ] = min ( low [ x ], dfn [ y ]); } if ( dfn [ x ] == low [ x ]) //scc judge success { cnt ++ ; //scc_cnt++ while ( st [ st_p ] != x ) { int y = st [ st_p ]; //scc[cnt].emplace_back(y); inst [ y ] = false ; c [ y ] = cnt ; sum [ cnt ] += a [ y ]; st_p -- ; } //x //scc[cnt].emplace_back(x); inst [ x ] = false ; c [ x ] = cnt ; sum [ cnt ] += a [ x ]; st_p -- ; } } void creat_new_graph () { for ( int i = 1 ; i <= n ; i ++ ) { for ( int e = head [ i ]; e ; e = edge [ e ]. inext ) { int y = edge [ e ]. to ; if ( c [ i ] == c [ y ]) continue ; //same scc else { adde_c ( c [ i ], c [ y ]); in_degree [ c [ y ]] ++ ; } } } } int f [ N ], ans = 0 ; void topo () //for Graph2 { queue < int > q ; for ( int i = 1 ; i <= cnt ; i ++ ) { if ( ! in_degree [ i ]) { q . push ( i ); f [ i ] = sum [ i ]; ans = max ( ans , f [ i ]); } } while ( q . size ()) { int x = q . front (); q . pop (); for ( int e = head_c [ x ]; e ; e = edge_c [ e ]. inext ) { int y = edge_c [ e ]. to ; f [ y ] = max ( f [ y ], f [ x ] + sum [ y ]); ans = max ( ans , f [ y ]); in_degree [ y ] -- ; if ( ! in_degree [ y ]) q . push ( y ); } } } int main () { ios :: sync_with_stdio ( false ); cin >> n >> m ; for ( int i = 1 ; i <= n ; i ++ ) cin >> a [ i ]; for ( int i = 1 ; i <= m ; i ++ ) { int x , y ; cin >> x >> y ; adde ( x , y ); } for ( int i = 1 ; i <= n ; i ++ ) { if ( ! dfn [ i ]) tarjan ( i ); } creat_new_graph (); topo (); cout << ans << endl ; return 0 ; } \u5308\u7259\u5229 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <cstdlib> #include <algorithm> #include <string> #include <vector> #include <map> #include <unordered_map> #include <set> #include <unordered_set> #include <queue> using namespace std ; typedef long long ll ; namespace Edges { typedef int Ty ; const int N = 1e4 + 10 , M = 2e5 + 100 ; //public int n , m ; //n,m: \u70b9\u3001\u8fb9\u6570\u91cf struct E { int to , inext ; Ty w ; } edge [ M ]; int head [ N ], total ; void adde ( int x , int y , Ty w ) { edge [ ++ total ]. to = y ; edge [ total ]. w = w ; edge [ total ]. inext = head [ x ]; head [ x ] = total ; } } using namespace Edges ; namespace Hungary { const int N = 1e4 + 10 ; //local bool vis [ N ]; int match [ N ]; //vis:\u5308\u7259\u5229\u7b97\u6cd5\u4e2d\u7528\u4e8e\u6807\u8bb0\u8282\u70b9\u662f\u5426\u8d70\u8fc7 //match:\u4e8c\u5206\u56fe\u7684\u53f3\u4fa7\u8282\u70b9\u5bf9\u5e94\u7684\u5de6\u4fa7\u8282\u70b9\u5339\u914d\u8c01\uff08\u5982\u679c\u662f\u5728\u540c\u4e00\u5f20\u56fe\u4e2d\u4f7f\u7528\u7edf\u4e00\u7f16\u53f7\u5219\u4e5f\u53ef\u4fdd\u5b58\u5de6\u4fa7\u70b9\u7684\u5339\u914d\u60c5\u51b5\uff09 //\u9644\u6ce8\uff1a\u539f\u7b97\u6cd5\u91cc\u9762\u5de6\u4fa7\u8282\u70b9\u7684\u7f16\u53f7\u548c\u53f3\u4fa7\u8282\u70b9\u7684\u6807\u53f7\u662f\u53ef\u4ee5\u76f8\u540c\u7684\u3002\u6362\u53e5\u8bdd\u8bf4\u628a\u5de6\u4fa7\u548c\u53f3\u4fa7\u770b\u6210\u4e86\u4e24\u4e2a\u4e0d\u540c\u7684\u56fe //\u5bfb\u627e\u4e00\u6761\u589e\u5e7f\u8def\u5e76\u6539\u53d8\u5339\u914d bool __dfs ( int x ) { for ( int e = head [ x ]; e ; e = edge [ e ]. inext ) { int y = edge [ e ]. to ; if ( ! vis [ y ]) { vis [ y ] = true ; if ( ! match [ y ] || __dfs ( match [ y ])) { match [ y ] = x ; // match[x]=y; //\u80fd\u4f7f\u7528\u5f53\u4e14\u4ec5\u5f53\u6240\u6709\u70b9\u7f16\u53f7\u552f\u4e00\uff08\u5de6\u4fa7\u70b9\u4e0e\u53f3\u4fa7\u70b9\u7f16\u53f7\u4e0d\u4f1a\u76f8\u540c\uff09 return true ; } } } return false ; } void __clear_visit ( int n = n ) { for ( int i = 1 ; i <= n * 2 ; i ++ ) vis [ i ] = false ; //\u6ce8\u610f\u8981\u6539\u8303\u56f4 } //\u4e8c\u5206\u56fe\u5339\u914d int do_Hungary () { int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) //\u4e8c\u5206\u56fe\u7684\u4e00\u4fa7\uff08\u5de6\u4fa7\uff09\u6709n\u4e2a\u70b9\uff0c\u7f16\u53f7\u4e3a1~n { __clear_visit (); if ( __dfs ( i )) ans ++ ; } return ans ; } } using namespace Hungary ; int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ), cout . tie ( 0 ); return 0 ; } KM-BFS \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 //2021\u725b\u5ba2\u591a\u68215 J Jewels #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <cstdlib> #include <algorithm> #include <string> #include <vector> #include <map> #include <unordered_map> #include <set> #include <unordered_set> #include <queue> using namespace std ; // typedef long long ll; using ll = long long ; // const int N=2e5+10; namespace KMKM { using Ty = ll ; const int N = 310 ; const Ty Inf = 1e18 ; int n ; Ty g [ N ][ N ]; //g\uff1a\u5e26\u6743\u5de6\u53f3\u5b50\u56fe\uff08\u4e8c\u5206\u56fe\uff0c\u5de6\u53f3\u4e24\u8fb9\u4e0b\u6807\u90fd\u662f\u4ece1\u5f00\u59cb\uff09 int matchx [ N ], matchy [ N ]; int pre [ N ]; bool visx [ N ], visy [ N ]; Ty lx [ N ], ly [ N ]; Ty slack [ N ]; //match:\u5339\u914d\u70b9\u6620\u5c04\u96c6\u5408\u3002\u8981\u6c42\u4e00\u5b9a\u662f\u5b8c\u7f8e\u5339\u914d\uff0c\u56e0\u6b64\u4e00\u5b9a\u5b58\u5728 //slack\uff1a\u677e\u5f1b\u6570\u7ec4\uff0c\u8bb0\u5f55\u4e86delta\u503c //lx\u3001ly\uff1a\u6807\u53f7\u6570\u7ec4\uff0c\u53c2\u89c1\u674e\u715c\u4e1c\u84dd\u4e66 //\u521d\u59cb\u5316\u6807\u53f7\u6570\u7ec4\u7684\u503c void __init ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { lx [ i ] = ly [ i ] = 0 ; for ( int j = 1 ; j <= n ; j ++ ) { lx [ i ] = max ( lx [ i ], g [ i ][ j ]); } } } bool __check ( int y , queue < int > & q ) { visy [ y ] = 1 ; if ( matchy [ y ] != 0 ) { q . push ( matchy [ y ]); visx [ matchy [ y ]] = 1 ; return false ; } while ( y != 0 ) { matchy [ y ] = pre [ y ]; swap ( y , matchx [ pre [ y ]]); } return true ; } void __bfs ( int u ) { queue < int > q ; q . push ( u ); visx [ u ] = 1 ; while ( true ) { while ( q . size ()) { int x = q . front (); q . pop (); for ( int y = 1 ; y <= n ; y ++ ) { if ( visy [ y ] == 0 ) { Ty delta = lx [ x ] + ly [ y ] - g [ x ][ y ]; if ( slack [ y ] >= delta ) { pre [ y ] = x ; if ( delta ) { slack [ y ] = delta ; } else if ( __check ( y , q )) { return ; } } } } } Ty delta = Inf ; for ( int j = 1 ; j <= n ; j ++ ) { if ( visy [ j ] == 0 ) { delta = min ( delta , slack [ j ]); } } for ( int j = 1 ; j <= n ; j ++ ) { if ( visx [ j ]) { lx [ j ] -= delta ; } if ( visy [ j ]) { ly [ j ] += delta ; } else { slack [ j ] -= delta ; } } for ( int j = 1 ; j <= n ; j ++ ) { if ( visy [ j ] == 0 && slack [ j ] == 0 && __check ( j , q )) { return ; } } } } //\u6700\u5927\u6743\u503c\u5339\u914d\u3002\u8981\u60f3\u53d6\u5f97\u6700\u5c0f\u6743\u503c\u5339\u914d\uff0c\u5c06\u6743\u503c\u53d6\u53cd\u3002 void KM () { __init ( n ); for ( int i = 1 ; i <= n ; i ++ ) { fill ( slack , slack + 1 + n , Inf ); fill ( visx , visx + 1 + n , 0 ); fill ( visy , visy + 1 + n , 0 ); __bfs ( i ); } } } using namespace KMKM ; struct J { ll x , y , z , v ; } a [ 310 ]; ll gw ( ll t , int i ) { return a [ i ]. v * a [ i ]. v * t * t + a [ i ]. z * 2 * a [ i ]. v * t ; } int main () { scanf ( \"%d\" , & n ); ll ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { // cin>>a[i].x scanf ( \"%lld\" , & a [ i ]. x ); scanf ( \"%lld\" , & a [ i ]. y ); scanf ( \"%lld\" , & a [ i ]. z ); scanf ( \"%lld\" , & a [ i ]. v ); ans += a [ i ]. x * a [ i ]. x ; ans += a [ i ]. y * a [ i ]. y ; ans += a [ i ]. z * a [ i ]. z ; } for ( int i = 1 ; i <= n ; i ++ ) //t=0~n-1 { ll t = i - 1 ; for ( int j = 1 ; j <= n ; j ++ ) { ll val = gw ( t , j ); g [ i ][ j ] =- val ; } } KM (); for ( int i = 1 ; i <= n ; i ++ ) { ans +=- g [ i ][ matchx [ i ]]; } printf ( \"%lld \\n \" , ans ); return 0 ; } \u7f51\u7edc\u6d41\uff1aEdmonds Karp \u00b6 Funs || Methods Reliance Time Complexity Inputs Outputs Description __bfs n Edges\uff1a\u6b8b\u5dee\u7f51\u7edc\u3002S\u3001T\uff1a\u6e90\u70b9\u548c\u6c47\u70b9 incf\uff1a\u6e90\u70b9\u5230\u70b9x\u7684\u6700\u5c0f\u5269\u4f59\u5bb9\u91cf\u3002pre\uff1a\u70b9x\u7684\u524d\u9a71\u6570\u7ec4 \u904d\u5386\u6b8b\u5dee\u7f51\u7edc\u627e\u5230\u6700\u957f\u589e\u5e7f\u8def\u3002 __update m Edges\uff1a\u6b8b\u5dee\u7f51\u7edc\uff1bincf\u3001pre\uff1a\u540c\u4e0a\u8f93\u51fa\u3002S\u3001T\uff1a\u6e90\u70b9\u548c\u6c47\u70b9 \u8fd4\u56de\u6b64\u6b21\u66f4\u65b0\u7684\u6d41\u91cf\u5927\u5c0f\u3002Edges\uff1a\u66f4\u65b0\u540e\u7684\u6b8b\u5dee\u7f51\u7edc\u3002 \u4ece\u6c47\u70b9t\u5f00\u59cb\u5012\u7740\u66f4\u65b0\u589e\u5e7f\u8def\u4ee5\u53ca\u53cd\u5411\u8fb9\u7684\u5269\u4f59\u5bb9\u91cf get_maxflow nm^2 s,t\uff1a\u6e90\u70b9\u4e0e\u6c47\u70b9 \u6700\u5927\u6d41\u5927\u5c0f \u53d6\u5f97\u6700\u5927\u6d41 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 //\u7f51\u7edc\u6d41\uff1aEdmonds_Karp\u7b97\u6cd5 #include <iostream> #include <queue> #include <memory.h> using namespace std ; typedef long long ll ; namespace Edges { typedef ll Ty ; const int N = 1e4 + 10 , M = 2e5 + 100 ; //public int n , m ; //n,m: \u70b9\u3001\u8fb9\u6570\u91cf //\u6b8b\u5dee\u7f51\u7edc\u7684\u8fb9 struct E { int from , to , inext ; Ty w ; } edge [ M ]; int head [ N ], total ; void adde ( int x , int y , Ty w ) { edge [ ++ total ]. from = x ; edge [ total ]. to = y ; edge [ total ]. w = w ; edge [ total ]. inext = head [ x ]; head [ x ] = total ; } } using namespace Edges ; namespace Edmonds_Karp { typedef ll Ty ; const int N = 1e4 + 10 ; //N\uff1a\u70b9\u4e2a\u6570 const Ty Inf = 1e18 ; //Inf\uff1a\u6d41\u91cf\u65e0\u7a77\u5927\u503c //public int S , T ; //S,T:\u6e90\u70b9\u548c\u6c47\u70b9 //local bool v [ N ]; //v:__bfs\u65f6\u4f7f\u7528\u7684\u6807\u8bb0\u904d\u5386\u6570\u7ec4 int pre [ N ]; //pre\uff1a__bfs\u65f6\u4f7f\u7528\u7684\u8bb0\u5f55\u74f6\u9888\u8def\u524d\u9a71\u8f6c\u79fb\u65b9\u5411\u7684\u6570\u7ec4 Ty incf [ N ]; //incf\uff1a\u589e\u5e7f\u8def //\u904d\u5386\u6b8b\u5dee\u7f51\u7edc\u627e\u5230\u6700\u957f\u589e\u5e7f\u8def\u3002\u4ece\u6c47\u70b9t\u5f00\u59cb\u5012\u7740\u66f4\u65b0\u589e\u5e7f\u8def\u4ee5\u53ca\u53cd\u5411\u8fb9\u7684\u5269\u4f59\u5bb9\u91cf bool __bfs ( int s , int t ) { memset ( v , 0 , sizeof ( v )); queue < int > q ; q . push ( s ); v [ s ] = 1 ; incf [ s ] = Inf ; while ( q . size ()) { int x = q . front (); q . pop (); for ( int e = head [ x ]; e ; e = edge [ e ]. inext ) { int y = edge [ e ]. to ; if ( edge [ e ]. w && ! v [ y ]) { incf [ y ] = min ( incf [ x ], edge [ e ]. w ); pre [ y ] = e ; v [ y ] = 1 ; q . push ( y ); if ( y == t ) return true ; } } } return false ; } //\u4ece\u6c47\u70b9t\u5f00\u59cb\u5012\u7740\u66f4\u65b0\u589e\u5e7f\u8def\u4ee5\u53ca\u53cd\u5411\u8fb9\u7684\u5269\u4f59\u5bb9\u91cf Ty __update ( int s , int t ) { int x = t ; while ( x != s ) { int e = pre [ x ]; edge [ e ]. w -= incf [ t ]; if ( e % 2 ) edge [ e + 1 ]. w += incf [ t ]; else edge [ e - 1 ]. w -= incf [ t ]; x = edge [ e ]. from ; } return incf [ t ]; } //\u53d6\u5f97\u6700\u5927\u6d41 Ty get_maxflow ( int s = S , int t = T ) { Ty maxflow = 0 ; while ( __bfs ( s , t )) maxflow += __update ( s , t ); return maxflow ; } } using namespace Edmonds_Karp ; int main () { ios :: sync_with_stdio ( false ); cin >> n >> m >> S >> T ; for ( int i = 1 ; i <= m ; i ++ ) { int x , y , w ; cin >> x >> y >> w ; adde ( x , y , w ); adde ( y , x , 0 ); } ll maxflow = get_maxflow ( S , T ); cout << maxflow << endl ; return 0 ; } \u7f51\u7edc\u6d41\uff1aDinic \u00b6 \u522b\u5fd8\u4e86\u52a0\u8fb9\u7684\u65f6\u5019\u52a0\u53cd\u5411\u8fb9\u3002 10.12\u66f4\u65b0\uff1a\u73b0\u5728\u66f4\u65b0\u4e3a\u5e26\u5f53\u524d\u5f27\u4f18\u5316\u7684\u7248\u672c\uff0c\u53c2\u89c1\u6ce8\u91ca \uff08\u2b50\uff1a\u8fd9\u73a9\u610f\u8fd8\u6709\u4e2a\u6700\u77ed\u5f27\u4f18\u5316\u6211\u6ca1\u6574\u2026\u2026\u6709\u5f85\u8fdb\u4e00\u6b65\u6539\u8fdb\uff09 Funs || Methods Reliance Time Complexity Inputs Outputs Description __bfs n Edges\uff1a\u6b8b\u5dee\u7f51\u7edc\u3002S\u3001T\uff1a\u6e90\u70b9\u548c\u6c47\u70b9 d\uff1a\u5c42\u6b21\u6570\u7ec4 \u53d6\u5f97\u5f53\u524d\u6b8b\u5dee\u7f51\u7edc\u4eces\u89e6\u53d1\u7684\u5404\u4e2a\u70b9\u7684\u5c42\u6b21 __dinic n Edges\uff1a\u6b8b\u5dee\u7f51\u7edc\u3002d\uff1a\u5c42\u6b21\u6570\u7ec4\u3002S\u3001T\uff1a\u6e90\u70b9\u548c\u6c47\u70b9\u3002 \u8fd4\u56de\u6b64\u6b21\u66f4\u65b0\u7684\u6d41\u91cf\u5927\u5c0f\u3002Edges\uff1a\u66f4\u65b0\u540e\u7684\u6b8b\u5dee\u7f51\u7edc\u3002 \u5728\u5206\u5c42\u56fe\u4e0a\u66f4\u65b0\u6700\u5927\u6d41\u5e76\u8fd4\u56de\u66f4\u65b0\u503c get_maxflow (n^2)*m s,t\uff1a\u6e90\u70b9\u4e0e\u6c47\u70b9\u3002 \u6700\u5927\u6d41\u5927\u5c0f \u53d6\u5f97\u6700\u5927\u6d41 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 //\u7f51\u7edc\u6d41\uff1aDinic\u7b97\u6cd5 //\u5e26\u5f53\u524d\u5f27\u4f18\u5316 #include <iostream> #include <memory.h> #include <queue> using namespace std ; typedef long long ll ; namespace Edges { typedef ll Ty ; const int N = 1e4 + 10 , M = 2e5 + 100 ; //public int n , m ; //n,m: \u70b9\u3001\u8fb9\u6570\u91cf //\u6b8b\u5dee\u7f51\u7edc\u7684\u8fb9 struct E { int from , to , inext ; Ty w ; } edge [ M ]; int head [ N ], total ; void adde ( int x , int y , Ty w ) { edge [ ++ total ]. from = x ; edge [ total ]. to = y ; edge [ total ]. w = w ; edge [ total ]. inext = head [ x ]; head [ x ] = total ; } } using namespace Edges ; namespace Dinic { typedef ll Ty ; const int N = 1e4 + 10 ; //N\uff1a\u70b9\u4e2a\u6570 const Ty Inf = 1e18 ; //Inf\uff1a\u6d41\u91cf\u65e0\u7a77\u5927\u503c //public int S , T ; //S,T:\u6e90\u70b9\u548c\u6c47\u70b9 //local int d [ N ]; //d\uff1a\u5c42\u6b21\u6570\u7ec4 int cur_head [ N ]; // cur_head: \u7528\u4e8e\u5f53\u524d\u5f27\u4f18\u5316 //\u53d6\u5f97\u5f53\u524d\u6b8b\u5dee\u7f51\u7edc\u4eces\u89e6\u53d1\u7684\u5404\u4e2a\u70b9\u7684\u5c42\u6b21 bool __bfs ( int s , int t ) { memset ( d , 0 , sizeof ( d )); memcpy ( cur_head , head , sizeof ( head )); //\u7528\u4e8e\u5f53\u524d\u5f27\u4f18\u5316 queue < int > q ; q . push ( s ); d [ s ] = 1 ; while ( q . size ()) { int x = q . front (); q . pop (); // for (int e = head[x]; e; e = edge[e].inext) for ( int e = cur_head [ x ]; e ; e = edge [ e ]. inext ) { cur_head [ x ] = e ; //\u66f4\u65b0\u5f53\u524d\u5f27\uff1a\u539f\u56e0\u662f\u4e00\u6761\u8fb9\u589e\u5e7f\u4e00\u6b21\u540e\u5c31\u4e0d\u4f1a\u518d\u6b21\u589e\u5e7f\u4e86\uff0c\u6240\u4ee5\u4e0b\u6b21\u589e\u5e7f\u65f6\u4e0d\u9700\u8981\u518d\u8003\u8651\u8fd9\u6761\u8fb9\u3002 int y = edge [ e ]. to ; if ( edge [ e ]. w && ! d [ y ]) { q . push ( y ); d [ y ] = d [ x ] + 1 ; if ( y == t ) return true ; } } } return false ; } // \u5728\u5206\u5c42\u56fe\u4e0a\u66f4\u65b0\u6700\u5927\u6d41\u5e76\u8fd4\u56de\u66f4\u65b0\u503c Ty __dinic ( int x , Ty flow , int t ) { if ( x == t ) return flow ; Ty rest = flow , delta ; for ( int e = head [ x ]; e ; e = edge [ e ]. inext ) { if ( rest == 0 ) return flow ; //!!! if ( edge [ e ]. w && d [ edge [ e ]. to ] == d [ x ] + 1 ) { delta = __dinic ( edge [ e ]. to , min ( edge [ e ]. w , rest ), t ); if ( ! delta ) d [ edge [ e ]. to ] = 0 ; //pruning edge [ e ]. w -= delta ; if ( e % 2 ) edge [ e + 1 ]. w += delta ; else edge [ e - 1 ]. w += delta ; //+= ? rest -= delta ; } } return flow - rest ; } // \u53d6\u5f97\u6700\u5927\u6d41 Ty get_maxflow ( int s = S , int t = T ) { Ty maxflow = 0 ; while ( __bfs ( s , t )) { Ty flow ; while ( flow = __dinic ( s , Inf , t )) maxflow += flow ; } return maxflow ; } } using namespace Dinic ; int main () { ios :: sync_with_stdio ( false ); cin >> n >> m >> S >> T ; for ( int i = 1 ; i <= m ; i ++ ) { int x , y , w ; cin >> x >> y >> w ; adde ( x , y , w ); //\u522b\u5fd8\u4e86\u52a0\u53cd\u5411\u8fb9\uff01 adde ( y , x , 0 ); } ll maxflow = get_maxflow ( S , T ); cout << maxflow << endl ; return 0 ; } \u7f51\u7edc\u6d41\uff1aHLPP\uff08\u6700\u9ad8\u6807\u53f7\u9884\u6d41\u63a8\u8fdb\u7b97\u6cd5\uff09 \u00b6 \u26a0\ufe0f\u6ce8\u610f\uff1a\u9700\u8981\u5c06total\u521d\u59cb\u5316\u4e3a1\u3002 Funs || Methods Reliance Time Complexity Inputs Outputs Description __ht_init n Edges\uff1a\u6b8b\u5dee\u7f51\u7edc\uff1bs\u3001t\uff1a\u6e90\u70b9\u548c\u6c47\u70b9 \u8fd4\u56de\u503c\u8868\u793as\u3001t\u662f\u5426\u8fde\u901a\u3002ht\uff1a\u9ad8\u5ea6\u6570\u7ec4\u3002 \u4ecet\u5f00\u59cb\u8ba1\u7b97\u5404\u70b9\u9ad8\u5ea6\u3002\u8fd4\u56de\u503c\u8868\u793as\u3001t\u662f\u5426\u8fde\u901a __gap_init n ht\uff1a\u9ad8\u5ea6\u6570\u7ec4\uff1bs\u3001t\uff1a\u6e90\u70b9\u548c\u6c47\u70b9 gap\uff1a\u7edf\u8ba1\u5bf9\u5e94\u9ad8\u5ea6\u4e2a\u6570\u7684\u70b9\u6570\u7684\u6570\u7ec4 \u7edf\u8ba1\u5bf9\u5e94\u9ad8\u5ea6\u4e2a\u6570\u7684\u70b9\u6570 __s_init s\u76f8\u90bb\u70b9\u6570 Edges\uff1a\u6b8b\u5dee\u7f51\u7edc\uff1bs\u3001t\uff1a\u6e90\u70b9\u548c\u6c47\u70b9 pq\uff1a\u6700\u9ad8\u6807\u53f7\u4f18\u5148\u961f\u5217\u3002vis\uff1a\u8bbf\u95ee\u6570\u7ec4\u3002 \u7528\u6e90\u70b9s\u76f8\u90bb\u7684\u70b9\u521d\u59cb\u5316\u4f18\u5148\u961f\u5217 __push u\u76f8\u90bb\u70b9\u6570 Edges\uff1a\u6b8b\u5dee\u7f51\u7edc\uff1bs\u3001t\uff1a\u6e90\u70b9\u548c\u6c47\u70b9\u3002u\uff1a\u8282\u70b9\u6807\u53f7\u3002 ex\uff1a\u8d85\u989d\u6d41\u6570\u7ec4\u3002vis\uff1a\u8bbf\u95ee\u6570\u7ec4\uff08\u662f\u5426\u5728\u4f18\u5148\u961f\u5217\u4e2d\uff09\u3002Edges\uff1a\u6b8b\u5dee\u7f51\u7edc\u3002 \u5c06\u70b9u\u5411\u7740\u76f8\u90bb\u70b9\u63a8\u9001\u8d85\u989d\u6d41 __relabel u\u76f8\u90bb\u70b9\u6570 Edges\uff1a\u6b8b\u5dee\u7f51\u7edc\uff1bht\uff1a\u9ad8\u5ea6\u6570\u7ec4\uff1bu\uff1a\u8282\u70b9\u6807\u53f7\u3002 ht\uff1a\u9ad8\u5ea6\u6570\u7ec4 \u4e3a\u70b9u\u91cd\u8d34\u9ad8\u5ea6\u6807\u7b7e get_maxflow n^2*sqrt(m) s,t\uff1a\u6e90\u70b9\u4e0e\u6c47\u70b9 \u6700\u5927\u6d41\u5927\u5c0f \u53d6\u5f97\u6700\u5927\u6d41 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 #include <iostream> #include <memory.h> #include <queue> using namespace std ; typedef long long ll ; namespace Edges { typedef ll Ty ; const int N = 2e4 + 10 , M = 4e5 + 100 ; //public int n , m ; //n,m: \u70b9\u3001\u8fb9\u6570\u91cf //\u6b8b\u5dee\u7f51\u7edc\u7684\u8fb9 struct E { int from , to , inext ; Ty w ; } edge [ M ]; int head [ N ], total = 1 ; //total\uff1a\u5e94\u5f53\u521d\u59cb\u5316\u4e3a1 void adde ( int x , int y , Ty w ) { edge [ ++ total ]. from = x ; edge [ total ]. to = y ; edge [ total ]. w = w ; edge [ total ]. inext = head [ x ]; head [ x ] = total ; } } using namespace Edges ; namespace HLPP { typedef ll Ty ; const int N = 2e4 + 10 ; //N\uff1a\u70b9\u4e2a\u6570 const int Inf2 = 0x3f3f3f3f ; //inf2\uff1a\u9ad8\u5ea6\u65e0\u7a77\u5927\u503c const Ty Inf = 1e18 ; //Inf\uff1a\u6d41\u91cf\u65e0\u7a77\u5927\u503c //public int S , T ; //S,T:\u6e90\u70b9\u548c\u6c47\u70b9 //local int ht [ N ], gap [ N ]; //ht, gap\uff1a\u9ad8\u5ea6\u548c\u7edf\u8ba1\u5bf9\u5e94\u9ad8\u5ea6\u6709\u591a\u5c11\u4e2a\u6570\u7684gap\u6570\u7ec4 Ty ex [ N ]; //ex\uff1a\u8d85\u989d\u6d41 bool vis [ N ]; //vis\uff1a\u6807\u8bb0\u67d0\u70b9\u662f\u5426\u88ab\u904d\u5386 struct __cmp { bool operator ()( int a , int b ) const { return ht [ a ] < ht [ b ]; } }; //\u4f2a\u88c5\u6bd4\u8f83\u51fd\u6570\u7c7b priority_queue < int , vector < int > , __cmp > pq ; //pq\uff1a\u4f18\u5148\u961f\u5217\uff0c\u7528\u4e8e\u53d6\u51fa\u6700\u5927\u6807\u53f7\u7684\u70b9 //\u4ecet\u5f00\u59cb\u8ba1\u7b97\u5404\u70b9\u9ad8\u5ea6\u3002\u8fd4\u56de\u503c\u8868\u793as\u3001t\u662f\u5426\u8fde\u901a bool __ht_init ( int s = S , int t = T ) { memset ( ht , 0x3f , sizeof ( ht )); queue < int > q ; q . push ( t ); ht [ t ] = 0 ; while ( q . size ()) { int u = q . front (); q . pop (); for ( int e = head [ u ]; e ; e = edge [ e ]. inext ) { int y = edge [ e ]. to ; if ( edge [ e ^ 1 ]. to && ht [ y ] > ht [ u ] + 1 ) { ht [ y ] = ht [ u ] + 1 ; q . push ( y ); } } } return ht [ s ] != Inf2 ; } //\u7edf\u8ba1\u5bf9\u5e94\u9ad8\u5ea6\u4e2a\u6570\u7684\u70b9\u6570 void __gap_init () { memset ( gap , 0 , sizeof ( gap )); for ( int i = 1 ; i <= n ; i ++ ) { if ( ht [ i ] != Inf2 ) { gap [ ht [ i ]] ++ ; } } } //\u7528\u6e90\u70b9s\u76f8\u90bb\u7684\u70b9\u521d\u59cb\u5316\u4f18\u5148\u961f\u5217 void __s_init ( int s = S , int t = T ) { memset ( ex , 0 , sizeof ( ex )); for ( int e = head [ s ]; e ; e = edge [ e ]. inext ) { int y = edge [ e ]. to ; Ty w = edge [ e ]. w ; if ( w == 0 ) continue ; ex [ s ] -= w ; ex [ y ] += w ; edge [ e ]. w -= w ; edge [ e ^ 1 ]. w += w ; if ( y != s && y != t && vis [ y ] == 0 ) { pq . push ( y ); vis [ y ] = true ; } } } //\u5c06\u70b9u\u5411\u7740\u76f8\u90bb\u70b9\u63a8\u9001\u8d85\u989d\u6d41 bool __push ( int u , int s = S , int t = T ) { for ( int e = head [ u ]; e ; e = edge [ e ]. inext ) { int y = edge [ e ]. to ; Ty w = edge [ e ]. w ; if ( w == 0 || ht [ u ] != ht [ y ] + 1 ) continue ; Ty k = min ( w , ex [ u ]); ex [ u ] -= k ; ex [ y ] += k ; edge [ e ]. w -= k ; edge [ e ^ 1 ]. w += k ; if ( y != s && y != t && vis [ y ] == 0 ) { pq . push ( y ); vis [ y ] = true ; } if ( ex [ u ] == 0 ) { return false ; } } return true ; } // \u4e3a\u70b9u\u91cd\u8d34\u9ad8\u5ea6\u6807\u7b7e void __relabel ( int u ) { ht [ u ] = Inf2 ; for ( int e = head [ u ]; e ; e = edge [ e ]. inext ) { int y = edge [ e ]. to ; Ty w = edge [ e ]. w ; if ( w ) { ht [ u ] = min ( ht [ u ], ht [ y ] + 1 ); } } //ht[u]++; } //\u53d6\u5f97\u6700\u5927\u6d41 Ty get_maxflow ( int s = S , int t = T ) { if ( __ht_init ( s , t ) == 0 ) // \u56fe\u4e0d\u8fde\u901a return 0 ; ht [ s ] = n ; //\u521d\u59cb\u5316s\u7684\u9ad8\u5ea6 while ( pq . size ()) { //\u6e05\u7a7a\u961f\u5217 pq . pop (); } __gap_init (); __s_init ( s , t ); while ( pq . size ()) { int u = pq . top (); pq . pop (); vis [ u ] = 0 ; while ( __push ( u , s , t )) { if ( -- gap [ ht [ u ]] == 0 ) { for ( int i = 1 ; i <= n ; i ++ ) { //gap optimization //\u5728\u7b97\u6cd5\u7684\u67d0\u4e00\u65f6\u523b\uff0ch(u)=t \u7684\u7ed3\u70b9\u4e2a\u6570\u4e3a0\uff0c\u90a3\u4e48\u5bf9\u4e8eh(i)>t\u7684\u7ed3\u70b9i\u5c31\u6c38\u8fdc\u65e0\u6cd5\u63a8\u9001\u8d85\u989d\u6d41\u5230t\uff0c\u56e0\u6b64\u53ea\u80fd\u9001\u56des\uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u5728\u8fd9\u65f6\u76f4\u63a5\u8ba9\u4ed6\u4eec\u7684\u9ad8\u5ea6\u53d8\u6210n+1\uff0c\u4ee5\u5c3d\u5feb\u63a8\u9001\u56des\uff0c\u51cf\u5c11\u91cd\u8d34\u6807\u7b7e\u7684\u64cd\u4f5c\u3002 if ( i != s && i != t && ht [ i ] > ht [ u ] && ht [ i ] < n + 1 ) { ht [ i ] = n + 1 ; } } } __relabel ( u ); gap [ ht [ u ]] ++ ; } } return ex [ t ]; } } int main () { ios :: sync_with_stdio ( false ); cin >> n >> m >> HLPP :: S >> HLPP :: T ; for ( int i = 1 ; i <= m ; i ++ ) { int x , y ; ll w ; cin >> x >> y >> w ; adde ( x , y , w ); //\u522b\u5fd8\u4e86\u52a0\u53cd\u5411\u8fb9\uff01 adde ( y , x , 0 ); } ll maxflow = HLPP :: get_maxflow ( HLPP :: S , HLPP :: T ); cout << maxflow << endl ; return 0 ; } \u2b50\u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41\uff08MCMF\uff09\uff1aEK \u00b6 \u26a0\ufe0f\u6ce8\u610f\uff1a\u8fd9\u73a9\u610f\u4e0d\u80fd\u76f4\u63a5\u7528\u4e8e\u6709\u8d1f\u73af\uff08\u8d39\u7528\u8d1f\u73af\uff09\u7684\u56fe\u4e2d\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 //\u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41 #include <iostream> #include <memory.h> #include <queue> #include <utility> using namespace std ; typedef long long ll ; namespace Edges { typedef int Ty ; const int N = 5e3 + 10 , M = 1.2e5 + 100 ; //public int n , m ; //n,m: \u70b9\u3001\u8fb9\u6570\u91cf //\u6b8b\u5dee\u7f51\u7edc\u7684\u8fb9 struct E { int from , to , inext ; Ty w , c ; //w:\u6d41\u91cf, c: \u5355\u4f4d\u8d39\u7528 } edge [ M ]; int head [ N ], total ; void adde ( int x , int y , Ty w , Ty c ) { edge [ ++ total ]. from = x ; edge [ total ]. to = y ; edge [ total ]. w = w ; edge [ total ]. c = c ; edge [ total ]. inext = head [ x ]; head [ x ] = total ; } } using namespace Edges ; namespace MCMF_EK { typedef int Ty ; const int N = 5e3 + 10 ; //N\uff1a\u70b9\u4e2a\u6570 const Ty Inf = 0x3f3f3f3f ; //Inf\uff1a\u6d41\u91cf\u65e0\u7a77\u5927\u503c // const int Inf2=0x3f3f3f3f; //inf2\uff1a\u5c42\u6b21\u65e0\u7a77\u5927\u503c //public int S , T ; //S,T: \u6e90\u70b9\u3001\u6c47\u70b9 //local bool v [ N ]; int pre [ N ]; Ty incf [ N ], d [ N ]; //incf\uff1a\u589e\u5e7f\u8def, //v:__spfa\u65f6\u4f7f\u7528\u7684\u6807\u8bb0\u5728\u961f\u5217\u4e2d\u6570\u7ec4, //pre\uff1a__bfs\u65f6\u4f7f\u7528\u7684\u8bb0\u5f55\u74f6\u9888\u8def\u524d\u9a71\u8f6c\u79fb\u65b9\u5411\u7684\u6570\u7ec4, //d: spfa\u6700\u77ed\u8def bool __spfa ( int s = S , int t = T ) { queue < int > q ; // memset(d,0x3f,sizeof(d)); //c //memset(v,0,sizeof(v)); for ( int i = 1 ; i <= n ; i ++ ) //\u6ce8\u610f\u8fd9\u4e2a\u5730\u65b9\u7684n\u53ef\u80fd\u8981\u6539 { d [ i ] = Inf ; //\u6ce8\u610f\u8fd9\u4e2a\u6e05\u7a7a\u4e0d\u80fd\u4f7f\u7528Inf2\uff0c\u56e0\u4e3ad\u7684\u503c\u4e0d\u518d\u662f\u5c42\u6b21\u800c\u662f\u8d39\u7528\u6700\u77ed\u8def\u957f\u5ea6\u4e86 v [ i ] = 0 ; } q . push ( s ); d [ s ] = 0 ; v [ s ] = 1 ; incf [ s ] = Inf ; while ( q . size ()) { int x = q . front (); q . pop (); v [ x ] = 0 ; for ( int e = head [ x ]; e ; e = edge [ e ]. inext ) { int y = edge [ e ]. to ; if ( edge [ e ]. w && d [ y ] > d [ x ] + edge [ e ]. c ) { d [ y ] = d [ x ] + edge [ e ]. c ; incf [ y ] = min ( incf [ x ], edge [ e ]. w ); pre [ y ] = e ; if ( ! v [ y ]) { v [ y ] = 1 ; q . push ( y ); } } } } if ( d [ t ] == Inf ) return false ; //no connect return true ; } Ty __update ( Ty & maxflow , int s = S , int t = T ) { int x = t ; while ( x != s ) { int e = pre [ x ]; edge [ e ]. w -= incf [ t ]; if ( e % 2 ) edge [ e + 1 ]. w += incf [ t ]; else edge [ e -1 ]. w += incf [ t ]; x = edge [ e ]. from ; } maxflow += incf [ t ]; return incf [ t ] * d [ t ]; } auto get_mcmf ( int s = S , int t = T ) { Ty maxflow = 0 , cost = 0 ; while ( __spfa ( s , t )) { cost += __update ( maxflow , s , t ); } return make_pair ( maxflow , cost ); } } int main () { ios :: sync_with_stdio ( false ); cin >> n >> m >> MCMF_EK :: S >> MCMF_EK :: T ; for ( int i = 1 ; i <= m ; i ++ ) { int x , y ; ll w , c ; cin >> x >> y >> w >> c ; adde ( x , y , w , c ); //! adde ( y , x , 0 , - c ); //! } auto ans = MCMF_EK :: get_mcmf (); cout << ans . first << \" \" << ans . second << endl ; return 0 ; } ZKW \u8d39\u7528\u6d41 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <cstdlib> #include <algorithm> #include <string> #include <vector> #include <map> #include <unordered_map> #include <set> #include <unordered_set> #include <queue> using namespace std ; typedef long long ll ; namespace Edges { typedef int Ty ; const int N = 5e3 + 10 , M = 1.2e5 + 10 ; //public int n , m ; //n,m: \u70b9\u3001\u8fb9\u6570\u91cf //\u6b8b\u5dee\u7f51\u7edc\u7684\u8fb9 struct E { int from , to , inext ; Ty w , c ; } edge [ M ]; int head [ N ], total ; void adde ( int x , int y , Ty w , Ty c ) { edge [ ++ total ]. from = x ; edge [ total ]. to = y ; edge [ total ]. w = w ; edge [ total ]. c = c ; edge [ total ]. inext = head [ x ]; head [ x ] = total ; } } using namespace Edges ; namespace MCMF_ZKW { typedef int Ty ; const int N = 5e3 + 10 ; //N\uff1a\u70b9\u4e2a\u6570 const Ty Inf = 0x3f3f3f3f ; //Inf\uff1a\u6d41\u91cf\u65e0\u7a77\u5927\u503c // const int Inf2=0x3f3f3f3f; //inf2\uff1a\u5c42\u6b21\u65e0\u7a77\u5927\u503c //public int S , T ; //S,T: \u6e90\u70b9\u3001\u6c47\u70b9 //local bool v [ N ]; Ty d [ N ]; //incf\uff1a\u589e\u5e7f\u8def //d: spfa\u6700\u77ed\u8def //\u4f7f\u7528SLF\u4f18\u5316\u7684spfa\u5bfb\u627e\u5206\u5c42\u56fe bool __spfa ( int s = S , int t = T ) { deque < int > q ; // memset(d,0x3f,sizeof(d)); //c //memset(v,0,sizeof(v)); for ( int i = 1 ; i <= n ; i ++ ) { d [ i ] = Inf ; //\u6ce8\u610f\u8fd9\u4e2a\u6e05\u7a7a\u4e0d\u80fd\u4f7f\u7528Inf2\uff0c\u56e0\u4e3ad\u7684\u503c\u4e0d\u518d\u662f\u5c42\u6b21\u800c\u662f\u8d39\u7528\u6700\u77ed\u8def\u957f\u5ea6\u4e86 v [ i ] = 0 ; } q . push_back ( s ); d [ s ] = 0 ; v [ s ] = 1 ; while ( q . size ()) { int x = q . front (); q . pop_front (); v [ x ] = 0 ; for ( int e = head [ x ]; e ; e = edge [ e ]. inext ) { int y = edge [ e ]. to ; if ( edge [ e ]. w > 0 && d [ y ] > d [ x ] + edge [ e ]. c ) { d [ y ] = d [ x ] + edge [ e ]. c ; if ( ! v [ y ]) { v [ y ] = 1 ; if ( q . size () && d [ y ] < d [ q . front ()]) { q . push_front ( y ); } else q . push_back ( y ); } } } } //no connect return d [ t ] < Inf ; } //\u4f7f\u7528dinic\u7b97\u6cd5\u63a8\u9001\u6d41\u3002\u8fd4\u56de\u7684\u662f\u6d41\u7684\u6539\u53d8\u91cf\u3002 Ty __dinic ( int x , int t , Ty flow , Ty & maxflow , Ty & cost ) { if ( x == t ) { maxflow += flow ; return flow ; } Ty rest = flow , delta ; v [ x ] = true ; for ( int e = head [ x ]; e ; e = edge [ e ]. inext ) { if ( rest == 0 ) return flow ; //!!! int y = edge [ e ]. to ; if ( v [ y ]) continue ; if ( edge [ e ]. w > 0 && d [ y ] == d [ x ] + edge [ e ]. c ) { delta = __dinic ( y , t , min ( edge [ e ]. w , rest ), maxflow , cost ); if ( ! delta ) d [ y ] = 0 ; //pruning edge [ e ]. w -= delta ; if ( e % 2 ) edge [ e + 1 ]. w += delta ; else edge [ e - 1 ]. w += delta ; //+= ? cost += delta * edge [ e ]. c ; //\u66f4\u65b0\u8d39\u7528 rest -= delta ; } } return flow - rest ; } //\u53d6\u5f97\u6700\u5927\u6d41\u6700\u5c0f\u8d39\u7528 auto get_mcmf ( int s = S , int t = T ) { Ty maxflow = 0 , cost = 0 ; while ( __spfa ( s , t )) { // cost+=__update(maxflow,s,t); __dinic ( s , t , Inf , maxflow , cost ); } return make_pair ( maxflow , cost ); } } int main () { ios :: sync_with_stdio ( false ); cin >> n >> m >> MCMF_ZKW :: S >> MCMF_ZKW :: T ; for ( int i = 1 ; i <= m ; i ++ ) { int x , y ; ll w , c ; cin >> x >> y >> w >> c ; adde ( x , y , w , c ); //! adde ( y , x , 0 , - c ); //! } auto ans = MCMF_ZKW :: get_mcmf (); cout << ans . first << \" \" << ans . second << endl ; return 0 ; } \u4f7f\u7528vector\u7684\u7248\u672c\uff0c\u5e38\u6570\u662f\u524d\u8005\u7684\u4e00\u534a\u5de6\u53f3 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <cstdlib> #include <algorithm> #include <string> #include <vector> #include <map> #include <unordered_map> #include <set> #include <unordered_set> #include <queue> using namespace std ; typedef long long ll ; namespace Edges { typedef ll Ty ; const int N = 5e5 + 10 , M = 1e6 + 10 ; //public int n , m ; //n,m: \u70b9\u3001\u8fb9\u6570\u91cf //\u6b8b\u5dee\u7f51\u7edc\u7684\u8fb9 struct E { int from , to ; Ty w , c ; int dualedge_num ; }; // int head[N], total; int total ; vector < E > head [ N ]; int adde ( int x , int y , Ty w , Ty c ) { ++ total ; // edge[++total].from = x; // edge[total].to = y; // edge[total].w = w; // edge[total].c=c; // edge[total].inext = head[x]; // head[x] = total; // head[x].emplace_back(x,y,w,c); head [ x ]. push_back ({ x , y , w , c }); return head [ x ]. size () -1 ; } void adde2 ( int x , int y , Ty w , Ty c ) { int dual1 = adde ( x , y , w , c ); int dual2 = adde ( y , x , 0 , - c ); head [ x ]. back (). dualedge_num = dual2 ; head [ y ]. back (). dualedge_num = dual1 ; } } using namespace Edges ; #include <bitset> namespace MCMF_ZKW { typedef ll Ty ; const int N = 5e5 + 10 ; //N\uff1a\u70b9\u4e2a\u6570 const Ty Inf = 1e18 ; //Inf\uff1a\u6d41\u91cf\u65e0\u7a77\u5927\u503c // const int Inf2=0x3f3f3f3f; //inf2\uff1a\u5c42\u6b21\u65e0\u7a77\u5927\u503c //public int S , T ; //S,T: \u6e90\u70b9\u3001\u6c47\u70b9 //local // bool v[N]; bitset < N > v ; Ty d [ N ]; //incf\uff1a\u589e\u5e7f\u8def //d: spfa\u6700\u77ed\u8def //\u4f7f\u7528SLF\u4f18\u5316\u7684spfa\u5bfb\u627e\u5206\u5c42\u56fe bool __spfa ( int s = S , int t = T ) { queue < int > q ; // memset(d,0x3f,sizeof(d)); //c //memset(v,0,sizeof(v)); fill ( d + 1 , d + 1 + n , Inf ); // fill(v+1,v+1+n,0); for ( int i = 1 ; i <= n ; i ++ ) { // d[i]=Inf; //\u6ce8\u610f\u8fd9\u4e2a\u6e05\u7a7a\u4e0d\u80fd\u4f7f\u7528Inf2\uff0c\u56e0\u4e3ad\u7684\u503c\u4e0d\u518d\u662f\u5c42\u6b21\u800c\u662f\u8d39\u7528\u6700\u77ed\u8def\u957f\u5ea6\u4e86 v [ i ] = 0 ; } q . push ( s ); d [ s ] = 0 ; v [ s ] = 1 ; while ( q . size ()) { int x = q . front (); q . pop (); v [ x ] = 0 ; // for(int e=head[x];e;e=edge[e].inext) for ( auto & e : head [ x ]) { // int y=edge[e].to; int y = e . to ; // if(edge[e].w>0 && d[y]>d[x]+edge[e].c) if ( e . w > 0 && d [ y ] > d [ x ] + e . c ) { // d[y]=d[x]+edge[e].c; d [ y ] = d [ x ] + e . c ; if ( ! v [ y ]) { v [ y ] = 1 ; // if(q.size() && d[y]<d[q.front()]) // { // q.push_front(y); // } // else q . push ( y ); } } } } //no connect return d [ t ] < Inf ; } //\u4f7f\u7528dinic\u7b97\u6cd5\u63a8\u9001\u6d41\u3002\u8fd4\u56de\u7684\u662f\u6d41\u7684\u6539\u53d8\u91cf\u3002 Ty __dinic ( int x , int t , Ty flow , Ty & maxflow , Ty & cost ) { if ( x == t ) { maxflow += flow ; return flow ; } Ty rest = flow , delta ; v [ x ] = true ; // for (int e = head[x]; e; e = edge[e].inext) for ( auto & e : head [ x ]) { if ( rest == 0 ) return flow ; //!!! // int y=edge[e].to; int y = e . to ; if ( v [ y ]) continue ; // if (edge[e].w>0 && d[y] == d[x] + edge[e].c) if ( e . w > 0 && d [ y ] == d [ x ] + e . c ) { // delta = __dinic(y, t, min(edge[e].w, rest), maxflow, cost); delta = __dinic ( y , t , min ( e . w , rest ), maxflow , cost ); if ( ! delta ) d [ y ] = 0 ; //pruning // edge[e].w -= delta; e . w -= delta ; // if (e % 2) // edge[e + 1].w += delta; // else // edge[e - 1].w += delta; //+= ? head [ y ][ e . dualedge_num ]. w += delta ; // cost+= delta*edge[e].c; //\u66f4\u65b0\u8d39\u7528 cost += delta * e . c ; rest -= delta ; } } return flow - rest ; } //\u53d6\u5f97\u6700\u5927\u6d41\u6700\u5c0f\u8d39\u7528 auto get_mcmf ( int s = S , int t = T ) { Ty maxflow = 0 , cost = 0 ; while ( __spfa ( s , t )) { // cost+=__update(maxflow,s,t); __dinic ( s , t , Inf , maxflow , cost ); } return make_pair ( maxflow , cost ); } } ll nn , a , b , c ; namespace Fast_IO { char __nc () { static char buf [ 1000000 ], * p = buf , * q = buf ; return p == q && ( q = ( p = buf ) + fread ( buf , 1 , 1000000 , stdin ), p == q ) ? EOF : * p ++ ; } template < typename T > inline void read ( T & x ) { char c ; int sgn = 1 ; x = 0 ; c = __nc (); while ( c > '9' || c < '0' ) { if ( c == '-' ) sgn = -1 ; c = __nc (); } while ( c <= '9' && c >= '0' ) { x = ( x << 3 ) + ( x << 1 ) + ( c - '0' ); c = __nc (); } x *= sgn ; } template < typename T > inline void print ( T x ) { if ( x < 0 ) { putchar ( '-' ); x = - x ; } if ( x > 9 ) { print ( x / 10 ); } putchar ( x % 10 + '0' ); } void readstr ( char * a ) { char c ; c = __nc (); while ( ! ( c <= 'z' && c >= 'a' )) c = __nc (); while ( c <= 'z' && c >= 'a' ) { * a = c ; a ++ ; c = __nc (); } } } // namespace Fast_IO using namespace Fast_IO ; int main () { // ios::sync_with_stdio(false); // cin.tie(0); // cout.tie(0); // cin>>nn>>a>>b>>c; read ( nn ); read ( a ); read ( b ); read ( c ); MCMF_ZKW :: S = nn + 2 ; MCMF_ZKW :: T = nn + 1 ; n = nn + 5 ; for ( int i = 1 ; i <= nn ; i ++ ) { ll ai , bi , ci ; // cin>>ai>>bi>>ci; read ( ai ); read ( bi ); read ( ci ); // adde2(nn+1,i,1,0); adde2 ( i , nn + 1 , 1 , 0 ); adde2 ( nn + 3 , i , 1 , - ai ); adde2 ( nn + 4 , i , 1 , - bi ); adde2 ( nn + 5 , i , 1 , - ci ); } adde2 ( nn + 2 , nn + 3 , a , 0 ); adde2 ( nn + 2 , nn + 4 , b , 0 ); adde2 ( nn + 2 , nn + 5 , c , 0 ); auto ans = MCMF_ZKW :: get_mcmf (); // cout<<-ans.second<<endl; print ( - ans . second ); // cin>>n>>m>>MCMF_ZKW::S>>MCMF_ZKW::T; // for(int i=1;i<=m;i++) // { // int x,y; // ll w,c; // cin>>x>>y>>w>>c; // adde(x,y,w,c); //! // adde(y,x,0,-c); //! // } // auto ans=MCMF_ZKW::get_mcmf(); // cout<<ans.first<<\" \"<<ans.second<<endl; return 0 ; } \u5e26\u82b1\u6811\u5339\u914d \u00b6 \u7b80\u8981\u539f\u7406\uff1a\u4ece\u6bcf\u4e2a\u5c1a\u672a\u5339\u914d\u7684\u70b9\u51fa\u53d1\u53bb\u5bfb\u627e\u589e\u5e7f\u8def\uff0c\u5982\u679c\u627e\u5230\u4e86\u5c31\u53cd\u8f6c\u3002\u4ea4\u66ff\u5730\u628a\u5339\u914d\u8fb9\u7684\u4e24\u7aef\u7684\u70b9\u6807\u8bb0\u6210o\u3001i\uff0c\u4eceo\u6807\u8bb0\u51fa\u53d1\u7684\u5982\u679c\u9047\u5230\u4e86o\uff0c\u8868\u660e\u9047\u5230\u4e86\u5947\u73af\uff0c\u5219\u6267\u884c\u7f29\u82b1\u64cd\u4f5c\uff1alca\u627e\u6839\uff0c\u7136\u540e\u6807\u8bb0\u6240\u6709\u73af\u4e0a\u7684\u70b9\u5bf9\u5e94\u7684\u82b1\u6839\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 // luogu 6113 #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <cstdlib> #include <algorithm> #include <string> #include <vector> #include <map> #include <unordered_map> #include <set> #include <unordered_set> #include <queue> #include <cassert> #include <random> #include <chrono> using namespace std ; typedef long long ll ; // graph namespace Blossom_Algorithm { template < typename T > class graph { public : struct edge { int from ; int to ; T cost ; }; vector < edge > edges ; vector < vector < int >> g ; int n ; graph ( int _n ) : n ( _n ) { g . resize ( n ); } virtual int add ( int from , int to , T cost ) = 0 ; }; // undirectedgraph template < typename T > class undirectedgraph : public graph < T > { public : using graph < T >:: edges ; //edges\uff1a\u8fb9\u8868 using graph < T >:: g ; //g\uff1a\u90bb\u63a5\u8868\uff0c\u4fdd\u5b58\u7684\u662f\u8fb9\u7684\u6807\u53f7 using graph < T >:: n ; undirectedgraph ( int _n ) : graph < T > ( _n ) {} int add ( int from , int to , T cost = 1 ) { assert ( 0 <= from && from < n && 0 <= to && to < n ); //\u6807\u53f7\u8303\u56f4\uff1a0~n-1 int id = ( int ) edges . size (); g [ from ]. push_back ( id ); g [ to ]. push_back ( id ); edges . push_back ({ from , to , cost }); return id ; } }; // blossom / find_max_unweighted_matching template < typename T > vector < int > find_max_unweighted_matching ( const undirectedgraph < T > & g ) { std :: mt19937 rng ( chrono :: steady_clock :: now (). time_since_epoch (). count ()); vector < int > match ( g . n , -1 ); // match\uff1a\u5339\u914d vector < int > aux ( g . n , -1 ); // aux\uff1a\u65f6\u95f4\u6233\u8bb0 vector < int > label ( g . n ); // label\uff1a\"o\" or \"i\"\uff0c\u7528\u4e8e\u5728\u627e\u589e\u5e7f\u8def\u65f6\u786e\u8ba4\u5947\u73af vector < int > orig ( g . n ); // orig\uff1a\u82b1\u6839 vector < int > parent ( g . n , -1 ); // parent\uff1a\u7236\u8282\u70b9 queue < int > q ; int aux_time = -1 ; //\u5bfb\u627e\uff08\u5df2\u7ecf\u6709\u7f29\u82b1\uff09\u56fe\u7684\u4e24\u4e2a\u82b1\u6839\u7684LCA auto lca = [ & ]( int v , int u ) { aux_time ++ ; //\u6bcf\u6b21\u8c03\u7528\u65f6\u90fd\u4ee3\u8868\u5b58\u5728\u4e00\u4e2a\u80fd\u7f29\u7684\u82b1\uff0c\u56e0\u6b64\u76f8\u5f53\u4e8e\u82b1\u7684\u7f16\u53f7\u4e86 //\u4e24\u4e2a\u70b9\u8f6e\u6d41\u4ea4\u66ff\u5411\u524d\u8df3\uff0c\u649e\u5230\u8bbf\u95ee\u8fc7\u7684\u70b9\u5c31\u8868\u660e\u662flca\u4e86 while ( true ) { if ( v != -1 ) { if ( aux [ v ] == aux_time ) { // \u627e\u5230\u62dc\u8bbf\u8fc7\u7684\u70b9 \u4e5f\u5c31\u662fLCA return v ; } aux [ v ] = aux_time ; if ( match [ v ] == -1 ) { v = -1 ; } else { v = orig [ parent [ match [ v ]]]; // \u4ee5\u5339\u914d\u70b9\u7684\u7236\u8282\u70b9\u7ee7\u7eed\u5bfb\u627e } } swap ( v , u ); } }; // lca //\u4ee5a\u4e3a\u6839\u7684\u82b1\u8fdb\u884c\u7f29\u82b1\uff08\u6ce8\u610f\u8fd9\u4e24\u4e2a\u70b9u\u3001v\u90fd\u662fo\u578b\u70b9\uff09 auto blossom = [ & ]( int v , int u , int a ) { while ( orig [ v ] != a ) { parent [ v ] = u ; u = match [ v ]; if ( label [ u ] == 1 ) { // \u521d\u59cb\u70b9\u8bbe\u4e3a\"o\" \u627e\u589e\u5e7f\u8def\uff08\u76f8\u5f53\u4e8e\u7f29\u82b1\u540e\u5c31\u65e0\u89c6\u4e86\u4ed6\u672c\u6765\u7684oi\u6807\u8bb0\u4e86\uff0ci\u578b\u70b9\u4e5f\u5168\u90e8\u6539\u6210o\u578b\u70b9\uff09 label [ u ] = 0 ; q . push ( u ); } orig [ v ] = orig [ u ] = a ; // \u7f29\u82b1 v = parent [ u ]; } }; // blossom //\u5f97\u5230\u4e86\u589e\u5e7f\u8def\u5e76\u53cd\u8f6c auto augment = [ & ]( int v ) { while ( v != -1 ) { int pv = parent [ v ]; int next_v = match [ pv ]; match [ v ] = pv ; match [ pv ] = v ; v = next_v ; } }; // augment //bfs\u6765\u5bfb\u627e\u589e\u5e7f\u8def\u5e76\u53cd\u8f6c\u4e4b\u4ee5\u5b9e\u73b0\u5339\u914d auto bfs = [ & ]( int root ) { fill ( label . begin (), label . end (), -1 ); iota ( orig . begin (), orig . end (), 0 ); while ( ! q . empty ()) { q . pop (); } q . push ( root ); // \u521d\u59cb\u70b9\u8bbe\u4e3a \"o\", \u8fd9\u91cc\u4ee5\"0\"\u4ee3\u66ff\"o\", \"1\"\u4ee3\u66ff\"i\" label [ root ] = 0 ; while ( ! q . empty ()) { int v = q . front (); q . pop (); for ( int id : g . g [ v ]) { auto & e = g . edges [ id ]; int u = e . from ^ e . to ^ v ; //e.from == v\uff0c\u6240\u4ee5\u5f02\u6216\u51fa\u6765\u5e94\u8be5\u4e00\u5b9a\u662fe.to\uff0c\u4e0d\u77e5\u9053\u4e3a\u4ec0\u4e48\u8981\u8fd9\u4e48\u5199\u2026\u2026 if ( label [ u ] == -1 ) { // \u627e\u5230\u672a\u62dc\u8bbf\u70b9 label [ u ] = 1 ; // \u6807\u8bb0 \"i\" parent [ u ] = v ; //\u5bf9\u6807\u8bb0\u4e3ai\u7684\u70b9\u4fdd\u5b58parent\uff08\u76f8\u5f53\u4e8e\u672a\u5339\u914d\u8fb9\u7684\u53cd\u5411\u8fde\u63a5\uff09 if ( match [ u ] == -1 ) { // \u627e\u5230\u672a\u5339\u914d\u70b9 augment ( u ); // \u5bfb\u627e\u589e\u5e7f\u8def\u5f84 return true ; } // \u627e\u5230\u5df2\u5339\u914d\u70b9 \u5c06\u4e0e\u5979\u5339\u914d\u7684\u70b9\u4e22\u5165queue \u5ef6\u4f38\u4ea4\u9519\u6811 label [ match [ u ]] = 0 ; q . push ( match [ u ]); continue ; } else if ( label [ u ] == 0 && orig [ v ] != orig [ u ]) { // \u627e\u5230\u5df2\u62dc\u8bbf\u70b9 \u4e14\u6807\u8bb0\u540c\u4e3a\"o\" \u4ee3\u8868\u627e\u5230\"\u82b1\" int a = lca ( orig [ v ], orig [ u ]); // \u627eLCA \u7136\u540e\u7f29\u82b1 blossom ( u , v , a ); blossom ( v , u , a ); } } } return false ; }; // bfs //\u968f\u673a\u6253\u4e71\u5e76\u5339\u914d auto greedy = [ & ]() { vector < int > order ( g . n ); // \u968f\u673a\u6253\u4e71 order iota ( order . begin (), order . end (), 0 ); shuffle ( order . begin (), order . end (), rng ); // \u5c06\u53ef\u4ee5\u5339\u914d\u7684\u70b9\u5339\u914d for ( int i : order ) { if ( match [ i ] == -1 ) { for ( auto id : g . g [ i ]) { auto & e = g . edges [ id ]; int to = e . from ^ e . to ^ i ; //\uff1f\uff1f\uff1f if ( match [ to ] == -1 ) { match [ i ] = to ; match [ to ] = i ; break ; } } } } }; // greedy // \u4e00\u5f00\u59cb\u5148\u968f\u673a\u5339\u914d greedy (); // \u5bf9\u672a\u5339\u914d\u70b9\u627e\u589e\u5e7f\u8def for ( int i = 0 ; i < g . n ; i ++ ) { if ( match [ i ] == -1 ) { bfs ( i ); } } return match ; } } using namespace Blossom_Algorithm ; int n , m ; int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ), cout . tie ( 0 ); cin >> n >> m ; undirectedgraph < int > G ( n ); for ( int i = 1 ; i <= m ; i ++ ) { int x , y ; cin >> x >> y ; G . add ( x -1 , y -1 ); //\u65e0\u5411\u8fb9\uff0c\u4e0d\u9700\u8981\u52a0\u4e24\u6b21 } auto res = find_max_unweighted_matching ( G ); int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( res [ i ] != -1 ) { ans ++ ; } } cout << ans / 2 << '\\n' ; for ( int i = 0 ; i < n ; i ++ ) { cout << (( res [ i ] == -1 ) ? 0 : ( res [ i ] + 1 )) << ' ' ; } return 0 ; } \u6742\u9879 \u00b6 \u79bb\u6563\u5316 \u00b6 Funs || Methods Reliance Time Complexity Inputs Outputs Description copy_to_b N a\uff1a\u6570\u7ec4 b \u590d\u5236a\u5230b sort_and_unique copy_to_b nlogn n\uff1a\u957f\u5ea6\uff1bb\uff1a\u79bb\u6563\u5316\u540e\u6570\u7ec4 dlen\uff1a\u53bb\u91cd\u540e\u7684\u6570\u7ec4\u957f\u5ea6 \u5bf9b\u6392\u5e8f\u3001\u53bb\u91cd\uff0c\u8fd4\u56de\u53bb\u91cd\u540e\u7684\u6570\u7ec4\u957f\u5ea6 get_id sort_and_unique logn x:\u67e5\u627e\u503c\uff1bb\uff1a\u79bb\u6563\u5316\u540e\u6570\u7ec4\uff1b \u8fd4\u56de\u79bb\u6563\u5316\u540e\u7684\u503c \u8fd4\u56de\u79bb\u6563\u5316\u540e\u7684\u503c\uff081\u5f00\u59cb\u8ba1\u6570\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 typedef long long ll ; namespace Discretization { const int N = 1e6 + 10 ; typedef ll Ty ; //public Ty a [ N ], b [ N ]; int dlen ; // \u590d\u5236a\u5230b void copy_to_b () { memcpy ( b , a , sizeof ( a )); } // \u5bf9b\u6392\u5e8f\u3001\u53bb\u91cd\uff0c\u8fd4\u56de\u53bb\u91cd\u540e\u7684\u6570\u7ec4\u957f\u5ea6 int sort_and_unique ( int n ) { sort ( b + 1 , b + 1 + n ); return dlen = unique ( b + 1 , b + 1 + n ) - b -1 ; } // \u8fd4\u56de\u79bb\u6563\u5316\u540e\u7684\u503c\uff081\u5f00\u59cb\u8ba1\u6570\uff09 inline int get_id ( Ty x ) { return lower_bound ( b + 1 , b + 1 + dlen , x ) - b ; } } using namespace Discretization ; \u5feb\u8bfb \u00b6 \u6ce8\u610f\uff1a\u7528\u5feb\u8bfb\u7684\u65f6\u5019\u52a1\u5fc5\u8981\u628a ios::sync_with_stdio(false); \u6ce8\u91ca\u6389\uff01 Funs || Methods Reliance Time Complexity Inputs Outputs Description read 1 \u6574\u6570\u53d8\u91cfx \u8bfb\u5165x \u8bfb\u5165x print 1 \u6574\u6570\u53d8\u91cfx \u8f93\u51fax\uff08\u4e0d\u5305\u62ec\u6362\u884c\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 #include <cstdio> #include <iostream> using namespace std ; namespace Fast_IO { char __nc () { static char buf [ 1000000 ], * p = buf , * q = buf ; return p == q && ( q = ( p = buf ) + fread ( buf , 1 , 1000000 , stdin ), p == q ) ? EOF : * p ++ ; } template < typename T > inline void read ( T & x ) { char c ; int sgn = 1 ; x = 0 ; c = __nc (); while ( c > '9' || c < '0' ) { if ( c == '-' ) sgn = -1 ; c = __nc (); } while ( c <= '9' && c >= '0' ) { x = ( x << 3 ) + ( x << 1 ) + ( c - '0' ); c = __nc (); } x *= sgn ; } template < typename T > inline void print ( T x ) { if ( x < 0 ) { putchar ( '-' ); x = - x ; } if ( x > 9 ) { print ( x / 10 ); } putchar ( x % 10 + '0' ); } void readstr ( char * a ) { char c ; c = __nc (); while ( ! ( c <= 'z' && c >= 'a' )) c = __nc (); while ( c <= 'z' && c >= 'a' ) { * a = c ; a ++ ; c = __nc (); } } } // namespace Fast_IO using namespace Fast_IO ; int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ), cout . tie ( 0 ); long long x ; read ( x ); print ( x ); putchar ( '\\n' ); print ( - x ); putchar ( '\\n' ); print ( 0 ); putchar ( '\\n' ); return 0 ; } nth_element \u00b6 1 nth_element ( a + 1 , a + k , a + n + 1 ); #include <algorithm> \u5185\u7f6e\u51fd\u6570\u3002\u7b2ck\u540d\u5c06\u5728a[k]\u5904\uff0c\u6bd4\u5b83\u5c0f\u7684\u6240\u6709\u5143\u7d20\u5728\u5de6\u4fa7\uff0c\u6bd4\u4ed6\u5927\u7684\u6240\u6709\u5143\u7d20\u5728\u53f3\u4fa7\u3002 \u4e8c\u5206 \u00b6 \u53ea\u662f\u8bb0\u4e00\u4e0b\uff0c\u4e00\u822c\u4e0d\u4f1a\u771f\u7684\u624b\u5199\u3002\u5305\u62ec\u4e00\u822c\u7684lowerbound\u548c\u53cd\u8fc7\u6765\u7248\u672c\u7684lowerbound\u3002\u6539\u6210upperbound\uff0c\u5219\u53ea\u9700\u8981\u6539\u4e00\u4e0b\u5224\u65ad\u5408\u6cd5\u6027\u7684\u6761\u4ef6\u3002\u8bf7\u52a1\u5fc5\u4fdd\u8bc1\u7b54\u6848\u5728l\u3001r\u5185\u5b58\u5728\u3002 \u53e3\u8bc0\uff1a\u4ee5o\u4e3a\u6b63\u65b9\u5411\uff0c\u53cd\u5411\u53d6\u6574\uff0c\u201c\u5426\u5219\u201d\u53cd\u5411+\u8d21\u732e\uff0c\u201c\u8d21\u732e\u201d\u6b63\u5411\u3002 Funs || Methods Reliance Time Complexity Inputs Outputs Description bs_lowerbound logn L\u3001R\uff1a\u641c\u7d22\u4e0b\u6807\u8303\u56f4\uff0ca\uff1a\u641c\u7d22\u5e8f\u5217\uff0cx\uff1a\u6bd4\u8f83\u503c \u540c\u63cf\u8ff0 \u627e\u5230\u5e8f\u5217a\u4e2d\u5728\u8303\u56f4\u5185\u7684>=x\u6700\u5c0f\u7684\u4e00\u4e2a\uff0c\u5e76\u8fd4\u56de\u5176\u503c bs_lowerbound2 logn L\u3001R\uff1a\u641c\u7d22\u4e0b\u6807\u8303\u56f4\uff0ca\uff1a\u641c\u7d22\u5e8f\u5217\uff0cx\uff1a\u6bd4\u8f83\u503c \u540c\u63cf\u8ff0 \u627e\u5230\u5e8f\u5217a\u4e2d\u5728\u8303\u56f4\u5185\u7684<= x\u6700\u5927\u7684\u4e00\u4e2a\uff0c\u5e76\u8fd4\u56de\u5176\u503c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 namespace BS { //\u627e\u5230>=x\u4e2d\u6700\u5c0f\u7684\u4e00\u4e2a template < typename T > T bs_lowerbound ( T L , T R , T a [], T x ) { T l = L , r = R ; //\u5de6x\u53f3o\uff1a\u5411\u4e0b\u53d6\u6574\uff0c\u201c\u5426\u5219\u201d\u4e3a\u5de6\uff0c+1\uff08\u5411\u53f3\uff09 while ( l < r ) { T mid = ( l + r ) >> 1 ; //\u6ce8\u610f\u8fd9\u6837\u5199\u662f\u5411\u4e0b\u53d6\u6574\uff0c\u7528\u9664\u6cd5\u662f\u54110\u53d6\u6574\uff0cl\u548cr\u4e3a\u8d1f\u6570\u65f6\u53ef\u80fd\u6709\u5f71\u54cd if ( a [ mid ] >= x ) r = mid ; else l = mid + 1 ; } return a [ l ]; } //\u627e\u5230<=x\u4e2d\u6700\u5927\u7684\u4e00\u4e2a template < typename T > T bs_lowerbound2 ( T L , T R , T a [], T x ) { T l = L , r = R ; while ( l < r ) { T mid = ( l + r + 1 ) >> 1 ; //\u6ce8\u610f\u8fd9\u6837\u5199\u662f\u5411\u4e0b\u53d6\u6574\uff0c\u7528\u9664\u6cd5\u662f\u54110\u53d6\u6574\uff0cl\u548cr\u4e3a\u8d1f\u6570\u65f6\u53ef\u80fd\u6709\u5f71\u54cd if ( a [ mid ] <= x ) l = mid ; else r = mid -1 ; } return a [ l ]; } } \u4e09\u5206 \u00b6 \u8fd9\u662f\u627e\u6700\u5c0f\u503c\u7684\u8fde\u7eed\u503c\u57df\u4e09\u5206\u3002\u5207\u8bb0\u4e0d\u80fd\u76f4\u63a5\u7528\u4e8e\u79bb\u6563\u503c\uff01\uff08\u9664\u975e\u9898\u76ee\u6709\u4efb\u4f55\u6027\u8d28\u4fdd\u8bc1\u4e86\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 namespace TS { template < typename T = double > T ts_findmin ( T l , T r , T ( * f )( T ), T eps = 1e-9 ) { //r>l T param = 0.01 ; while ( r - l >= eps ) { T mid = ( l + r ) / 2 ; T lmid = mid - ( r - l ) * param , rmid = mid + ( r - l ) * param ; if ( f ( lmid ) > f ( rmid )) { l = lmid ; } else r = rmid ; } return f ( r ); } } double f ( double x ) { return x * x ; } int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ), cout . tie ( 0 ); cout << TS :: ts_findmin ( -2.0 , 5.0 , f ) << endl ; return 0 ; } int128 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include <iostream> #include <cstdio> using namespace std ; void scan ( __int128_t & x ) //\u8f93\u5165 { x = 0 ; int f = 1 ; char ch ; if (( ch = getchar ()) == '-' ) f = - f ; else x = x * 10 + ch - '0' ; while (( ch = getchar ()) >= '0' && ch <= '9' ) x = x * 10 + ch - '0' ; x *= f ; } void print ( __int128_t x ) { if ( x < 0 ) { x = - x ; putchar ( '-' ); } if ( x > 9 ) print ( x / 10 ); putchar ( x % 10 + '0' ); } int main () { ios :: sync_with_stdio ( false ); __int128_t a , b ; scan ( a ); scan ( b ); print ( a + b ); return 0 ; } \u2b50\u5206\u6570\u7c7b \u00b6 \u6ce8\u610f\u8fd9\u4e2a\u9b3c\u4e1c\u897f\u5728\u5bf90\u7684\u5224\u65ad\u4e0a\u53ef\u80fd\u6709\u70b9\u95ee\u9898 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 ll gcd ( ll a , ll b ) { return b ? gcd ( b , a % b ) : a ; } struct Fr { ll x , y ; Fr ( ll xx , ll yy ) { if ( yy == 0 ) { x = xx ; y = yy ; return ; } ll g = gcd ( xx , yy ); x = xx / g ; y = yy / g ; } Fr () : x ( 0 ), y ( 1 ) {} Fr ( ll x ) : x ( x ), y ( 1 ) {} bool operator < ( const Fr & a ) const { if ( a == Fr ( 0 , 0 )) { if ( x == 0 && y == 0 ) return false ; return true ; } if ( x == 0 && y == 0 ) { return false ; } return x * a . y < y * a . x ; } bool operator > ( const Fr & a ) const { if ( a == Fr ( 0 , 0 )) { //if(x==0 && y==0) return false; return false ; } if ( x == 0 && y == 0 ) { return true ; } return x * a . y > y * a . x ; } bool operator == ( const Fr & a ) const { if ( a . x == 0 && a . y == 0 ) { if ( x == 0 && y == 0 ) return true ; return false ; } if ( x == 0 && y == 0 ) { if ( a . x == 0 && a . y == 0 ) return true ; return false ; } return x * a . y == y * a . x ; } Fr operator + ( const Fr & a ) const { return Fr ( x * a . y + y * a . x , y * a . y ); } Fr operator - ( const Fr & a ) const { return Fr ( x * a . y - y * a . x , y * a . y ); } Fr operator * ( const Fr & a ) const { return Fr ( x * a . x , y * a . y ); } Fr operator / ( const Fr & a ) const { return Fr ( x * a . y , y * a . x ); } bool is_frac () const { if ( y == 0 ) return false ; return x % y != 0 ; } }; \u6700\u5c0f\u4e8c\u4e58\u6cd5 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <cstdlib> #include <algorithm> #include <string> #include <vector> #include <map> #include <unordered_map> #include <set> #include <unordered_set> #include <queue> using namespace std ; typedef long long ll ; const int N = 2e5 + 10 ; int T ; int m ; ll a1 [ N ], a2 [ N ], b [ N ]; pair < double , double > get_kb ( ll a [], ll b [], ll n ) { ll x = 0 , y = 0 , xy = 0 , x2 = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { x += a [ i ]; y += b [ i ]; xy += a [ i ] * b [ i ]; x2 += a [ i ] * a [ i ]; } double k = ( n * xy - x * y ) / ( n * x2 - x * x ); double bb = ( y * x2 - x * xy ) / ( n * x2 - x * x ); return { k , bb }; } int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ), cout . tie ( 0 ); cin >> T ; for ( int _ = 1 ; _ <= T ; _ ++ ) { scanf ( \"%d\" , & m ); for ( int i = 1 ; i <= m ; i ++ ) { scanf ( \"%lld\" , & a1 [ i ]); } for ( int i = 1 ; i <= m ; i ++ ) { scanf ( \"%lld\" , & a2 [ i ]); } for ( int i = 1 ; i <= m ; i ++ ) { scanf ( \"%lld\" , & b [ i ]); } double k1 , b1 , k2 , b2 ; tie ( k1 , b1 ) = get_kb ( a1 , b , m ); tie ( k2 , b2 ) = get_kb ( a2 , b , m ); double ans1 = 0 , ans2 = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { ans1 += fabs ( b [ i ] - ( k1 * a1 [ i ] + b1 )); ans2 += fabs ( b [ i ] - ( k2 * a2 [ i ] + b2 )); } if ( ans1 > ans2 ) { printf ( \"2 \\n \" ); } else printf ( \"1 \\n \" ); } return 0 ; } \u5b50\u96c6\u679a\u4e3e\u4e0egospers_hack \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <cstdlib> #include <algorithm> #include <string> #include <vector> #include <map> #include <unordered_map> #include <set> #include <unordered_set> #include <queue> using namespace std ; typedef long long ll ; const int N = 2e5 + 10 ; //\u904d\u5386n\u4e2d\u9009k\u4e2a\u7684\u6240\u6709\u96c6\u5408 //GH(3,5): 00111,01011,...,11100 auto GospersHack ( int k , int n ) { int cur = ( 1 << k ) - 1 ; int limit = ( 1 << n ); vector < int > res ; while ( cur < limit ) { res . push_back ( cur ); // do something int lb = cur & - cur ; int r = cur + lb ; cur = (( r ^ cur ) >> __builtin_ctz ( lb ) + 2 ) | r ; // \u6216\uff1acur = (((r ^ cur) >> 2) / lb) | r; } return res ; } //\u679a\u4e3e\u5b50\u96c6 void it_subset ( int sta ) { for ( int sub = sta ; sub > 0 ; sub = ( sub - 1 ) & sta ) { //do something... } //bit:sta\u7684\u4e8c\u8fdb\u5236\u4e0b\u4f4d\u6570-1\uff0c\u76f8\u5f53\u4e8e\u5bf92\u53d6log int bit = 31 - __builtin_clz ( sta ); //\u53d6\u5f97\u5b50\u96c6\u548c\uff08\u4e0b\u6807\u4ece0\u5f00\u59cb\u8ba1\u6570\uff09\uff1a\u4f8b\u59821101\u8868\u793a\u4e0b\u6807\u4e3a0\u30012\u30013\u7684\u5143\u7d20\u7684\u548c for ( int sta = 1 ; sta < ( 1 << n ); ++ sta ) { //__builtin_clz : \u4e8c\u8fdb\u5236\u524d\u5bfc\u96f6\u4e2a\u6570 //bit\uff1a\u5728\u8fd9\u91cc\u662f\u76f8\u5f53\u4e8e\u5bf92\u53d6log\u7684\u7ed3\u679c int bit = 31 - __builtin_clz ( sta ); f [ sta ] = add ( f [ sta ^ ( 1 << bit )], a [ bit ]); } } // \u2022int __builtin_ffs (unsigned int x) // \u8fd4\u56dex\u7684\u6700\u540e\u4e00\u4f4d1\u7684\u662f\u4ece\u540e\u5411\u524d\u7b2c\u51e0\u4f4d\uff0c\u6bd4\u59827368\uff081110011001000\uff09\u8fd4\u56de4\u3002 // \u2022int __builtin_clz (unsigned int x) // \u8fd4\u56de\u524d\u5bfc\u76840\u7684\u4e2a\u6570\u3002\uff08int 1\u7684\u8fd4\u56de\u503c\u662f31\uff0c2\u30013\u662f30\uff0c4~7\u662f29\uff09 // \u2022int __builtin_ctz (unsigned int x) // \u8fd4\u56de\u540e\u9762\u76840\u4e2a\u4e2a\u6570\uff0c\u548c__builtin_clz\u76f8\u5bf9\u3002 // \u2022int __builtin_popcount (unsigned int x) // \u8fd4\u56de\u4e8c\u8fdb\u5236\u8868\u793a\u4e2d1\u7684\u4e2a\u6570\u3002 // \u2022int __builtin_parity (unsigned int x) // \u8fd4\u56dex\u7684\u5947\u5076\u6821\u9a8c\u4f4d\uff0c\u4e5f\u5c31\u662fx\u76841\u7684\u4e2a\u6570\u6a212\u7684\u7ed3\u679c\u3002 // \u6b64\u5916\uff0c\u8fd9\u4e9b\u51fd\u6570\u90fd\u6709\u76f8\u5e94\u7684usigned long\u548cusigned long long\u7248\u672c\uff0c\u53ea\u9700\u8981\u5728\u51fd\u6570\u540d\u540e\u9762\u52a0\u4e0al\u6216ll\u5c31\u53ef\u4ee5\u4e86\uff0c\u6bd4\u5982int __builtin_clzll\u3002 int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ), cout . tie ( 0 ); auto res = GospersHack ( 3 , 5 ); for ( auto v : res ) cout << v << \" \" ; return 0 ; } \u5bf9\u62cd \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 import os import random as rd import sys import time def generate_one_case () : n = rd . randint ( 1 , 30 ) k = rd . randint ( 1 , n ) print ( n , k ) for i in range ( n ) : val = rd . randint ( 1 , 50 ) print ( val , end = ' ' ) print () def generate_multi_case () : T = rd . randint ( 1 , 10 ) print ( T ) for i in range ( T ) : generate_one_case () print ( flush = True ) namae = \"k\" for _ in range ( 10000 ) : sys . stdout = open ( f \"{namae}_in.txt\" , \"w\" ) generate_multi_case () t1 = time . perf_counter () os . system ( f \"{namae}.exe < {namae}_in.txt >{namae}_out.txt\" ) t2 = time . perf_counter () print (( t2 - t1 ) * 1000 , file = sys . stderr ) t1 = time . perf_counter () os . system ( f \"{namae}_std.exe < {namae}_in.txt >{namae}2_out.txt\" ) t2 = time . perf_counter () print (( t2 - t1 ) * 1000 , file = sys . stderr ) if os . system ( f \"fc {namae}_out.txt {namae}2_out.txt\" ) : print ( \"WA\" , file = sys . stderr ) exit ( 0 ) print ( \"AC\" , file = sys . stderr ) \u6a21\u62df\u9000\u706b \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 //P1337 [JSOI2004]\u5e73\u8861\u70b9 / \u540a\u6253XXX // \u6c42n\u4e2a\u70b9\u7684\u5e26\u6743\u91cd\u5fc3\uff0c\u7b49\u4ef7\u4e8e\u6700\u5c0f\u5316\u67d0\u4e2a\u51fd\u6570\u503c #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <cstdlib> #include <algorithm> #include <string> #include <vector> #include <map> #include <unordered_map> #include <set> #include <unordered_set> #include <queue> #include <ctime> #include <random> #include <iomanip> using namespace std ; typedef long long ll ; const int N = 2e5 + 10 ; using ll = long long ; using ld = long double ; int n ; struct Point { ld x , y , w ; } a [ N ]; namespace Anneal { //do something... //public ld ansx , ansy , ansval ; ld nowx , nowy , nowval ; //ansx,ansy,ansval:\u5f53\u524d\u7ef4\u62a4\u7684\u6700\u597d\u7b54\u6848\uff0c\u56e0\u9898\u800c\u5f02 //nowx,nowy,nowval\uff1a\u5f53\u524d\u7684\u7b54\u6848\uff0c\u540c\u4e0a\uff0c\u56e0\u9898\u800c\u5f02 //do something end. //local ld t , tt ; ld D ; ld eps ; mt19937 rnd ( time ( 0 )); //t\uff1a\u6e29\u5ea6 //d\uff1a\u5355\u6b21\u964d\u6e29\u6bd4\u4f8b //eps\uff1a\u6700\u5927\u7cbe\u5ea6\u8bef\u5dee //rnd\uff1a\u968f\u673a\u6570\u751f\u6210\u5668 //\u751f\u6210\u968f\u673a\u6d6e\u70b9\u6570 inline ld __Rand () { return ( ld ) rand () / RAND_MAX ; } //\u751f\u6210\u968f\u673a\u6574\u6570 inline int __randint ( int r ) { return rnd () % r + 1 ; } //\u8ba1\u7b97\u8861\u91cf\u7528\u51fd\u6570\u503c ld calval ( ld x , ld y ) { //do something... ld ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { ld dx = a [ i ]. x - x , dy = a [ i ]. y - y ; ans += a [ i ]. w * sqrt ( dx * dx + dy * dy ); } return ans ; //do something end. } //\u968f\u673a\u6539\u53d8\u503c void rand_change () { //do something... ld nextx = nowx + t * ( __Rand () * 2-1 ); ld nexty = nowy + t * ( __Rand () * 2-1 ); ld delta = calval ( nextx , nexty ) - nowval ; //\u80fd\u91cf\u5dee\u503c //\u91cd\u8981\u516c\u5f0f\uff1a\u53d1\u751f\u8f6c\u79fb\u7684\u51e0\u7387P(delta E)=e^(-delta E/T) \uff08\u65b0\u72b6\u6001\u66f4\u52a3\u65f6\uff09 if ( delta < 0 || exp ( - delta / t ) > __Rand ()) // if( exp(-delta/t) > __Rand()) { ld tmp = nowval + delta ; tie ( nowx , nowy , nowval ) = tie ( nextx , nexty , tmp ); } if ( nowval < ansval ) { tie ( ansx , ansy , ansval ) = tie ( nowx , nowy , nowval ); } //do something end. } int __cnt = 0 ; auto anneal () { //init tt = t = 100000 ; D = 0.97 ; eps = 0.001 ; srand ( time ( 0 )); //do something... //init2 ansx = nowx = ansy = nowy = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { ansx += a [ i ]. x ; ansy += a [ i ]. y ; } ansx /= n ; ansy /= n ; // ansx=0.577; // ansy=1.000; ansval = calval ( ansx , ansy ); nowx = ansx ; nowy = ansy ; nowval = ansval ; // cerr<<\"init_ansx:\"<<ansx<<endl; // cerr<<\"init_ansy:\"<<ansy<<endl; // cerr<<\"init_ansval:\"<<ansval<<endl; while ( t >= eps ) { rand_change (); t *= D ; __cnt ++ ; } //do something end. // cerr<<\"__cnt:\"<<__cnt<<endl; // cerr<<\"nowval:\"<<nowval<<endl; // cerr<<\"ansval:\"<<ansval<<endl; //\u7ec6\u5316\u7cbe\u5ea6\uff0c\u5bf9\u4e8e\u8fd9\u9898\u6765\u8bf4\u662f\u5fc5\u8981\u7684 for ( int i = 1 ; i <= 3000 ; i ++ ) { ld nextx = ansx + t * ( __Rand () * 2-1 ); ld nexty = ansy + t * ( __Rand () * 2-1 ); ld delta = calval ( nextx , nexty ) - ansval ; //\u80fd\u91cf\u5dee\u503c if ( delta < 0 ) { ld tmp = ansval + delta ; tie ( ansx , ansy , ansval ) = tie ( nextx , nexty , tmp ); } } return make_pair ( ansx , ansy ); } } using namespace Anneal ; int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ), cout . tie ( 0 ); cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> a [ i ]. x >> a [ i ]. y >> a [ i ]. w ; } anneal (); cout << fixed << setprecision ( 3 ) << ansx << \" \" << ansy << endl ; // cout<<ansx<<\" \"<<ansy<<endl; return 0 ; } \u2b50\u5206\u9694\u5b57\u7b26\u4e32 in C++ \u00b6 \u81e8\u6642\u5f9e Algorithm_Design_and_other/pattern_recognition/classify.cpp\u88e1\u9762\u6284\u7684 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 //\u5b9e\u7528\u7c7b\u51fd\u6570 namespace __Utility { //\u975e\u6570\u636e\u7279\u5f81\u540d unordered_set < string > No_data_strings_name { \"Id\" , \"Species\" }; //\u975e\u6570\u636e\u7279\u5f81\u4f4d\u7f6e\u5bf9\u5e94\u7684\u540d\u5b57 unordered_map < int , string > No_data_strings { { 0 , \"Id\" }, { 5 , \"Species\" } }; //\u5206\u5272\u5b57\u7b26\u4e32 auto split_str ( const string & s , char split_char = ',' ) { vector < string > res ; //lambda auto string_find_first_not = []( const string & s , size_t pos = 0 , char split_char = ',' ) { for ( size_t i = pos ; i < s . size (); i ++ ) { if ( s [ i ] != split_char && s [ i ] != ' ' && s [ i ] != '\\t' ) return i ; } return string :: npos ; }; size_t begin_pos = string_find_first_not ( s , 0 , split_char ); size_t end_pos = s . find ( split_char , begin_pos ); while ( begin_pos != string :: npos ) { size_t end_pos2 = end_pos -1 ; while ( begin_pos < end_pos2 && ( s [ end_pos2 ] == '\\t' || s [ end_pos2 ] == ' ' )) { end_pos2 -- ; } res . emplace_back ( s . substr ( begin_pos , end_pos2 + 1 - begin_pos )); begin_pos = string_find_first_not ( s , end_pos , split_char ); end_pos = s . find ( split_char , begin_pos ); } return res ; } //\u5b57\u7b26\u4e32\u8f6cdouble double str_to_double ( const string & s ) { return atof ( s . c_str ()); } //\u5b57\u7b26\u4e32\u8f6cint int str_to_int ( const string & s ) { return atoi ( s . c_str ()); } } // namespace __Utility \u53ef\u53cd\u6094\u8d2a\u5fc3 \u00b6 Luogu 1484 \u79cd\u6811 \u9898\u610f\uff1a\u6709N\u4e2a\u5751\uff0c\u6bcf\u4e2a\u5751\u53ef\u4ee5\u79cd\u6811\uff0c\u4e14\u83b7\u5229a[i]\uff08\u53ef\u4ee5\u4e3a\u8d1f\uff09\u3002\u4efb\u4f55\u76f8\u90bb\u4e24\u4e2a\u5751\u91cc\u4e0d\u80fd\u90fd\u79cd\u6811\uff0c\u95ee\u5728\u6700\u591a\u79cdK\u68f5\u6811\u7684\u524d\u63d0\u4e0b\u7684\u6700\u5927\u83b7\u5229 \u505a\u6cd5\uff1a\u6bcf\u4e2a\u8282\u70b9\u5f00\u4e2a\u94fe\u8868\uff0c\u79cd\u6811\u4ee5\u540e\u5408\u5e76\u94fe\u8868\u4e24\u7aef\u8282\u70b9\uff0c\u7136\u540e\u63d2\u5165\u4f18\u5148\u961f\u5217\u4e2d\u7ef4\u62a4\u3002\u6bcf\u6b21\u8981\u79cd\u54ea\u68f5\u6811\u7531\u4f18\u5148\u961f\u5217\u4e2d\u7684\u961f\u5934\u8282\u70b9\u786e\u5b9a\u3002 \u8fd9\u4e48\u505a\u53ef\u4ee5\u4fdd\u8bc1\u6bcf\u6b21\u90fd\u53ea\u591a\u79cd\u4e00\u68f5\u6811\uff08\u76f8\u5f53\u4e8e\u53ea\u82b1\u8d391\u7684\u4ee3\u4ef7\uff09\uff0c\u5e76\u4e14\u5f97\u5230\u7684\u8d21\u732e\u5c31\u662f\u4e2d\u5bf9\u5e94\u8fd9\u4e48\u591a\u6570\u7684\u6700\u5927\u503c\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <cstdlib> #include <algorithm> #include <queue> using namespace std ; typedef long long ll ; const int N = 2e6 + 10 ; int T ; ll n , k ; struct Node { ll val ; ll lc , rc , ct ; //ct: center bool operator < ( const Node & b ) const { return val < b . val ; } } nd [ N ]; bool vis [ N ]; void dpdp () { priority_queue < Node > q ; for ( int i = 1 ; i <= n ; i ++ ) { q . push ( nd [ i ]); } ll ans = 0 ; bool flag = true ; while ( k -- ) { while ( vis [ q . top (). ct ]) { q . pop (); } auto u = q . top (); auto index = u . ct ; if ( u . val <= 0 ) { flag = false ; break ;} //\u5982\u679c\u662f\u4e00\u5b9a\u8981\u79cd\u90a3\u4e48\u591a\u6570\u5c31\u8bf7\u53bb\u6389\u8fd9\u4e2a ans += u . val ; q . pop (); // merge node nd [ index ]. val = nd [ nd [ index ]. lc ]. val + nd [ nd [ index ]. rc ]. val - nd [ index ]. val ; //list merge vis [ nd [ index ]. lc ] = vis [ nd [ index ]. rc ] = 1 ; nd [ index ]. lc = nd [ nd [ index ]. lc ]. lc ; nd [ nd [ index ]. lc ]. rc = index ; nd [ index ]. rc = nd [ nd [ index ]. rc ]. rc ; nd [ nd [ index ]. rc ]. lc = index ; q . push ( nd [ index ]); } if ( true ) { cout << ans << endl ; } else { cout << \"Error!\" << endl ; } } int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ), cout . tie ( 0 ); cin >> n >> k ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> nd [ i ]. val ; nd [ i ]. lc = i -1 ; nd [ i ]. rc = i + 1 ; nd [ i ]. ct = i ; vis [ i ] = 0 ; } // nd[1].lc=n; \u6709\u73af\u7684\u60c5\u51b5\uff08\u5bf9\u5e94luogu 1792\uff09 // nd[n].rc=1; dpdp (); return 0 ; } \u7ecf\u5178\u4e8c\u9009\u4e00\u95ee\u9898\uff082021icpc\u4e0a\u6d77\u7684\u67d0\u9898\uff09 \u00b6 \u95ee\u9898\uff1an\u4e2a\u6709\u5e8f\u5bf9ai,bi\uff0c\u5bf9\u4e8e\u6bcf\u4e2a\u6709\u5e8f\u5bf9\uff0c\u9009\u62e9\u5c06ai\u52a0\u5165set A\u6216\u8005\u5c06bi\u52a0\u5165set B\uff0c\u6700\u5c0f\u5316max(A)+max(B)\uff0c\uff08\u7a7a\u96c6\u65f6\u4e3a0\uff09 \u89e3\u6cd5\uff1a \u5148\u5c06\u6709\u5e8f\u5bf9\u6309ai\u4e3a\u7b2c\u4e00\u5173\u952e\u5b57\u6392\u5e8f\u3002\u7531\u4e8eai<=aj && bi<=bj\u65f6\uff0c \u53ef\u4ee5\u820d\u5f03ai,bi\uff08\u8fd9\u662f\u56e0\u4e3a\u8f83\u5927\u7684\u90a3\u4e2a\u5728\u6700\u4f18\u89e3\u4e2d\u4e00\u5b9a\u4f1a\u5728aj,bj\u4e2d\u9009\u4e00\u4e2a\uff0c\u800c\u6b64\u65f6ai,bi\u7684\u9009\u6cd5\u53ea\u8981\u8ddfaj,bj\u7684\u9009\u6cd5\u5c31\u4e00\u5b9a\u4e0d\u4f1a\u4f7f\u5f97\u7b54\u6848\u589e\u5927\uff09\uff0c\u56e0\u6b64\u9700\u8981\u4fdd\u8bc1\u5904\u7406\u540e\u7684\u5e8f\u5217\u4e2d\uff0cbi\u968fi\u5355\u8c03\u9012\u51cf\uff0c\u56e0\u6b64\u5012\u7740\u626b\u4e00\u904d\u5220\u9664\u7834\u574fbi\u5355\u8c03\u6027\u7684\u5143\u7d20\u5373\u53ef\u3002\u5177\u4f53\u5b9e\u73b0\u65f6\u4e0d\u662f\u771f\u7684\u5220\u9664\u800c\u662f\u65b0\u5f00\u4e00\u4e2a\u5217\u8868\u505a\u8fd9\u4e2a\u64cd\u4f5c\u3002 \u4e4b\u540e\uff0c\u5bf9\u4e8e\u67d0\u4e2aaj\uff0c\u53ea\u8981\u786e\u5b9a\u9009\u4e86j\uff0c\u90a3\u4e48\u6240\u6709\u6bd4j\u5927\u7684i\u90fd\u53ef\u4ee5\u5728\u4e0d\u589e\u52a0\u7b54\u6848\u7684\u524d\u63d0\u4e0b\u9009\u62e9ai\uff0cbj\u540c\u7406\u53ef\u4ee5\u5728\u4e0d\u589e\u52a0\u7b54\u6848\u7684\u524d\u63d0\u4e0b\u9009\u62e9\u6bd4j\u5c0f\u7684i\uff0c\u56e0\u6b64\u6700\u7ec8\u7b54\u6848\u51fa\u73b0\u5728 a1, a2+b1, a3+b2, ... , an+b_{n-1}, bn\u4e2d\u3002\u626b\u63cf\u4e00\u904d\u5373\u53ef\u5f97\u7b54\u6848\u3002 cf1408 D Searchlights \u00b6 \u9898\u610f\uff1a\u6709\u82e5\u5e72\u4e2a\u5f3a\u76d7\u548c\u63a2\u7167\u706f\uff0c\u7ed9\u51fa\u4ed6\u4eec\u7684\u5750\u6807\uff080\u52301e6\u8303\u56f4\u5185\uff09\uff0c\u706f\u80fd\u770b\u5230\u5f3a\u76d7\u5f53\u4e14\u4ec5\u5f53\u706f\u4e0d\u4e25\u683c\u5728\u5f3a\u76d7\u7684\u53f3\u4e0a\u65b9\u3002\u73b0\u5728\u80fd\u4e00\u6b21\u6027\u79fb\u52a8\u6240\u6709\u7684\u5f3a\u76d7\u5411\u4e0a\u6216\u5411\u53f3\u4e00\u6b65\uff0c\u95ee\u6700\u5c11\u9700\u8981\u591a\u5c11\u6b65\u6570\u624d\u80fd\u628a\u5f3a\u76d7\u5168\u90e8\u79fb\u51fa\u53bb\u3002 \u89e3\u6cd5\uff1a\u7b97\u51fa\u6bcf\u4e2a\u5f3a\u76d7\u5411\u4e0a\u548c\u5411\u53f3\u8d70\u6240\u9700\u7684\u6b65\u6570\u3002\u9898\u76ee\u5c31\u53d8\u6210\u4e86\u6700\u5c0f\u5316\u6700\u5927\u503c\u3002\u5957\u7528\u5373\u53ef\u3002 \uff08\u4e0a\u6d77\u7684H\u9898\u7684\u505a\u6cd5\u53c2\u8003oi\u505a\u9898\u8bb0\u5f55\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 #include <iostream> #include <cstdio> #include <algorithm> #include <memory.h> using namespace std ; int T ; int n , k ; const int N = 2e5 + 10 ; int a [ N ], b [ N ]; pair < int , int > li [ N ], li2 [ N ]; int li_p , li_p2 ; long long upd ( int n ) { li_p2 = 0 ; sort ( li + 1 , li + 1 + n ); pair < int , int > last = li [ n ]; li2 [ ++ li_p2 ] = last ; for ( int i = n -1 ; i >= 1 ; i -- ) { if ( li [ i ]. second > last . second ) { li2 [ ++ li_p2 ] = li [ i ]; last = li [ i ]; } } long long ans = min ( li2 [ 1 ]. first , li2 [ li_p2 ]. second ); for ( int i = 2 ; i <= li_p2 ; i ++ ) { ans = min ( ans ,( long long ) li2 [ i ]. first + li2 [ i -1 ]. second ); } return ans ; } int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); cin >> T ; while ( T -- ) { cin >> n >> k ; for ( int i = 1 ; i <= k ; i ++ ) { cin >> a [ i ]; } for ( int i = 1 ; i <= k ; i ++ ) { cin >> b [ i ]; } sort ( a + 1 , a + 1 + k ); sort ( b + 1 , b + 1 + k ); long long ans = 1e18 ; for ( int i = 1 ; i <= k ; i ++ ) //enumerate first match who; { li_p = 0 ; for ( int j = 1 ; j <= k ; j ++ ) //match { int L , R ; //L L = (( b [( j + i -2 ) % k + 1 ] - a [ j ]) % n + n ) % n ; //\u6ce8\u610f\u4e0b\u6807\u8d8a\u754c R = (( a [ j ] - b [( j + i -2 ) % k + 1 ]) % n + n ) % n ; li [ ++ li_p ] = { 2 * L , R }; } ans = min ( ans , upd ( li_p )); li_p = 0 ; for ( int j = 1 ; j <= k ; j ++ ) //match { int L , R ; //L L = (( b [( j + i -2 ) % k + 1 ] - a [ j ]) % n + n ) % n ; R = (( a [ j ] - b [( j + i -2 ) % k + 1 ]) % n + n ) % n ; li [ ++ li_p ] = { L , R * 2 }; } ans = min ( ans , upd ( li_p )); } cout << ans << endl ; } return 0 ; }","title":"\u81ea\u5236Template"},{"location":"old/%E8%87%AA%E5%88%B6Template/#template","text":"","title":"\u81ea\u5236Template"},{"location":"old/%E8%87%AA%E5%88%B6Template/#_1","text":"\u6570\u636e\u7ed3\u6784\uff1a\u4f7f\u7528namespace+struct\u5c01\u88c5\u3002 \u6563\u88c5\u51fd\u6570\uff1a\u4f7f\u7528namespace\u5c01\u88c5 \u65b9\u6cd5\u3001\u51fd\u6570\u524d\u4f7f\u7528\u6ce8\u91ca\u63cf\u8ff0\u529f\u80fd\u3001\u5f62\u53c2\u8bf4\u660e\u548c\u8fd4\u56de\u503c\u8bf4\u660e namespace \u6700\u5f00\u5934\u662f\u5e38\u91cf\u5b9a\u4e49\uff08\u6bd4\u5982MAXsize\u4e4b\u7c7b\u7684\uff09\uff0c\u7136\u540e\u4f7f\u7528\u7a7a\u884c\u548c\u6ce8\u91ca\u533a\u5206local\u53d8\u91cf\u548cpublic\u53d8\u91cf \u4ec5struct\u6216namespace\u5185\u4f7f\u7528\u7684\u51fd\u6570\u4f7f\u7528\u53cc\u4e0b\u5212\u7ebf\u5f00\u5934 namespace\u4e2d\u7684\u53d8\u91cf\u540d\u4e5f\u8bf7\u4f7f\u7528\u6ce8\u91ca\u7b80\u8981\u8bf4\u660e\u53d8\u91cf\u7528\u9014","title":"\u89c4\u8303"},{"location":"old/%E8%87%AA%E5%88%B6Template/#_2","text":"\u56fe\u8bba\uff1a\u90bb\u63a5\u8868\u683c\u5f0f\uff1f","title":"\u5f85\u8ba8\u8bba"},{"location":"old/%E8%87%AA%E5%88%B6Template/#_3","text":"\u7b97\u6cd5\u63cf\u8ff0\uff1a\u8f93\u5165\u63a5\u53e3\u3001\u8fd0\u884c\u7b97\u6cd5\u9700\u8981\u7684\u64cd\u4f5c\u3001\u8f93\u51fa\u63a5\u53e3\u3001\u65f6\u95f4\u590d\u6742\u5ea6 Funs || Methods Reliance Description Time Complexity Inputs Outputs or Returns","title":"[\u7b97\u6cd5\u540d]"},{"location":"old/%E8%87%AA%E5%88%B6Template/#_4","text":"","title":"\u5b57\u7b26\u4e32"},{"location":"old/%E8%87%AA%E5%88%B6Template/#kmpold","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include <iostream> #include <cstring> using namespace std ; const int N = 1e6 + 10 ; char a [ N ], b [ N ]; int inext [ N ], f [ N ]; void prenext ( int n ) //n: length of A \uff08\u6a21\u5f0f\u4e32\uff09 { inext [ 1 ] = 0 ; for ( int i = 2 , j = 0 ; i <= n ; i ++ ) { while ( j > 0 && a [ i ] != a [ j + 1 ]) j = inext [ j ]; if ( a [ i ] == a [ j + 1 ]) j ++ ; //extendable inext [ i ] = j ; } } void match ( int n , int m ) // n : length of A \uff08 \u6a21\u5f0f\u4e32 \uff09 ; m : length of B \uff08 \u4e3b\u4e32 \uff09 { for ( int i = 1 , j = 0 ; i <= m ; i ++ ) { while ( j > 0 && ( j == n || b [ i ] != a [ j + 1 ])) j = inext [ j ]; if ( b [ i ] == a [ j + 1 ]) j ++ ; f [ i ] = j ; if ( f [ i ] == n ) //Match { cout << i - n + 1 << endl ; } } } int main () { ios :: sync_with_stdio ( false ); a [ 0 ] = b [ 0 ] = '?' ; //cin>>b+1>>a+1; cin >> ( a + 1 ); int la = strlen ( a ) -1 , lb = strlen ( b ) -1 ; prenext ( la ); //match(la,lb); for ( int i = 1 ; i <= la ; i ++ ) { cout << inext [ i ] << \" \" ; } return 0 ; }","title":"KMP(OLD)"},{"location":"old/%E8%87%AA%E5%88%B6Template/#exkmp","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <cstdlib> #include <algorithm> #include <string> #include <vector> #include <map> #include <unordered_map> #include <set> #include <unordered_set> #include <queue> using namespace std ; typedef long long ll ; const int Mod = 10007 ; namespace EXKMP { const int N = 2e5 + 10 ; int z [ N ], extend [ N ]; char a [ N ], b [ N ]; int a_len , b_len ; //z,ext:b\u4e32\u5173\u4e8e\u81ea\u5df1\u7684\u6bcf\u4e2a\u4f4d\u7f6e\u7684lcp\uff08\u6700\u957f\u516c\u5171\u524d\u7f00\uff09\u957f\u5ea6\uff0ca\u4e32\u5173\u4e8eb\u4e32\u7684\u6700\u957f\u516c\u5171\u524d\u7f00\u957f\u5ea6 //a\uff0cb\uff1a\u4e32\uff08b\u662f\u6a21\u5f0f\u4e32\uff09 //a_len, b_len\uff1a \u4e32\u957f //\u6c42\u51fab\u7684z\u51fd\u6570\uff081\u53f7\u4f4d\u7f6e\u4e0d\u662f\u826f\u5b9a\u4e49\u7684\uff09 void get_z ( char b [], int n = b_len ) { int l = 1 , r = 1 ; z [ 1 ] = n ; //undefined for ( int i = 2 ; i <= n ; i ++ ) { z [ i ] = 0 ; if ( i <= r ) z [ i ] = min ( z [ i - l + 1 ], r - i + 1 ); //init while ( i + z [ i ] <= n && b [ z [ i ] + 1 ] == b [ i + z [ i ]]) //i+z[i] is next position, so accessible pos is i+z[i]-1 z [ i ] ++ ; if ( i + z [ i ] -1 > r ) l = i , r = i + z [ i ] -1 ; } } //\u6c42\u51faa\u5173\u4e8eb\u7684ext\u6570\u7ec4 void exkmp ( char a [], char b [], int m = a_len , int n = b_len ) { extend [ 1 ] = 0 ; while ( 1 + extend [ 1 ] <= m && a [ 1 + extend [ 1 ]] == b [ 1 + extend [ 1 ]]) extend [ 1 ] ++ ; int l = 1 , r = 1 ; for ( int i = 2 ; i <= m ; i ++ ) { extend [ i ] = 0 ; if ( i <= r ) extend [ i ] = min ( z [ i - l + 1 ], r - i + 1 ); while ( i + extend [ i ] <= m && b [ extend [ i ] + 1 ] == a [ i + extend [ i ]]) extend [ i ] ++ ; if ( i + extend [ i ] -1 > r ) l = i , r = i + extend [ i ] -1 ; } } } using namespace EXKMP ; int T ; int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ), cout . tie ( 0 ); cin >> T ; for ( int _ = 1 ; _ <= T ; _ ++ ) { cin >> b_len ; cin >> b + 1 ; get_z ( b , b_len ); //exkmp(a,b,a_len,b_len) ll ans = 0 ; for ( int i = 1 ; i <= b_len ; i ++ ) { // cout<<z[i]<<\"-\\n\"; ans = ( ans + z [ i ]) % Mod ; } cout << ans << endl ; } return 0 ; }","title":"EXKMP"},{"location":"old/%E8%87%AA%E5%88%B6Template/#_5","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include <iostream> using namespace std ; const int N = 6e5 + 7 ; int n , a [ N ]; int minimal_expression () { int i = 1 , j = 2 ; while ( i <= n && j <= n ) { int k = 0 ; for (; k < n && a [ i + k ] == a [ j + k ]; k ++ ); if ( k == n ) break ; if ( a [ i + k ] > a [ j + k ]) { i = i + k + 1 ; i += ( i == j ); } else { j = j + k + 1 ; j += ( i == j ); } } return min ( i , j ); } int main () { ios :: sync_with_stdio ( false ); cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> a [ i ]; a [ n + i ] = a [ i ]; } for ( int i = minimal_expression (), j = 1 ; j <= n ; i ++ , j ++ ) { cout << a [ i ] << \" \" ; } return 0 ; }","title":"\u6700\u5c0f\u8868\u793a\u6cd5"},{"location":"old/%E8%87%AA%E5%88%B6Template/#manacher","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 //luogu3805 \u9a6c\u62c9\u8f66 \u5206\u5f00\u6c42\u89e3\u6cd5 #include <iostream> #include <cstring> #include <memory.h> using namespace std ; namespace Manacher { const int N = 1.1e7 + 100 ; //public char s [ N ]; int len ; int d1 [ N ], d2 [ N ]; //s:\u539f\u5b57\u7b26\u4e32 //len:s\u7684\u4e32\u957f //d1,d2\uff1a\u5947\u6570\u4f4d\u7f6e\uff0c\u5076\u6570\u4f4d\u7f6e\uff08\u4e24\u4e2a\u5b57\u7b26\u4e2d\u95f4\uff09\u7684\u56de\u6587\u534a\u5f84\u3002 //\u5bf9\u4e8ed2\uff0c\u4e0b\u6807i\u8868\u793a\u7684\u662f\u5939\u5728i~i+1\u4e4b\u95f4\u7684\u4f4d\u7f6e\u4e3a\u4e2d\u5fc3\u7684\u56de\u6587\u534a\u5f84 void get_d1 () { d1 [ 1 ] = 1 ; int l = 1 , r = 1 ; for ( int i = 2 ; i <= len ; i ++ ) { int k = ( i > r ) ? 1 : min ( d1 [ l + r - i ], r - i + 1 ); while ( 1 <= i - k && i + k <= len && s [ i - k ] == s [ i + k ]) k ++ ; d1 [ i ] = k ; if ( i + k - 1 > r ) { r = i + k - 1 ; l = i - k + 1 ; } } } void get_d2 () { d2 [ 0 ] = 0 ; int l = 0 , r = -1 ; for ( int i = 1 ; i <= len ; i ++ ) { int k = ( i >= r ) ? 0 : min ( d2 [ l + r - i - 1 ], r - i ); while ( 1 <= i - k && i + k + 1 <= len && s [ i - k ] == s [ i + k + 1 ]) k ++ ; d2 [ i ] = k ; if ( i + k > r ) { r = i + k ; l = i - k + 1 ; } } } } using namespace Manacher ; int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); cin >> s + 1 ; len = strlen ( s + 1 ); get_d1 (); get_d2 (); int ans = 1 ; for ( int i = 1 ; i <= len ; i ++ ) { ans = max ( ans , d1 [ i ] * 2 - 1 ); ans = max ( ans , d2 [ i ] * 2 ); } cout << ans << endl ; return 0 ; }","title":"Manacher\uff08\u5206\u5f00\u6c42\u89e3\u6cd5\uff09"},{"location":"old/%E8%87%AA%E5%88%B6Template/#_6","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 //luogu3805 \u9a6c\u62c9\u8f66 \u63d2\u5165\u4e95\u53f7\u6cd5 #include <iostream> #include <cstring> #include <memory.h> using namespace std ; const int N = 1.1e7 + 100 ; char s [ N ], s2 [ N * 2 ]; int n , nn ; int d1 [ N * 2 ]; void get_d1 () { nn = 1 ; s2 [ 0 ] = '$' ; s2 [ 1 ] = '#' ; for ( int i = 1 ; i <= n ; i ++ ) { s2 [ ++ nn ] = s [ i ]; s2 [ ++ nn ] = '#' ; } d1 [ 1 ] = 1 ; int l = 1 , r = 1 ; for ( int i = 2 ; i <= nn ; i ++ ) { int k = ( i > r ) ? 1 : min ( d1 [ l + r - i ], r - i + 1 ); while ( 1 <= i - k && i + k <= nn && s2 [ i - k ] == s2 [ i + k ]) k ++ ; d1 [ i ] = k ; if ( i + k -1 > r ) { r = i + k -1 ; l = i - k + 1 ; } } } int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); cin >> s + 1 ; n = strlen ( s + 1 ); get_d1 (); int ans = 0 ; for ( int i = 1 ; i <= nn ; i ++ ) { ans = max ( ans , d1 [ i ] -1 ); } cout << ans << endl ; return 0 ; }","title":"\u9a6c\u62c9\u8f66\uff08\u63d2\u5165\u4e95\u53f7\u6cd5\uff09"},{"location":"old/%E8%87%AA%E5%88%B6Template/#sa","text":"sa\u662f\u5b57\u7b26\u4e32s\u7684\u6bcf\u4e00\u4e2a\u540e\u7f00\u7684\u6392\u540d\u5230\u5b57\u7b26\u4e32s\u4e2d\u7684\u4e0b\u6807\u7684\u6620\u5c04\u6570\u7ec4\u3002rk\u662f\u6bcf\u4e00\u4e2a\u540e\u7f00\u7684\u4e0b\u6807\u5230\u6392\u540d\u7684\u6620\u5c04\u6570\u7ec4\u3002ht\u662f\u7b2ci\u540d\u548c\u7b2ci-1\u540d(\u6ce8\u610f\u662f\u6392\u540d)\u7684\u6700\u957f\u516c\u5171\u524d\u7f00\u957f\u5ea6\u3002 \u8f93\u5165\u5b57\u7b26\u4e32s\u548c\u957f\u5ea6len\uff0c\u8c03\u7528get_sa\u548cget_ht\uff0c\u5f97\u5230\u7684sa\u3001rk\u3001ht\u6570\u7ec4\u3002 Funs || Methods Reliance Time Complexity Inputs Outputs Description get_sa nlogn \u8f93\u5165s\u7684\u957f\u5ea6len\uff1b\u5b57\u7b26\u4e32s\u3002 \u4fee\u6539sa\u3001rk\u6570\u7ec4\u4f5c\u4e3a\u8f93\u51fa\u3002 \u5f97\u5230\u540e\u7f00\u6570\u7ec4sa\u3001rk get_ht get_sa n \u8f93\u5165s\u7684\u957f\u5ea6len\uff1b\u6570\u7ec4sa\u548cht\u3002 \u4fee\u6539\u6570\u7ec4ht\u4f5c\u4e3a\u8f93\u51fa\u3002 \u5f97\u5230\u540e\u7f00\u6570\u7ec4ht 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 #include <iostream> #include <cstdio> #include <cstring> #include <memory.h> using namespace std ; //\u540e\u7f00\u6570\u7ec4\uff1a\u8f93\u5165\u5b57\u7b26\u4e32s\u548c\u5176\u957f\u5ea6len\uff0c\u6267\u884cget_sa\u3001get_ht\uff0c\u8fd4\u56de\u5b57\u7b26\u4e32\u7684sa\u3001rk\u3001ht\u6570\u7ec4\u3002\u590d\u6742\u5ea6nlogn\u3002 namespace SA { const int N = 1e6 + 5 , M = 300 ; //N\uff1a\u957f\u5ea6\u4e0a\u9650 M\uff1a\u5b57\u7b26\u96c6\u5927\u5c0f //public char s [ N ]; //s:\u5b57\u7b26\u4e32 int len ; //len:\u7684\u957f\u5ea6 int sa [ N ], rk [ N ], ht [ N ]; //sa\u3001rk\u3001ht\u6570\u7ec4 //sa: \u6392\u540d -> \u4e0b\u6807 //rk: \u4e0b\u6807 -> \u6392\u540d //local int oldrk [ N * 2 ], id [ N ], px [ N ], cnt [ N ]; //id: (\u6309\u7b2c\u4e8c/\u7b2c\u4e00\u5173\u952e\u5b57\u6392\u5e8f\u540e\u7684)\u6392\u540d->\u4e0b\u6807(\u4e34\u65f6\u6570\u7ec4) //px: rk[id[i]], \u5728\u6309\u7b2c\u4e00\u5173\u952e\u5b57\u6392\u5e8f\u65f6,\u7b49\u4ef7\u4e8e\u7b2c\u4e8c\u5173\u952e\u5b57\u6392\u540d->\u4e0b\u6807-> w-1\u65f6\u8be5\u4e0b\u6807\u5904\u7684\u6392\u540d //ht: height\u6570\u7ec4 //\u5224\u65ad\u65e7rk\u6570\u7ec4\u4e2d\u5bf9\u5e94\u7684\u4e24\u4e2a\u4f4d\u7f6ex\u3001y\u4ee5\u53cax+w\u3001y+w\u662f\u5426\u76f8\u7b49 bool __is_equal ( int x , int y , int w ) { return oldrk [ x ] == oldrk [ y ] && oldrk [ x + w ] == oldrk [ y + w ]; } //\u8f93\u5165s\u7684\u957f\u5ea6len\uff0c\u4fee\u6539sa\u6570\u7ec4\u4f5c\u4e3a\u8f93\u51fa void get_sa ( int len = len ) { //\u8ba1\u6570\u6392\u5e8f //\u7b2c\u4e00\u6b21\u6392\u5e8f\uff08w=0\uff09 int m = M , p = 0 ; for ( int i = 1 ; i <= len ; i ++ ) cnt [ rk [ i ] = s [ i ]] ++ ; for ( int i = 1 ; i <= m ; i ++ ) cnt [ i ] += cnt [ i - 1 ]; //\u524d\u7f00\u548c for ( int i = len ; i >= 1 ; i -- ) sa [ cnt [ rk [ i ]] -- ] = i ; for ( int w = 1 ; w < len ; w <<= 1 , m = p ) { p = 0 ; for ( int i = len ; i > len - w ; i -- ) //\u7b2c\u4e8c\u5173\u952e\u5b57\u65e0\u7a77\u5c0f\u7684\u5148\u653e { id [ ++ p ] = i ; } for ( int i = 1 ; i <= len ; i ++ ) if ( sa [ i ] > w ) id [ ++ p ] = sa [ i ] - w ; // i:\u6392\u540d, sa[i]:\u4e0b\u6807, sa[i]-w \u4e0b\u6807\u504f\u79fb //\u8fd9\u91ccsa\u662fw-1\u65f6\u7684,\u56e0\u6b64sa\u770b\u4f5c\u662fw\u65f6\u7684\u7b2c\u4e8c\u5173\u952e\u5b57\u7684\u6392\u540d->\u4e0b\u6807\u6620\u5c04,\u5219sa[i]-w\u662f\u6b64\u65f6\u7b2c\u4e00\u5173\u952e\u5b57\u7684\u4e0b\u6807 //id\u4e0d\u518d\u8fd4\u5b58\u56desa\u6570\u7ec4\u4e2d memset ( cnt , 0 , sizeof ( cnt )); for ( int i = 1 ; i <= len ; i ++ ) cnt [ px [ i ] = rk [ id [ i ]]] ++ ; for ( int i = 1 ; i <= m ; i ++ ) cnt [ i ] += cnt [ i - 1 ]; for ( int i = len ; i >= 1 ; i -- ) sa [ cnt [ px [ i ]] -- ] = id [ i ]; memcpy ( oldrk , rk , sizeof ( rk )); p = 0 ; for ( int i = 1 ; i <= len ; i ++ ) { rk [ sa [ i ]] = __is_equal ( sa [ i ], sa [ i - 1 ], w ) ? p : ++ p ; } } } //(get_sa)\u5f97\u5230\u540e\u7f00\u6570\u7ec4ht\uff1a\u8f93\u5165s\u7684\u957f\u5ea6len\u3001\u6570\u7ec4sa\u548cht\uff0c\u4fee\u6539\u6570\u7ec4ht\u4e3a\u7ed3\u679c void get_ht ( int len = len ) { int k = 0 ; //\u4e0a\u4e00ht\u503c for ( int i = 1 ; i <= len ; i ++ ) { if ( k ) k -- ; // k>=0 while ( s [ i + k ] == s [ sa [ rk [ i ] - 1 ] + k ]) //\u6839\u636e\u5b9a\u4e49\u66b4\u529b\u6c42 { k ++ ; } ht [ rk [ i ]] = k ; } } } // namespace SA using namespace SA ; int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ), cout . tie ( 0 ); cin >> s + 1 ; len = strlen ( s + 1 ); get_sa (); get_ht (); for ( int i = 1 ; i <= len ; i ++ ) cout << sa [ i ] << \" \" ; return 0 ; }","title":"\u540e\u7f00\u6570\u7ec4\uff08SA\uff09"},{"location":"old/%E8%87%AA%E5%88%B6Template/#_7","text":"\u7ed9\u5b9a\u4e00\u4e2a\u53ea\u5305\u542b\u5c0f\u5199\u5b57\u6bcd\u7684\u5b57\u7b26\u4e32S,\u8bf7\u4f60\u6c42\u51fa S \u7684\u6240\u6709\u51fa\u73b0\u6b21\u6570\u4e0d\u4e3a 1 \u7684\u5b50\u4e32\u7684\u51fa\u73b0\u6b21\u6570\u4e58\u4e0a\u8be5\u5b50\u4e32\u957f\u5ea6\u7684\u6700\u5927\u503c\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 //luogu 3804 #include <iostream> #include <cstdio> #include <memory.h> #include <cstring> #include <queue> using namespace std ; const int N = 2e6 + 5 ; struct SAM_NODE { int inext [ 26 ], len , link , siz ; } sam [ N ]; int total , last ; char s [ N ]; int len ; void sam_init () { sam [ 0 ]. len = sam [ 0 ]. siz = 0 ; sam [ 0 ]. link = -1 ; memset ( sam [ 0 ]. inext , 0 , sizeof ( sam [ 0 ]. inext )); total = last = 0 ; } void sam_extend ( char c ) { int cur =++ total , cc = c - 'a' ; sam [ cur ]. len = sam [ last ]. len + 1 ; int p = last ; while ( p != -1 && ! sam [ p ]. inext [ cc ]) { sam [ p ]. inext [ cc ] = cur ; //\u8fd8\u6ca1\u6709\u5230\u5b57\u7b26c\u7684\u8f6c\u79fb\uff0c\u6211\u4eec\u5c31\u6dfb\u52a0\u4e00\u4e2a\u5230\u72b6\u6001c\u7684\u8f6c\u79fb p = sam [ p ]. link ; } if ( p == -1 ) //\u672a\u627e\u5230\u73b0\u6709\u8f6c\u79fb sam [ cur ]. link = 0 ; else //\u5df2\u7ecf\u627e\u5230\u73b0\u6709\u8f6c\u79fb { int q = sam [ p ]. inext [ cc ]; if ( sam [ p ]. len + 1 == sam [ q ]. len ) //\u8fde\u7eed\u8f6c\u79fb sam [ cur ]. link = q ; else //\u4e0d\u8fde\u7eed\u8f6c\u79fb { int clone =++ total ; sam [ clone ]. len = sam [ p ]. len + 1 ; memcpy ( sam [ clone ]. inext , sam [ q ]. inext , sizeof ( sam [ q ]. inext )); sam [ clone ]. link = sam [ q ]. link ; while ( p != -1 && sam [ p ]. inext [ cc ] == q ) { sam [ p ]. inext [ cc ] = clone ; p = sam [ p ]. link ; } sam [ q ]. link = sam [ cur ]. link = clone ; } } last = cur ; sam [ cur ]. siz = 1 ; // \u6807\u8bb0\u7ec8\u70b9\u8282\u70b9 } void sam_marksuf () { int p = last ; while ( p != -1 ) { //...\u5411\u6807\u8bb0\u6570\u7ec4\u5199\u5165 p = sam [ p ]. link ; } } void sam_traverse ( int x = 0 ) //\u8c03\u8bd5\u7528\uff0c\u8f93\u51fasam\u7ed3\u6784 { cout << x << \":\" ; for ( int i = 0 ; i < 26 ; i ++ ) { //\u8f6c\u79fb\u5b57\u7b26 \u6807\u53f7 if ( sam [ x ]. inext [ i ]) cout << ( char )( 'a' + i ) << sam [ x ]. inext [ i ] << \" \" ; } cout << endl ; for ( int i = 0 ; i < 26 ; i ++ ) if ( sam [ x ]. inext [ i ]) sam_traverse ( sam [ x ]. inext [ i ]); } void sam_tr_suftree () //\u8c03\u8bd5\u7528\uff0c\u8f93\u51fa\u540e\u7f00\u94fe\u63a5\u6811\u7ed3\u6784 { //\u4ece\u53f6\u5b50\u5230\u6839 for ( int i = 1 ; i <= total ; i ++ ) { if ( sam [ i ]. siz ) { int p = i ; while ( p != -1 ) { cout << p << \" \" ; p = sam [ p ]. link ; } cout << endl ; } } } long long ans = 0 ; int deg [ N ]; void get_size () //\u4ece\u53f6\u5b50\u8282\u70b9\u5f00\u59cbbfs\uff0c\u7d2f\u52a0siz\uff0c\u975e\u53f6\u5b50\u8282\u70b9\u7684siz\u503c\u5c31\u662f\u8fd9\u4e2a\u8282\u70b9\u7684\u7ec8\u70b9\u96c6\u5408\u5927\u5c0f\uff0c\u4e5f\u5373\u8fd9\u4e2a\u8282\u70b9\u5bf9\u5e94\u6700\u957f\u4e32\u51fa\u73b0\u7684\u6b21\u6570 { queue < int > q ; for ( int i = 1 ; i <= total ; i ++ ) { deg [ sam [ i ]. link ] ++ ; /*bool flag=true; for(int j=0;j<26;j++) if(sam[i].inext[j]) {flag=false;break;} if(flag) q.push(i);*/ //\u5144\u554a\u8fd9\u4e48\u5199\u6839\u672c\u548clink\u6ca1\u5173\u7cfb\u554a\uff01 } for ( int i = 1 ; i <= total ; i ++ ) if ( deg [ i ] == 0 ) q . push ( i ); while ( q . size ()) { int x = q . front (); q . pop (); sam [ sam [ x ]. link ]. siz += sam [ x ]. siz ; deg [ sam [ x ]. link ] -- ; if ( deg [ sam [ x ]. link ] == 0 ) q . push ( sam [ x ]. link ); } } int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ), cout . tie ( 0 ); cin >> s + 1 ; len = strlen ( s + 1 ); sam_init (); for ( int i = 1 ; i <= len ; i ++ ) sam_extend ( s [ i ]); //sam_traverse(0); //sam_tr_suftree(); get_size (); for ( int i = 1 ; i <= total ; i ++ ) if ( sam [ i ]. siz >= 2 ) ans = max ( ans ,( long long ) sam [ i ]. siz * sam [ i ]. len ); cout << ans << endl ; return 0 ; }","title":"\u5f8c\u7db4\u81ea\u52d5\u6a5f"},{"location":"old/%E8%87%AA%E5%88%B6Template/#_8","text":"","title":"\u5b57\u7b26\u4e32\u5468\u671f\uff1f"},{"location":"old/%E8%87%AA%E5%88%B6Template/#2017-2018-acm-icpc-asia-daejeon-regional-contest","text":"\u9898\u76ee\u63cf\u8ff0\uff1a\u7ed9\u51fa\u4e00\u4e2a\u957f\u5ea6\u4e3a \\(n\\) \u7684\u5e8f\u5217 \\(a_i\\) \uff0c\u8fd9\u4e2a\u5e8f\u5217\u7b2c \\(k+1\\) \u8d77\u5230\u6700\u540e\u662f\u82e5\u5e72\u4e2a\u5faa\u73af\uff0c\u5468\u671f\u4e3a \\(p\\) \uff0c\u6700\u540e\u4e00\u4e2a\u5faa\u73af\u53ef\u4ee5\u4e0d\u5b8c\u6574\u3002\u6c42 \\(k+p\\) \u6700\u5c0f\u503c\u5bf9\u5e94\u7684 \\(k, p\\) \u3002 solution \u5c06\u5e8f\u5217 \\(a_i\\) \u7ffb\u8f6c\uff0c\u505a\u4e00\u6b21 \\(KMP\\) ( \\(fail[i]\\) )\uff0c\u679a\u4e3e \\(k+1\\) \u7684\u4f4d\u7f6e \\(i\\) \uff0c\u5219\u5468\u671f \\(p=i-fail[i], k=n-i\\) \u3002\u66f4\u65b0\u7b54\u6848\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include <bits/stdc++.h> using namespace std ; int n ; int a [ 1000010 ]; int nnext [ 1000010 ]; int k = 10000000 , p = 10000000 ; void cal_next () { nnext [ 1 ] = 0 ; for ( int i = 2 , j = 0 ; i <= n ; i ++ ) { while ( j > 0 && a [ i ] != a [ j + 1 ]) j = nnext [ j ]; if ( a [ j + 1 ] == a [ i ]) j ++ ; nnext [ i ] = j ; } } int main () { cin >> n ; for ( int i = n ; i >= 1 ; i -- ) scanf ( \"%d\" , & a [ i ]); cal_next (); for ( int i = 1 ; i <= n ; i ++ ) { int tempk = n - i , tempp = i - nnext [ i ] + 1 ; if ( tempk + tempp < k + p ) { k = tempk ; p = tempp ; } } cout << k << \" \" << p -1 ; return 0 ; }","title":"2017-2018 ACM-ICPC, Asia Daejeon Regional Contest"},{"location":"old/%E8%87%AA%E5%88%B6Template/#2021-ccpc-f","text":"\u4e0d\u96be\u53d1\u73b0\u884c\u4e0e\u5217\u662f\u4e24\u4e2a\u72ec\u7acb\u7684\u95ee\u9898\uff0c\u56e0\u6b64\u53ea\u9700\u8981\u6c42\u51fa\u884c\u7684\u6700\u77ed\u5faa\u73af\u8282\u7684\u957f\u5ea6\uff0c\u518d\u6c42\u51fa\u5217\u7684 \u6700\u77ed\u5faa\u73af\u8282\u7684\u957f\u5ea6\uff0c\u76f8\u4e58\u5c31\u662f\u7b54\u6848\u3002 \u4ee5\u884c\u4e3a\u4f8b\uff0c\u9996\u5148\u901a\u8fc7 Hash \u5c06\u95ee\u9898\u8f6c\u5316\u4e3a\u4e00\u7ef4\u95ee\u9898\u3002\u4e00\u7ef4\u95ee\u9898\u5219\u662f\u7ecf\u5178\u95ee\u9898\uff0c\u5bf9\u4e8e\u4e00\u4e2a\u957f \u5ea6\u4e3a n \u7684\u5b57\u7b26\u4e32\uff0c\u957f\u5ea6\u4e3a d \u7684\u524d\u7f00\u662f\u5faa\u73af\u8282\u5f53\u4e14\u4ec5\u5f53\u957f\u5ea6\u4e3a n \u2212 d \u7684\u524d\u540e\u7f00\u76f8\u7b49\uff0c\u56e0\u6b64\u9700\u8981\u627e\u5230\u8fd9\u4e2a\u5b57\u7b26\u4e32\u6700\u957f\u7684\u524d\u7f00\uff0c\u6ee1\u8db3\u8be5\u524d\u7f00\u4e5f\u662f\u8be5\u5b57\u7b26\u4e32\u7684\u540e\u7f00\u3002\u53ef\u4ee5\u679a\u4e3e\u6240\u6709\u53ef\u80fd\u7684 d \u7136\u540e\u4f7f\u7528Hash O(1) \u5224\u65ad\uff1b\u4e5f\u53ef\u4ee5\u4f7f\u7528 KMP \u7b97\u6cd5\u6c42\u51fa nxt \u6570\u7ec4\uff0c\u7b54\u6848\u5373\u4e3a n \u2212 nxt[n]\u3002 \u65f6\u95f4\u590d\u6742\u5ea6 O(n^2 + qn)\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 #include <bits/stdc++.h> using namespace std ; string a [ 2010 ]; const int P = 131 ; long long p [ 2010 ]; long long hashrow [ 2010 ][ 2010 ], hashcol [ 2010 ][ 2010 ]; long long drow [ 2010 ], dcol [ 2010 ]; int n , q ; int nex [ 2010 ]; void getnex ( long long s [], long long len ) { int i = 0 ; int j = -1 ; nex [ 0 ] = -1 ; while ( i < len ) { if ( j == -1 || s [ i ] == s [ j ]) { i ++ ; j ++ ; nex [ i ] = j ; } else j = nex [ j ]; } } int main () { cin >> n >> q ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> a [ i ]; a [ i ] = \" \" + a [ i ]; } p [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) p [ i ] = p [ i -1 ] * P ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { hashrow [ i ][ j ] = hashrow [ i -1 ][ j ] * P + a [ i ][ j ] - 'a' ; hashcol [ i ][ j ] = hashcol [ i ][ j -1 ] * P + a [ i ][ j ] - 'a' ; } } for ( int t = 1 ; t <= q ; t ++ ) { long long x1 , y1 , x2 , y2 ; cin >> x1 >> y1 >> x2 >> y2 ; long long ans1 = 0 , ans2 = 0 ; for ( int j = y1 ; j <= y2 ; j ++ ) drow [ j - y1 ] = hashrow [ x2 ][ j ] - hashrow [ x1 -1 ][ j ] * p [ x2 - x1 + 1 ], nex [ j - y1 ] = 0 ; getnex ( drow , y2 - y1 + 1 ); ans1 = y2 - y1 + 1 - nex [ y2 - y1 + 1 ]; for ( int i = x1 ; i <= x2 ; i ++ ) dcol [ i - x1 ] = hashcol [ i ][ y2 ] - hashcol [ i ][ y1 -1 ] * p [ y2 - y1 + 1 ], nex [ i - x1 ] = 0 ; getnex ( dcol , x2 - x1 + 1 ); ans2 = x2 - x1 + 1 - nex [ x2 - x1 + 1 ]; cout << ans1 * ans2 << endl ; } return 0 ; }","title":"2021 CCPC \u5973\u751f\u8d5b F"},{"location":"old/%E8%87%AA%E5%88%B6Template/#ac","text":"","title":"AC \u81ea\u52a8\u673a"},{"location":"old/%E8%87%AA%E5%88%B6Template/#luogu-3796-ac","text":"\u6709N\u4e2a\u7531\u5c0f\u5199\u5b57\u6bcd\u7ec4\u6210\u7684\u6a21\u5f0f\u4e32\u4ee5\u53ca\u4e00\u4e2a\u6587\u672c\u4e32 T\u3002\u6bcf\u4e2a\u6a21\u5f0f\u4e32\u53ef\u80fd\u4f1a\u5728\u6587\u672c\u4e32\u4e2d\u51fa\u73b0\u591a\u6b21\u3002\u4f60\u9700\u8981\u627e\u51fa\u54ea\u4e9b\u6a21\u5f0f\u4e32\u5728\u6587\u672c\u4e32 T \u4e2d\u51fa\u73b0\u7684\u6b21\u6570\u6700\u591a\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 #include <iostream> #include <cstdio> #include <memory.h> #include <queue> using namespace std ; const int N = 1e6 + 10 ; int n ; char s [ 151 ][ 100 ], t [ N ]; int trie [ N ][ 26 ], total , id [ N ], fail [ N ], last [ N ]; int cnt [ N ]; void insert ( char * s , int num ) { int u = 0 ; for ( int i = 1 ; s [ i ]; i ++ ) { int x = s [ i ] - 'a' ; if ( ! trie [ u ][ x ]) trie [ u ][ x ] =++ total ; u = trie [ u ][ x ]; } id [ u ] = num ; } void build () { queue < int > q ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( trie [ 0 ][ i ]) q . push ( trie [ 0 ][ i ]); } while ( q . size ()) { int u = q . front (); q . pop (); for ( int i = 0 ; i < 26 ; i ++ ) { if ( trie [ u ][ i ]) { fail [ trie [ u ][ i ]] = trie [ fail [ u ]][ i ]; last [ trie [ u ][ i ]] = ( id [ fail [ trie [ u ][ i ]]] == 0 ) ? ( last [ fail [ trie [ u ][ i ]]]) : ( fail [ trie [ u ][ i ]]); //\u6709\u6548\u5b57\u7b26\u4e32\u7ed3\u5c3e q . push ( trie [ u ][ i ]); } else trie [ u ][ i ] = trie [ fail [ u ]][ i ]; } } } void query ( char * s ) { int u = 0 ; for ( int i = 1 ; s [ i ]; i ++ ) { int x = s [ i ] - 'a' ; u = trie [ u ][ x ]; for ( int j = u ; j ; j = last [ j ]) { cnt [ id [ j ]] ++ ; } } } int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ), cout . tie ( 0 ); while ( cin >> n && n ) { memset ( trie , 0 , sizeof ( trie )); memset ( fail , 0 , sizeof ( fail )); memset ( last , 0 , sizeof ( last )); memset ( cnt , 0 , sizeof ( cnt )); memset ( id , 0 , sizeof ( id )); for ( int i = 1 ; i <= n ; i ++ ) { cin >> s [ i ] + 1 ; insert ( s [ i ], i ); } build (); cin >> t + 1 ; query ( t ); int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { ans = max ( ans , cnt [ i ]); } cout << ans << endl ; for ( int i = 1 ; i <= n ; i ++ ) if ( ans == cnt [ i ]) cout << s [ i ] + 1 << endl ; } return 0 ; }","title":"luogu 3796 AC\u81ea\u52a8\u673a\uff08\u52a0\u5f3a\u7248\uff09"},{"location":"old/%E8%87%AA%E5%88%B6Template/#_9","text":"\u7ed9\u4f60\u4e00\u4e2a\u6587\u672c\u4e32 S \u548c n \u4e2a\u6a21\u5f0f\u4e32 T_{1..n}\uff0c\u8bf7\u4f60\u5206\u522b\u6c42\u51fa\u6bcf\u4e2a\u6a21\u5f0f\u4e32 T_i\u5728 S \u4e2d\u51fa\u73b0\u7684\u6b21\u6570\u3002 \u8be6\u7ec6\u8bf4\u660e\u89c1OI\u6742\u7b14\u8bb0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 //\u4e8c\u6b21\u52a0\u5f3a\u7248 #include <iostream> #include <cstdio> #include <queue> using namespace std ; const int N = 2e5 + 1 , M = 2e6 + 10 ; int n ; char s [ N ], t [ M ]; int trie [ M / 2 ][ 26 ], total , fail [ M / 2 ]; int id [ M / 2 ], node_ [ N ]; //\u7ed3\u70b9\u548c\u5b57\u7b26\u4e32\u7f16\u53f7\u7684\u6620\u5c04 int delta [ M / 2 ], sum [ M / 2 ]; //\u6811\u4e0a\u5dee\u5206\u6570\u7ec4\uff0c\u5dee\u5206\u6c42\u548c struct E { int to , inext ; } edge [ M / 2 ]; int head [ M / 2 ], e_total ; void adde ( int x , int y ) { edge [ ++ e_total ]. to = y ; edge [ e_total ]. inext = head [ x ]; head [ x ] = e_total ; } void insert ( char * s , int num ) { int u = 0 ; for ( int i = 1 ; s [ i ]; i ++ ) { int x = s [ i ] - 'a' ; if ( ! trie [ u ][ x ]) trie [ u ][ x ] =++ total ; //!! u = trie [ u ][ x ]; } if ( ! id [ u ]) id [ u ] = num ; node_ [ num ] = u ; } void build () { queue < int > q ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( trie [ 0 ][ i ]) q . push ( trie [ 0 ][ i ]); } while ( q . size ()) { int u = q . front (); q . pop (); for ( int i = 0 ; i < 26 ; i ++ ) { if ( trie [ u ][ i ]) { fail [ trie [ u ][ i ]] = trie [ fail [ u ]][ i ]; q . push ( trie [ u ][ i ]); } else { trie [ u ][ i ] = trie [ fail [ u ]][ i ]; } } } for ( int i = 1 ; i <= total ; i ++ ) { adde ( fail [ i ], i ); } } void traverse ( char * s ) { int u = 0 ; for ( int i = 1 ; s [ i ]; i ++ ) { int x = s [ i ] - 'a' ; u = trie [ u ][ x ]; delta [ u ] ++ ; } } void dfs ( int u = 0 ) { sum [ u ] = delta [ u ]; for ( int e = head [ u ]; e ; e = edge [ e ]. inext ) { int y = edge [ e ]. to ; dfs ( y ); sum [ u ] += sum [ y ]; } } int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ), cout . tie ( 0 ); cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> s + 1 ; insert ( s , i ); } build (); cin >> t + 1 ; traverse ( t ); dfs ( 0 ); for ( int i = 1 ; i <= n ; i ++ ) { cout << sum [ node_ [ i ]] << endl ; } return 0 ; }","title":"\u4e8c\u6b21\u52a0\u5f3a\u7248"},{"location":"old/%E8%87%AA%E5%88%B6Template/#_10","text":"","title":"\u52a8\u6001\u89c4\u5212"},{"location":"old/%E8%87%AA%E5%88%B6Template/#dp","text":"","title":"\u2b50\u51e0\u79cd\u5f62\u6001\u7684\u6570\u4f4dDP"},{"location":"old/%E8%87%AA%E5%88%B6Template/#1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 //CFED50 C classy_numbers //\u984c\u610f\uff1a\u6c42\u89e3L~R\u5167\uff0c\u5341\u9032\u5236\u8868\u793a\u4e0b\u4e0d\u8d85\u904e3\u500b\u6578\u662f\u975e0\u6578\u7684\u500b\u6578 #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <cstdlib> #include <algorithm> #include <string> #include <vector> #include <map> #include <unordered_map> #include <set> #include <unordered_set> #include <queue> using namespace std ; typedef long long ll ; const int N = 2e5 + 10 ; //from left to right, the pos-th digit (start from 1) int s [ 30 ], n ; void getdigit ( ll R ) { if ( R == 0 ) { n = 1 ; s [ 1 ] = 0 ; return ; } n = log10 ( R ) + 1 ; for ( int i = n ; i >= 1 ; i -- ) { s [ i ] = R % 10 ; R /= 10 ; } } //1~n ll dp [ 21 ][ 4 ][ 2 ]; //pos,cnt,limit ll dfs ( int pos , int cnt , int limit ) { if ( pos == n + 1 ) { return dp [ pos ][ cnt ][ limit ] = 1 ; } if ( cnt == 3 ) { return dp [ pos ][ cnt ][ limit ] = 1 ; } if ( dp [ pos ][ cnt ][ limit ] != -1 ) return dp [ pos ][ cnt ][ limit ]; ll ans = 0 ; if ( limit ) { for ( int d = 0 ; d <= s [ pos ]; d ++ ) { ans += dfs ( pos + 1 , cnt + ( d > 0 ), ( d == s [ pos ])); } } else { for ( int d = 0 ; d <= 9 ; d ++ ) { ans += dfs ( pos + 1 , cnt + ( d > 0 ), 0 ); } } return dp [ pos ][ cnt ][ limit ] = ans ; } int T ; int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ), cout . tie ( 0 ); cin >> T ; for ( int _ = 1 ; _ <= T ; _ ++ ) { ll L , R ; cin >> L >> R ; getdigit ( R ); memset ( dp , -1 , sizeof ( dp )); ll Rans = dfs ( 1 , 0 , 1 ); getdigit ( L - 1 ); memset ( dp , -1 , sizeof ( dp )); ll Lans = dfs ( 1 , 0 , 1 ); cout << Rans - Lans << endl ; } return 0 ; }","title":"\u5f62\u614b1\uff1a\u8a18\u61b6\u5316\u641c\u7d22"},{"location":"old/%E8%87%AA%E5%88%B6Template/#2","text":"\u4e0d\u898162\uff1a\u533a\u95f4\u5185\u6709\u591a\u5c11\u4e2a\u6570\uff0c\u95ee\u5f53\u4e2d\u6709\u591a\u5c11\u4e2a\u6570\u662f\u5e26\u6709\u8fde\u7eed62\u7684 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 #include <iostream> #include <memory.h> #include <cmath> using namespace std ; int f [ 10 ][ 10 ]; void init () { memset ( f , 0 , sizeof ( f )); for ( int k = 0 ; k <= 9 ; k ++ ) { if ( k != 4 ) f [ 1 ][ k ] = 1 ; } for ( int i = 2 ; i <= 7 ; i ++ ) { for ( int j = 0 ; j <= 9 ; j ++ ) { if ( j != 4 ) { for ( int k = 0 ; k <= 9 ; k ++ ) { if ( j != 6 || ( j == 6 && k != 2 )) { f [ i ][ j ] += f [ i -1 ][ k ]; } } } } } } int take_bit ( int x , int i ) { if ( log10 ( x ) + 1 < i ) return -10 ; //no exist for ( int j = 1 ; j <= i -1 ; j ++ ) x /= 10 ; return x %= 10 ; } int fill ( int x ) { if ( x <= 0 ) return 0 ; int ans = 0 ; for ( int i = log10 ( x ); i >= 1 ; i -- ) { for ( int j = 1 ; j <= 9 ; j ++ ) if ( j != 4 ) ans += f [ i ][ j ]; } for ( int i = log10 ( x ) + 1 ; i >= 1 ; i -- ) { for ( int j = (( i == ( int )( log10 ( x ) + 1 )) ? 1 : 0 );( j < take_bit ( x , i ) || ( i == 1 && j <= take_bit ( x , i ))); j ++ ) { if ( j == 4 ) continue ; if ( take_bit ( x , i + 1 ) == 6 && j == 2 ) continue ; if ( i >= 2 ) { for ( int k = 0 ; k <= 9 ; k ++ ) { if ( k == 4 ) continue ; if ( j == 6 && k == 2 ) continue ; ans += f [ i -1 ][ k ]; } } else { ans ++ ; } } if ( take_bit ( x , i ) == 4 ) break ; if ( take_bit ( x , i + 1 ) == 6 && take_bit ( x , i ) == 2 ) break ; } return ans ; } int main () { int n , m ; init (); while ( 1 ) { cin >> n >> m ; if ( n == 0 && m == 0 ) break ; cout << fill ( m ) - fill ( n -1 ) << endl ; } return 0 ; } \u9b54\u9b3c\u6570 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #include <iostream> using namespace std ; long long f [ 30 ][ 4 ]; //f[i][0|1|2]:not beastly number; f[i][3];is beastly number void init () { f [ 0 ][ 0 ] = 1 ; for ( int i = 1 ; i <= 20 ; i ++ ) { f [ i ][ 0 ] = 9 * ( f [ i -1 ][ 0 ] + f [ i -1 ][ 1 ] + f [ i -1 ][ 2 ]); f [ i ][ 1 ] = f [ i -1 ][ 0 ]; f [ i ][ 2 ] = f [ i -1 ][ 1 ]; f [ i ][ 3 ] = 10 * f [ i -1 ][ 3 ] + f [ i -1 ][ 2 ]; } } int main () { init (); int t ; cin >> t ; while ( t -- ) { long long x , cnt = 0 , bit = 1 ; cin >> x ; while ( f [ bit ][ 3 ] < x ) bit ++ ; //find out how many bit it have for ( int i = bit , k = 0 ; i >= 1 ; i -- ) { for ( int j = 0 ; j <= 9 ; j ++ ) { int tempcnt = 0 ; tempcnt += f [ i -1 ][ 3 ]; if ( j == 6 && k >= 0 ) tempcnt += f [ i -1 ][ 2 ]; if ( j == 6 && k >= 1 ) tempcnt += f [ i -1 ][ 1 ]; if ( j == 6 && k >= 2 ) tempcnt += f [ i -1 ][ 0 ]; if ( j != 6 && k >= 3 ) tempcnt += ( f [ i -1 ][ 2 ] + f [ i -1 ][ 1 ] + f [ i -1 ][ 0 ]); if ( cnt + tempcnt < x ) cnt += tempcnt ; else { cout << j ; if ( k < 3 ) { if ( j == 6 ) k ++ ; else k = 0 ; } break ; } } } cout << endl ; } return 0 ; } \u6708\u4e4b\u8c1c\uff08\u540c\u7c7b\u5206\u5e03\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 #include <cstdio> #include <cstring> #include <cstdlib> using namespace std ; // f[\u6a21][\u5269\u4f59\u6570\u5b57\u6570\u76ee][\u5269\u4f59\u6570\u5b57\u7684\u548c][\u5269\u4f59\u4f4d\u7684\u6a21] = \u5408\u6cd5\u65b9\u6848\u6570 // f[S][i][j][k] = \u2211(f[S][i - 1][j - R][(k - pwr[i - 1] * R) mod S], 0\u2264R\u22649) // \u8fb9\u754c\u6761\u4ef6 F[S][0][0][0] = 1 int f [ 82 ][ 10 ][ 82 ][ 82 ], pwr [ 82 ][ 10 ]; inline int modabs ( int a , int mod ) { return (( a % mod ) + mod ) % mod ; } int num [ 10 ]; int count ( int p , int sum , int mod , int s , bool e ) { if ( s - sum < 0 ) return 0 ; else if ( ! e ) return f [ s ][ p + 1 ][ s - sum ][( s - mod ) % s ]; else if ( p == -1 ) { if ( sum == s && mod == 0 ) return 1 ; else return 0 ; } else { int res = 0 ; for ( int d = 0 ; d <= num [ p ]; d ++ ) res += count ( p - 1 , sum + d , ( mod + pwr [ s ][ p ] * d ) % s , s , d == num [ p ]); return res ; } } int fcount ( int tt ) { if ( tt == 0 ) return 0 ; int maxp = 0 ; while ( tt ) num [ maxp ++ ] = tt % 10 , tt /= 10 ; int res = 0 ; for ( int i = 1 ; i <= 81 ; i ++ ) res += count ( maxp - 1 , 0 , 0 , i , true ); return res ; } int main () { freopen ( \"mystery.in\" , \"r\" , stdin ); freopen ( \"mystery.out\" , \"w\" , stdout ); for ( int s = 1 ; s <= 81 ; s ++ ) { memset ( f [ s ], 0 , sizeof f [ s ]); f [ s ][ 0 ][ 0 ][ 0 ] = 1 ; pwr [ s ][ 0 ] = 1 % s ; for ( int i = 1 ; i <= 9 ; i ++ ) pwr [ s ][ i ] = ( pwr [ s ][ i - 1 ] * 10 ) % s ; for ( int i = 1 ; i <= 9 ; i ++ ) { for ( int j = 0 ; j <= i * 9 ; j ++ ) { for ( int k = 0 ; k <= s ; k ++ ) { for ( int d = 0 ; d <= 9 && j - d >= 0 ; d ++ ) f [ s ][ i ][ j ][ k ] += f [ s ][ i - 1 ][ j - d ][ modabs ( k - pwr [ s ][ i - 1 ] * d , s )]; } } } } int l , r ; while ( scanf ( \"%d %d\" , & l , & r ) == 2 ) printf ( \"%d \\n \" , fcount ( r ) - fcount ( l - 1 )); fclose ( stdin ); fclose ( stdout ); return 0 ; }","title":"\u5f62\u60012 \u8bd5\u586b\u6cd5"},{"location":"old/%E8%87%AA%E5%88%B6Template/#_11","text":"","title":"\u60ac\u7ebf\u6cd5"},{"location":"old/%E8%87%AA%E5%88%B6Template/#klargest-common-submatrix","text":"(2019\u94f6\u5ddd\u533a\u57df\u8d5bK\u9898 by hqh) \u9898\u610f:\u7ed9\u4e24\u4e2anm(1000\u4ee5\u5185)\u7684\u77e9\u9635,\u95ee\u8fd9\u4e24\u4e2a\u77e9\u9635\u7684\u6700\u5927\u5b50\u77e9\u9635\u5927\u5c0f,\u5355\u4e2a\u77e9\u9635\u5185\u5143\u7d20\u4e24\u4e24\u4e0d\u540c,\u4e14\u90fd\u57281~nm\u5185. \u89e3\u6cd5:\u5148\u5efa\u7acb\u4e24\u4e2a\u77e9\u9635\u5143\u7d20\u4e4b\u95f4\u7684\u4f4d\u7f6e\u6620\u5c04(\u7528\u4e2a\u6570\u7ec4\u4e4b\u7c7b\u7684\u4fdd\u5b58). \u7136\u540e\u4f7f\u7528\u60ac\u7ebf\u6cd5( https://oi-wiki.org/misc/hoverline/),\u5bf9\u4e8e\u6bcf\u4e2a\u4f4d\u7f6e(i,j)\u6211\u4eec\u5047\u8bbe\u8fd9\u4e2a\u4f4d\u7f6e\u6709\u4e2a\u7ad6\u76f4\u60ac\u7ebf(\u6709\u9ad8\u5ea6\u548c\u5de6\u53f3\u6269\u5c55\u6700\u5927\u8ddd\u79bb\u7b49\u4fe1\u606f),\u6211\u4eec\u6700\u7ec8\u7684\u76ee\u6807\u662f\u8ba9\u60ac\u7ebf\u9ad8\u5ea6\u7b49\u4e8e\u8fd9\u4e00\u5217\u80fd\u6269\u5c55\u7684\u6700\u5927\u9ad8\u5ea6\u7684\u60c5\u51b5\u4e0b,\u8ba9\u60ac\u7ebf\u5411\u5de6\u6216\u8005\u5411\u53f3\u6269\u5c55\u7684\u8ddd\u79bb\u5c3d\u53ef\u80fd\u5927.\u80fd\u6269\u5c55\u5f53\u4e14\u4ec5\u5f53a\u77e9\u9635\u4e2d\u5bf9\u5e94\u7684\u67d0\u4e2a\u6570x\u5728b\u77e9\u9635\u4e2d\u5bf9\u5e94\u7684\u76f8\u5bf9\u4f4d\u7f6e\u4e5f\u7b26\u5408\u8981\u6c42 . \u4f8b\u5982\u77e9\u9635 a= 5 6 1 7 9 3 2 4 8 b= 1 2 3 4 5 6 8 7 9 a\u4e2d\u76847\u5bf9\u5e94b\u4e2d(3,2)\u4f4d\u7f6e,\u5047\u8bbe7\u8fd9\u4e2a\u4f4d\u7f6e\u7684\u60ac\u7ebf\u521d\u59cb\u9ad8\\\u5de6\\\u53f3\u6269\u5c55\u6700\u5927\u4f4d\u7f6e\u5206\u522b\u662fh=1 l=1 \\r=1;\u5148\u66f4\u65b0\u9ad8\u5ea6,a\u4e2d5\u57287\u7684\u4e0a\u9762,b\u4e2d\u4e5f\u662f\u5982\u6b64,\u56e0\u6b64\u9ad8\u5ea6\u4e3a2.\u6b64\u65f6\u4e0d\u80fd\u518d\u6269\u5c55\u4e86.\u5de6\u53f3\u6700\u5927\u8ddd\u79bb\u7684\u66f4\u65b0\u4e5f\u7c7b\u4f3c,\u60ac\u7ebf\u7684\u9ad8\u5ea6\u548c\u5de6\\\u53f3\u6700\u5927\u53ef\u8fbe\u8ddd\u79bb\u662f\u53ef\u88ab\u7ebf\u6027\u66f4\u65b0\u7684. \u6c42\u51fa\u6240\u6709\u60ac\u7ebf\u540e,\u76f4\u63a5\u7528\u60ac\u7ebf\u7684\u4fe1\u606f(r-l)*h\u4f5c\u4e3a\u77e9\u5f62\u7684\u6700\u5927\u9762\u79ef\u66f4\u65b0\u5373\u53ef 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 #include <iostream> #include <cstdio> #include <unordered_map> #include <map> using namespace std ; int n , m ; const int N = 2010 ; struct HOVER { int h , l , r ; } hl [ N ][ N ]; //map<int,pair<int,int>> mp; pair < int , int > mp [ N * N ]; int a [ N ][ N ], b [ N ][ N ]; void do_hoverline () { for ( int i = 1 ; i <= n ; i ++ ) { //L for ( int j = 1 ; j <= m ; j ++ ) { //Height //pair<int,int> iijj=mp[b[i][j]]; pair < int , int > iijj = mp [ b [ i ][ j ]]; //b! \uff08\u4e0d\u662fa if ( b [ i -1 ][ j ] == a [ iijj . first -1 ][ iijj . second ]) { hl [ i ][ j ]. h = hl [ i -1 ][ j ]. h + 1 ; } while ( hl [ i ][ j ]. l > 1 && iijj . second - ( j - ( hl [ i ][ j ]. l -1 )) >= 1 && b [ i ][ hl [ i ][ j ]. l -1 ] == a [ iijj . first ][ iijj . second - ( j - ( hl [ i ][ j ]. l -1 ))] //\u6ce8\u610f\u60ac\u7ebf\u6269\u5c55\u65f6b\u4e5f\u8981\u5339\u914d && hl [ i ][ hl [ i ][ j ]. l -1 ]. h >= hl [ i ][ j ]. h ) { hl [ i ][ j ]. l = hl [ i ][ hl [ i ][ j ]. l -1 ]. l ; } } //R for ( int j = m ; j >= 1 ; j -- ) { pair < int , int > iijj = mp [ b [ i ][ j ]]; //b! while ( hl [ i ][ j ]. r < m && iijj . second + (( hl [ i ][ j ]. r + 1 ) - j ) <= m && b [ i ][ hl [ i ][ j ]. r + 1 ] == a [ iijj . first ][ iijj . second + (( hl [ i ][ j ]. r + 1 ) - j )] //\u6ce8\u610f\u60ac\u7ebf\u6269\u5c55\u65f6b\u4e5f\u8981\u5339\u914d && hl [ i ][ hl [ i ][ j ]. r + 1 ]. h >= hl [ i ][ j ]. h ) { hl [ i ][ j ]. r = hl [ i ][ hl [ i ][ j ]. r + 1 ]. r ; } } } } int main () { //ios::sync_with_stdio(false); //cin.tie(0),cout.tie(0); //cin>>n>>m; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { //cin>>a[i][j]; scanf ( \"%d\" , & a [ i ][ j ]); mp [ a [ i ][ j ]] = { i , j }; hl [ i ][ j ] = { 1 , j , j }; } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { scanf ( \"%d\" , & b [ i ][ j ]); } } do_hoverline (); int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { ans = max ( ans ,( hl [ i ][ j ]. r - hl [ i ][ j ]. l + 1 ) * hl [ i ][ j ]. h ); } } //cout<<ans<<endl; printf ( \"%d \\n \" , ans ); return 0 ; }","title":"K.Largest Common Submatrix"},{"location":"old/%E8%87%AA%E5%88%B6Template/#_12","text":"\u9898\u610f\uff1a \u7ed9\u5b9a\u4e00\u4e2a\u75310,1\u7ec4\u6210\u7684n*n\u65b9\u9635\uff08n\u5728\u8fd0\u884c\u65f6\u63d0\u9192\u7528\u6237\u8f93\u5165\uff09\uff0c\u5224\u65ad\u5176\u4e2d\u7531\u51681\u7ec4\u6210\u7684\u6700\u5927\u5b50\u65b9\u9635\u7684\u5de6\u4e0a\u89d2\u4f4d\u7f6e\u548c\u9636\u6570\u3002\u7f16\u5199\u65b9\u6cd5\u5b9e\u73b0\u4e0a\u8ff0\u529f\u80fd\uff0c\u8fd4\u56de\u503c\u662f\u4e00\u4e2a\u5305\u542b3\u4e2a\u5143\u7d20\u7684\u6570\u7ec4\uff0c\u4f9d\u6b21\u8868\u793a\u884c\u4e0b\u6807\uff0c\u5217\u4e0b\u6807\uff0c\u9636\u6570\u3002 \u89e3\u6cd5\uff1a \u76f4\u63a5\u904d\u5386\u6bcf\u4e2a\u65b9\u683c\u5e76\u67e5\u627e\u4ee5\u8fd9\u4e2a\u65b9\u683c\u4e3a\u5de6\u4e0a\u89d2\u9876\u70b9\u7684\u6700\u5927\u5b50\u65b9\u9635\uff0c\u9700\u8981\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO\\left(n 3\\right)\u3002\u4e8b\u5b9e\u4e0a\u6b64\u95ee\u9898\u53ef\u7528\u60ac\u7ebf\u6cd5\u52a8\u6001\u89c4\u5212\u5c06\u65f6\u95f4\u590d\u6742\u5ea6\u4f18\u5316\u5230O\\left(n 2\\right)\u3002 \u5047\u8bbe\u6bcf\u4e2a\u65b9\u683c\u5bf9\u5e94\u4e00\u6761\u4ece\u8be5\u65b9\u683c\u5f00\u59cb\u5230\u8be5\u65b9\u683c\u80fd\u5411\u4e0a\u6269\u5c55\u5230\u7684\u6700\u9ad8\u4f4d\u7f6e\u4e3a\u6b62\u7684\u60ac\u7ebf\uff0c\u5e76\u5c06\u8fd9\u4e2a\u4f4d\u7f6e\u7684\u60ac\u7ebf\u9ad8\u5ea6\u8bb0\u4e0b\u3002\u60ac\u7ebf\u80fd\u5411\u4e0a\u6269\u5c55\uff0c\u5f53\u4e14\u4ec5\u5f53\u60ac\u7ebf\u9876\u90e8\u7684\u4e0a\u65b9\u65b9\u683c\u662f1\u3002\u7279\u522b\u5730\uff0c\u5982\u679c\u8fd9\u4e2a\u65b9\u683c\u5bf9\u5e94\u4f4d\u7f6e\u7684\u503c\u5c31\u662f0\uff0c\u90a3\u4e48\u8fd9\u4e2a\u60ac\u7ebf\u7684\u9ad8\u5ea6\u4e3a0\u3002 \u63a5\u4e0b\u6765\u8003\u8651\u8fd9\u4e2a\u60ac\u7ebf\u5411\u5de6\u6216\u8005\u5411\u53f3\u5e73\u79fb\uff0c\u5e76\u8003\u8651\u5b83\u6269\u5c55\u5230\u7684\u6700\u8fdc\u4f4d\u7f6e\u3002\u60ac\u7ebf\u80fd\u5411\u5de6\u6216\u8005\u5411\u53f3\u6269\u5c55\uff0c\u5f53\u4e14\u4ec5\u5f53\u60ac\u7ebf\u76ee\u524d\u80fd\u5411\u5de6\u6216\u5411\u53f3\u80fd\u6269\u5c55\u5230\u7684\u6700\u8fdc\u4f4d\u7f6e\u7684\u5de6\u8fb9\uff08\u6216\u8005\u53f3\u8fb9\uff09\u5c06\u88ab\u60ac\u7ebf\u8986\u76d6\u65f6\u8986\u76d6\u7684\u6240\u6709\u65b9\u683c\u90fd\u662f1\u3002\u4f8b\u5982\uff0c\u8003\u8651\u4e0b\u9762\u7684\u6570\u636e\u7684\u6700\u4e0b\u9762\u4e00\u884c\u7684\u65b9\u683c\u5bf9\u5e94\u7684\u60ac\u7ebf\uff1a $$ 0110\\ 1111\\ 1111\\ $$ \u7b2c3\u884c\u7b2c4\u5217\u7684\u65b9\u683c\u5bf9\u5e94\u7684\u60ac\u7ebf\u9ad8\u5ea6\u4e3a2\uff08\u56e0\u4e3a\u4ece\u8fd9\u4e2a\u4f4d\u7f6e\u5f00\u59cb\u5411\u4e0a\u80fd\u5230\u8fbe\u7684\u6700\u8fdc\u975e\u96f6\u683c\u662f\u7b2c2\u884c\u7b2c4\u5217\u7684\u65b9\u683c\uff09\uff0c\u80fd\u5411\u5de6\u6269\u5c55\u5230\u7684\u6700\u8fdc\u4f4d\u7f6e\u662f\u7b2c1\u5217\u3002\u800c\u7b2c3\u884c\u7b2c3\u5217\u7684\u65b9\u683c\u5bf9\u5e94\u7684\u60ac\u7ebf\u9ad8\u5ea6\u662f3\uff0c\u5411\u5de6\u80fd\u6269\u5c55\u5230\u7684\u6700\u8fdc\u4f4d\u7f6e\u662f\u7b2c2\u5217\uff08\u4e0d\u80fd\u518d\u5411\u7b2c\u4e00\u5217\u6269\u5c55\u4e86\uff0c\u56e0\u4e3a\u7b2c3\u884c\u7b2c1\u5217\u5bf9\u5e94\u65b9\u683c\u7684\u9ad8\u5ea6\u53ea\u67092\uff0c\u6bd4\u73b0\u5728\u7684\u60ac\u7ebf\u9ad8\u5ea63\u8981\u5c0f\uff09\u3002\u5982\u679c\u80fd\u5982\u6b64\u6c42\u51fa\u8fd9\u4e9b\u65b9\u683c\u7684\u60ac\u7ebf\u9ad8\u5ea6\u4ee5\u53ca\u4ed6\u4eec\u80fd\u5411\u5de6\u6216\u5411\u53f3\u6269\u5c55\u7684\u6700\u5927\u8ddd\u79bb\uff0c\u5c31\u80fd\u6c42\u51fa\u4ee5\u8be5\u60ac\u7ebf\u4e3a\u9ad8\u7684\u6700\u5927\u77e9\u5f62\u9762\u79ef\uff0c\u53d6\u8fd9\u4e9b\u77e9\u5f62\u7684\u957f\u5bbd\u4e2d\u7684\u6700\u5c0f\u503c\u5e76\u8ba1\u7b97\u51fa\u5bf9\u5e94\u7684\u6b63\u65b9\u5f62\u7684\u9762\u79ef\u4ee5\u53ca\u5de6\u4e0a\u89d2\u4f4d\u7f6e\uff0c\u5c31\u53ef\u4ee5\u627e\u5230\u6700\u5927\u5b50\u65b9\u9635\u3002 \u8003\u8651\u5982\u4f55\u6309\u884c\u66f4\u65b0\u6bcf\u4e00\u5217\u65b9\u683c\u7684\u60ac\u7ebf\u9ad8\u5ea6\uff1a\u5982\u679c\u4e0a\u4e00\u884c\u5bf9\u5e94\u4f4d\u7f6e\u7684\u60ac\u7ebf\u9ad8\u5ea6\u662fh\uff0c\u82e5\u5f53\u524d\u884c\u5bf9\u5e94\u65b9\u683c\u662f1\u5219\u5f53\u524d\u884c\u7684\u60ac\u7ebf\u9ad8\u5ea6\u5c31\u662fh+1\uff0c\u5426\u5219\u5c06\u60ac\u7ebf\u9ad8\u5ea6\u6e05\u96f6\u3002 \u8003\u8651\u66f4\u65b0\u60ac\u7ebf\u7684\u5411\u5de6\u6216\u8005\u5411\u53f3\u6269\u5c55\u7684\u6700\u8fdc\u8ddd\u79bb\uff1a\u4ee5\u5411\u5de6\u6269\u5c55\u4e3a\u4f8b\uff0c\u521d\u59cb\u503c\u5c31\u662f\u5f53\u524d\u5217\u3002\u82e5\u5f53\u524d\u60ac\u7ebf\u80fd\u6269\u5c55\u5230\u7684\u6700\u8fdc\u8ddd\u79bb\u7684\u5de6\u4fa7\u4e00\u5217\u7684\u540c\u4e00\u884c\u7684\u60ac\u7ebf\u9ad8\u5ea6\u6bd4\u5f53\u524d\u60ac\u7ebf\u9ad8\u5ea6\u66f4\u9ad8\uff0c\u8bf4\u660e\u90a3\u4e2a\u60ac\u7ebf\u5411\u5de6\u80fd\u6269\u5c55\u5230\u7684\u5730\u65b9\uff0c\u5f53\u524d\u60ac\u7ebf\u4e5f\u4e00\u5b9a\u80fd\u6269\u5c55\u5230\uff0c\u56e0\u6b64\u76f4\u63a5\u4f7f\u7528\u516c\u5f0f \\( \\(l\\left[i\\right]=l\\left[l\\left[i\\right]-1\\right]\\) \\) \u8f6c\u79fb\uff0c\u5176\u4e2dl[i] \u8868\u793a\u8fd9\u4e00\u884c\u7b2ci\u5217\u7684\u60ac\u7ebf\u80fd\u5411\u5de6\u6269\u5c55\u5230\u7684\u6700\u8fdc\u4f4d\u7f6e\u3002\u5982\u6b64\u53cd\u590d\u8fed\u4ee3\u76f4\u5230\u9047\u5230\u60ac\u7ebf\u9ad8\u5ea6\u6bd4\u5f53\u524d\u9ad8\u5ea6\u66f4\u77ee\u6216\u5230\u8fbe\u77e9\u9635\u5c3d\u5934\u4e3a\u6b62\u3002\u5411\u53f3\u80fd\u6269\u5c55\u5230\u7684\u6700\u8fdc\u8ddd\u79bb\u540c\u7406\u3002 \u7a0b\u5e8f\u5728\u5b9e\u73b0\u65f6\uff0c\u4e3a\u6bcf\u4e00\u884c\u7684\u6240\u6709\u5217\u5bf9\u5e94\u7684\u60ac\u7ebf\u5b9e\u73b0\u4e86\u4e00\u4e2aHoverline\u7c7b\uff0c\u5305\u542b\u4e09\u4e2a\u6210\u5458\uff1ah,l,r\uff0c\u5206\u522b\u8868\u793a\u60ac\u7ebf\u9ad8\u5ea6\u3001\u60ac\u7ebf\u80fd\u5411\u5de6\u548c\u5411\u53f3\u6269\u5c55\u5230\u7684\u6700\u8fdc\u4f4d\u7f6e\u3002\u540c\u65f6\u5305\u542binit\u3001update_l\u3001update_r\u4ee5\u53caget_ans\u65b9\u6cd5\uff0c\u5206\u522b\u7528\u4e8e\u521d\u59cb\u5316\u60ac\u7ebf\u7684\u9ad8\u5ea6\u548c\u80fd\u6269\u5c55\u5230\u7684\u6700\u8fdc\u4f4d\u7f6e\u3001\u66f4\u65b0\u5411\u5de6\u548c\u5411\u53f3\u80fd\u6269\u5c55\u5230\u7684\u6700\u8fdc\u4f4d\u7f6e\uff0c\u4ee5\u53ca\u8ba1\u7b97\u60ac\u7ebf\u5bf9\u5e94\u65b9\u9635\u7684\u5927\u5c0f\u548c\u5de6\u4e0a\u89d2\u5750\u6807\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 1. import java.util.Scanner ; 2. import java.util.Arrays ; 3. 4. class Hoverline { 5. public int [] h , l , r ; 6. public int n ; 7. Hoverline ( int n ){ 8. this . n = n ; 9. h = new int [ n ] ; 10. l = new int [ n ] ; 11. r = new int [ n ] ; 12. } 13. //\u7528\u4e8e\u521d\u59cb\u5316\u60ac\u7ebf\u7684\u9ad8\u5ea6\u548c\u80fd\u6269\u5c55\u5230\u7684\u6700\u8fdc\u4f4d\u7f6e 14. public void init ( int [][] m , int line ){ 15. for ( int i = 0 ; i < n ; i ++ ){ 16. h [ i ]= ( m [ line ][ i ]== 0 ) ? 0 :( h [ i ]+ 1 ); 17. l [ i ]= r [ i ]= i ; 18. } 19. } 20. //\u66f4\u65b0\u5411\u5de6\u80fd\u6269\u5c55\u5230\u7684\u6700\u8fdc\u4f4d\u7f6e 21. public void update_l ( int i ){ 22. while ( l [ i ]- 1 >= 0 && h [ l [ i ]- 1 ]>= h [ i ] ){ 23. l [ i ]= l [ l [ i ]- 1 ] ; 24. } 25. } 26. //\u66f4\u65b0\u5411\u5de6\u80fd\u6269\u5c55\u5230\u7684\u6700\u8fdc\u4f4d\u7f6e 27. public void update_r ( int i ){ 28. while ( r [ i ]+ 1 < n && h [ r [ i ]+ 1 ]>= h [ i ] ){ 29. r [ i ]= r [ r [ i ]+ 1 ] ; 30. } 31. } 32. //\u8ba1\u7b97\u60ac\u7ebf\u5bf9\u5e94\u65b9\u9635\u7684\u5927\u5c0f\u548c\u5de6\u4e0a\u89d2\u5750\u6807,\u540c\u65f6\u66f4\u65b0\u7b54\u6848 33. public void get_ans ( int [] ans , int line ){ 34. 35. for ( int i = 0 ; i < n ; i ++ ){ 36. int minval = Math . min ( r [ i ]- l [ i ]+ 1 , h [ i ] ); 37. int tmp_area = minval * minval ; 38. if ( tmp_area > ans [ 2 ] ){ 39. ans [ 0 ]= line - h [ i ]+ 1 ; 40. ans [ 1 ]= l [ i ] ; 41. ans [ 2 ]= tmp_area ; 42. } 43. } 44. } 45. } 46. 47. public class a { 48. 49. public static int [] findLargestBlock ( int [][] m ){ 50. int [] ans = new int [ 3 ] ; 51. 52. int n = m . length ; 53. Hoverline hoverline = new Hoverline ( n ); 54. //\u66f4\u65b0\u60ac\u7ebf 55. for ( int i = 0 ; i < n ; i ++ ){ 56. hoverline . init ( m , i ); 57. for ( int j = 0 ; j < n ; j ++ ) { 58. hoverline . update_l ( j ); 59. } 60. for ( int j = n - 1 ; j >= 0 ; j -- ){ 61. hoverline . update_r ( j ); 62. } 63. hoverline . get_ans ( ans , i ); 64. 65. } 66. 67. return ans ; 68. } 69. 70. // \u8f93\u5165\u77e9\u9635 71. static int [][] read_matrix () { 72. int n ; 73. Scanner sc = new Scanner ( System . in ); 74. System . out . println ( \"Enter matrix size:\" ); 75. n = sc . nextInt (); 76. int [][] m = new int [ n ][ n ] ; 77. for ( int i = 0 ; i < n ; i ++ ){ 78. for ( int j = 0 ; j < n ; j ++ ) 79. m [ i ][ j ]= sc . nextInt (); 80. } 81. return m ; 82. } 83. 84. public static void main ( String [] args ) { 85. 86. var m = read_matrix (); 87. var ans = findLargestBlock ( m ); 88. System . out . println ( \"row_index, column_index, size: \" + Arrays . toString ( ans )); //\u8f93\u51fa\u7b54\u6848 89. } 90. }","title":"\u6700\u5927\u5b50\u65b9\u9635"},{"location":"old/%E8%87%AA%E5%88%B6Template/#_13","text":"","title":"\u56db\u8fb9\u5f62\u4e0d\u7b49\u5f0f\u51b3\u7b56\u4f18\u5316"},{"location":"old/%E8%87%AA%E5%88%B6Template/#_14","text":"\u9898\u610f\uff1a n\u4e2a\u7269\u54c1\u6709\u91cd\u91cfwi\u548c\u4ef7\u503cvi\uff0c\u6700\u5927\u5316\u4ef7\u503c\u3002\uff08wi\u5728100\u4ee5\u5185\uff0c\u7269\u54c1\u4e2a\u65702e5\uff0c\u80cc\u5305\u5927\u5c0f2e5\uff0c\u4ef7\u503c1e9\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 #include <iostream> #include <cstdio> #include <algorithm> #include <memory.h> using namespace std ; const int N = 2e5 + 10 ; //!2 long long w [ 110 ][ N ], pre [ N ]; //\u4ef7\u503c long long dp [ N ], last [ N ]; int n , m ; struct P { int k , l , r ; } queue [ N ]; int hd , rr ; long long s ( int l ) { return pre [ l ]; } bool is_better ( int x , int k , int u , int i , int p ) //p is better than k for x(p<=x) { return last [ u + p * i ] + s ( x - p ) >= last [ u + k * i ] + s ( x - k ); } int bs ( int u , int i , int p ) { int bs_l = queue [ rr ]. l , bs_r = queue [ rr ]. r ; while ( bs_l < bs_r ) { int mid = ( bs_l + bs_r ) >> 1 ; if ( is_better ( mid , queue [ rr ]. k , u , i , p )) { bs_r = mid ; } else bs_l = mid + 1 ; } if ( bs_l == queue [ rr ]. r && ! is_better ( bs_l , queue [ rr ]. k , u , i , p )) bs_l ++ ; return bs_l ; } int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ), cout . tie ( 0 ); while ( cin >> n >> m ) { //memset(w,0,sizeof(w)); for ( int i = 1 ; i <= 100 ; i ++ ) w [ i ][ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int ww ; cin >> ww ; cin >> w [ ww ][ ++ w [ ww ][ 0 ]]; } for ( int i = 1 ; i <= m ; i ++ ) dp [ i ] = last [ i ] = 0 ; for ( int i = 1 ; i <= 100 ; i ++ ) { if ( w [ i ][ 0 ] == 0 ) { for ( int j = 0 ; j <= m ; j ++ ) last [ j ] = dp [ j ]; continue ; } sort ( w [ i ] + 1 , w [ i ] + w [ i ][ 0 ] + 1 , greater < long long > ()); for ( int j = 1 ; j <= w [ i ][ 0 ]; j ++ ) pre [ j ] = pre [ j -1 ] + w [ i ][ j ]; for ( int u = 0 ; u < i ; u ++ ) { hd = 1 , rr = 0 ; //reset queue int pmax = ( m - u ) / i ; queue [ ++ rr ] = { 0 , 1 , min ( pmax ,( int )( 0 + w [ i ][ 0 ]))}; //k=0 ,l=1, r=k+w[i][0] for ( int p = 1 ; p <= pmax ; p ++ ) { while ( hd <= rr && ( queue [ hd ]. r < p )) hd ++ ; //time out if ( queue [ hd ]. l < p ) queue [ hd ]. l = p ; //can transfer if ( hd <= rr && queue [ hd ]. l <= p && p <= queue [ hd ]. r ) dp [ u + p * i ] = max ( dp [ u + p * i ], last [ u + queue [ hd ]. k * i ] + s ( p - queue [ hd ]. k )); //try to insert new policy (from last[u+p*i]) (p<=queue[rr].l<=queue[rr].r) while ( hd <= rr && is_better ( queue [ rr ]. l , queue [ rr ]. k , u , i , p )) rr -- ; int pos ; if ( hd <= rr ) { pos = bs ( u , i , p ); queue [ rr ]. r = pos -1 ;} //!1 else pos = 1 ; queue [ ++ rr ] = { p , pos , min ( pmax ,( int )( p + w [ i ][ 0 ]))}; } } for ( int j = 0 ; j <= m ; j ++ ) last [ j ] = dp [ j ]; } long long ans = 0 ; for ( int i = 0 ; i <= m ; i ++ ) ans = max ( ans , dp [ i ]); cout << ans << endl ; } return 0 ; }","title":"\u5c0f\u7c73\u8d5b\u80cc\u5305\u9898"},{"location":"old/%E8%87%AA%E5%88%B6Template/#_15","text":"","title":"\u6570\u5b66"},{"location":"old/%E8%87%AA%E5%88%B6Template/#_16","text":"","title":"\u9ad8\u65af\u6d88\u5143"},{"location":"old/%E8%87%AA%E5%88%B6Template/#luogu-4035-ball_space_generator","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 #include <iostream> #include <iomanip> #include <cmath> using namespace std ; int n ; double c [ 101 ][ 102 ], a [ 101 ][ 102 ]; void gaussian_elimination () { double sum1 , sum2 ; sum1 = sum2 = 0.0 ; for ( int i = 1 ; i <= n ; i ++ ) { sum1 = sum2 = 0.0 ; for ( int j = 1 ; j <= n ; j ++ ) { sum1 += a [ i ][ j ] * a [ i ][ j ]; sum2 += a [ i + 1 ][ j ] * a [ i + 1 ][ j ]; c [ i ][ j ] = 2 * ( a [ i + 1 ][ j ] - a [ i ][ j ]); } c [ i ][ n + 1 ] = sum2 - sum1 ; } int pos = 1 ; for ( int i = 1 ; i <= n ; i ++ ) //for per line { bool flag_of_find = false ; for ( int j = pos ; j <= n ; j ++ ) { if ( fabs ( c [ i ][ j ]) > 1e-8 ) //c[j][i] ???????? { flag_of_find = true ; for ( int k = 1 ; k <= n + 1 ; k ++ ) { swap ( c [ pos ][ k ], c [ i ][ k ]); } } } if ( ! flag_of_find ) continue ; for ( int j = 1 ; j <= n ; j ++ ) { if ( j == pos ) continue ; double rate = c [ j ][ i ] / c [ pos ][ i ]; for ( int k = 1 ; k <= n + 1 ; k ++ ) { c [ j ][ k ] -= rate * c [ pos ][ k ]; } } pos ++ ; } } int main () { ios :: sync_with_stdio ( false ); cin >> n ; for ( int i = 1 ; i <= n + 1 ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) cin >> a [ i ][ j ]; } gaussian_elimination (); cout << fixed ; for ( int i = 1 ; i <= n ; i ++ ) { cout << setprecision ( 3 ) << c [ i ][ n + 1 ] / c [ i ][ i ] << \" \" ; } return 0 ; }","title":"luogu 4035 ball_space_generator"},{"location":"old/%E8%87%AA%E5%88%B6Template/#gaussian-elimination","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include <iostream> #include <cstdio> #include <cmath> using namespace std ; const int N = 888 ; double c [ N ][ N ]; int n ; int main () { cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n + 1 ; j ++ ) { cin >> c [ i ][ j ]; } } //int i=1; //ps:\u5c06pos\u6539\u6210i\u540e\uff0c\u5f97\u5230\u7684\u77e9\u9635\u5c06\u662f\u5bf9\u89d2\u7ebf\u4e0a\u5168\u662f1\u7684\u77e9\u9635 for ( int i = 1 ; i <= n ; i ++ ) { //find a equation that the coefficient of the x_i is not 0 bool flag_of_find = false ; for ( int j = i ; j <= n ; j ++ ) { if ( fabs ( c [ j ][ i ]) > 1e-8 ) { flag_of_find = true ; for ( int k = 1 ; k <= n + 1 ; k ++ ) { swap ( c [ i ][ k ], c [ j ][ k ]); } } } if ( ! flag_of_find ) continue ; for ( int j = 1 ; j <= n ; j ++ ) { if ( i == j ) continue ; double rate = c [ j ][ i ] / c [ i ][ i ]; for ( int k = 1 ; k <= n + 1 ; k ++ ) { c [ j ][ k ] -= c [ i ][ k ] * rate ; } } //i++; } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n + 1 ; j ++ ) { printf ( \"%.8lf \" , c [ i ][ j ]); } cout << endl ; } return 0 ; }","title":"gaussian elimination"},{"location":"old/%E8%87%AA%E5%88%B6Template/#2020-icpc-shenyang-a","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <cstdlib> #include <algorithm> #include <string> #include <vector> #include <map> #include <unordered_map> #include <set> #include <unordered_set> #include <queue> using namespace std ; typedef long long ll ; const int N = 310 , Mod = 998244353 ; int n ; int a [ N ][ N ]; int b [ N ][ N ]; int c [ N ][ N ], d [ N ]; ll pow2 [ N ]; void predo () { pow2 [ 0 ] = 1 ; for ( int i = 1 ; i <= 305 ; i ++ ) { pow2 [ i ] = pow2 [ i -1 ] * 2 ; pow2 [ i ] %= Mod ; } } void gauss_elimination ( int c [][ N ], int b [], int n ) { int pos = 1 ; for ( int i = 1 ; i <= n ; i ++ ) // for every x { bool flag_of_find = false ; for ( int j = pos ; j <= n ; j ++ ) { if ( c [ j ][ i ]) { flag_of_find = true ; for ( int k = 1 ; k <= n ; k ++ ) swap ( c [ pos ][ k ], c [ j ][ k ]); swap ( b [ pos ], b [ j ]); } } if ( ! flag_of_find ) continue ; for ( int j = 1 ; j <= n ; j ++ ) //for every equation, execute elimination { if ( j == pos ) continue ; if ( c [ j ][ i ] == 0 ) continue ; //1->0: No need to eliminate for ( int k = 1 ; k <= n ; k ++ ) { c [ j ][ k ] ^= c [ pos ][ k ]; } b [ j ] ^= b [ pos ]; } pos ++ ; } } void work () { ll ans = 1 ; for ( int j = 1 ; j <= n ; j ++ ) { for ( int i = 1 ; i <= n ; i ++ ) { for ( int k = 1 ; k <= n ; k ++ ) { c [ i ][ k ] = 0 ; if ( a [ i ][ k ]) { c [ i ][ k ] = 1 ; } } if ( b [ i ][ j ]) { c [ i ][ i ] ^= 1 ; } } fill ( d , d + n + 1 , 0 ); gauss_elimination ( c , d , n ); int pos = 1 ; int ans2 = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { while ( pos <= n && c [ i ][ pos ] == 0 ) { pos ++ ; } if ( pos <= n ) { ans2 ++ ; } } ans2 = n - ans2 ; ans = ( ans * pow2 [ ans2 ]) % Mod ; } cout << ans << endl ; } int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ), cout . tie ( 0 ); freopen ( \"a_in.txt\" , \"r\" , stdin ); cin >> n ; predo (); for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { cin >> a [ i ][ j ]; } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { cin >> b [ i ][ j ]; } } work (); return 0 ; }","title":"2020 icpc shenyang A"},{"location":"old/%E8%87%AA%E5%88%B6Template/#_17","text":"\u53ef\u5728\u5bf9\u6570\u65f6\u95f4\u5185\u5b8c\u6210\u63d2\u5165\u3001\u67e5\u8be2\u96c6\u5408\u6700\u5927\u503c\u548c\u6700\u5c0f\u5f02\u6216\u548c\u7684\u64cd\u4f5c\u3002 \u5b8c\u6210\u91cd\u6784\u64cd\u4f5c\u540e\uff08\u82b1\u8d39\u5bf9\u6570\u5e73\u65b9\u7684\u65f6\u95f4\uff09\u53ef\u8f6c\u6362\u4e3a\u5f62\u4f3c\u4e8e\u6700\u7b80\u884c\u9636\u68af\u578b\u77e9\u9635\u7684\u5f62\u5f0f\uff0c\u4e4b\u540e\u53ef\u5728\u5bf9\u6570\u65f6\u95f4\u5185\u67e5\u8be2\u96c6\u5408\u5185\u7b2ck\u5927\u5f02\u6216\u548c\u3002 \u6700\u5927\u503c \uff08restructure\u524d\uff09\u4ece\u5927\u5230\u5c0f\u679a\u4e3e\u6bcf\u4e2a\u6570\u5f02\u6216\u8fdb\u6765\u4f1a\u4e0d\u4f1a\u4f7f\u5f97\u7b54\u6848\u66f4\u5927\uff0c\u5982\u679c\u4f1a\u5c31\u5f02\u6216\u8fdb\u6765\u3002 \u5982\u679c\u9700\u8981\u5728\u5f02\u6216\u521d\u503c\u4e0d\u4e3a\u96f6\u7684\u60c5\u51b5\u4e0b\u53d6\u5f97\u6700\u5927\u503c\uff0c\u53ea\u9700\u8981\u66f4\u6539ans\u7684\u521d\u59cb\u503c\u5373\u53ef\u3002 \u6700\u5c0f\u503c \uff1a \u76f4\u63a5\u8d2a\u5fc3\u62ff\u7ebf\u6027\u57fa\u4e2d\u6700\u5c0f\u7684\u6570\uff08\u5f53\u7136\uff0c\u9700\u8981\u7279\u5224\u7ebf\u6027\u57fa\u662f\u5426\u53ef\u83b7\u5f970\uff09 Funs || Methods Reliance Time Complexity Inputs Outputs Description LB 1 \u6784\u9020\u51fd\u6570 insert log x \u8fd4\u56de\u662f\u5426\u63d2\u5165\u6210\u529f\uff0c\u4e0d\u6210\u529f\u5219\u8868\u660e\u5176\u53ef\u4ee5\u88ab\u7ebf\u6027\u8868\u51fa \u5c06x\u63d2\u5165\u7ebf\u6027\u57fa get_max log ans=0 \u6700\u5927\u503c \u53d6\u5f97\u7ebf\u6027\u57fa\u80fd\u7ebf\u6027\u8868\u51fa\u7684\u6700\u5927\u503c\uff08\u91cd\u6784\u524d\uff09\uff0c\u82e5\u521d\u59cb\u5f02\u6216\u503c\u4e0d\u4e3a0\u5219\u5411ans\u4f20\u9012\u53c2\u6570 get_min log \u6700\u5c0f\u503c \u53d6\u5f97\u7ebf\u6027\u57fa\u4e2d\u80fd\u8868\u51fa\u7684\u6700\u5c0f\u7684\u503c\uff08\u91cd\u6784\u524d\uff09 restructure log^2 \u4fee\u6539p\u6570\u7ec4 \u5bf9\u7ebf\u6027\u57fa\u505a\u884c\u53d8\u6362\u4f7f\u5176\u6210\u4e3a\u7c7b\u4f3c\u4e8e\u9ad8\u65af\u6d88\u5143\u7684\u5f62\u5f0f\uff0c\u4ee5\u4fbf\u80fd\u6c42\u51fa\u6392\u540d kth restructure log k:\u7b2ck\u5c0f\u6570\u7684\u6392\u540dk \u7b2ck\u5c0f\u6570 \u6c42\u51fa\u7b2ck\u5c0f\u7684\u80fd\u88ab\u8868\u51fa\u7684\u6570\uff08\u91cd\u6784\u540e\uff09 operator| log^2 n2\uff1a\u5f85\u5408\u5e76\u7684\u7ebf\u6027\u57fa ret\uff1a\u5408\u5e76\u540e\u7684\u7ebf\u6027\u57fa \u5408\u5e76\u7ebf\u6027\u57fa\uff08\u91cd\u6784\u524d\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 //HDOJ 3949 #include <iostream> #include <cstdio> #include <cstring> #include <memory.h> #include <algorithm> #include <map> #include <vector> #include <queue> #include <cmath> using namespace std ; typedef long long ll ; const int N = 2e5 + 10 ; namespace Linear_Basis { struct LB //linear basis { static const int SZ = 63 ; //local ll p [ SZ ]; //p\uff1a\u7b2ci\u4e2ap\u4fdd\u5b58\u5bf9\u5e94\u6700\u9ad8\u4f4d\u4e3a1\u7684\u6570 bool flag ; //flag:\u662f\u5426\u53ef\u5f02\u6216\u5f97\u52300 (whether can do xor to obtain 0) int cnt ; //cnt\uff1a\u91cd\u6784\u540e\uff08\u9ad8\u65af\u6d88\u5143\uff09\u7684\u57fa\u5927\u5c0f //\u521d\u59cb\u5316 LB () { //for(int i=0;i<SZ;i++) //p[i]=0; memset ( p , 0 , sizeof ( p )); //\u6ca1\u4ec0\u4e48\u592a\u5927\u6027\u80fd\u5f00\u9500 cnt = flag = 0 ; } //\u63d2\u5165x\u5230\u7ebf\u6027\u57fa\u4e2d bool insert ( ll x ) { for ( int j = SZ -1 ; j >= 0 ; j -- ) { if ( x >> j == 0 ) continue ; if ( p [ j ] == 0 ) { p [ j ] = x ; return true ; } x ^= p [ j ]; } flag = true ; return false ; } //\u53d6\u5f97\u7ebf\u6027\u57fa\u80fd\u7ebf\u6027\u8868\u51fa\u7684\u6700\u5927\u503c\uff08\u91cd\u6784\u524d\uff09 ll get_max ( ll ans = 0 ) //ans:\u5f02\u6216\u521d\u503c { for ( int i = SZ -1 ; i >= 0 ; i -- ) { if (( ans ^ p [ i ]) > ans ) ans ^= p [ i ]; } return ans ; } //\u53d6\u5f97\u7ebf\u6027\u57fa\u4e2d\u80fd\u8868\u51fa\u7684\u6700\u5c0f\u7684\u503c\uff08\u91cd\u6784\u524d\uff09 ll get_min () { if ( flag ) return 0 ; for ( int i = 0 ; i < SZ ; i ++ ) { if ( p [ i ]) return p [ i ]; } return 0 ; } //\u5bf9\u7ebf\u6027\u57fa\u505a\u884c\u53d8\u6362\u4f7f\u5176\u6210\u4e3a\u7c7b\u4f3c\u4e8e\u9ad8\u65af\u6d88\u5143\u7684\u5f62\u5f0f void restructure () { for ( int i = SZ -1 ; i >= 0 ; i -- ) { if ( p [ i ]) { for ( int j = i -1 ; j >= 0 ; j -- ) { if ( p [ i ] & ( 1l l << j )) { p [ i ] ^= p [ j ]; } } } } for ( int i = 0 ; i < SZ ; i ++ ) { if ( p [ i ]) { p [ cnt ++ ] = p [ i ]; } } } //\u6c42\u51fa\u7b2ck\u5c0f\u7684\u80fd\u88ab\u8868\u51fa\u7684\u6570\uff08\u91cd\u6784\u540e\uff09 ll kth ( ll k ) //before calling this func, must run restructure func once { //\u5bf9k\u6216k-1\u505a\u4e8c\u8fdb\u5236\u5206\u89e3 if ( flag ) k -- ; if ( k == 0 ) return 0 ; if ( k >= ( 1l l << cnt )) return -1 ; ll ans = 0 ; for ( int i = 0 ; i < cnt ; i ++ ) { if ( k & ( 1l l << i )) { ans ^= p [ i ]; } } return ans ; } //\u5408\u5e76\u7ebf\u6027\u57fa\uff08\u91cd\u6784\u524d\uff09 LB operator | ( const LB & n2 ) //\u5408\u5e76\u7ebf\u6027\u57fa { LB ret = * this ; for ( int i = 0 ; i < SZ ; i ++ ) { if ( n2 . p [ i ]) { ret . insert ( n2 . p [ i ]); } } ret . flag |= n2 . flag ; //? return ret ; } }; } using namespace Linear_Basis ; int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); int T ; cin >> T ; for ( int _ = 1 ; _ <= T ; _ ++ ) { int n ; cin >> n ; LB lb ; for ( int i = 1 ; i <= n ; i ++ ) { ll x ; cin >> x ; lb . insert ( x ); } lb . restructure (); cout << \"Case #\" << _ << \":\" << endl ; int q ; cin >> q ; for ( int i = 1 ; i <= q ; i ++ ) { ll k ; cin >> k ; cout << lb . kth ( k ) << endl ; } } return 0 ; }","title":"\u7ebf\u6027\u57fa"},{"location":"old/%E8%87%AA%E5%88%B6Template/#_18","text":"\u8fd9\u4e2a\u61d2\u5f97\u6574namespace\u4e86\u2026\u2026 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include <iostream> #include <cstdio> #include <cmath> using namespace std ; const int N = 114514 ; long long inv [ N ], p ; void linear_inv ( int n ) //in mod p { inv [ 1 ] = 1 ; //p=ki+j==0 (mod p) -> -kj^-1=i^-1 //k=p/i, j=(p%i)^-1 for ( int i = 2 ; i <= n ; i ++ ) { inv [ i ] = ( long long )( p - p / i ) * inv [ p % i ] % p ; //(p-p/i)==(-p/i) } //if inv[i]=0, inverse not exists. //\u5982\u679c\u6ca1\u6709\u76f8\u5e94\u7684\u9006\u5143\u7684\u65f6\u5019\uff0cinv[i] \u7684\u503c\u662f\u672a\u5b9a\u4e49\u7684 } int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ), cout . tie ( 0 ); return 0 ; }","title":"\u7ebf\u6027\u6c42\u9006\u5143"},{"location":"old/%E8%87%AA%E5%88%B6Template/#n","text":"","title":"\u7ebf\u6027\u6c42\u4efb\u610f\u7ed9\u5b9an\u4e2a\u6570\u7684\u9006\u5143"},{"location":"old/%E8%87%AA%E5%88%B6Template/#luogu-5431-multi_inverse2","text":"\u9898\u610f\uff1a\u7ed9\u5b9an\u4e2a\u6570ai\uff0c\u6c42\u5728mod p\u610f\u4e49\u4e0b\u7684\u9006\u5143\u3002\u7ed9\u5b9a\u5e38\u6570k\uff0c\u8f93\u51fa \\(\\sum_{i=1}^n \\frac{k^i}{a_i} \\% p\\) \u89e3\u6cd5\uff1a \u9996\u5148\u8ba1\u7b97 \\(n\\) \u4e2a\u6570\u7684\u524d\u7f00\u79ef\uff0c\u8bb0\u4e3a \\(s_i\\) \uff0c\u7136\u540e\u4f7f\u7528\u5feb\u901f\u5e42\u6216\u6269\u5c55\u6b27\u51e0\u91cc\u5f97\u6cd5\u8ba1\u7b97 \\(s_n\\) \u7684\u9006\u5143\uff0c\u8bb0\u4e3a \\(sv_n\\) \u3002 \u56e0\u4e3a \\(sv_n\\) \u662f \\(n\\) \u4e2a\u6570\u7684\u79ef\u7684\u9006\u5143\uff0c\u6240\u4ee5\u5f53\u6211\u4eec\u628a\u5b83\u4e58\u4e0a \\(a_n\\) \u65f6\uff0c\u5c31\u4f1a\u548c \\(a_n\\) \u7684\u9006\u5143\u62b5\u6d88\uff0c\u4e8e\u662f\u5c31\u5f97\u5230\u4e86 \\(a_1\\) \u5230 \\(a_{n-1}\\) \u7684\u79ef\u9006\u5143\uff0c\u8bb0\u4e3a \\(sv_{n-1}\\) \u3002 \u540c\u7406\u6211\u4eec\u53ef\u4ee5\u4f9d\u6b21\u8ba1\u7b97\u51fa\u6240\u6709\u7684 \\(sv_i\\) \uff0c\u4e8e\u662f \\(a_i^{-1}\\) \u5c31\u53ef\u4ee5\u7528 \\(s_{i-1} \\times sv_i\\) \u6c42\u5f97\u3002 \u6240\u4ee5\u6211\u4eec\u5c31\u5728 \\(O(n + \\log p)\\) \u7684\u65f6\u95f4\u5185\u8ba1\u7b97\u51fa\u4e86 \\(n\\) \u4e2a\u6570\u7684\u9006\u5143\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 #include <iostream> #include <cstdio> using namespace std ; const int N = 5e6 + 10 ; int n , p , k , kk = 1 , ans = 0 ; int a [ N ], s [ N ], sv [ N ], inv [ N ]; typedef long long ll ; namespace Fast_IO { template < typename T > inline void read ( T & x ) { char c ; int sgn = 1 ; x = 0 ; c = getchar (); while ( c > '9' || c < '0' ) { if ( c == '-' ) sgn = -1 ; c = getchar (); } while ( c <= '9' && c >= '0' ) { x = ( x << 3 ) + ( x << 1 ) + ( c - '0' ); c = getchar (); } x *= sgn ; } // template <typename T> inline void read(T &x){ // x=0; // char ch; // for(ch=getchar();ch<'0'||ch>'9';ch=getchar()); // for(;ch>='0'&&ch<='9';ch=getchar()) // x=(x<<3)+(x<<1)+(ch&15); // } template < typename T > inline void print ( T x ) { if ( x < 0 ) { putchar ( '-' ); x = - x ; } if ( x > 9 ) { print ( x / 10 ); } putchar ( x % 10 + '0' ); } } // namespace Fast_IO using namespace Fast_IO ; // //\u6269\u5c55\u6b27\u51e0\u91cc\u5f97\uff1aax+by=1 // ll exgcd(ll a,ll b,ll &x,ll &y) // { // if(!b) // { // x=1,y=0; // return a; // } // ll d=exgcd(b,a%b,x,y),tempx=x,tempy=y; // x=tempy; // y=tempx-tempy*(a/b); // return d; // } //\u5faa\u73af int ksm ( int a , int b , int Mod ) { int ans = 1 ; while ( b ) { if ( b & 1 ) ans = ( 1l l * ans * a ) % Mod ; a = ( 1l l * a * a ) % Mod ; b >>= 1 ; } return ans ; } void getinv () { // long long x,y; //exgcd(s[n],p,x,y); //get s[n]^-1 (mod p) //sv[n]=(x%p+p)%p; //sv[i]=s[i]^-1 //exgcd(k,p,x,y); int k_inv = ksm ( k , p -2 , p ); sv [ n ] = ksm ( s [ n ], p -2 , p ); for ( int i = n ; i >= 1 ; i -- ) { if ( i < n ) { sv [ i ] = ( 1l l * sv [ i + 1 ] * a [ i + 1 ]) % p ; } inv [ i ] = ( 1l l * sv [ i ] * s [ i -1 ]) % p ; // print(inv[i]); // putchar('\\n'); //custom ans = ( ans + ( 1l l * kk * inv [ i ]) % p ) % p ; kk = ( 1l l * kk * k_inv ) % p ; } print ( ans ); } int main () { read ( n ), read ( p ), read ( k ); s [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { // scanf(\"%d\",&a[i]); read ( a [ i ]); s [ i ] = ( 1l l * s [ i -1 ] * a [ i ]) % p ; kk = ( 1l l * kk * k ) % p ; } getinv (); return 0 ; }","title":"luogu 5431 multi_inverse2"},{"location":"old/%E8%87%AA%E5%88%B6Template/#_19","text":"Funs || Methods Reliance Time Complexity Inputs Outputs Description linear_sieve n n prime,p,v \u7b5b\u51fa\u5230n\u4e3a\u6b62\u7684\u8d28\u6570 \u5206\u89e3k\u7684\u56e0\u6570 linear_sieve <=sqrt k res\uff1a\u4e00\u4e2a\u4fdd\u5b58\u6240\u6709\u56e0\u6570\u7684vector\uff08\u6ca1\u6392\u5e8f\uff09 \u5206\u89e3k\u7684\u56e0\u6570\uff0c\u5b58\u5728vector\u4e2d \u5206\u89e3x\u7684\u8d28\u56e0\u6570 linear_sieve log x res\uff1a\u4fdd\u5b58pair\u7684vector\uff0cpair\u7b2c\u4e00\u4e2a\u6570\u662fprime\uff0c\u7b2c\u4e8c\u4e2a\u6570\u662fcnt \u5206\u89e3x\u7684\u8d28\u56e0\u6570 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 //\u7ebf\u6027\u7b5b+\u5206\u89e3\u56e0\u6570 #include <vector> #include <iostream> using namespace std ; namespace L { const int N = ( int ) 1e7 + 10 ; //local int prime [ N ], p , v [ N ]; //prime\uff1a\u8d28\u6570\u96c6\u5408 //p:\u8d28\u6570\u4e2a\u6570 //v\uff1a\u4e0b\u6807i\u4ee3\u8868\u7684\u6570\u7684\u6700\u5c0f\u8d28\u56e0\u5b50 //\u7b5b\u51fa\u5230n\u4e3a\u6b62\u7684\u8d28\u6570 void linear_sieve ( int n ) { for ( int i = 2 ; i <= n ; i ++ ) { if ( ! v [ i ]) { v [ i ] = i ; prime [ ++ p ] = i ; } for ( int j = 1 ; j <= p && ( long long ) prime [ j ] * i <= n && v [ i ] >= prime [ j ]; j ++ ) { v [ i * prime [ j ]] = prime [ j ]; } } } //\u5206\u89e3k\u7684\u56e0\u6570(\u9700\u8981\u6392\u5e8f\uff01) vector < long long > Div ( long long k ) { vector < long long > res ; res . push_back ( 1 ); for ( long long i = 1 ; prime [ i ] * prime [ i ] <= k ; i ++ ) { if ( k % prime [ i ] == 0 ) { long long now = prime [ i ]; long long len = res . size (); while ( k % prime [ i ] == 0 ) { for ( long long j = 0 ; j < len ; j ++ ) { res . push_back ( res [ j ] * now ); } now *= prime [ i ]; k /= prime [ i ]; } } } if ( k > 1 ) { long long len = res . size (); for ( long long j = 0 ; j < len ; j ++ ) { res . push_back ( res [ j ] * k ); } } return res ; } //\u5206\u89e3x\u7684\u8d28\u56e0\u6570 vector < pair < int , int >> div2 ( int x ) //\u5206\u89e3\u8d28\u56e0\u6570 { vector < pair < int , int >> res ; while ( x > 1 ) { int minprime = v [ x ]; int cnt = 0 ; while ( x % minprime == 0 ) { x /= minprime ; cnt ++ ; } res . push_back ({ minprime , cnt }); } return res ; } } using namespace L ; int main () { linear_sieve ( 1e7 ); int n ; cin >> n ; vector < long long > s = Div ( n ); for ( auto i : s ) cout << i << \" \" ; return 0 ; }","title":"\u7ebf\u6027\u8d28\u6570\u7b5b \u4e0e \u57fa\u4e8e\u7b5b\u7684\u56e0\u6570\u5206\u89e3"},{"location":"old/%E8%87%AA%E5%88%B6Template/#phi","text":"","title":"\u6b27\u62c9\u51fd\u6570Phi\u7b5b"},{"location":"old/%E8%87%AA%E5%88%B6Template/#16th-f-function","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <cstdlib> #include <algorithm> #include <string> #include <vector> #include <map> #include <unordered_map> #include <set> #include <unordered_set> #include <queue> using namespace std ; typedef unsigned long long ll ; const int N = 1e7 + 10 ; int phi [ N ]; int pri [ N ]; ll vis [ N ]; int cnt = 0 ; void init () { phi [ 1 ] = 1 ; for ( int i = 2 ; i <= 10000000 ; ++ i ) { if ( ! vis [ i ]) { phi [ i ] = i - 1 ; pri [ cnt ++ ] = i ; } for ( int j = 0 ; j < cnt ; ++ j ) { if ( 1l l * i * pri [ j ] > 10000000 ) break ; vis [ i * pri [ j ]] = pri [ j ]; if ( i % pri [ j ]) { phi [ i * pri [ j ]] = phi [ i ] * ( pri [ j ] - 1 ); } else { // i % pri[j] == 0 // \u6362\u8a00\u4e4b\uff0ci \u4e4b\u524d\u88ab pri[j] \u7b5b\u8fc7\u4e86 // \u7531\u4e8e pri \u91cc\u9762\u8d28\u6570\u662f\u4ece\u5c0f\u5230\u5927\u7684\uff0c\u6240\u4ee5 i \u4e58\u4e0a\u5176\u4ed6\u7684\u8d28\u6570\u7684\u7ed3\u679c\u4e00\u5b9a\u4f1a\u88ab // pri[j] \u7684\u500d\u6570\u7b5b\u6389\uff0c\u5c31\u4e0d\u9700\u8981\u5728\u8fd9\u91cc\u5148\u7b5b\u4e00\u6b21\uff0c\u6240\u4ee5\u8fd9\u91cc\u76f4\u63a5 break // \u6389\u5c31\u597d\u4e86 phi [ i * pri [ j ]] = phi [ i ] * pri [ j ]; break ; } } } } ll cal ( int xx ) { int t = 0 ; int tx = vis [ xx ], txx = xx ; for (;;) { if (( xx / tx ) * tx != xx ) { break ; } t ++ ; xx /= tx ; } ll sum = 0 ; sum = t % 2 == 0 ? t / 2 : t / 2 + 1 ; sum = txx / pow ( tx , sum ); return sum ; } int main () { ll ans = 0 ; init (); int n ; cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) { if ( vis [ i ] == 0 ) { //cout<<\"t\"<<1<<endl; ans += 1 ; continue ; } else { auto tmp = cal ( i ); //cout<<\"t\"<<tmp<<endl; ans += tmp ; } } cout << ans << endl ; return 0 ; }","title":"16th \u9ed1\u9f99\u6c5f\u7701\u8d5b f-function"},{"location":"old/%E8%87%AA%E5%88%B6Template/#_20","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 namespace Mo { const int NN = 1e7 + 10 ; int mu [ NN ], v [ NN ], prime [ NN ], prime_tot ; //\u7b5b\u51fa\u8d28\u6570\u4e0e\u83ab\u6bd4\u4e4c\u65af\u51fd\u6570\u7684\u503c void linear_sieve_mo ( int n ) { prime_tot = 0 ; mu [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( ! v [ i ]) { v [ i ] = i ; prime [ ++ prime_tot ] = i ; mu [ i ] = -1 ; } for ( int j = 1 ; j <= prime_tot && 1l l * i * prime [ j ] <= n ; j ++ ) { v [ i * prime [ j ]] = prime [ j ]; if ( i % prime [ j ] == 0 ) { mu [ i * prime [ j ]] = 0 ; break ; } mu [ i * prime [ j ]] = - mu [ i ]; } } } } using namespace Mo ;","title":"\u83ab\u6bd4\u4e4c\u65af\u51fd\u6570"},{"location":"old/%E8%87%AA%E5%88%B6Template/#_21","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <cstdlib> #include <algorithm> #include <string> #include <vector> #include <map> #include <unordered_map> #include <set> #include <unordered_set> #include <queue> using namespace std ; typedef long long ll ; namespace Shulunfenkuai { inline ll ceil ( ll n , ll m ) { return n / m + ( n % m != 0 ); } //\u5411\u4e0a\u53d6\u6574\u6c42\u548c ll calculate1 ( ll k , ll n ) { ll ans = 0 ; for ( ll x = 1 , gx ; x <= n ; x = gx + 1 ) { gx = ( k / x ) ? min ( k / ( k / x ) , n ) : n ; ans += k / x ; } return ans ; } //\u5411\u4e0b\u53d6\u6574\u6c42\u548c : k/m <= i <= (k-1)/(m-1) , (m=ceil(k/i)) //https://www.cnblogs.com/zjjws/p/13393858.html ll calculate2 ( ll k , ll n ) { ll ans = 0 ; for ( ll x = 1 , gx ; x <= n ; x = gx + 1 ) { ll v = ceil ( n , x ); gx = ( v != 1 ) ? min (( k -1 ) / ( v -1 ) , n ) : ( n ); ans += v ; } return ans ; } } using namespace Shulunfenkuai ; int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ), cout . tie ( 0 ); return 0 ; }","title":"\u6570\u8bba\u5206\u5757"},{"location":"old/%E8%87%AA%E5%88%B6Template/#_22","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 const long long Mod = 10 ; //\u9012\u5f52 long long ksm ( long long a , long long b ) { if ( b == 0 ) return 1 ; if ( b == 1 ) return a % Mod ; long long ans = ksm ( a , b >> 1 ); ans *= ans ; ans %= Mod ; if ( b & 1 ) { ans *= a ; } return ans % Mod ; } //\u5faa\u73af long long ksm ( long long a , long long b , long long Mod ) { long long ans = 1 ; while ( b ) { if ( b & 1 ) ans = ( ans * a ) % Mod ; a = ( a * a ) % Mod ; b >>= 1 ; } return ans ; } //\u5feb\u901f\u4e58\u6cd5\uff08\u7528\u4e8e\u89e3\u51b3\u4e58\u6cd5\u7206longlong\uff09 long long mul ( long long a , long long b , long long Mod ) { long long ans = a ; while ( b ) { if ( b & 1 ) ans = ( ans + a ) % Mod ; a = ( a + a ) % Mod ; b >>= 1 ; } return ans ; }","title":"\u5feb\u901f\u5e42"},{"location":"old/%E8%87%AA%E5%88%B6Template/#gcdexgcd","text":"Funs || Methods Reliance Time Complexity Inputs Outputs Description gcd log a,b gcd(a,b) gcd exgcd log a,b,x,y \u8fd4\u56degcd(a,b)\uff0c\u4fee\u6539x\u3001y\u4f5c\u4e3a\u7ed3\u679c exgcd\uff1aax+by=1 get_inv log a,p x\uff1aa^-1 \u6c42\u51faa\u5173\u4e8ep\u7684\u9006\u5143\u3002\u4f46\u8981\u6ce8\u610fgcd(a,p)==1\u65f6\u9006\u5143\u624d\u5b58\u5728 solve_linear_equation log a,b,p \u4e00\u4e2a\u89e3x \u6c42\u51fa\u65b9\u7a0bax=b(mod p) \u7684\u89e3\u3002\u4f46\u8981\u6ce8\u610f\u6709\u89e3\u5f53\u4e14\u4ec5\u5f53 gcd(a,p) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 namespace EXGCD { typedef long long ll ; //\u666e\u901a\u7684gcd ll gcd ( ll a , ll b ) { return b ? gcd ( b , a % b ) : a ; } //\u6269\u5c55\u6b27\u51e0\u91cc\u5f97\uff1aax+by=1 ll exgcd ( ll a , ll b , ll & x , ll & y ) { if ( ! b ) { x = 1 , y = 0 ; return a ; } ll d = exgcd ( b , a % b , x , y ), tempx = x , tempy = y ; x = tempy ; y = tempx - tempy * ( a / b ); return d ; } //\u6c42a\u5173\u4e8ep\u7684\u9006\u5143\uff08\u6c42\u540c\u4f59\u65b9\u7a0bax=1(mod p)-> p|(ax-1) -> ax+py=1\uff09 ll get_inv ( ll a , ll p ) { ll x , y ; ll g = exgcd ( a , p , x , y ); //x\u5c31\u662f\u89e3\uff0c\u4f46\u662f\u8981\u6ce8\u610f\u5982\u679c\u5e0c\u671b\u5f97\u5230\u6b63\u6574\u6570\u89e3\u5e94\u8be5\u5bf9x\u53d6\u6a21 return x = ( x % p + p ) % p ; } //\u6c42\u51fa\u65b9\u7a0bax=b(mod p) \u7684\u89e3\u3002\u4f46\u8981\u6ce8\u610f\u6709\u89e3\u5f53\u4e14\u4ec5\u5f53 gcd(a,p)|b ll solve_linear_equation ( ll a , ll b , ll p ) { //ax=b(mod p) -> ax+py=b //\u6709\u89e3\u5f53\u4e14\u4ec5\u5f53 gcd(a,p)|b\uff0c\u6c42\u51faax0+py0\u89e3\u540ex0\u4e58\u4ee5b/gcd(a,m)\u5373\u53ef\u5f97\u539f\u65b9\u7a0b\u7684\u4e00\u4e2a\u89e3 ll x , y ; ll g = exgcd ( a , p , x , y ); if ( b % g != 0 ) return -1 ; x *= ( b / g ); //\u6ce8\u610f\uff1a\u9700\u8981g|b\uff0c\u5426\u5219\u65e0\u89e3 x = ( x % p + p ) % p ; return x ; } } using namespace EXGCD ;","title":"gcd\u4e0eexgcd\u3001\u7ebf\u6027\u540c\u4f59\u65b9\u7a0b"},{"location":"old/%E8%87%AA%E5%88%B6Template/#_23","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include <iostream> //Chinese remainder theorem using namespace std ; int congruence_equation_number ; long long m [ 20 ], a [ 20 ], t [ 20 ], M = 1 ; long long exgcd ( long long a , long long b , long long & x , long long & y ) { if ( b == 0 ) { x = 1 ; y = 0 ; return a ; } long long d = exgcd ( b , a % b , x , y ), temp_x = x , temp_y = y ; x = temp_y ; y = temp_x - temp_y * ( a / b ); return d ; } int main () { ios :: sync_with_stdio ( false ); cin >> congruence_equation_number ; for ( int i = 1 ; i <= congruence_equation_number ; i ++ ) { cin >> m [ i ] >> a [ i ]; M *= m [ i ]; } for ( int i = 1 ; i <= congruence_equation_number ; i ++ ) { long long x , y ; exgcd ( M / m [ i ], m [ i ], x , y ); t [ i ] = x ; } long long ans = 0 ; for ( int i = 1 ; i <= congruence_equation_number ; i ++ ) { ans += ( a [ i ] * M / m [ i ] * t [ i ]) % M ; ans %= M ; } cout << ( ans + M ) % M << endl ; return 0 ; }","title":"\u4e2d\u56fd\u5269\u4f59\u5b9a\u7406"},{"location":"old/%E8%87%AA%E5%88%B6Template/#_24","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <cstdlib> #include <algorithm> #include <string> #include <vector> #include <map> #include <unordered_map> #include <set> #include <unordered_set> #include <queue> using namespace std ; typedef long long ll ; typedef long double ld ; namespace EXGCD { typedef long long ll ; //\u666e\u901a\u7684gcd ll gcd ( ll a , ll b ) { return b ? gcd ( b , a % b ) : a ; } //\u6269\u5c55\u6b27\u51e0\u91cc\u5f97\uff1aax+by=1 ll exgcd ( ll a , ll b , ll & x , ll & y ) { if ( ! b ) { x = 1 , y = 0 ; return a ; } ll d = exgcd ( b , a % b , x , y ), tempx = x , tempy = y ; x = tempy ; y = tempx - tempy * ( a / b ); return d ; } //\u6c42a\u5173\u4e8ep\u7684\u9006\u5143\uff08\u6c42\u540c\u4f59\u65b9\u7a0bax=1(mod p)-> p|(ax-1) -> ax+py=1\uff09 ll get_inv ( ll a , ll p ) { ll x , y ; ll g = exgcd ( a , p , x , y ); //x\u5c31\u662f\u89e3\uff0c\u4f46\u662f\u8981\u6ce8\u610f\u5982\u679c\u5e0c\u671b\u5f97\u5230\u6b63\u6574\u6570\u89e3\u5e94\u8be5\u5bf9x\u53d6\u6a21 return x = ( x % p + p ) % p ; } //\u6c42\u51fa\u65b9\u7a0bax=b(mod p) \u7684\u89e3\u3002\u4f46\u8981\u6ce8\u610f\u6709\u89e3\u5f53\u4e14\u4ec5\u5f53 gcd(a,p)|b ll solve_linear_equation ( ll a , ll b , ll p ) { //ax=b(mod p) -> ax+py=b //\u6709\u89e3\u5f53\u4e14\u4ec5\u5f53 gcd(a,p)|b\uff0c\u6c42\u51faax0+py0\u89e3\u540ex0\u4e58\u4ee5b/gcd(a,m)\u5373\u53ef\u5f97\u539f\u65b9\u7a0b\u7684\u4e00\u4e2a\u89e3 ll x , y ; ll g = exgcd ( a , p , x , y ); x *= ( b / g ); //\u6ce8\u610f\uff1a\u9700\u8981g|b\uff0c\u5426\u5219\u65e0\u89e3 x = ( x % p + p ) % p ; return x ; } } using namespace EXGCD ; namespace Zhengshu_points { //(ai+b)/c=k (k>0,0<=i<=n) // a,b,c>0, n>=0 ll get_zhengshu_points ( ll a , ll b , ll c , ll n ) { ll i0 , k0 ; ll g = exgcd ( a , - c , i0 , k0 ); if ( - b % g != 0 ) return 0 ; //no solution // ll Kr=-b*i0 double Krd = ( - b * i0 ) * ( ld ) 1.0 / c ; double Kld = ( n * g + b * i0 ) * ( ld ) 1.0 / ( - c ); if ( g < 0 ) { swap ( Kld , Krd ); } ll Kr = floor ( Krd ); ll Kl = ceil ( Kld ); return max ( 0l l , Kr - Kl + 1 ); } } using namespace Zhengshu_points ; int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ), cout . tie ( 0 ); ll a , b , c , n ; cin >> a >> b >> c >> n ; cout << get_zhengshu_points ( a , b , c , n ) << endl ; return 0 ; }","title":"\u6269\u5c55\u6b27\u51e0\u91cc\u5f97\u6c42\u6574\u6570\u70b9\u4e2a\u6570"},{"location":"old/%E8%87%AA%E5%88%B6Template/#_25","text":"","title":"\u7c7b\u6b27\u51e0\u91cc\u5f97\u7b97\u6cd5"},{"location":"old/%E8%87%AA%E5%88%B6Template/#202-icpc-shenyang","text":"\u539f\u9898\u53ef\u8f6c\u5316\u4e3a\u8ba1\u7b97 $$ f(a,b,c,n)=\\sum_{i=0}^n \\lfloor\\frac{ai+b}{c}\\rfloor $$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <cstdlib> #include <algorithm> #include <string> #include <vector> #include <map> #include <unordered_map> #include <set> #include <unordered_set> #include <queue> using namespace std ; typedef long long ll ; typedef long double ld ; typedef __int128 vl ; ll H , M , A ; namespace Like_Euclid { // vl ff ( vl a , vl b , vl c , vl n ) { if ( a == 0 ) return b / c * ( n + 1 ); if ( a >= c || b >= c ) { return ff ( a % c , b % c , c , n ) + ( a / c ) * n * ( n + 1 ) / 2 + ( b / c ) * ( n + 1 ); } vl m = ( a * n + b ) / c ; return n * m - ff ( c , c - b -1 , a , m -1 ); } } using namespace Like_Euclid ; namespace EXGCD { //\u6269\u5c55\u6b27\u51e0\u91cc\u5f97\uff1aax+by=1 vl exgcd ( vl a , vl b , vl & x , vl & y ) { if ( ! b ) { x = 1 , y = 0 ; return a ; } vl d = exgcd ( b , a % b , x , y ), tempx = x , tempy = y ; x = tempy ; y = tempx - tempy * ( a / b ); return d ; } } using namespace EXGCD ; namespace Zhengshu_points { template < typename Ty > Ty fl ( Ty a , Ty b ) { if (( a < 0 && b > 0 ) || ( a > 0 && b < 0 )) { return ( a / b ) - ( a % b != 0 ); } return a / b ; } template < typename Ty > Ty ce ( Ty a , Ty b ) { if (( a < 0 && b > 0 ) || ( a > 0 && b < 0 )) { return ( a / b ); } return ( a / b ) + ( a % b != 0 ); } //(ai+b)/c=k (k>0,0<=i<=n) // a,b,c>0, n>=0 vl get_zhengshu_points ( vl a , vl b , vl c , vl n ) { vl i0 , k0 ; vl g = exgcd ( a , - c , i0 , k0 ); if ( - b % g != 0 ) return 0 ; //no solution // ld Krd=(-b*i0)*(ld)1.0/c; // ld Kld=(n*g+b*i0)*(ld)1.0/(-c); // if(g<0) // { // swap(Kld,Krd); // } // vl Kr= floor(Krd); // vl Kl= ceil(Kld); vl Kr , Kl ; if ( g < 0 ) { // Kl=(-b*i0)/c + ((-b*i0)%c != 0); Kl = ce ( - b * i0 , c ); // Kr=(n*g+b*i0)/(-c); Kr = fl ( n * g + b * i0 , - c ); } else { // Kl=(n*g+b*i0)/(-c) + ((n*g+b*i0)%(-c) != 0); Kl = ce ( n * g + b * i0 , - c ); // Kr=(-b*i0)/c; Kr = fl ( - b * i0 , c ); } return max (( vl ) 0 , Kr - Kl + 1 ); } } using namespace Zhengshu_points ; ll solve ( ll H , ll M , ll A ) { //a=MH,b=A,c=H-1 vl ans = ff ( M * H , A , H -1 , H -2 ); // ld zero_point=A/(M*H); vl z1 = A / ( M * H ); vl z2 = z1 + 1 ; z1 = min ( z1 ,( vl )( H -2 )); vl bb = M * H * z1 - A ; // bb=-bb; bb<=0 ans += ff ( M * H , - bb , H -1 , z1 ); if ( z2 <= H -2 ) { vl bb2 = M * H * z2 - A ; ans -= ff ( M * H , bb2 , H -1 , H -2 - z2 ); ans += get_zhengshu_points ( M * H , bb2 , H -1 , H -2 - z2 ); } // cout<<\"ans:\"<<(ll)ans<<endl; // cout<<\"z1:\"<<(ll)z1<<endl; // cout<<\"a2mh:\"<<(ll)(A*2!=M*H)<<endl; // return ans+z1+(A*2!=M*H); return ans + z1 + 1 ; } int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ), cout . tie ( 0 ); cin >> H >> M >> A ; if ( H * M == A * 2 ) { cout << H * M << endl ; } // else if(A==0) // { // cout<<1<<endl; // } else cout << solve ( H , M , A ) << endl ; return 0 ; }","title":"202 ICPC Shenyang"},{"location":"old/%E8%87%AA%E5%88%B6Template/#pollard-rho","text":"\u8bf4\u8d77\u6765\u8fd9\u73a9\u610f\u4f1a\u7528\u5230mt19937\u8fd9\u73a9\u610f\u2026\u2026 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 //pollard Rho & Miller Rabin LUOGU 4718 #include <iostream> #include <cstdio> #include <ctime> #include <map> #include <random> using namespace std ; typedef long long ll ; typedef __int128_t lll ; int T ; ll n ; namespace PR { //local std :: mt19937 rd ( time ( 0 )); ll __a [] = { 2 , 325 , 9375 , 28178 , 450775 , 9780504 , 1795265022 }; //b[]={2,7,61}; (for 2^32) ll gcd ( ll a , ll b ) { return b == 0 ? a : gcd ( b , a % b ); } ll ksm ( ll a , ll b , ll Mod ) //\u6ce8\u610f\uff1a\u4f7f\u7528lll\u9632\u70b8 { ll ans = 1 ; while ( b ) { if ( b & 1 ) ans = (( lll ) ans * a ) % Mod ; a = (( lll ) a * a ) % Mod ; b >>= 1 ; } return ans ; } //\u8d28\u6570\u5224\u522b bool miller_rabin ( ll n ) { if ( n == 2 || n == 3 ) return true ; if ( n < 2 || n % 2 == 0 ) return false ; // n%2==0 spj for even num ll d = n -1 , r = 0 ; while ( d % 2 == 0 ) { r ++ ; d /= 2 ; } for ( int a_p = 0 ; a_p < 7 ; a_p ++ ) { ll aa = __a [ a_p ]; ll x = ksm ( aa , d , n ); //maybe 0, need to special judge x=0 if ( x <= 1 || x == n -1 ) continue ; //a^{d}=1 or -1 for ( int i = 0 ; i < r -1 ; i ++ ) { x = ( lll ) x * x % n ; if ( x == n -1 ) break ; // find a^{2^r d}=-1 (mod n) } if ( x != n -1 ) return false ; //!= } return true ; } //\u8ba1\u7b97x^2+c\uff0c\u4f1a\u88ab\u4e0b\u9762\u7684PR\u51fd\u6570\u7528\u5230 ll __f ( ll x , ll c , ll Mod ) { return (( lll ) x * x + c ) % Mod ; } //\u6c42\u51fan\u7684\u4e00\u4e2a\u56e0\u6570 ll Pollard_Rho ( ll n ) //n must be composite { ll s = 0 , t = 0 ; ll c = ( ll ) rd () % ( n -1 ) + 1 ; ll val = 1 ; for ( ll goal = 1 ;; goal <<= 1 , s = t , val = 1 ) { for ( ll step = 1 ; step <= goal ; step ++ ) { t = __f ( t , c , n ); val = ( lll ) val * abs ( t - s ) % n ; if ( step % 127 == 0 ) { ll d = gcd ( val , n ); if ( d > 1 ) return d ; } } ll d = gcd ( val , n ); if ( d > 1 ) return d ; } } //local ll maxfactor = 0 ; //maxfactor\uff1a\u4fdd\u5b58n\u7684\u6700\u5927\u56e0\u6570 //\u5206\u89e3n\u5e76\u6c42n\u7684\u6700\u5927\u56e0\u6570 void do_div ( ll n ) //maximun prime factor of n { if ( n <= maxfactor || n < 2 ) return ; if ( miller_rabin ( n )) { maxfactor = max ( maxfactor , n ); return ; } ll m = n ; while ( m == n ) { m = Pollard_Rho ( n ); } while ( n % m == 0 ) { n /= m ; } do_div ( n ); do_div ( m ); } map < ll , ll > dv ; //dv\uff1a\u7528\u4e8e\u4fdd\u5b58\u56e0\u6570\u5206\u89e3\u7ed3\u679c //\u5206\u89e3\u56e0\u6570n\uff0c\u5e76\u5c06n\u7684\u6240\u6709\u56e0\u6570\u4fdd\u5b58\u5728dv\u4e2d void do_div2 ( map < ll , ll > & dv , ll n ) { if ( miller_rabin ( n )) { dv [ n ] ++ ; return ; } ll m = n ; while ( m == n ) { m = Pollard_Rho ( n ); } n /= m ; do_div2 ( dv , n ); do_div2 ( dv , m ); } } using namespace PR ; int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ), cout . tie ( 0 ); cin >> T ; while ( T -- ) { maxfactor = 0 ; cin >> n ; do_div ( n ); if ( maxfactor == n ) cout << \"Prime\" << endl ; else cout << maxfactor << endl ; } return 0 ; }","title":"\u7c73\u52d2\u7f57\u5bbe\u8d28\u6570\u5224\u522b\u6cd5 \u4e0e Pollard Rho \u56e0\u6570\u5206\u89e3\u6cd5"},{"location":"old/%E8%87%AA%E5%88%B6Template/#bsgs","text":"\u590d\u6742\u5ea6\u662f\u6839\u53f7\u7ea7\u522b\u7684\uff0c\u7528\u4e8e\u6c42\u89e3 $$ a^x\\equiv b\\pmod p $$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 #include <iostream> #include <unordered_map> #include <cmath> using namespace std ; typedef long long ll ; namespace BSGS { //public long long a , b , p ; //local unordered_map < long long , long long > ha ; //ha:\u7528\u4e8e\u4fdd\u5b58\u4e2d\u9014\u7a77\u4e3e\u7684\u7ed3\u679c //a^x=b(mod p) //a^(it-j)=b (mod p) //a^t^i=ba^j (mod p) long long ksm ( long long a , long long b , long long m ) { if ( b == 0 ) return 1 ; if ( b == 1 ) return a % m ; long long ans = ksm ( a , b / 2 , m ); ans *= ans ; ans %= m ; if ( b % 2 ) { ans *= a ; ans %= m ; } return ans ; } long long bsgs ( long long a , long long b , long long p ) { ha . clear (); long long t = sqrt ( p ); if ( t * t != p ) t ++ ; for ( int j = 0 ; j <= t -1 ; j ++ ) { long long val = ( b % p * ksm ( a , j , p )) % p ; ha [ val ] = j ; } long long at = ksm ( a , t , p ); if ( a == 0 ) return b == 0 ? 1 : -1 ; for ( int i = 0 ; i <= t ; i ++ ) { long long val = ksm ( at , i , p ); int j = ( ha . find ( val ) == ha . end () ? -1 : ha [ val ]); if ( j >= 0 && i * t - j >= 0 ) { return i * t - j ; } } return -1 ; } } using namespace BSGS ; int main () { ios :: sync_with_stdio ( false ); cin >> a >> b >> p ; //b<p cout << bsgs ( a , b , p ) << endl ; return 0 ; } /* 69 5 19260817 15013953 */","title":"BSGS\uff08\u6a21\u610f\u4e49\u4e0b\u53d6\u5bf9\u6570\uff09"},{"location":"old/%E8%87%AA%E5%88%B6Template/#_26","text":"","title":"\u2b50\u539f\u6839"},{"location":"old/%E8%87%AA%E5%88%B6Template/#luogu-6091","text":"\u9898\u610f\uff1a\u7ed9\u5b9a\u6574\u6570 n\uff0c\u6c42\u5b83\u7684\u6240\u6709\u539f\u6839\u3002\u4e3a\u4e86\u51cf\u5c0f\u4f60\u7684\u8f93\u51fa\u91cf\uff0c\u7ed9\u51fa\u8f93\u51fa\u53c2\u6570 d\uff0c\u8bbe n \u7684\u6240\u6709\u539f\u6839\u6709 c \u4e2a\uff0c\u4ece\u5c0f\u5230\u5927\u5206\u522b\u4e3a g1,..,gc, \u53ea\u9700\u8981\u4f9d\u6b21\u6b21\u8f93\u51fag_d,g_2d,...,g_{(c/d)*d} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 //P6091 \u539f\u6839\u6a21\u7248 //\u6709\u5f85\u4f18\u5316\uff08\u4f8b\u5982\u5c06\u6b27\u62c9\u51fd\u6570\u6539\u6210\u7ebf\u6027\u7b5b\u5f62\u5f0f\u3001gcd\u6539\u6210ksm\u9a8c\u8bc1\u4e4b\u7c7b\u7684\uff09 #include <iostream> #include <cstdio> #include <cmath> #include <memory.h> #include <algorithm> using namespace std ; const int N = 1e6 + 5 ; int T , n , d ; int prime_list [ N ], pp , m_phi ; int g_list [ N ], g_p ; int phi ( int n ) { int ans = n ; for ( int i = 2 ; i <= sqrt ( n ); i ++ ) { if ( n % i == 0 ) { ans = ans / i * ( i -1 ); while ( n % i == 0 ) { n /= i ; } } } if ( n > 1 ) ans = ans / n * ( n -1 ); return ans ; } void divide ( int n ) { pp = 0 ; for ( int i = 2 ; i <= sqrt ( n ); i ++ ) { if ( n % i == 0 ) { prime_list [ ++ pp ] = i ; while ( n % i ) { n /= i ; } } } if ( n > 1 ) prime_list [ ++ pp ] = n ; } long long ksm ( long long a , long long b , long long Mod ) { long long ans = 1 ; while ( b ) { if ( b & 1 ) ans = ( ans * a ) % Mod ; a = ( a * a ) % Mod ; b >>= 1 ; } return ans ; } long long gcd ( long long a , long long b ) { return b ? gcd ( b , a % b ) : a ; } int get_min_primitive_root ( int m ) { m_phi = phi ( m ); if ( m == 1 ) return 0 ; if ( m == 2 ) return 1 ; divide ( m_phi ); for ( int g = 2 ; g <= m -1 ; g ++ ) { if ( gcd ( g , m ) != 1 ) continue ; bool flag = true ; for ( int i = 1 ; i <= pp ; i ++ ) { if ( ksm ( g , m_phi / prime_list [ i ], m ) == 1 ) { flag = false ; break ; } } if ( flag ) { return g ; } } return -1 ; } int main () { //ios::sync_with_stdio(false); scanf ( \"%d\" , & T ); //cin>>T; while ( T -- ) { //cin>>n>>d; scanf ( \"%d%d\" , & n , & d ); pp = g_p = 0 ; int g = get_min_primitive_root ( n ); if ( g == -1 ) { printf ( \"0 \\n\\n \" ); //cout<<0<<endl<<endl; continue ; } /*int m_phi_phi=phi(m_phi); //cout<<m_phi_phi<<endl; printf(\"%d\\n\",m_phi_phi);*/ int m_phi_phi = 0 ; for ( int i = 1 ; i <= m_phi ; i ++ ) { if ( gcd ( i , m_phi ) == 1 ) { m_phi_phi ++ ; g_list [ ++ g_p ] = ksm ( g , i , n ); } } sort ( g_list + 1 , g_list + 1 + g_p ); printf ( \"%d \\n \" , m_phi_phi ); //\u6b64\u5904\u7b54\u6848\u4e3aphi(m_phi) for ( int i = d ; i <= m_phi_phi / d * d ; i += d ) //\u8f93\u51fa\u63a7\u5236\uff0c\u53ef\u4ee5\u65e0\u89c6\u8fd9\u90e8\u5206 { //cout<<g_list[i]<<\" \"; printf ( \"%d \" , g_list [ i ]); } printf ( \" \\n \" ); } return 0 ; }","title":"luogu 6091 \u539f\u6839\u6a21\u7248"},{"location":"old/%E8%87%AA%E5%88%B6Template/#cipolla","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 //Cipolla\u7b97\u6cd5\u6c42\u89e3\u4e00\u4e2a\u6570\u7684\u6a21\u610f\u4e49\u4e0b\u6839\u53f7 #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <cstdlib> #include <algorithm> #include <string> #include <vector> #include <map> #include <unordered_map> #include <set> #include <unordered_set> #include <queue> #include <random> #include <ctime> using namespace std ; typedef long long ll ; const int N = 2e5 + 10 ; mt19937 rd ( time ( 0 )); int T ; namespace Cipolla { //local ll w , p ; //w: i^2 = a*a-n //p: \u6a21\u6570 struct Imagenum { ll x , y ; Imagenum (){} Imagenum ( ll x , ll y ) : x ( x ), y ( y ) {} Imagenum operator * ( const Imagenum & b ) const { return Imagenum ( (( x * b . x % p + y * b . y % p * w % p ) % p + p ) % p , (( x * b . y % p + y * b . x % p ) % p + p ) % p ); } }; //\u5faa\u73af long long ksm ( long long a , long long b , long long Mod ) { long long ans = 1 ; while ( b ) { if ( b & 1 ) ans = ( ans * a ) % Mod ; a = ( a * a ) % Mod ; b >>= 1 ; } return ans ; } Imagenum ksm ( Imagenum a , ll b ) { Imagenum ans ( 1 , 0 ); while ( b ) { if ( b & 1 ) { ans = ans * a ; } a = a * a ; b >>= 1 ; } return ans ; } //cipolla: \u8ba1\u7b97n\u5728mod p\u610f\u4e49\u4e0b\u7684\u5e73\u65b9\u6839\uff0c\u6ce8\u610fp\u4e00\u5b9a\u8981\u662f\u5947\u6570\u8d28\u6570 ll cipolla ( ll n , ll P ) { p = P ; n %= p ; if ( p == 2 ) return n ; if ( ksm ( n ,( p -1 ) / 2 , p ) == p -1 ) return -1 ; //\u52d2\u8ba9\u5fb7\u7b26\u53f7=-1\uff0c\u8868\u660e\u4e0d\u5b58\u5728\u89e3 if ( n == 0 ) return 0 ; //\u5fc5\u8981\u7684\u7279\u5224\uff0c\u5426\u5219\u5e95\u4e0b\u5faa\u73af\u4f1a\u5361\u4f4f ll a ; while ( 1 ) { a = rd () % p ; w = (( a * a % p - n ) % p + p ) % p ; if ( ksm ( w ,( p -1 ) / 2 , p ) == p -1 ) break ; } Imagenum x ( a , 1 ); // (a+i)^((p+1)/2) == n^(1/2) return ksm ( x ,( p + 1 ) / 2 ). x ; // \u5b9e\u90e8\u4e3a\u7b54\u6848\uff0c\u865a\u90e8\u4e00\u5b9a\u4e3a0 } } int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ), cout . tie ( 0 ); cin >> T ; for ( int _ = 1 ; _ <= T ; _ ++ ) { ll n , p ; cin >> n >> p ; auto ans = Cipolla :: cipolla ( n , p ); if ( ans == -1 ) { cout << \"Hola! \\n \" ; } else { auto ans2 = ( p - ans ) % p ; if ( ans > ans2 ) swap ( ans , ans2 ); if ( ans == ans2 ) cout << ans << '\\n' ; else cout << ans << \" \" << ans2 << '\\n' ; } } return 0 ; }","title":"\u6c42\u89e3\u4e8c\u6b21\u5269\u4f59\u7684Cipolla \u7b97\u6cd5"},{"location":"old/%E8%87%AA%E5%88%B6Template/#fft","text":"Funs || Methods Reliance Time Complexity Inputs Outputs Description getlen1 logn n len \u53d6\u5f97\u6bd4n\u5927\u7684\u5e42\u957flen getlen2 logn len1,len2 len \u53d6\u5f97\u6bd4len1*2\u3001len2*2\u90fd\u5927\u7684\u5e42\u957f fft nlogn \u8f93\u5165\u590d\u6570\u6570\u7ec4y\u3001\u5e42\u957flen\uff082\u7684\u5e42\uff09\u3001ifft=1\u3002 \u4fee\u6539\u6570\u7ec4y\u4f5c\u4e3a\u7ed3\u679c\u3002 \u5f97\u5230\u7531\u7cfb\u6570\u8868\u793a\u6cd5\u8f6c\u6362\u4e3a\u70b9\u503c\u8868\u793a\u6cd5\uff08ifft=-1\u5219\u53cd\u8fc7\u6765\uff09\u7684\u6570\u7ec4\uff1aifft\u4e3a1\u65f6\u505afft\uff0c-1\u5219\u505aifft\u3002 multi n \u8f93\u5165\u590d\u6570\u6570\u7ec4y1\u3001y2\u3001y3\uff0c\u5e42\u957flen \u4fee\u6539\u6570\u7ec4y3\u4f5c\u4e3a\u7ed3\u679c\u3002 \u5bf9\u70b9\u503c\u8868\u793a\u6cd5\u7684\u6570\u7ec4y1\u3001y2\u505a\u4e58\u6cd5\u4fdd\u5b58\u81f3y3\u4e2d\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 //FFT #include <iostream> #include <cmath> #include <complex> #include <cstring> #include <memory.h> using namespace std ; namespace FFT { const int N = 2e6 + 5 ; //N\uff1a\u957f\u5ea6\u4e0a\u9650 const double PI = acos ( -1.0 ); //PI //public complex < double > s1 [ N * 2 ], s2 [ N * 2 ], s3 [ N * 2 ]; //s1,s2,s3\uff1a\u8f93\u5165\u7cfb\u6570\u8868\u793a\u6cd5\u7528\u7684\u6570\u7ec4 int sum [ N * 2 ]; //\u4e58\u6cd5\u5b8c\u6210\u540e\u8ba1\u7b97\u6c42\u548c\u7528\u7684\u6570\u7ec4 char a [ N ], b [ N ]; //a\u3001b:\u8f93\u5165\u7684\u4e24\u4e2a\u6570\u7684\u5b57\u7b26\u4e32\u5f62\u5f0f //local int rev [ N * 2 ]; //rev\uff1a\ud83e\udd8b\u53d8\u6362\u7528\u6570\u7ec4 //\u9884\u5904\u7406\ud83e\udd8b\u53d8\u6362 void __pre_rev ( int len ) { rev [ 0 ] = 0 ; for ( int i = 1 ; i <= len ; i ++ ) { rev [ i ] = rev [ i >> 1 ] >> 1 ; if ( i & 1 ) { rev [ i ] |= len >> 1 ; } } } // \ud83e\udd8b\u53d8\u6362 void __change ( complex < double > y [], int len ) { __pre_rev ( len ); for ( int i = 0 ; i < len ; i ++ ) { if ( i < rev [ i ]) { swap ( y [ i ], y [ rev [ i ]]); } } } //\u53d6\u5f97\u6bd4n\u5927\u7684\u5e42\u957flen int getlen1 ( int n ) { int len = 1 ; while ( len < n ) { len <<= 1 ; } return len ; } //\u53d6\u5f97\u6bd4len1\\*2\u3001len2\\*2\u90fd\u5927\u7684\u5e42\u957f int getlen2 ( int len1 , int len2 ) { int len = 1 ; while ( len < len1 * 2 || len < len2 * 2 ) len <<= 1 ; //*2\uff0c\u4e0d\u7136\u8fdb\u4f4d\u4f1a\u70b8\u6389\uff0c\u5e76\u4e14\ud83e\udd8b\u53d8\u6362\u4f1a\u9519 return len ; } //\u5f97\u5230\u7531\u7cfb\u6570\u8868\u793a\u6cd5\u8f6c\u6362\u4e3a\u70b9\u503c\u8868\u793a\u6cd5\uff08ifft=-1\u5219\u53cd\u8fc7\u6765\uff09\u7684\u6570\u7ec4\uff1a\u8f93\u5165\u590d\u6570\u6570\u7ec4y\u3001\u957f\u5ea6len\uff082\u7684\u5e42\uff09\u3001ifft=1\u3002\u4fee\u6539\u6570\u7ec4y\u4f5c\u4e3a\u7ed3\u679c\u3002ifft\u4e3a1\u65f6\u505afft\uff0c-1\u5219\u505aifft\u3002 void fft ( complex < double > y [], int len , int ifft = 1 ) { __change ( y , len ); for ( int h = 2 ; h <= len ; h <<= 1 ) // \u5408\u5e76\u7684\u957f\u5ea6 { complex < double > w_n ( cos ( 2 * PI / h ), sin ( ifft * 2 * PI / h )); //\u5bf9\u5e94\u957f\u5ea6\u7684\u5355\u4f4d\u590d\u6839 for ( int j = 0 ; j < len ; j += h ) //\u8d77\u59cb\u4f4d\u7f6e { complex < double > w ( 1 , 0 ); //\u521d\u59cb\u7684w_n^k for ( int k = j ; k < j + h / 2 ; k ++ ) // \u904d\u5386\u4f4d\u7f6e { complex < double > u = y [ k ], v = w * y [ k + h / 2 ]; //\u5076\u6570\u9879\u3001\u5947\u6570\u9879 y [ k ] = u + v ; y [ k + h / 2 ] = u - v ; w *= w_n ; } } } if ( ifft == -1 ) { for ( int i = 0 ; i < len ; i ++ ) { y [ i ] /= len ; } } } //\u5bf9\u70b9\u503c\u8868\u793a\u6cd5\u7684\u6570\u7ec4y1\u3001y2\u505a\u4e58\u6cd5\u4fdd\u5b58\u81f3y3\u4e2d\u3002 void multi ( complex < double > y1 [], complex < double > y2 [], complex < double > y3 [], int len ) { for ( int i = 0 ; i < len ; i ++ ) { y3 [ i ] = y1 [ i ] * y2 [ i ]; } } } using namespace FFT ; int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); cin >> a + 1 >> b + 1 ; int len1 = strlen ( a + 1 ), len2 = strlen ( b + 1 ); int len = getlen2 ( len1 , len2 ); //*2\uff0c\u4e0d\u7136\u8fdb\u4f4d\u4f1a\u70b8\u6389\uff0c\u5e76\u4e14\ud83e\udd8b\u53d8\u6362\u4f1a\u9519 //while (len < len1 * 2 || len < len2 * 2) // len <<= 1; for ( int i = 0 , j = len1 ; i < len1 ; i ++ , j -- ) //\u6ce8\u610f\u5012\u7740\u5b58 { s1 [ i ] = {( double )( a [ j ] - '0' ), 0 }; } for ( int i = 0 , j = len2 ; i < len2 ; i ++ , j -- ) { s2 [ i ] = {( double )( b [ j ] - '0' ), 0 }; } for ( int i = len1 ; i < len ; i ++ ) s1 [ i ] = { 0 , 0 }; for ( int i = len2 ; i < len ; i ++ ) s2 [ i ] = { 0 , 0 }; fft ( s1 , len ); fft ( s2 , len ); for ( int i = 0 ; i < len ; i ++ ) // \u4e58\u6cd5\u2026\u2026 s3 [ i ] = s1 [ i ] * s2 [ i ]; fft ( s3 , len , -1 ); //len=len1+len2-1; //len=(len1+len2-1); sum [ len ] = 0 ; //\u6700\u9ad8\u8fdb\u4f4d\u590d\u5199\u4e3a0 for ( int i = 0 ; i < len ; i ++ ) sum [ i ] = round ( real ( s3 [ i ])); for ( int i = 0 ; i < len ; i ++ ) { sum [ i + 1 ] += sum [ i ] / 10 ; sum [ i ] %= 10 ; } while ( sum [ len ] == 0 && len > 0 ) { len -- ; } for ( int i = len ; i >= 0 ; i -- ) cout << sum [ i ]; cout << endl ; return 0 ; }","title":"FFT"},{"location":"old/%E8%87%AA%E5%88%B6Template/#ntt-998244353","text":"Funs || Methods Reliance Time Complexity Inputs Outputs Description getlen1 logn n len \u53d6\u5f97\u6bd4n\u5927\u7684\u5e42\u957flen getlen2 logn len1,len2 len \u53d6\u5f97\u6bd4len1*2\u3001len2*2\u90fd\u5927\u7684\u5e42\u957f ntt nlogn \u8f93\u5165\u590d\u6570\u6570\u7ec4y\u3001\u5e42\u957flen\uff082\u7684\u5e42\uff09\u3001ifft=1\u3002 \u4fee\u6539\u6570\u7ec4y\u4f5c\u4e3a\u7ed3\u679c\u3002 \u5f97\u5230\u7531\u7cfb\u6570\u8868\u793a\u6cd5\u8f6c\u6362\u4e3a\u70b9\u503c\u8868\u793a\u6cd5\uff08ifft=-1\u5219\u53cd\u8fc7\u6765\uff09\u7684\u6570\u7ec4\uff1aifft\u4e3a1\u65f6\u505afft\uff0c-1\u5219\u505aifft\u3002 multi n \u8f93\u5165\u590d\u6570\u6570\u7ec4y1\u3001y2\u3001y3\uff0c\u5e42\u957flen \u4fee\u6539\u6570\u7ec4y3\u4f5c\u4e3a\u7ed3\u679c\u3002 \u5bf9\u70b9\u503c\u8868\u793a\u6cd5\u7684\u6570\u7ec4y1\u3001y2\u505a\u4e58\u6cd5\u4fdd\u5b58\u81f3y3\u4e2d\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 //FFT but use NTT #include <iostream> #include <cmath> #include <complex> #include <cstring> #include <memory.h> using namespace std ; typedef long long ll ; namespace NTT { const int N = 2e6 + 5 , Mod = 998244353 ; //N\uff1a\u957f\u5ea6\u4e0a\u9650, Mod: \u9ed8\u8ba4\u6a21\u6570 const double PI = acos ( -1.0 ); //Pi const int primitive_root = 3 ; //primitive-root: 3 //public ll s1 [ N * 2 ], s2 [ N * 2 ], s3 [ N * 2 ]; //s1,s2,s3\uff1a\u8f93\u5165\u7cfb\u6570\u8868\u793a\u6cd5\u7528\u7684\u6570\u7ec4 //local int rev [ N * 2 ]; //rev\uff1a\ud83e\udd8b\u53d8\u6362\u7528\u6570\u7ec4 //\u5feb\u901f\u5e42 long long __ksm ( long long a , long long b , long long Mod ) { long long ans = 1 ; while ( b ) { if ( b & 1 ) ans = ( ans * a ) % Mod ; a = ( a * a ) % Mod ; b >>= 1 ; } return ans ; } //\u9884\u5904\u7406\ud83e\udd8b\u53d8\u6362 void __pre_rev ( int len ) { rev [ 0 ] = 0 ; for ( int i = 1 ; i <= len ; i ++ ) { rev [ i ] = rev [ i >> 1 ] >> 1 ; if ( i & 1 ) { rev [ i ] |= len >> 1 ; } } } // \ud83e\udd8b\u53d8\u6362 void __change ( ll y [], int len ) { __pre_rev ( len ); for ( int i = 0 ; i < len ; i ++ ) { if ( i < rev [ i ]) { swap ( y [ i ], y [ rev [ i ]]); } } } //\u53d6\u5f97\u6bd4n\u5927\u7684\u5e42\u957flen int getlen1 ( int n ) { int len = 1 ; while ( len < n ) { len <<= 1 ; } return len ; } //\u53d6\u5f97\u6bd4len1\\*2\u3001len2\\*2\u90fd\u5927\u7684\u5e42\u957f int getlen2 ( int len1 , int len2 ) { int len = 1 ; while ( len < len1 * 2 || len < len2 * 2 ) len <<= 1 ; //*2\uff0c\u4e0d\u7136\u8fdb\u4f4d\u4f1a\u70b8\u6389\uff0c\u5e76\u4e14\ud83e\udd8b\u53d8\u6362\u4f1a\u9519 return len ; } //\u5f97\u5230\u7531\u7cfb\u6570\u8868\u793a\u6cd5\u8f6c\u6362\u4e3a\u70b9\u503c\u8868\u793a\u6cd5\uff08ifft=-1\u5219\u53cd\u8fc7\u6765\uff09\u7684\u6570\u7ec4\uff1aifft\u4e3a1\u65f6\u505afft\uff0c-1\u5219\u505aifft\u3002 void ntt ( ll y [], int len , int ifft = 1 ) { __change ( y , len ); for ( int h = 2 ; h <= len ; h <<= 1 ) // \u5408\u5e76\u7684\u957f\u5ea6 { //complex<double> w_n(cos(2 * PI / h), sin(ifft * 2 * PI / h)); //\u5bf9\u5e94\u957f\u5ea6\u7684\u5355\u4f4d\u590d\u6839 ll gn ; if ( ifft == 1 ) gn = __ksm ( primitive_root ,(( ll ) Mod -1 ) / h , Mod ); //gn else gn = __ksm ( primitive_root ,(( ll ) Mod -1 ) / h * ( h -1 ), Mod ); //gn^-1 //else gn=ksm(332748118,(Mod-1)/h,Mod); for ( int j = 0 ; j < len ; j += h ) //\u8d77\u59cb\u4f4d\u7f6e { //complex<double> w(1, 0); //\u521d\u59cb\u7684w_n^k ll g = 1 ; for ( int k = j ; k < j + h / 2 ; k ++ ) // \u904d\u5386\u4f4d\u7f6e { ll u = y [ k ], v = ( g * y [ k + h / 2 ] % Mod ); //\u5076\u6570\u9879\u3001\u5947\u6570\u9879 y [ k ] = ( u + v + Mod ) % Mod ; y [ k + h / 2 ] = ( u - v + Mod ) % Mod ; //w *= w_n; //debug //cout<<k<<\":\"<<y[k]<<endl; //cout<<k+h/2<<\":\"<<y[k+h/2]<<endl; g = ( g * gn ) % Mod ; } } } if ( ifft == -1 ) { ll len_inv = __ksm ( len , Mod -2 , Mod ); for ( int i = 0 ; i < len ; i ++ ) { y [ i ] = y [ i ] * len_inv % Mod ; } } } //\u5bf9\u70b9\u503c\u8868\u793a\u6cd5\u7684\u6570\u7ec4y1\u3001y2\u505a\u4e58\u6cd5\u4fdd\u5b58\u81f3y3\u4e2d\u3002 void multi ( ll y1 [], ll y2 [], ll y3 [], int len ) { for ( int i = 0 ; i < len ; i ++ ) { y3 [ i ] = ( y1 [ i ] * y2 [ i ] % Mod + Mod ) % Mod ; } } } using namespace NTT ; int n , m ; int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); cin >> n >> m ; n ++ , m ++ ; for ( int i = 0 ; i < n ; i ++ ) { cin >> s1 [ i ]; } for ( int i = 0 ; i < m ; i ++ ) { cin >> s2 [ i ]; } int len = getlen2 ( n , m ); //*2\uff0c\u4e0d\u7136\u8fdb\u4f4d\u4f1a\u70b8\u6389\uff0c\u5e76\u4e14\ud83e\udd8b\u53d8\u6362\u4f1a\u9519 ntt ( s1 , len ); ntt ( s2 , len ); multi ( s1 , s2 , s3 , len ); ntt ( s3 , len , -1 ); for ( int i = 0 ; i < ( n -1 ) + ( m -1 ) + 1 ; i ++ ) { cout << s3 [ i ] << \" \" ; } return 0 ; }","title":"NTT (998244353)"},{"location":"old/%E8%87%AA%E5%88%B6Template/#fwt","text":"\u7528\u4e8e\u89e3\u51b3\u4e0e\u4f4d\u8fd0\u7b97\u6709\u5173\u7684\u5377\u79ef\u95ee\u9898\uff1a \\(\\vec c=\\vec a \\oplus \\vec b\\) $$ C_i=\\sum_{i=j|k}A_j B_k $$ \u5176\u4e2d\u7ad6\u7ebf\u8868\u793a\u6216\u3001\u4e0e\u548c\u5f02\u6216\u4e09\u79cd\u8fd0\u7b97\u3002\u7ed3\u679c\u5bf9Mod\u53d6\u6a21\u3002 \u5bf9\u6216\u8fd0\u7b97\u6765\u8bf4\uff0c\u6784\u9020\uff1a $$ A'=FWT[A]:A' i=\\sum A_j $$ \u4e5f\u5373FWT\u53d8\u6362\u540eA'_i\u8868\u793a\u4e8c\u8fdb\u5236\u4e0b\u76841\u662fi\u7684\u5b50\u96c6\u7684Aj\u7684\u603b\u548c\u3002 Funs || Methods Reliance Time Complexity Inputs Outputs Description fwt nlogn \u8f93\u5165\u590d\u6570\u6570\u7ec4y\u3001\u957f\u5ea6len\u3001\u4e09\u79cd\u8fd0\u7b97\u63a7\u5236\u7b26bitcal\u3001ifft=1\u3002 \u4fee\u6539\u6570\u7ec4y\u4f5c\u4e3a\u7ed3\u679c\u3002 \u4f5cFWT\u53d8\u6362\uff08ifft=-1\u5219\u53cd\u8fc7\u6765\uff09\u7684\u6570\u7ec4\uff1aifft\u4e3a1\u65f6\u505afft\uff0c-1\u5219\u505aifft\u3002bitcal\u4e3a1\u30012\u30013\u65f6\u5206\u522b\u8868\u793a\u5bf9or\u3001and\u548cxor\u4e09\u79cd\u8fd0\u7b97\u505aFWT\u3002 multi n \u8f93\u5165\u590d\u6570\u6570\u7ec4y1\u3001y2\u3001y3\uff0c\u5e42\u957flen \u4fee\u6539\u6570\u7ec4y3\u4f5c\u4e3a\u7ed3\u679c\u3002 \u5bf9\u6570\u7ec4y1\u3001y2\u505a\u4e58\u6cd5\uff08\u6a21\u6570\u4e3aMod\uff09\u4fdd\u5b58\u81f3y3\u4e2d\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 //luogu 4717 #include <iostream> #include <cstdio> #include <cstring> #include <memory.h> #include <algorithm> #include <map> #include <vector> #include <queue> #include <cmath> using namespace std ; typedef long long ll ; namespace FWT { const int N = 2e5 + 10 ; //N: \u957f\u5ea6\u4e0a\u9650 const int Mod = 998244353 , inv2 = 499122177 ; //Mod:\u6a21\u6570 inv2: pow(2,998244353-2,998244353) //public ll s1 [ N * 2 ], s2 [ N * 2 ], s3 [ N * 2 ]; //s1,s2,s3\uff1a\u8f93\u5165\u7cfb\u6570\u8868\u793a\u6cd5\u7528\u7684\u6570\u7ec4 //bitcal: 1 or ; 2 and ; 3 xor void fwt ( ll y [], int len , int bitcal , int ifft = 1 ) { for ( int h = 2 ; h <= len ; h <<= 1 ) { for ( int j = 0 ; j < len ; j += h ) //initiative position { for ( int k = j ; k < j + h / 2 ; k ++ ) // traverse { ll u = y [ k ], v = y [ k + h / 2 ]; if ( ifft == 1 ) { if ( bitcal == 3 ) //xor \uff08\u540c\u6216\u5c31\u5bf9\u8c03+-\u7b26\u53f7\uff0c\u4e0b\u540c\uff09 { y [ k ] = ( u + v ) % Mod ; y [ k + h / 2 ] = ( u - v + Mod ) % Mod ; } else if ( bitcal == 1 ) //or { //y[k]=u; y [ k + h / 2 ] = ( u + v ) % Mod ; } else if ( bitcal == 2 ) // and { y [ k ] = ( u + v ) % Mod ; //y[k+h/2]=(v); } } else { if ( bitcal == 3 ) //xor { y [ k ] = ( u + v ) * inv2 % Mod ; y [ k + h / 2 ] = (( u - v ) * inv2 % Mod + Mod ) % Mod ; } else if ( bitcal == 1 ) //or { //y[k]=u; y [ k + h / 2 ] = ( v - u + Mod ) % Mod ; } else if ( bitcal == 2 ) // and { y [ k ] = ( u - v + Mod ) % Mod ; //y[k+h/2]=(v); } } } } } } //\u70b9\u503c\u8868\u793a\u6cd5\u591a\u9879\u5f0f\u7684\u4e58\u6cd5\uff0c\u8f93\u5165y1,y2\u662f\u70b9\u503c\u8868\u793a\u6cd5\u4e0b\u7684\u591a\u9879\u5f0f void multi ( ll y1 [], ll y2 [], ll y3 [], int len ) { for ( int i = 0 ; i < len ; i ++ ) { y3 [ i ] = ( y1 [ i ] * y2 [ i ] % Mod + Mod ) % Mod ; } } } using namespace FWT ; ll A [ N ], B [ N ]; int n ; int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); cin >> n ; n = ( 1 << n ); for ( int i = 0 ; i < n ; i ++ ) { cin >> A [ i ]; } for ( int i = 0 ; i < n ; i ++ ) { cin >> B [ i ]; } int len = n ; //while(len<n) len<<=1; //or memcpy ( s1 , A , sizeof ( A )); memcpy ( s2 , B , sizeof ( B )); fwt ( s1 , len , 1 ); fwt ( s2 , len , 1 ); multi ( s1 , s2 , s3 , len ); fwt ( s3 , len , 1 , -1 ); for ( int i = 0 ; i < n ; i ++ ) cout << s3 [ i ] << \" \" ; cout << endl ; //and memcpy ( s1 , A , sizeof ( A )); memcpy ( s2 , B , sizeof ( B )); fwt ( s1 , len , 2 ); fwt ( s2 , len , 2 ); multi ( s1 , s2 , s3 , len ); fwt ( s3 , len , 2 , -1 ); for ( int i = 0 ; i < n ; i ++ ) cout << s3 [ i ] << \" \" ; cout << endl ; //xor memcpy ( s1 , A , sizeof ( A )); memcpy ( s2 , B , sizeof ( B )); fwt ( s1 , len , 3 ); fwt ( s2 , len , 3 ); multi ( s1 , s2 , s3 , len ); fwt ( s3 , len , 3 , -1 ); for ( int i = 0 ; i < n ; i ++ ) cout << s3 [ i ] << \" \" ; cout << endl ; return 0 ; }","title":"FWT"},{"location":"old/%E8%87%AA%E5%88%B6Template/#fft_1","text":"\u53ef\u4ee5\u5feb\u901f\u8ba1\u7b97\u4e0b\u6807\u8303\u56f4\u57280 to n-1\u7684\u5e8f\u5217f\uff1a\u7ed9\u5b9a\u4e0b\u6807\u57281 to n-1 \u7684\u5e8f\u5217g\uff0c\u8ba1\u7b97 $$ f_i=\\sum_{j=1}^if_{i-j}g_{j} $$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 //\u5b9e\u9645\u4e0a\u8981\u7528NTT\u2026\u2026 #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <cstdlib> #include <algorithm> #include <string> #include <vector> #include <map> #include <unordered_map> #include <set> #include <unordered_set> #include <queue> using namespace std ; typedef long long ll ; namespace NTT { const int N = 2e5 + 5 , Mod = 998244353 ; //N\uff1a\u957f\u5ea6\u4e0a\u9650, Mod: \u9ed8\u8ba4\u6a21\u6570 const double PI = acos ( -1.0 ); //Pi const int primitive_root = 3 ; //primitive-root: 3 //public // ll s1[N * 2], s2[N * 2], s3[N * 2]; //s1,s2,s3\uff1a\u8f93\u5165\u7cfb\u6570\u8868\u793a\u6cd5\u7528\u7684\u6570\u7ec4 //local int rev [ N * 2 ]; //rev\uff1a\ud83e\udd8b\u53d8\u6362\u7528\u6570\u7ec4 //\u5feb\u901f\u5e42 long long __ksm ( long long a , long long b , long long Mod ) { long long ans = 1 ; while ( b ) { if ( b & 1 ) ans = ( ans * a ) % Mod ; a = ( a * a ) % Mod ; b >>= 1 ; } return ans ; } //\u9884\u5904\u7406\ud83e\udd8b\u53d8\u6362 void __pre_rev ( int len ) { rev [ 0 ] = 0 ; for ( int i = 1 ; i <= len ; i ++ ) { rev [ i ] = rev [ i >> 1 ] >> 1 ; if ( i & 1 ) { rev [ i ] |= len >> 1 ; } } } // \ud83e\udd8b\u53d8\u6362 void __change ( ll y [], int len ) { __pre_rev ( len ); for ( int i = 0 ; i < len ; i ++ ) { if ( i < rev [ i ]) { swap ( y [ i ], y [ rev [ i ]]); } } } //\u53d6\u5f97\u6bd4n\u5927\u7684\u5e42\u957flen int getlen1 ( int n ) { int len = 1 ; while ( len < n ) { len <<= 1 ; } return len ; } //\u53d6\u5f97\u6bd4len1\\*2\u3001len2\\*2\u90fd\u5927\u7684\u5e42\u957f int getlen2 ( int len1 , int len2 ) { int len = 1 ; while ( len < len1 * 2 || len < len2 * 2 ) len <<= 1 ; //*2\uff0c\u4e0d\u7136\u8fdb\u4f4d\u4f1a\u70b8\u6389\uff0c\u5e76\u4e14\ud83e\udd8b\u53d8\u6362\u4f1a\u9519 return len ; } //\u5f97\u5230\u7531\u7cfb\u6570\u8868\u793a\u6cd5\u8f6c\u6362\u4e3a\u70b9\u503c\u8868\u793a\u6cd5\uff08ifft=-1\u5219\u53cd\u8fc7\u6765\uff09\u7684\u6570\u7ec4\uff1aifft\u4e3a1\u65f6\u505afft\uff0c-1\u5219\u505aifft\u3002 void ntt ( ll y [], int len , int ifft = 1 ) { __change ( y , len ); for ( int h = 2 ; h <= len ; h <<= 1 ) // \u5408\u5e76\u7684\u957f\u5ea6 { //complex<double> w_n(cos(2 * PI / h), sin(ifft * 2 * PI / h)); //\u5bf9\u5e94\u957f\u5ea6\u7684\u5355\u4f4d\u590d\u6839 ll gn ; if ( ifft == 1 ) gn = __ksm ( primitive_root ,(( ll ) Mod -1 ) / h , Mod ); //gn else gn = __ksm ( primitive_root ,(( ll ) Mod -1 ) / h * ( h -1 ), Mod ); //gn^-1 //else gn=ksm(332748118,(Mod-1)/h,Mod); for ( int j = 0 ; j < len ; j += h ) //\u8d77\u59cb\u4f4d\u7f6e { //complex<double> w(1, 0); //\u521d\u59cb\u7684w_n^k ll g = 1 ; for ( int k = j ; k < j + h / 2 ; k ++ ) // \u904d\u5386\u4f4d\u7f6e { ll u = y [ k ], v = ( g * y [ k + h / 2 ] % Mod ); //\u5076\u6570\u9879\u3001\u5947\u6570\u9879 y [ k ] = ( u + v + Mod ) % Mod ; y [ k + h / 2 ] = ( u - v + Mod ) % Mod ; //w *= w_n; //debug //cout<<k<<\":\"<<y[k]<<endl; //cout<<k+h/2<<\":\"<<y[k+h/2]<<endl; g = ( g * gn ) % Mod ; } } } if ( ifft == -1 ) { ll len_inv = __ksm ( len , Mod -2 , Mod ); for ( int i = 0 ; i < len ; i ++ ) { y [ i ] = y [ i ] * len_inv % Mod ; } } } //\u5bf9\u70b9\u503c\u8868\u793a\u6cd5\u7684\u6570\u7ec4y1\u3001y2\u505a\u4e58\u6cd5\u4fdd\u5b58\u81f3y3\u4e2d\u3002 void multi ( ll y1 [], ll y2 [], ll y3 [], int len ) { for ( int i = 0 ; i < len ; i ++ ) { y3 [ i ] = ( y1 [ i ] * y2 [ i ] % Mod + Mod ) % Mod ; } } } using namespace NTT ; namespace CDQ_FFT { int n ; ll ans [ N ]; ll gg [ N * 2 ]; ll g [ N * 2 ], f [ N * 2 ]; //ans\uff1a\u7b54\u6848\u5e8f\u5217f\uff0c\u6c42\u89e3solve(l,r)\u65f6\uff0cl~mid\u7684\u7b54\u6848\u5e8f\u5217f\u5df2\u7ecf\u6c42\u51fa\uff0c\u800cmid+1~r\u4e2d\u4ec5\u4ec5\u4fdd\u5b58\u4e86\u90e8\u5206\u8d21\u732e //gg\uff1a\u8f93\u5165\u7684g\u5e8f\u5217 //g\u3001f:\u7528\u4e8entt\u8ba1\u7b97\u7528\u7684\u5e8f\u5217\uff0c\u5728\u505a\u5206\u6cbb\u65f6\u8981\u53cd\u590d\u5199\u5165 //\u5bf9l~r\u8303\u56f4\u5185\u7684\u5e8f\u5217\u505a\u5206\u6cbbntt //\u6ce8\u610f\uff1a\u4e0d\u53ef\u8c03\u6362\u5b50\u5206\u6cbb\u7684\u8c03\u7528\u987a\u5e8f\uff08\u63d0\u524d\u8c03\u7528\u4f1a\u5bfc\u81f4\u4f7f\u7528\u4e0d\u5b8c\u6574\u7684\u8d21\u732e\u503c\u53bb\u8ba1\u7b97\u65b0\u8d21\u732e\uff09 void solve ( int l , int r ) { if ( l == r ) return ; int mid = ( l + r ) >> 1 ; solve ( l , mid ); //\u5206\u6cbb\u505al~mid\u8303\u56f4\u5185\u7684ntt //\u63a5\u4e0b\u6765\u8ba1\u7b97l~mid\u8303\u56f4\u5185\u7684f(0~mid)\u5bf9mid+1~r\u7684f\u7684\u8d21\u732e\u3002 int len = r - l + 1 ; len = getlen1 ( len ); //copy for ( int i = 0 ; i < len ; i ++ ) { g [ i ] = gg [ i ]; } int j = 0 ; for ( int i = l ; i <= mid ; i ++ , j ++ ) { f [ j ] = ans [ i ]; //\u6620\u5c04\u5173\u7cfb\uff1al->0, l+1->1 } for ( int i = mid + 1 ; i <= l + len -1 ; i ++ , j ++ ) { f [ j ] = 0 ; } ntt ( g , len ); ntt ( f , len ); multi ( g , f , f , len ); ntt ( f , len , -1 ); for ( int i = mid + 1 ; i <= r ; i ++ ) { ans [ i ] = ( ans [ i ] + f [ i - l ]) % Mod ; //\u8fd9\u91cc\u5957\u7528\u4e0a\u9762\u7684\u6620\u5c04\u5173\u7cfb } solve ( mid + 1 , r ); //\u5206\u6cbb\u505amid+1~r\u8303\u56f4\u5185\u7684ntt } } using namespace CDQ_FFT ; int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ), cout . tie ( 0 ); cin >> n ; for ( int i = 1 ; i <= n -1 ; i ++ ) { cin >> gg [ i ]; } ans [ 0 ] = 1 ; solve ( 0 , n -1 ); for ( int i = 0 ; i <= n -1 ; i ++ ) { cout << ans [ i ] << \" \" ; } return 0 ; }","title":"\u5206\u6cbbFFT"},{"location":"old/%E8%87%AA%E5%88%B6Template/#_27","text":"","title":"\u2b50\u62c9\u683c\u6717\u65e5\u63d2\u503c"},{"location":"old/%E8%87%AA%E5%88%B6Template/#luogu-4791-lagrange","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 // \u62c9\u683c\u6717\u65e5\u63d2\u503c #include <iostream> #include <cstring> #include <memory.h> #include <cmath> using namespace std ; const int N = 2e3 + 10 ; const int Mod = 998244353 ; long long x [ N ], y [ N ], n , k ; long long ksm ( long long a , long long b , long long Mod ) { long long ans = 1 ; while ( b ) { if ( b & 1 ) ans = ans * a % Mod ; a = ( a * a ) % Mod ; b >>= 1 ; } return ans ; } long long lagrange () { long long fz , fm , temp , ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { fz = fm = 1 ; temp = y [ i ]; for ( int j = 1 ; j <= n ; j ++ ) { if ( j == i ) continue ; fz = ( fz * ( k - x [ j ] + Mod ) % Mod ) % Mod ; fm = ( fm * ( x [ i ] - x [ j ] + Mod ) % Mod ) % Mod ; } temp = ( temp * fz ) % Mod ; temp = ( temp * ksm ( fm , Mod -2 , Mod )) % Mod ; ans = ( ans + temp ) % Mod ; } return ans ; } int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); cin >> n >> k ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> x [ i ] >> y [ i ]; } cout << lagrange () << endl ; return 0 ; }","title":"luogu 4791 lagrange"},{"location":"old/%E8%87%AA%E5%88%B6Template/#_28","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 long long C ( long long y , long long x ) { if ( y < 0 || x < 0 || y < x ) return 0 ; //No sense y %= Mod ; //x far below than Mod so that x%Mod==x if ( y == 0 && x == 0 ) return 1 ; long long ans = 1 ; for ( long long j = y ; j >= y - x + 1 ; j -- ) { ans *= j ; ans %= Mod ; } ans *= f_inv [ x ]; return ans % Mod ; }","title":"\u89c4\u8303\u7ec4\u5408\u6570"},{"location":"old/%E8%87%AA%E5%88%B6Template/#_29","text":"","title":"\u6570\u636e\u7ed3\u6784"},{"location":"old/%E8%87%AA%E5%88%B6Template/#st","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 template < typename T > struct ST_table { static const int N = 2e5 + 10 , M = 25 ; T ma [ N ][ M ], mi [ N ][ M ]; int n , t ; void init ( T a []) { t = log2 ( n ) + 1 ; for ( int i = 1 ; i <= n ; i ++ ) ma [ i ][ 0 ] = ma [ i ][ 0 ] = make_pair ( a [ i ], i ); for ( int k = 1 ; k < t ; k ++ ) { for ( int i = 1 ; i <= n - ( 1 << k ) + 1 ; i ++ ) { ma [ i ][ k ] = max ( ma [ i ][ k - 1 ], ma [ i + ( 1 << ( k - 1 ))][ k - 1 ]); mi [ i ][ k ] = min ( mi [ i ][ k - 1 ], mi [ i + ( 1 << ( k - 1 ))][ k - 1 ]); } } } T ask_mi ( int l , int r ) { int k = ( int ) log2 ( r - l + 1 ); return min ( mi [ l ][ k ], mi [ r - ( 1 << k ) + 1 ][ k ]); } T ask_ma ( int l , int r ) { int k = ( int ) log2 ( r - l + 1 ); return max ( ma [ l ][ k ], ma [ r - ( 1 << k ) + 1 ][ k ]); } };","title":"ST\u8868\uff08\u4e00\u7ef4\uff09"},{"location":"old/%E8%87%AA%E5%88%B6Template/#_30","text":"\u540c\u65f6\u652f\u6301\u52a0\u6cd5\u3001\u4e58\u6cd5\u64cd\u4f5c\uff08\u5bf9p\u53d6\u6a21\uff09\u7684\u7ebf\u6bb5\u6811\u3002\u7ebf\u6bb5\u6811\u7684\u6bcf\u4e2a\u8282\u70b9\u4fdd\u5b58\u5176\u6240\u7ef4\u62a4\u7684\u533a\u95f4\u5927\u5c0f\u3002 Funs || Methods Reliance Time Complexity Inputs Outputs Description __tagdown 1 u\uff1a\u6811\u8282\u70b9\u4e0b\u6807\u3002ln:\u5de6\u5b50\u6811\u5bf9\u5e94\u533a\u95f4\u957f\u5ea6\u3002rn\uff1a\u53f3\u5b50\u6811\u5bf9\u5e94\u533a\u95f4\u957f\u5ea6 \u6807\u8bb0\u4e0b\u653e\uff1a\u5148\u66f4\u65b0\u4e58\u6cd5\u6807\u8bb0\u540e\u66f4\u65b0\u52a0\u6cd5\u6807\u8bb0\uff0c\u6700\u540e\u6e05\u7a7au\u7684\u6807\u8bb0\u3002 build_tree nlogn u\uff1a\u6811\u8282\u70b9\u4e0b\u6807\uff08\u521d\u59cb\u8c03\u7528\u65f6u=1\uff09\u3002l\u3001r\uff1a\u8282\u70b9\u7ba1\u8f96\u7684\u5de6\u53f3\u7aef\u70b9 \u521d\u59cb\u5316\u70b9\u6bb5\u6811\uff1a\u66f4\u65b0\u6bcf\u4e2a\u8282\u70b9\u7684val\u503c\u4e3a\u5b69\u5b50val\u503c\u548c\uff0c\u53f6\u5b50\u8282\u70b9\u7684\u503c\u88ab\u8bbe\u4e3aa[l]\u3002 asksum build_tree logn u\uff1a\u6811\u8282\u70b9\u4e0b\u6807\u3002L\u3001R\uff1a\u8be2\u95ee\u533a\u95f4\u3002 \u533a\u95f4\u548c \u8fd4\u56de\u533a\u95f4L\u3001R\u7684\u548c\u3002 segupd build_tree logn u\uff1a\u6811\u8282\u70b9\u4e0b\u6807\uff08\u521d\u59cb\u8c03\u7528\u65f6u=1\uff09\u3002L\u3001R\uff1a\u8be2\u95ee\u533a\u95f4\u3002addval\uff1a\u589e\u52a0\u7684\u503c \u533a\u95f4L,R\u52a0\u6cd5\u66f4\u65b0 segupd2 build_tree logn u\uff1a\u6811\u8282\u70b9\u4e0b\u6807\uff08\u521d\u59cb\u8c03\u7528\u65f6u=1\uff09\u3002L\u3001R\uff1a\u8be2\u95ee\u533a\u95f4\u3002addval\uff1a\u4e58\u6cd5\u7684\u503c \u533a\u95f4L,R\u4e58\u6cd5\u66f4\u65b0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 //Luogu 3373 Segment t 2 (\u4e0b\u6807\u4fdd\u5b58\u7248) #include <iostream> using namespace std ; typedef long long ll ; namespace Segment_tree { const int MAXN = 1e5 + 10 ; //MAXN\uff1a\u7ebf\u6bb5\u6811\u5927\u5c0f\u4e0a\u9650 //public ll n , m , a [ MAXN ], p ; //n:\u957f\u5ea6\uff0c m\uff1a\u8be2\u95ee\u4e2a\u6570\uff0c a\uff1a\u521d\u59cb\u6570\u7ec4\u4e2a\u6570\uff0c p\uff1a\u6a21\u6570 template < typename Ty , int MAXN = MAXN > struct SEGMENT_TREE { struct NODE { Ty val , tagplus , tagmulti ; //val, tagplus, tagmulti\uff1a\u503c\uff0c\u52a0\u6cd5\u6807\u8bb0\uff0c\u4e58\u6cd5\u6807\u8bb0 Ty l , r ; //l\u3001r\uff1a\u7ebf\u6bb5\u6811\u8282\u70b9\u6240\u7ef4\u62a4\u7684\u533a\u95f4 } t [ MAXN * 4 ]; //\u6807\u8bb0\u4e0b\u653e\uff1a\u5148\u66f4\u65b0\u4e58\u6cd5\u6807\u8bb0\u540e\u66f4\u65b0\u52a0\u6cd5\u6807\u8bb0\uff0c\u6700\u540e\u6e05\u7a7au\u7684\u6807\u8bb0\u3002 //ln:\u5de6\u5b50\u6811\u5bf9\u5e94\u533a\u95f4\u957f\u5ea6 rn\uff1a\u53f3\u5b50\u6811\u5bf9\u5e94\u533a\u95f4\u957f\u5ea6 void __tagdown ( Ty u , Ty ln , Ty rn ) { //\u6309\u5f53\u524d\u8282\u70b9\uff08u0\uff09\u6807\u8bb0\u66f4\u65b0\u5de6\u53f3\u513f\u5b50\u7684\u503c t [ u * 2 ]. val = ( t [ u * 2 ]. val * t [ u ]. tagmulti + t [ u ]. tagplus * ln ) % p ; t [ u * 2 + 1 ]. val = ( t [ u * 2 + 1 ]. val * t [ u ]. tagmulti + t [ u ]. tagplus * rn ) % p ; //\u66f4\u65b0\u5de6\u53f3\u513f\u5b50\u4e58\u6cd5\u6807\u8bb0(\u5148\u4e58\u540e\u52a0\u6cd5) t [ u * 2 ]. tagmulti = ( t [ u * 2 ]. tagmulti * t [ u ]. tagmulti ) % p ; t [ u * 2 + 1 ]. tagmulti = ( t [ u * 2 + 1 ]. tagmulti * t [ u ]. tagmulti ) % p ; //\u66f4\u65b0\u5de6\u53f3\u513f\u5b50\u52a0\u6cd5\u6807\u8bb0 t [ u * 2 ]. tagplus = ( t [ u * 2 ]. tagplus * t [ u ]. tagmulti + t [ u ]. tagplus ) % p ; t [ u * 2 + 1 ]. tagplus = ( t [ u * 2 + 1 ]. tagplus * t [ u ]. tagmulti + t [ u ]. tagplus ) % p ; //\u91cd\u8bbe\u6807\u8bb0 t [ u ]. tagplus = 0 ; t [ u ]. tagmulti = 1 ; } //\u521d\u59cb\u5316\u70b9\u6bb5\u6811\uff1a\u66f4\u65b0\u6bcf\u4e2a\u8282\u70b9\u7684val\u503c\u4e3a\u5b69\u5b50val\u503c\u548c\uff0c\u53f6\u5b50\u8282\u70b9\u7684\u503c\u88ab\u8bbe\u4e3aa[l]\u3002 void build_tree ( Ty u , Ty l , Ty r ) { t [ u ]. tagplus = 0 ; t [ u ]. tagmulti = 1 ; t [ u ]. l = l ; t [ u ]. r = r ; if ( l == r ) { t [ u ]. val = a [ l ]; return ; } ll mid = ( l + r ) >> 1 ; build_tree ( u * 2 , l , mid ); build_tree ( u * 2 + 1 , mid + 1 , r ); t [ u ]. val = ( t [ u * 2 ]. val + t [ u * 2 + 1 ]. val ) % p ; } Ty asksum ( Ty u , Ty L , Ty R ) //LR:\u8be2\u95ee lr\uff1a\u8282\u70b9 { if ( L <= t [ u ]. l && t [ u ]. r <= R ) return t [ u ]. val % p ; Ty mid = ( t [ u ]. l + t [ u ]. r ) >> 1 , ans = 0 ; __tagdown ( u , mid - t [ u ]. l + 1 , t [ u ]. r - mid ); if ( L <= mid ) { ans += asksum ( u * 2 , L , R ); ans %= p ; } if ( R > mid ) { ans += asksum ( u * 2 + 1 , L , R ); ans %= p ; } return ans ; } //\u52a0\u6cd5\u66f4\u65b0 void segupd ( Ty u , Ty L , Ty R , Ty addval ) { if ( L <= t [ u ]. l && t [ u ]. r <= R ) { t [ u ]. val = ( t [ u ]. val + addval * ( t [ u ]. r - t [ u ]. l + 1 )) % p ; t [ u ]. tagplus = ( addval + t [ u ]. tagplus ) % p ; return ; } ll mid = ( t [ u ]. l + t [ u ]. r ) >> 1 ; __tagdown ( u , mid - t [ u ]. l + 1 , t [ u ]. r - mid ); if ( L <= mid ) segupd ( u * 2 , L , R , addval ); if ( mid < R ) segupd ( u * 2 + 1 , L , R , addval ); t [ u ]. val = ( t [ u * 2 ]. val + t [ u * 2 + 1 ]. val ) % p ; } //\u4e58\u6cd5\u66f4\u65b0 void segupd2 ( Ty u , Ty L , Ty R , Ty addval ) { if ( L <= t [ u ]. l && t [ u ]. r <= R ) { t [ u ]. tagplus = ( t [ u ]. tagplus * addval ) % p ; t [ u ]. tagmulti = ( t [ u ]. tagmulti * addval ) % p ; t [ u ]. val = ( t [ u ]. val * addval ) % p ; return ; } Ty mid = ( t [ u ]. l + t [ u ]. r ) >> 1 ; __tagdown ( u , mid - t [ u ]. l + 1 , t [ u ]. r - mid ); if ( L <= mid ) segupd2 ( u * 2 , L , R , addval ); if ( mid < R ) segupd2 ( u * 2 + 1 , L , R , addval ); t [ u ]. val = ( t [ u * 2 ]. val + t [ u * 2 + 1 ]. val ) % p ; } }; } // namespace Segment_tree using namespace Segment_tree ; SEGMENT_TREE < ll > tree ; int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); cin >> n >> m >> p ; for ( ll i = 1 ; i <= n ; i ++ ) { cin >> a [ i ]; } tree . build_tree ( 1 , 1 , n ); for ( ll i = 1 ; i <= m ; i ++ ) { ll caozuo , l , r ; cin >> caozuo >> l >> r ; if ( caozuo == 2 ) { ll k ; cin >> k ; tree . segupd ( 1 , l , r , k ); } else if ( caozuo == 1 ) { ll k ; cin >> k ; tree . segupd2 ( 1 , l , r , k ); } else { cout << tree . asksum ( 1 , l , r ) << endl ; } } return 0 ; }","title":"\u7ebf\u6bb5\u6811"},{"location":"old/%E8%87%AA%E5%88%B6Template/#_31","text":"\u9759\u6001\u533a\u95f4\u7b2c k \u5c0f\u3002 \u53ef\u6301\u4e45\u5316\u7ebf\u6bb5\u6811\u7ef4\u62a4\u7684\u662f\u6743\u503c(\u4e5f\u5373\uff0c\u6570\u7ec4\u7d22\u5f15\u4ee3\u8868\u503c\u672c\u8eab\uff0c\u6570\u7ec4\u5bf9\u5e94\u7684\u503c\u8868\u793a\u8fd9\u4e2a\u503c\u6709\u591a\u5c11\u4e2a)\u3002\u539f\u6570\u7ec4\u7684\u533a\u95f4\u5bf9\u5e94\u5230\u53ef\u6301\u4e45\u5316\u7ebf\u6bb5\u6811\u7684\u5e94\u8be5\u662f\u4e0d\u540c\u7248\u672c\u7684\u6811\u6839\u3002 \u8c03\u7528\u524d\u9700\u8981\u624b\u52a8\u8bbe\u5b9arange_upb\u3002 Funs || Methods Reliance Time Complexity Inputs Outputs Description build_tree NlogN l\uff0cr: \u6743\u503c\u5de6\u53f3\u8fb9\u754c \u521d\u59cb\u5316\u6743\u503c\u7ebf\u6bb5\u6811 change build_tree logN u\uff1a\u4e0a\u4e00\u7248\u672c\u6811\u6839\u4e0b\u6807\u3002l\u3001r\uff1a\u6743\u503c\u5de6\u53f3\u8fb9\u754c\u3002pos\uff1a\u4fee\u6539\u6743\u503c\u7684\u4f4d\u7f6e\u3002val(=1)\uff1a\u4fee\u6539\u6743\u503c\u5927\u5c0f \u5f53\u524d\u7248\u672c\u6839\u4e0b\u6807 \u5728\u4e0a\u4e00\u7248\u672c\u7684\u57fa\u7840\u4e0a\uff0c\u7ed9pos\u4f4d\u7f6e\u7684\u4e2a\u6570+1 ask build_tree logN pa\u3001pb\uff1a\u65e7\u7248\u672c\u3001\u65b0\u7248\u672c\u7ebf\u6bb5\u6811\u7684\u6839\u3002l\u3001r\uff1a\u4e8c\u5206\u6743\u503c\u8303\u56f4\uff08\u521d\u59cb\u4e3a1\u548crange_upb\uff09\u3002rnk\uff1a\u7b2crnk\u5c0f\u7684\u6570 \u4ecb\u4e8e\u65e7\u7248\u672c\u3001\u65b0\u7248\u672c\u7ebf\u6bb5\u6811\u4e4b\u95f4\u7684\u7b2crnk\u5c0f\u6570 \u8fd4\u56de\u4ecb\u4e8e\u65e7\u7248\u672c\u3001\u65b0\u7248\u672c\u7ebf\u6bb5\u6811\u4e4b\u95f4\uff08\u5bf9\u5e94\u6570\u7ec4\u533a\u95f4L\u3001R\uff09\u7684\u7b2crnk\u5c0f\u6570\u3002\u5982\u679c\u79bb\u6563\u5316\u4e86\u5219\u8fd9\u4e2a\u8fd4\u56de\u503c\u5e94\u8be5\u8868\u793a\u7d22\u5f15\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 #include <iostream> #include <cstdio> #include <map> #include <algorithm> #include <memory.h> using namespace std ; typedef long long ll ; namespace Chairman_Tree { const int N = 2e5 + 5 ; //public int n , m ; //n:\u6570\u7684\u4e2a\u6570 m:\u8be2\u95ee\u4e2a\u6570 \uff08\u5176\u5b9e\u8fd9\u4e24\u4e2a\u53d8\u91cf\u53ef\u4ee5\u653e\u5230\u5916\u9762\u2026\u2026\uff09 int range_upb ; // range_upb:\u6743\u503c\u8303\u56f4\u4e0a\u9650 //local template < typename Ty > struct CHairman_Tree { //public int root [ N ]; //root: \u4e0d\u540c\u7248\u672c\u7684\u7ebf\u6bb5\u6811\u6811\u6839 //local struct Node { int lc , rc ; //lc\u3001rc\uff1a\u5de6\u53f3\u5b69\u5b50\u7d22\u5f15 Ty cnt ; //cnt: \u6743\u503c\u548c } t [ 20 * N ]; int total ; //total: \u7ebf\u6bb5\u6811\u8282\u70b9\u7684\u4e2a\u6570 //\u521d\u59cb\u5316\u6743\u503c\u7ebf\u6bb5\u6811 int build_tree ( int l , int r ) { int p =++ total ; if ( l == r ) { t [ p ]. cnt = 0 ; return p ; } int mid = ( l + r ) >> 1 ; t [ p ]. lc = build_tree ( l , mid ); t [ p ]. rc = build_tree ( mid + 1 , r ); t [ p ]. cnt = 0 ; return p ; } //\u5728\u4e0a\u4e00\u7248\u672c\u7684\u57fa\u7840\u4e0a\uff0c\u7ed9pos\u4f4d\u7f6e\u7684\u4e2a\u6570+1 int change ( int p , int l , int r , int pos , int val = 1 ) { int q =++ total ; // new node t [ q ] = t [ p ]; // copy if ( l == r ) { t [ q ]. cnt += val ; return q ; } int mid = ( l + r ) >> 1 ; if ( pos <= mid ) t [ q ]. lc = change ( t [ p ]. lc , l , mid , pos , val ); else t [ q ]. rc = change ( t [ p ]. rc , mid + 1 , r , pos , val ); t [ q ]. cnt = t [ t [ q ]. lc ]. cnt + t [ t [ q ]. rc ]. cnt ; return q ; } //\u8fd4\u56de\u4ecb\u4e8e\u65e7\u7248\u672c\u3001\u65b0\u7248\u672c\u7ebf\u6bb5\u6811\u4e4b\u95f4\u7684\u7b2crnk\u5c0f\u6570\u3002\u5982\u679c\u79bb\u6563\u5316\u4e86\u5219\u8fd9\u4e2a\u8fd4\u56de\u503c\u5e94\u8be5\u8868\u793a\u7d22\u5f15\u3002 int ask ( int pa , int pb , int l , int r , int rnk ) // \u83b7\u5f97\u79bb\u6563\u5316\u540e\u7684\u503c\uff08\u5bf9\u503c\u57df\u8fdb\u884c\u4e8c\u5206\uff09 { if ( l == r ) { return l ; } int mid = ( l + r ) >> 1 ; int cnt = t [ t [ pb ]. lc ]. cnt - t [ t [ pa ]. lc ]. cnt ; // Count of [L,mid] if ( cnt >= rnk ) return ask ( t [ pa ]. lc , t [ pb ]. lc , l , mid , rnk ); else return ask ( t [ pa ]. rc , t [ pb ]. rc , mid + 1 , r , rnk - cnt ); } }; } using namespace Chairman_Tree ; namespace Discretization { const int N = 1e6 + 10 ; typedef int Ty ; //public Ty a [ N ], b [ N ]; int dlen ; // \u590d\u5236a\u5230b void copy_to_b () { memcpy ( b , a , sizeof ( a )); } // \u5bf9b\u6392\u5e8f\u3001\u53bb\u91cd\uff0c\u8fd4\u56de\u53bb\u91cd\u540e\u7684\u6570\u7ec4\u957f\u5ea6 int sort_and_unique ( int n ) { sort ( b + 1 , b + 1 + n ); return dlen = unique ( b + 1 , b + 1 + n ) - b -1 ; } // \u8fd4\u56de\u79bb\u6563\u5316\u540e\u7684\u503c\uff081\u5f00\u59cb\u8ba1\u6570\uff09 inline int get_id ( Ty x ) { return lower_bound ( b + 1 , b + 1 + dlen , x ) - b ; } } //using namespace Discretization; CHairman_Tree < int > t ; int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); cin >> n >> m ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> Discretization :: a [ i ]; } //\u79bb\u6563\u5316 Discretization :: copy_to_b (); range_upb = Discretization :: sort_and_unique ( n ); //\u5efa\u6811 t . build_tree ( 1 , range_upb ); //\u4fee\u6539\u5e76\u5efa\u7acb\u5386\u53f2\u7248\u672c for ( int i = 1 ; i <= n ; i ++ ) { int x = Discretization :: get_id ( Discretization :: a [ i ]); t . root [ i ] = t . change ( t . root [ i -1 ], 1 , range_upb , x ); } //\u67e5\u8be2\u533a\u95f4\u7b2ck\u5927\uff1a\u901a\u8fc7\u4e0e\u5386\u53f2\u7248\u672c\u4f5c\u5dee\u5b9e\u73b0\u6743\u503c\u4e8c\u5206 for ( int i = 1 ; i <= m ; i ++ ) { int l , r , k ; cin >> l >> r >> k ; int index = t . ask ( t . root [ l -1 ], t . root [ r ], 1 , range_upb , k ); cout << Discretization :: b [ index ] << endl ; } return 0 ; }","title":"\u53ef\u6301\u4e45\u5316\u6743\u503c\u7ebf\u6bb5\u6811"},{"location":"old/%E8%87%AA%E5%88%B6Template/#cdq","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 //Luogu P3810 \u3010\u6a21\u677f\u3011\u4e09\u7ef4\u504f\u5e8f\uff08\u964c\u4e0a\u82b1\u5f00 //\u984c\u610f\uff1a\u6c42\u6eff\u8db3aj<=ai, bj<=bi, cj<=ci (j!=i)\u7684\u9ede\u5c0d\u6578\u91cf\uff0c\u5c0d\u65bcd in [0,n)\uff0c\u6c42f(i)=d\u7684\u6578\u91cf #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <cstdlib> #include <algorithm> #include <string> #include <vector> #include <map> #include <unordered_map> #include <set> #include <unordered_set> #include <queue> using namespace std ; typedef long long ll ; const int N = 4e5 + 10 ; namespace BIT { const int MAXN = 4e5 + 10 ; template < typename Ty > struct Bit { //local Ty t [ MAXN ]; int __lowbit ( int x ) { return x & ( - x ); } void add ( int pos , Ty val = 1 ) { while ( pos < MAXN ) { t [ pos ] += val ; pos += __lowbit ( pos ); } } Ty ask ( int pos ) { Ty ans = 0 ; while ( pos >= 1 ) { ans += t [ pos ]; pos -= __lowbit ( pos ); } return ans ; } }; } using namespace BIT ; int n , k ; struct P { int x , y , z ; int id ; int cnt ; } a [ N ], b [ N ]; int ap ; struct Q { int y , z ; int typ ; //0:op , 1:query int id ; int cnt ; } c [ N ]; int cp ; Bit < int > tree ; int cnt [ N ]; int ans [ N ]; int ans2 [ N ]; int cmpx ( const P & a , const P & b ) { if ( a . x == b . x && a . y == b . y ) return a . z < b . z ; if ( a . x == b . x ) return a . y < b . y ; return a . x < b . x ; } int cmpq ( const Q & a , const Q & b ) { if ( a . y == b . y && a . z == b . z ) return a . typ < b . typ ; if ( a . y == b . y ) return a . z < b . z ; return a . y < b . y ; } void solve ( int l , int r ) { if ( l == r ) { return ; } int mid = ( l + r ) / 2 ; solve ( l , mid ); solve ( mid + 1 , r ); cp = 0 ; for ( int i = l ; i <= mid ; i ++ ) { c [ ++ cp ] = { a [ i ]. y , a [ i ]. z , 0 , a [ i ]. id , a [ i ]. cnt }; } for ( int i = mid + 1 ; i <= r ; i ++ ) { c [ ++ cp ] = { a [ i ]. y , a [ i ]. z , 1 , a [ i ]. id , a [ i ]. cnt }; } sort ( c + 1 , c + 1 + cp , cmpq ); for ( int i = 1 ; i <= cp ; i ++ ) { if ( c [ i ]. typ == 0 ) //op { tree . add ( c [ i ]. z , c [ i ]. cnt ); } else //query { ans [ c [ i ]. id ] += tree . ask ( c [ i ]. z ); } } //undo change of BIT for ( int i = 1 ; i <= cp ; i ++ ) { if ( c [ i ]. typ == 0 ) { tree . add ( c [ i ]. z , - c [ i ]. cnt ); } } } void my_unique () { ap = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( a [ ap ]. x == b [ i ]. x && a [ ap ]. y == b [ i ]. y && a [ ap ]. z == b [ i ]. z ) { a [ ap ]. cnt ++ ; } else { a [ ++ ap ] = b [ i ]; } } } int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ), cout . tie ( 0 ); cin >> n >> k ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> b [ i ]. x ; cin >> b [ i ]. y ; cin >> b [ i ]. z ; b [ i ]. id = i ; b [ i ]. cnt = 1 ; } sort ( b + 1 , b + 1 + n , cmpx ); my_unique (); sort ( a + 1 , a + 1 + ap , cmpx ); for ( int i = 1 ; i <= ap ; i ++ ) { cnt [ a [ i ]. id ] = a [ i ]. cnt ; } solve ( 1 , ap ); for ( int i = 1 ; i <= n ; i ++ ) { ans [ i ] += cnt [ i ] - 1 ; if ( ans [ i ] >= 0 ) ans2 [ ans [ i ]] += cnt [ i ]; // cout<<ans[i]<<endl; } // cout<<endl; for ( int i = 0 ; i < n ; i ++ ) { cout << ans2 [ i ] << endl ; } return 0 ; } //Luogu P3810 \u3010\u6a21\u677f\u3011\u4e09\u7ef4\u504f\u5e8f\uff08\u964c\u4e0a\u82b1\u5f00 //\u984c\u610f\uff1a\u6c42\u6eff\u8db3aj<=ai, bj<=bi, cj<=ci (j!=i)\u7684\u9ede\u5c0d\u6578\u91cf\uff0c\u5c0d\u65bcd in [0,n)\uff0c\u6c42f(i)=d\u7684\u6578\u91cf #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <cstdlib> #include <algorithm> #include <string> #include <vector> #include <map> #include <unordered_map> #include <set> #include <unordered_set> #include <queue> using namespace std ; typedef long long ll ; const int N = 4e5 + 10 ; namespace BIT { const int MAXN = 4e5 + 10 ; template < typename Ty > struct Bit { //local Ty t [ MAXN ]; int __lowbit ( int x ) { return x & ( - x ); } void add ( int pos , Ty val = 1 ) { while ( pos < MAXN ) { t [ pos ] += val ; pos += __lowbit ( pos ); } } Ty ask ( int pos ) { Ty ans = 0 ; while ( pos >= 1 ) { ans += t [ pos ]; pos -= __lowbit ( pos ); } return ans ; } }; } using namespace BIT ; int n , k ; struct P { int x , y , z ; int id ; int cnt ; } a [ N ], b [ N ]; int ap ; struct Q { int y , z ; int typ ; //0:op , 1:query int id ; int cnt ; } c [ N ]; int cp ; Bit < int > tree ; int cnt [ N ]; int ans [ N ]; int ans2 [ N ]; int cmpx ( const P & a , const P & b ) { if ( a . x == b . x && a . y == b . y ) return a . z < b . z ; if ( a . x == b . x ) return a . y < b . y ; return a . x < b . x ; } int cmpq ( const Q & a , const Q & b ) { if ( a . y == b . y && a . z == b . z ) return a . typ < b . typ ; if ( a . y == b . y ) return a . z < b . z ; return a . y < b . y ; } void solve ( int l , int r ) { if ( l == r ) { return ; } int mid = ( l + r ) / 2 ; solve ( l , mid ); solve ( mid + 1 , r ); cp = 0 ; for ( int i = l ; i <= mid ; i ++ ) { c [ ++ cp ] = { a [ i ]. y , a [ i ]. z , 0 , a [ i ]. id , a [ i ]. cnt }; } for ( int i = mid + 1 ; i <= r ; i ++ ) { c [ ++ cp ] = { a [ i ]. y , a [ i ]. z , 1 , a [ i ]. id , a [ i ]. cnt }; } sort ( c + 1 , c + 1 + cp , cmpq ); for ( int i = 1 ; i <= cp ; i ++ ) { if ( c [ i ]. typ == 0 ) //op { tree . add ( c [ i ]. z , c [ i ]. cnt ); } else //query { ans [ c [ i ]. id ] += tree . ask ( c [ i ]. z ); } } //undo change of BIT for ( int i = 1 ; i <= cp ; i ++ ) { if ( c [ i ]. typ == 0 ) { tree . add ( c [ i ]. z , - c [ i ]. cnt ); } } } void my_unique () { ap = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( a [ ap ]. x == b [ i ]. x && a [ ap ]. y == b [ i ]. y && a [ ap ]. z == b [ i ]. z ) { a [ ap ]. cnt ++ ; } else { a [ ++ ap ] = b [ i ]; } } } int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ), cout . tie ( 0 ); cin >> n >> k ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> b [ i ]. x ; cin >> b [ i ]. y ; cin >> b [ i ]. z ; b [ i ]. id = i ; b [ i ]. cnt = 1 ; } sort ( b + 1 , b + 1 + n , cmpx ); my_unique (); sort ( a + 1 , a + 1 + ap , cmpx ); for ( int i = 1 ; i <= ap ; i ++ ) { cnt [ a [ i ]. id ] = a [ i ]. cnt ; } solve ( 1 , ap ); for ( int i = 1 ; i <= n ; i ++ ) { ans [ i ] += cnt [ i ] - 1 ; if ( ans [ i ] >= 0 ) ans2 [ ans [ i ]] += cnt [ i ]; // cout<<ans[i]<<endl; } // cout<<endl; for ( int i = 0 ; i < n ; i ++ ) { cout << ans2 [ i ] << endl ; } return 0 ; }","title":"CDQ\u5206\u6cbb"},{"location":"old/%E8%87%AA%E5%88%B6Template/#bit","text":"Funs || Methods Reliance Time Complexity Inputs Outputs Description __lowbit 1 x x&-x \u521d\u59cb\u5316\u6743\u503c\u7ebf\u6bb5\u6811 add logn pos\uff1a\u6dfb\u52a0\u7684\u4f4d\u7f6e\u3002val\uff08=1\uff09\uff1a\u6dfb\u52a0\u7684\u503c\u3002 \u5c06pos\u4f4d\u7f6e\u7684\u503c\u52a0\u4e0aval ask logn pos\uff1a\u67e5\u8be2\u7684\u524d\u7f00\u4f4d\u7f6e \u8fd41~pos\u7684\u548c \u8fd4\u56de1~pos\u7684\u548c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include <iostream> using namespace std ; namespace BIT { const int MAXN = 4e5 + 10 ; template < typename Ty > struct Bit { //local Ty t [ MAXN ]; int __lowbit ( int x ) { return x & ( - x ); } void add ( int pos , Ty val = 1 ) { while ( pos < MAXN ) { t [ pos ] += val ; pos += __lowbit ( pos ); } } Ty ask ( int pos ) { Ty ans = 0 ; while ( pos >= 1 ) { ans += t [ pos ]; pos -= __lowbit ( pos ); } return ans ; } }; } using namespace BIT ;","title":"\u6811\u72b6\u6570\u7ec4(BIT)"},{"location":"old/%E8%87%AA%E5%88%B6Template/#_32","text":"Funs || Methods Reliance Time Complexity Inputs Outputs Description init n n\uff1a\u5143\u7d20\u4e2a\u6570 \u521d\u59cb\u5316\u5e76\u67e5\u96c6\u4e2d\u7684\u6bcf\u4e2a\u8282\u70b9\uff0c\u4ee4\u6bcf\u4e2a\u8282\u70b9\u7684\u7236\u4eb2\u4e3a\u5176\u672c\u8eab getfa init 1 x\uff1a\u8282\u70b9 x\u7684\u7236\u4eb2 \u53d6\u5f97\u7236\u4eb2\u5e76\u8def\u5f84\u538b\u7f29 merge init 1 x\u3001y\uff1a\u8282\u70b9 \u5408\u5e76\u540e\u7684\u7236\u4eb2\u8282\u70b9\u3002\u82e5\u4e3a-1\u8868\u660exy\u5df2\u7ecf\u5728\u540c\u4e00\u96c6\u5408 \u5408\u5e76x\u3001y\uff08\u6309\u79e9\u5408\u5e76\uff09 check init 1 x\u3001y\uff1a\u8282\u70b9 \u662f\u5426\u5df2\u7ecf\u5728\u540c\u4e00\u96c6\u5408 \u68c0\u67e5\u662f\u5426\u5728\u540c\u4e00\u96c6\u5408 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <iostream> #include <map> #include <queue> #include <set> #include <string> #include <unordered_map> #include <unordered_set> #include <vector> using namespace std ; typedef long long ll ; namespace Union_find_set { struct Unionfindset { static const int N = 3e5 + 10 ; // local int fa [ N ], sz [ N ]; //fa,sz\uff1a\u7236\u4eb2\u548c\u79e9\u7684\u5927\u5c0f //\u521d\u59cb\u5316\u5e76\u67e5\u96c6 void init ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { fa [ i ] = i ; sz [ i ] = 1 ; } } //\u53d6\u5f97\u7236\u4eb2\u5e76\u8def\u5f84\u538b\u7f29 int getfa ( int x ) { if ( fa [ x ] == x ) return x ; return fa [ x ] = getfa ( fa [ x ]); } //\u5408\u5e76x\u3001y int merge ( int x , int y ) { int x_fa = getfa ( x ), y_fa = getfa ( y ); if ( x_fa == y_fa ) return -1 ; if ( sz [ x_fa ] > sz [ y_fa ]) { swap ( x , y ); swap ( x_fa , y_fa ); } fa [ x_fa ] = y_fa ; sz [ y_fa ] += sz [ x_fa ]; return y_fa ; } //\u68c0\u67e5\u662f\u5426\u5728\u540c\u4e00\u96c6\u5408 bool check ( int x , int y ) { return getfa ( x ) == getfa ( y ); } } ufs ; } // namespace Union_find_set int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ), cout . tie ( 0 ); return 0 ; }","title":"\u5e76\u67e5\u96c6\uff08\u6309\u79e9\u5408\u5e76\uff09"},{"location":"old/%E8%87%AA%E5%88%B6Template/#kdtree","text":"\u26a0\ufe0f\uff1a\u4f7f\u7528\u524d\u9700\u8981\u5148\u5904\u7406\u6811\u4e2d\u7684s\u6570\u7ec4\u548c\u53d8\u91cfn 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <cstdlib> #include <algorithm> #include <string> #include <vector> #include <map> #include <unordered_map> #include <set> #include <unordered_set> #include <queue> using namespace std ; typedef long long ll ; namespace KDTREE { typedef ll Ty ; const int N = 2e5 + 10 ; //\u5e73\u65b9 template < typename T > T sqr ( T x ) { return x * x ; } struct Node { Ty x , y ; Ty L , R , U , D ; int lc , rc ; int d ; //x,y:\u70b9\u7684\u5750\u6807 //LRUD\uff1a\u70b9\u6240\u7ba1\u8f96\u7684\u5b50\u6811\u7684\u6700\u5c0f\u77e9\u5f62\u8986\u76d6 //lc\uff0crc\uff1a\u5de6\u53f3\u5b69\u5b50 // d\uff1a\u8be5\u8282\u70b9\u5b50\u6811\u662f\u6309\u54ea\u4e00\u7ef4\u5212\u5206\u7684\uff0c1\u662f\u6309x\uff0c2\u6309y //\u8ddd\u79bb\u7684\u5e73\u65b9 Ty dis2 ( const Node & b ) const { return sqr ( x - b . x ) + sqr ( y - b . y ); } }; //\u6309x\u8f74\u5750\u6807\u6bd4\u8f83 bool __cmpx ( const Node & a , const Node & b ) { return a . x < b . x ; } //\u6309y\u8f74\u5750\u6807\u6bd4\u8f83 bool __cmpy ( const Node & a , const Node & b ) { return a . y < b . y ; } //\u4e8c\u7ef4kd\u6811\uff0c\u4f7f\u7528\u524d\u9700\u8981\u5148\u6574\u597dn\u548cs\u6570\u7ec4 struct Kdtree { Node s [ N ]; int n ; //s:\u70b9\uff08\u9700\u8981\u9884\u5148\u8bfb\u5165\uff09 //n\uff1a\u70b9\u7684\u4e2a\u6570\uff08\u9700\u8981\u9884\u5148\u8bfb\u5165\uff09 //\u5efa\u6811\u65f6\u7ef4\u62a4\u5b50\u6811 void __upd ( int p ) { s [ p ]. L = s [ p ]. R = s [ p ]. x ; s [ p ]. U = s [ p ]. D = s [ p ]. y ; if ( s [ p ]. lc ) { //\u6ce8\u610f\u8fd9\u91ccmin\u548cmax\u7684\u6b21\u5e8f s [ p ]. L = min ( s [ p ]. L , s [ s [ p ]. lc ]. L ); s [ p ]. R = max ( s [ p ]. R , s [ s [ p ]. lc ]. R ); s [ p ]. U = max ( s [ p ]. U , s [ s [ p ]. lc ]. U ); s [ p ]. D = min ( s [ p ]. D , s [ s [ p ]. lc ]. D ); } if ( s [ p ]. rc ) { s [ p ]. L = min ( s [ p ]. L , s [ s [ p ]. rc ]. L ); s [ p ]. R = max ( s [ p ]. R , s [ s [ p ]. rc ]. R ); s [ p ]. U = max ( s [ p ]. U , s [ s [ p ]. rc ]. U ); s [ p ]. D = min ( s [ p ]. D , s [ s [ p ]. rc ]. D ); } } //\u53d6\u5f97\u65b9\u5dee\u4ee5\u51b3\u5b9a\u5b50\u6811\u5212\u5206\u65b9\u5f0f bool __get_variance ( int l , int r ) { double sumx = 0 , sumy = 0 ; for ( int i = l ; i <= r ; i ++ ) { sumx += s [ i ]. x ; sumy += s [ i ]. y ; } sumx /= r - l + 1 ; sumy /= r - l + 1 ; double vx = 0 , vy = 0 ; for ( int i = l ; i <= r ; i ++ ) { // vx+=(s[i].x-sumx)*(s[i].x-sumx); vx += sqr ( s [ i ]. x - sumx ); // vy+=(s[i].y-sumy)*(s[i].y-sumy); vy += sqr ( s [ i ]. y - sumy ); } if ( vx >= vy ) return true ; return false ; } //\u5efa\u6811 int build ( int l , int r ) { if ( l > r ) return 0 ; if ( l == r ) { __upd ( l ); return l ; } int mid = ( l + r ) / 2 ; bool mark = __get_variance ( l , r ); if ( mark ) { nth_element ( s + l , s + mid , s + r + 1 , __cmpx ); s [ mid ]. d = 1 ; } else { nth_element ( s + l , s + mid , s + r + 1 , __cmpy ); s [ mid ]. d = 2 ; } s [ mid ]. lc = build ( l , mid -1 ); s [ mid ]. rc = build ( mid + 1 , r ); __upd ( mid ); return mid ; } //\u4e0b\u6807\u4e3ap\u7684\u70b9\u5230\u4e0b\u6807\u4e3ab\u7684\u70b9\u6240\u7ef4\u62a4\u7684\u77e9\u5f62\u7684\u8ddd\u79bb Ty __to_rectangle_dis ( int p , int b ) { Ty ans = 0 ; if ( s [ b ]. L > s [ p ]. x ) { // ans+=(s[b].L-s[p].x)*(s[b].L-s[p].x); ans += sqr ( s [ b ]. L - s [ p ]. x ); } if ( s [ b ]. R < s [ p ]. x ) { ans += sqr ( s [ b ]. R - s [ p ]. x ); } if ( s [ b ]. U < s [ p ]. y ) { ans += sqr ( s [ b ]. U - s [ p ]. y ); } if ( s [ b ]. D > s [ p ]. y ) { ans += sqr ( s [ b ]. D - s [ p ]. y ); } return ans ; } // \u8be2\u95ee\u4e0b\u6807\u4e3aindex\u7684\u70b9\u5230\u6811\u4e0a\u9664\u4e86\u81ea\u5df1\u5916\u6700\u8fd1\u70b9\u7684\u8ddd\u79bb void query ( int l , int r , int index , Ty & ans ) { if ( l > r ) { return ; } int mid = ( l + r ) / 2 ; if ( mid != index ) { ans = min ( ans , s [ mid ]. dis2 ( s [ index ])); } if ( l == r ) return ; Ty dis1 = __to_rectangle_dis ( index , s [ mid ]. lc ); Ty dis2 = __to_rectangle_dis ( index , s [ mid ]. rc ); if ( dis1 < dis2 ) { if ( dis1 < ans ) query ( l , mid -1 , index , ans ); if ( dis2 < ans ) query ( mid + 1 , r , index , ans ); } else { if ( dis2 < ans ) query ( mid + 1 , r , index , ans ); if ( dis1 < ans ) query ( l , mid -1 , index , ans ); } /* if(dis1<ans && dis2<ans) { if(dis1<dis2) { if(dis1<ans) query(l,mid-1,index,ans); if(dis2<ans) query(mid+1,r,index,ans); } else { if(dis2<ans) query(mid+1,r,index,ans); if(dis1<ans) query(l,mid-1,index,ans); } } else { if(dis1<ans) query(l,mid-1,index,ans); if(dis2<ans) query(mid+1,r,index,ans); }*/ } } kdt ; } using namespace KDTREE ; int main () { //ios::sync_with_stdio(false); //cin.tie(0),cout.tie(0); scanf ( \"%d\" , & kdt . n ); for ( int i = 1 ; i <= kdt . n ; i ++ ) { Ty x , y ; scanf ( \"%lld%lld\" , & x , & y ); kdt . s [ i ]. x = x ; kdt . s [ i ]. y = y ; } kdt . build ( 1 , kdt . n ); Ty ans = 5e18 ; for ( int i = 1 ; i <= kdt . n ; i ++ ) { kdt . query ( 1 , kdt . n , i , ans ); } printf ( \"%.4lf \\n \" , sqrt ( ans )); return 0 ; } Finding Hotels 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <cstdlib> #include <algorithm> #include <string> #include <vector> #include <map> #include <unordered_map> #include <set> #include <unordered_set> #include <queue> using namespace std ; typedef long long ll ; namespace KDTREE { typedef ll Ty ; const int N = 1e6 + 10 ; //\u5e73\u65b9 template < typename T > T sqr ( T x ) { return x * x ; } struct Node { Ty x , y ; Ty L , R , U , D ; int lc , rc ; int d ; //x,y:\u70b9\u7684\u5750\u6807 //LRUD\uff1a\u70b9\u6240\u7ba1\u8f96\u7684\u5b50\u6811\u7684\u6700\u5c0f\u77e9\u5f62\u8986\u76d6 //lc\uff0crc\uff1a\u5de6\u53f3\u5b69\u5b50 // d\uff1a\u8be5\u8282\u70b9\u5b50\u6811\u662f\u6309\u54ea\u4e00\u7ef4\u5212\u5206\u7684\uff0c1\u662f\u6309x\uff0c2\u6309y int c ; int cc ; int id ; //\u8ddd\u79bb\u7684\u5e73\u65b9 Ty dis2 ( const Node & b ) const { return sqr ( x - b . x ) + sqr ( y - b . y ); } }; //\u6309x\u8f74\u5750\u6807\u6bd4\u8f83 bool __cmpx ( const Node & a , const Node & b ) { return a . x < b . x ; } //\u6309y\u8f74\u5750\u6807\u6bd4\u8f83 bool __cmpy ( const Node & a , const Node & b ) { return a . y < b . y ; } //\u4e8c\u7ef4kd\u6811\uff0c\u4f7f\u7528\u524d\u9700\u8981\u5148\u6574\u597dn\u548cs\u6570\u7ec4 struct Kdtree { Node s [ N ]; int n ; //s:\u70b9\uff08\u9700\u8981\u9884\u5148\u8bfb\u5165\uff09 //n\uff1a\u70b9\u7684\u4e2a\u6570\uff08\u9700\u8981\u9884\u5148\u8bfb\u5165\uff09 //\u5efa\u6811\u65f6\u7ef4\u62a4\u5b50\u6811 void __upd ( int p ) { s [ p ]. L = s [ p ]. R = s [ p ]. x ; s [ p ]. U = s [ p ]. D = s [ p ]. y ; s [ p ]. cc = s [ p ]. c ; if ( s [ p ]. lc ) { //\u6ce8\u610f\u8fd9\u91ccmin\u548cmax\u7684\u6b21\u5e8f s [ p ]. L = min ( s [ p ]. L , s [ s [ p ]. lc ]. L ); s [ p ]. R = max ( s [ p ]. R , s [ s [ p ]. lc ]. R ); s [ p ]. U = max ( s [ p ]. U , s [ s [ p ]. lc ]. U ); s [ p ]. D = min ( s [ p ]. D , s [ s [ p ]. lc ]. D ); s [ p ]. cc = min ( s [ p ]. cc , s [ s [ p ]. lc ]. cc ); } if ( s [ p ]. rc ) { s [ p ]. L = min ( s [ p ]. L , s [ s [ p ]. rc ]. L ); s [ p ]. R = max ( s [ p ]. R , s [ s [ p ]. rc ]. R ); s [ p ]. U = max ( s [ p ]. U , s [ s [ p ]. rc ]. U ); s [ p ]. D = min ( s [ p ]. D , s [ s [ p ]. rc ]. D ); s [ p ]. cc = min ( s [ p ]. cc , s [ s [ p ]. rc ]. cc ); } } //\u53d6\u5f97\u65b9\u5dee\u4ee5\u51b3\u5b9a\u5b50\u6811\u5212\u5206\u65b9\u5f0f bool __get_variance ( int l , int r ) { double sumx = 0 , sumy = 0 ; for ( int i = l ; i <= r ; i ++ ) { sumx += s [ i ]. x ; sumy += s [ i ]. y ; } sumx /= r - l + 1 ; sumy /= r - l + 1 ; double vx = 0 , vy = 0 ; for ( int i = l ; i <= r ; i ++ ) { // vx+=(s[i].x-sumx)*(s[i].x-sumx); vx += sqr ( s [ i ]. x - sumx ); // vy+=(s[i].y-sumy)*(s[i].y-sumy); vy += sqr ( s [ i ]. y - sumy ); } if ( vx >= vy ) return true ; return false ; } //\u5efa\u6811 int build ( int l , int r , bool mark ) { if ( l > r ) return 0 ; if ( l == r ) { __upd ( l ); return l ; } int mid = ( l + r ) / 2 ; // bool mark=__get_variance(l,r); mark = __get_variance ( l , r ); if ( mark ) { nth_element ( s + l , s + mid , s + r + 1 , __cmpx ); s [ mid ]. d = 1 ; } else { nth_element ( s + l , s + mid , s + r + 1 , __cmpy ); s [ mid ]. d = 2 ; } s [ mid ]. lc = build ( l , mid -1 ,(( mark ) ? ( 0 ) : ( 1 ))); s [ mid ]. rc = build ( mid + 1 , r ,(( mark ) ? ( 0 ) : ( 1 ))); __upd ( mid ); return mid ; } Ty __to_rectangle_dis ( Node & nd , Node & b ) { Ty ans = 0 ; if ( b . L > nd . x ) { // ans+=(s[b].L-s[p].x)*(s[b].L-s[p].x); ans += sqr ( b . L - nd . x ); } if ( b . R < nd . x ) { ans += sqr ( b . R - nd . x ); } if ( b . U < nd . y ) { ans += sqr ( b . U - nd . y ); } if ( b . D > nd . y ) { ans += sqr ( b . D - nd . y ); } return ans ; } //\u4ee5\u70b9\u641c\u6700\u8fd1\u70b9 void query ( int l , int r , Node & nd , Ty & ans , Node & ans2 ) { if ( l > r ) return ; int mid = ( l + r ) / 2 ; if ( s [ mid ]. c <= nd . c ) { // ans=min(ans,nd.dis2(s[mid])); Ty dis = nd . dis2 ( s [ mid ]); if ( ans > dis ) { ans = dis ; ans2 = s [ mid ]; } else if ( ans == dis ) { if ( ans2 . id > s [ mid ]. id ) { ans = dis ; ans2 = s [ mid ]; } } } if ( l == r ) return ; //\u526a\u679d\u5224\u636e\u2026\u2026 Ty dis1 = __to_rectangle_dis ( nd , s [ s [ mid ]. lc ]); Ty dis2 = __to_rectangle_dis ( nd , s [ s [ mid ]. rc ]); //... if ( dis1 < dis2 ) { if ( dis1 <= ans && s [ s [ mid ]. lc ]. cc <= nd . c ) query ( l , mid -1 , nd , ans , ans2 ); if ( dis2 <= ans && s [ s [ mid ]. rc ]. cc <= nd . c ) query ( mid + 1 , r , nd , ans , ans2 ); } else { if ( dis2 <= ans && s [ s [ mid ]. rc ]. cc <= nd . c ) query ( mid + 1 , r , nd , ans , ans2 ); if ( dis1 <= ans && s [ s [ mid ]. lc ]. cc <= nd . c ) query ( l , mid -1 , nd , ans , ans2 ); } } } kdt ; } using namespace KDTREE ; int T ; int n1 , n2 ; int main () { scanf ( \"%d\" , & T ); while ( T -- ) { scanf ( \"%d\" , & n1 ); scanf ( \"%d\" , & n2 ); kdt . n = n1 ; for ( int i = 1 ; i <= n1 ; i ++ ) { kdt . s [ i ] = kdt . s [ 0 ]; int x , y , c ; scanf ( \"%d%d%d\" , & x , & y , & c ); kdt . s [ i ]. x = x ; kdt . s [ i ]. y = y ; kdt . s [ i ]. c = c ; kdt . s [ i ]. id = i ; } kdt . build ( 1 , kdt . n , 1 ); for ( int i = 1 ; i <= n2 ; i ++ ) { int x , y , c ; scanf ( \"%d%d%d\" , & x , & y , & c ); Node nd , ans2 ; ll ans = 1e18 ; nd . x = x ; nd . y = y ; nd . c = c ; kdt . query ( 1 , kdt . n , nd , ans , ans2 ); printf ( \"%lld %lld %d \\n \" , ans2 . x , ans2 . y , ans2 . c ); } } return 0 ; }","title":"KDTree\uff08\u4e8c\u7ef4\uff09"},{"location":"old/%E8%87%AA%E5%88%B6Template/#_33","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 // CF600E Lomsat gelral //\u6811\u4e0a\u542f\u53d1\u5f0f\u5408\u5e76\u3002\u9898\u610f\u7ffb\u8bd1\uff1a\u6811\u7684\u8282\u70b9\u6709\u989c\u8272\uff0c\u4e00\u79cd\u989c\u8272\u5360\u9886\u4e86\u4e00\u4e2a\u5b50\u6811\uff0c\u5f53\u4e14\u4ec5\u5f53\u6ca1\u6709\u5176\u4ed6\u989c\u8272\u5728\u8fd9\u4e2a\u5b50\u6811\u4e2d\u51fa\u73b0\u5f97\u6bd4\u5b83\u591a\u3002\u6c42\u5360\u9886\u6bcf\u4e2a\u5b50\u6811\u7684\u6240\u6709\u989c\u8272\u4e4b\u548c\u3002 #include <iostream> #include <cstdio> #include <cstring> #include <memory.h> #include <algorithm> #include <map> #include <vector> #include <queue> #include <cmath> using namespace std ; typedef long long ll ; const int N = 2e5 + 10 ; int n ; struct E { int to , inext ; } edge [ N * 2 ]; struct NODE { int sz , color , heavy_son ; //\u5b50\u6811\u5927\u5c0f\uff0c\u70b9\u7684\u989c\u8272\uff0c\u91cd\u513f\u5b50 } node [ N ]; int head [ N ], total ; void adde ( int x , int y ) { edge [ ++ total ]. to = y ; edge [ total ]. inext = head [ x ]; head [ x ] = total ; } namespace dsu_on_tree { int cnt [ N ]; ll sum = 0 , maxval = -1 ; //sum\uff0cmaxval\uff1a\u5f71\u54cd\u90e8\u5206\uff0csum\u8868\u793a\u6570\u91cf\u6700\u591a\u7684\u90a3\u4e2a\u989c\u8272\u7684\u4e2a\u6570\uff0cmaxval\u8868\u793a\u6570\u91cf\u6700\u591a\u7684\u90a3\u4e2a\u989c\u8272\u7684\u6807\u53f7 ll ans [ N ]; //\u7b54\u6848\u90e8\u5206\uff1a\u6bcf\u4e2a\u70b9\u7684\u7b54\u6848\u4fdd\u5b58\u5728\u6b64 //\u7edf\u8ba1\u67d0\u4e2a\u5b50\u6811\u4e0b\uff08\u9664\u4e86heavy_son\u7684\u5b50\u6811\u56e0\u4e3a\u5df2\u7ecf\u7edf\u8ba1\u8fc7\u4e86\uff09\u5bf9\u7b54\u6848\u9020\u6210\u7684\u5f71\u54cd void addans ( int x , int fa , int heavy_son , int val ) { //\u66b4\u529b\u600e\u4e48\u5199\u4e0b\u9762\u5c31\u600e\u4e48\u5199 cnt [ node [ x ]. color ] += val ; if ( cnt [ node [ x ]. color ] > maxval ) { maxval = cnt [ node [ x ]. color ]; sum = node [ x ]. color ; } else if ( cnt [ node [ x ]. color ] == maxval ) sum += ( ll ) node [ x ]. color ; for ( int e = head [ x ]; e ; e = edge [ e ]. inext ) { int y = edge [ e ]. to ; if ( y == fa || y == heavy_son ) continue ; addans ( y , x , heavy_son , val ); } } //\u7b2c\u4e00\u6b21\u904d\u5386\uff0c\u5f97\u5230\u5b50\u6811size\u548cheavy_son void dfs ( int x , int fa ) { node [ x ]. sz = 1 ; node [ x ]. heavy_son = 0 ; int maxsz = 0 ; for ( int e = head [ x ]; e ; e = edge [ e ]. inext ) { int y = edge [ e ]. to ; if ( y == fa ) continue ; dfs ( y , x ); node [ x ]. sz += node [ y ]. sz ; if ( node [ y ]. sz > maxsz ) { maxsz = node [ y ]. sz ; node [ x ]. heavy_son = y ; } } } //\u7b2c\u4e8c\u6b21\u904d\u5386\uff0c\u7edf\u8ba1\u7b54\u6848 void dfs2 ( int x , int fa , bool sv ) //sv:\u662f\u5426\u4fdd\u7559 { //\u8f7b\u513f\u5b50\uff08\u9012\u5f52\uff09 for ( int e = head [ x ]; e ; e = edge [ e ]. inext ) { int y = edge [ e ]. to ; if ( y == fa || y == node [ x ]. heavy_son ) continue ; //\u8df3\u8fc7\u7236\u4eb2\u548c\u91cd\u513f\u5b50 dfs2 ( y , x , 0 ); } //\u91cd\u513f\u5b50\uff08\u9012\u5f52\uff09 if ( node [ x ]. heavy_son ) { dfs2 ( node [ x ]. heavy_son , x , 1 ); } //\u8f7b\u513f\u5b50\uff08\u66b4\u529b\uff09 addans ( x , fa , node [ x ]. heavy_son , 1 ); ans [ x ] = sum ; //update ans if ( sv == 0 ) //\u64a4\u9500\u5b50\u6811\u4e0b\u7684\u6240\u6709\u5f71\u54cd { addans ( x , fa , 0 , -1 ); sum = 0 ; maxval = -1 ; } } } // namespace dsu_on_tree using namespace dsu_on_tree ; int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> node [ i ]. color ; } for ( int i = 1 ; i <= n - 1 ; i ++ ) { int x , y ; cin >> x >> y ; adde ( x , y ); adde ( y , x ); } dfs ( 1 , 0 ); //root is 1, predo:heavy_son dfs2 ( 1 , 0 , 0 ); for ( int i = 1 ; i <= n ; i ++ ) { cout << ans [ i ] << \" \" ; } return 0 ; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 /** * 2021\u725b\u5ba2\u591a\u68219 E Eyjafjalla \u9898\u610f\uff1a\u7ed9\u5b9a\u4e00\u4e2a\u4ee5 1 \u4e3a\u6839\u7684\u6709\u6839\u6811\uff0c\u5b69\u5b50\u7684\u70b9\u6743\u5c0f\u4e8e\u7236\u4eb2\u7684\u70b9\u6743\u3002\u591a\u6b21\u8be2\u95ee\uff0c\u6bcf\u6b21\u8be2\u95ee\u5305\u542b x \u8282\u70b9\u7684\u6743\u503c\u8303\u56f4\u4e3a [l, r] \u7684\u6781\u5927\u8fde\u901a\u7684\u5927\u5c0f\u3002 \u505a\u6cd5\uff1a\u79bb\u7ebf\u7136\u540e\u79bb\u6563\u5316\uff0c\u4e4b\u540e\u7528\u4e2a\u6811\u72b6\u6570\u7ec4\u7edf\u8ba1\u6bcf\u4e2a\u8be2\u95ee\u5728\u5b50\u6811\u4e2d\u7684\u7b54\u6848\u3002 **/ #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <cstdlib> #include <algorithm> #include <string> #include <vector> #include <map> #include <unordered_map> #include <set> #include <unordered_set> #include <queue> using namespace std ; typedef long long ll ; const int N = 2e5 + 10 ; namespace BIT { const int MAXN = 4e5 + 10 ; template < typename Ty > struct Bit { //local Ty t [ MAXN ]; int __lowbit ( int x ) { return x & ( - x ); } void add ( int pos , Ty val = 1 ) { while ( pos < MAXN ) { t [ pos ] += val ; pos += __lowbit ( pos ); } } Ty ask ( int pos ) { Ty ans = 0 ; while ( pos >= 1 ) { ans += t [ pos ]; pos -= __lowbit ( pos ); } return ans ; } }; } using namespace BIT ; Bit < int > bit ; //... int n ; int w [ N ]; int ww [ N * 2 ], ww_p ; unordered_map < int , int > mp ; struct Q { int x , l , r ; int ans ; } query [ N ]; int q ; struct E { int to , inext ; } edge [ N * 2 ]; int head [ N ], total ; int f [ N ][ 30 ]; int vis [ N ]; struct Node { vector < int > qid ; int sz ; int heavy_son ; } node [ N ]; //... void adde ( int x , int y ) { edge [ ++ total ]. to = y ; edge [ total ]. inext = head [ x ]; head [ x ] = total ; } int upb ; //bfs\uff0c\u4f7f\u5f97\u80fd\u6811\u4e0a\u500d\u589e void predo ( int rt = 1 ) { queue < int > q ; q . push ( rt ); vis [ rt ] = 1 ; while ( q . size ()) { int x = q . front (); q . pop (); for ( int e = head [ x ]; e ; e = edge [ e ]. inext ) { int y = edge [ e ]. to ; if ( vis [ y ] == 0 ) { vis [ y ] = vis [ x ] + 1 ; f [ y ][ 0 ] = x ; for ( int k = 1 ; k <= upb ; k ++ ) { f [ y ][ k ] = f [ f [ y ][ k -1 ]][ k -1 ]; } q . push ( y ); } } } } //\u9884\u5904\u7406\u79bb\u7ebf\u7b54\u6848 void predo2 ( int i ) { int x = query [ i ]. x ; int r = query [ i ]. r ; int l = query [ i ]. l ; // int tmpans=x; if ( l <= w [ x ] && w [ x ] <= r ) { for ( int k = upb ; k >= 0 ; k -- ) { if ( f [ x ][ k ] != 0 && w [ f [ x ][ k ]] <= r ) { x = f [ x ][ k ]; } } node [ x ]. qid . emplace_back ( i ); } else { query [ i ]. ans = 0 ; } } //dsu on tree void dfs1 ( int x , int fa ) { node [ x ]. sz = 1 ; node [ x ]. heavy_son = 0 ; int maxsz = 0 ; for ( int e = head [ x ]; e ; e = edge [ e ]. inext ) { int y = edge [ e ]. to ; if ( y == fa ) continue ; dfs1 ( y , x ); node [ x ]. sz += node [ y ]. sz ; if ( node [ y ]. sz > maxsz ) { maxsz = node [ y ]. sz ; node [ x ]. heavy_son = y ; } } } void addans ( int x , int fa , int heavy_son , int val = 1 ) { bit . add ( mp [ w [ x ]], val ); for ( int e = head [ x ]; e ; e = edge [ e ]. inext ) { int y = edge [ e ]. to ; if ( y == fa || y == heavy_son ) continue ; addans ( y , x , heavy_son , val ); } } //dsu on tree\uff0c\u6811\u4e0a\u542f\u53d1\u5f0f void dfs2 ( int x , int fa , bool sv ) { for ( int e = head [ x ]; e ; e = edge [ e ]. inext ) { int y = edge [ e ]. to ; if ( y == fa || y == node [ x ]. heavy_son ) continue ; dfs2 ( y , x , 0 ); } if ( node [ x ]. heavy_son ) { dfs2 ( node [ x ]. heavy_son , x , 1 ); } addans ( x , fa , node [ x ]. heavy_son , 1 ); //getans for ( auto v : node [ x ]. qid ) { int l = query [ v ]. l ; query [ v ]. ans = node [ x ]. sz - bit . ask ( mp [ l ] -1 ); } if ( sv == 0 ) { addans ( x , fa , 0 , -1 ); //\u91cd\u8981\uff1a\u5220\u9664\u5b50\u6811\u5f71\u54cd\u7684heavy_son\u4e00\u5b9a\u8981\u662f0\uff0c\u4e0d\u80fd\u548c\u4e4b\u524d\u90a3\u4e2a\u7528addans\u7684\u4e00\u6837 } } int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ), cout . tie ( 0 ); cin >> n ; upb = log2 ( n ) + 1 ; for ( int i = 1 ; i <= n -1 ; i ++ ) { int x , y ; cin >> x >> y ; adde ( x , y ); adde ( y , x ); } for ( int i = 1 ; i <= n ; i ++ ) { cin >> w [ i ]; ww [ ++ ww_p ] = w [ i ]; } cin >> q ; for ( int i = 1 ; i <= q ; i ++ ) { cin >> query [ i ]. x ; cin >> query [ i ]. l ; cin >> query [ i ]. r ; ww [ ++ ww_p ] = query [ i ]. l ; ww [ ++ ww_p ] = query [ i ]. r ; } sort ( ww + 1 , ww + 1 + ww_p ); for ( int i = 1 ; i <= ww_p ; i ++ ) { mp [ ww [ i ]] = i ; } //bfs predo (); //\u9884\u5904\u7406\u79bb\u7ebf\u7b54\u6848 for ( int i = 1 ; i <= q ; i ++ ) { predo2 ( i ); } dfs1 ( 1 , 0 ); dfs2 ( 1 , 0 , 0 ); for ( int i = 1 ; i <= q ; i ++ ) { cout << query [ i ]. ans << '\\n' ; } return 0 ; }","title":"\u6811\u4e0a\u542f\u53d1\u5f0f\u5408\u5e76"},{"location":"old/%E8%87%AA%E5%88%B6Template/#splay","text":"\uff08\u9644\u8a3b\uff1a\u53ef\u80fd\u9019\u500b\u7248\u672c\u7684Splay\u6709\u9ede\u554f\u984c\uff0c\u5230\u6642\u5019\u5f97\u63db\u6389\uff09\uff08\u5c1a\u672a\u6574\u7406\uff09","title":"\u2b50Splay \u4f38\u5c55\u6a39"},{"location":"old/%E8%87%AA%E5%88%B6Template/#_34","text":"\u60a8\u9700\u8981\u5199\u4e00\u79cd\u6570\u636e\u7ed3\u6784\uff08\u53ef\u53c2\u8003\u9898\u76ee\u6807\u9898\uff09\uff0c\u6765\u7ef4\u62a4\u4e00\u4e9b\u6570\uff0c\u5176\u4e2d\u9700\u8981\u63d0\u4f9b\u4ee5\u4e0b\u64cd\u4f5c\uff1a \u63d2\u5165 xx \u6570 \u5220\u9664 xx \u6570(\u82e5\u6709\u591a\u4e2a\u76f8\u540c\u7684\u6570\uff0c\u56e0\u53ea\u5220\u9664\u4e00\u4e2a) \u67e5\u8be2 xx \u6570\u7684\u6392\u540d(\u6392\u540d\u5b9a\u4e49\u4e3a\u6bd4\u5f53\u524d\u6570\u5c0f\u7684\u6570\u7684\u4e2a\u6570 +1+1 ) \u67e5\u8be2\u6392\u540d\u4e3a xx \u7684\u6570 \u6c42 xx \u7684\u524d\u9a71(\u524d\u9a71\u5b9a\u4e49\u4e3a\u5c0f\u4e8e xx\uff0c\u4e14\u6700\u5927\u7684\u6570) \u6c42 xx \u7684\u540e\u7ee7(\u540e\u7ee7\u5b9a\u4e49\u4e3a\u5927\u4e8e xx\uff0c\u4e14\u6700\u5c0f\u7684\u6570) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 #include <iostream> #include <memory.h> using namespace std ; namespace SPLAY { const int N = 114514 ; using Ty = int ; const Ty Inf = 1 << 30 ; //Inf\uff1a\u8bb0\u5f97longlong\u7684\u8bdd\u8981\u6539\u8fd9\u91cc\uff01 //\u6ce8\u610f\uff1aInf\u4e0d\u5e94\u8be5\u4e0e\u4efb\u4f55\u53ef\u80fd\u7684\u503c\u76f8\u7b49\uff0c\u5426\u5219\u4f60\u9700\u8981\u8003\u8651\u522b\u7684\u65b9\u5f0f struct Splay { struct Node { int fa , ch [ 2 ]; Ty val ; //val\uff1a\u8981\u7ef4\u62a4\u7684\u503c Ty cnt , size ; //cnt\u3001size\uff1a\u56fa\u5b9a\uff0c\u6bcf\u4e2a\u8282\u70b9\u7684\u4e2a\u6570\u548c\u5b50\u6811\u5927\u5c0f } t [ N ]; //root:\u6839\u8282\u70b9\u4e0b\u6807 //total:\u603b\u8282\u70b9\u6570 int root , total ; //\u66f4\u65b0\u8282\u70b9p\u7684\u4fe1\u606f void __upd ( int p ) { if ( p == 0 ) return ; t [ p ]. size = t [ t [ p ]. ch [ 0 ]]. size + t [ t [ p ]. ch [ 1 ]]. size + t [ p ]. cnt ; } //\u5224\u65adp\u662f\u5426\u662f\u5728\u53f3\u513f\u5b50\u4f4d\u7f6e judge whether p is father's R-child bool __get ( int p ) { return p == t [ t [ p ]. fa ]. ch [ 1 ]; } //\u5728\u5185\u5b58\u8282\u70b9\u6c60\u4e2d\u5206\u914d\u4e00\u4e2a\u65b0\u7684\u503c\uff0c\u5e76\u8fd4\u56de\u5b83\u7684\u4e0b\u6807 int __add ( Ty val ) { t [ ++ total ]. val = val ; t [ total ]. cnt = t [ total ]. size = 1 ; t [ total ]. fa = 0 ; t [ total ]. ch [ 0 ] = t [ total ]. ch [ 1 ] = 0 ; return total ; } void init () { root = 1 ; total = 0 ; __add ( - Inf ); //1 __add ( Inf ); //2 t [ 1 ]. ch [ 1 ] = 2 ; t [ 2 ]. fa = 1 ; __upd ( root ); } //zip or zap (depending on [whether p is father's R-child]) void __rotate ( int p ) { // z->y->p int y = t [ p ]. fa , z = t [ y ]. fa , chk = __get ( p ); //!!!You must use previous version Get(p) if ( y == 0 || p == 0 ) return ; // Modify p's R(L)Child as y's L(R)Child t [ y ]. ch [ chk ] = t [ p ]. ch [ chk ^ 1 ]; if ( t [ p ]. ch [ chk ^ 1 ]) t [ t [ p ]. ch [ chk ^ 1 ]]. fa = y ; // Then change p's Child t [ p ]. ch [ chk ^ 1 ] = y ; t [ y ]. fa = p ; // Finally change p's father as z (which was y's father) t [ p ]. fa = z ; if ( z ) t [ z ]. ch [ y == t [ z ]. ch [ 1 ]] = p ; __upd ( y ); __upd ( p ); } //\u4f38\u5c55\u64cd\u4f5c : // \u5982\u679c p \u7684\u7236\u4eb2\u662f\u6839\u8282\u70b9\uff0c\u76f4\u63a5\u5c06 p \u5de6\u65cb\u6216\u53f3\u65cb // \u5982\u679c p \u7684\u7236\u4eb2\u4e0d\u662f\u6839\u8282\u70b9\uff0c\u4e14 p \u548c\u7236\u4eb2\u7684\u513f\u5b50\u7c7b\u578b\u76f8\u540c\uff0c\u9996\u5148\u5c06\u5176\u7236\u4eb2\u5de6\u65cb\u6216\u53f3\u65cb\uff0c\u7136\u540e\u5c06 p \u53f3\u65cb\u6216\u5de6\u65cb // \u5982\u679c p \u7684\u7236\u4eb2\u4e0d\u662f\u6839\u8282\u70b9\uff0c\u4e14 p \u548c\u7236\u4eb2\u7684\u513f\u5b50\u7c7b\u578b\u4e0d\u540c\uff0c\u5c06 p \u5de6\u65cb\u518d\u53f3\u65cb\u3001\u6216\u8005\u53f3\u65cb\u518d\u5de6\u65cb void __splay ( int p ) { for ( int f = t [ p ]. fa ; f = t [ p ]. fa ; __rotate ( p )) { if ( t [ f ]. fa ) __rotate ( __get ( p ) == __get ( f ) ? f : p ); //Case 3,4:(p,y,z at the same line) | 5,6:(else) } root = p ; } //\u63d2\u5165\u4e00\u4e2a\u503c\u4e3aval\u7684\u5143\u7d20 void insert ( Ty val ) { if ( root == 0 ) { root = __add ( val ); __upd ( root ); return ; } int p = root , f = 0 ; while ( true ) { if ( t [ p ]. val == val ) { t [ p ]. cnt ++ ; __upd ( p ); __upd ( f ); __splay ( p ); return ; } f = p ; //f!=0; p = t [ p ]. ch [ t [ p ]. val < val ]; if ( ! p ) //Child does not exist { t [ f ]. ch [ t [ f ]. val < val ] = __add ( val ); t [ total ]. fa = f ; __upd ( total ); __upd ( f ); __splay ( total ); return ; } } } //\u53d6\u5f97>=val\u7684\u8282\u70b9\u6700\u5c0f\u6392\u540d\uff08\u4ece1\u8ba1\u6570\uff09\u548c\u4e0b\u6807\uff0c\u76f8\u5f53\u4e8elower_bound //\u6ce8\u610f\u8fd9\u51e0\u4e2a\u64cd\u4f5c\u4f1a\u7acb\u5373\u4f7f\u5f97\u88ab\u627e\u5230\u7684\u8282\u70b9\u88absplay\u5230\u6839\u8282\u70b9\uff0c\u4e0d\u8fc7\u4e0b\u6807\u4ecd\u7136\u662f\u6709\u6548\u7684 pair < Ty , int > get_rank_by_val ( Ty val ) { int p = root ; if ( p == 0 ) return { t [ root ]. size + 1 , -1 }; int sum = 0 ; //\u5f53\u524d < val \u7684\u8282\u70b9cnt\u4e4b\u548c int ans = t [ root ]. size + 1 ; //ans:\u5f53\u524d\u6700\u597d\u6392\u540d int cur = -1 ; //cur\uff1a\u5f53\u524d\u7b54\u6848\u7684\u4e0b\u6807 while ( p ) { if ( t [ p ]. val < val ) // < { sum += t [ p ]. cnt ; if ( t [ p ]. ch [ 0 ]) sum += t [ t [ p ]. ch [ 0 ]]. size ; p = t [ p ]. ch [ 1 ]; } else // >= { int tmpans = sum + 1 + (( t [ p ]. ch [ 0 ]) ? ( t [ t [ p ]. ch [ 0 ]]. size ) : ( 0 )); if ( tmpans < ans ) { ans = tmpans ; cur = p ; } p = t [ p ]. ch [ 0 ]; } } // *\u5982\u679c\u4e0d\u9009\u62e9\u5728init\u65f6\u63d2\u5165\u4e24\u4e2a\u521d\u59cb\u65e0\u7a77\u5927\u503c\uff0c\u5219\u8bf7\u5728\u8fd9\u91cc\u79fb\u9664\u8fd9\u6bb5\u4ee3\u7801 ans -= 1 ; // *\u79fb\u9664\u4ee3\u7801\u6bb5\u7ed3\u675f if ( cur != -1 ) __splay ( cur ); return { ans , cur }; } //\u6839\u636e\u6392\u540d\uff08\u4ece1\u5f00\u59cb\uff09\u53d6\u5f97\u503c\u548c\u4e0b\u6807 //\u6ce8\u610f\u8fd9\u51e0\u4e2a\u64cd\u4f5c\u4f1a\u7acb\u5373\u4f7f\u5f97\u88ab\u627e\u5230\u7684\u8282\u70b9\u88absplay\u5230\u6839\u8282\u70b9\uff0c\u4e0d\u8fc7\u4e0b\u6807\u4ecd\u7136\u662f\u6709\u6548\u7684 pair < Ty , int > get_val_by_rank ( int rank ) { // *\u5982\u679c\u4e0d\u9009\u62e9\u5728init\u65f6\u63d2\u5165\u4e24\u4e2a\u521d\u59cb\u65e0\u7a77\u5927\u503c\uff0c\u5219\u8bf7\u5728\u8fd9\u91cc\u79fb\u9664\u8fd9\u6bb5\u4ee3\u7801 rank += 1 ; // *\u79fb\u9664\u4ee3\u7801\u6bb5\u7ed3\u675f int p = root ; while ( true ) { if ( t [ p ]. ch [ 0 ] && t [ t [ p ]. ch [ 0 ]]. size >= rank ) { p = t [ p ]. ch [ 0 ]; } else { rank -= t [ p ]. cnt + t [ t [ p ]. ch [ 0 ]]. size ; if ( rank <= 0 ) { __splay ( p ); return { t [ p ]. val , p }; } p = t [ p ]. ch [ 1 ]; } } } //\u6839\u636eval\u7684\u503c\uff0c\u5bfb\u627e\u5bf9\u5e94\u8282\u70b9\u7684\u540e\u7ee7\uff0c\u8fd4\u56de\u8282\u70b9\u4e0b\u6807 //\u6ce8\u610f\uff1a1.\u4e00\u5b9a\u8981\u4fdd\u8bc1\u8282\u70b9\u5b58\u5728\uff0c 2.\u4e00\u5b9a\u8981\u4fdd\u8bc1\u6811\u4e2d\u6709\u65e0\u7a77\u5c0f\u548c\u65e0\u7a77\u5927\u4e24\u4e2a\u8282\u70b9\uff0c\u4e14\u4e0b\u6807\u5206\u522b\u662f1\u30012 int get_next_index ( Ty val ) { int ans = 2 , p = root ; //t[ans].val== Inf (INIT) while ( p ) { if ( val == t [ p ]. val ) //search success { if ( t [ p ]. ch [ 1 ]) { p = t [ p ]. ch [ 1 ]; while ( t [ p ]. ch [ 0 ]) p = t [ p ]. ch [ 0 ]; ans = p ; } break ; } //else update ans using path if ( t [ p ]. val > val && t [ p ]. val < t [ ans ]. val ) ans = p ; p = ( t [ p ]. val < val ) ? t [ p ]. ch [ 1 ] : t [ p ]. ch [ 0 ]; } return ans ; //Notice that return value is subscript } //\u6839\u636eval\u7684\u503c\uff0c\u5bfb\u627e\u5bf9\u5e94\u8282\u70b9\u7684\u524d\u9a71\uff0c\u8fd4\u56de\u8282\u70b9\u4e0b\u6807 //\u6ce8\u610f\uff1a1.\u4e00\u5b9a\u8981\u4fdd\u8bc1\u8282\u70b9\u5b58\u5728\uff0c 2.\u4e00\u5b9a\u8981\u4fdd\u8bc1\u6811\u4e2d\u6709\u65e0\u7a77\u5c0f\u548c\u65e0\u7a77\u5927\u4e24\u4e2a\u8282\u70b9\uff0c\u4e14\u4e0b\u6807\u5206\u522b\u662f1\u30012 int get_pre_index ( Ty val ) { int ans = 1 , p = root ; //t[ans].val== -Inf (INIT) while ( p ) { if ( val == t [ p ]. val ) //search success { if ( t [ p ]. ch [ 0 ]) { p = t [ p ]. ch [ 0 ]; while ( t [ p ]. ch [ 1 ]) p = t [ p ]. ch [ 1 ]; ans = p ; } break ; } //else update ans using path if ( t [ p ]. val < val && t [ p ]. val > t [ ans ]. val ) ans = p ; p = ( t [ p ]. val < val ) ? t [ p ]. ch [ 1 ] : t [ p ]. ch [ 0 ]; } return ans ; //Notice that return value is subscript } //\u6839\u636eval\u5220\u53bb\u8282\u70b9\uff1a\u5148\u901a\u8fc7lower_bound\u627e\u5230\u7b2c\u4e00\u4e2a\u7b49\u4e8eval\u7684\u8282\u70b9\uff0c\u628a\u4ed6splay\u5230\u6839\uff0c\u7136\u540e\u5220\u9664\u4e4b //\u6ce8\u610f\uff1a\u6811\u4e2d\u4e00\u5b9a\u8981\u6709\u7b49\u4e8eval\u503c\u7684\u8282\u70b9\uff01 void del ( Ty val ) { if ( get_rank_by_val ( val ). second == -1 ) return ; if ( t [ root ]. cnt > 1 ) { t [ root ]. cnt -- ; __upd ( root ); return ; } int p = root ; int q = get_pre_index ( val ); __splay ( q ); t [ t [ p ]. ch [ 1 ]]. fa = q ; t [ q ]. ch [ 1 ] = t [ p ]. ch [ 1 ]; } } splay_tree ; } int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); SPLAY :: splay_tree . init (); int n ; cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) { int op , x ; cin >> op >> x ; if ( op == 1 ) SPLAY :: splay_tree . insert ( x ); else if ( op == 2 ) SPLAY :: splay_tree . del ( x ); else if ( op == 3 ) cout << SPLAY :: splay_tree . get_rank_by_val ( x ). first << endl ; else if ( op == 4 ) cout << SPLAY :: splay_tree . get_val_by_rank ( x ). first << endl ; else if ( op == 5 ) cout << SPLAY :: splay_tree . t [ SPLAY :: splay_tree . get_pre_index ( x )]. val << endl ; else cout << SPLAY :: splay_tree . t [ SPLAY :: splay_tree . get_next_index ( x )]. val << endl ; } return 0 ; } /* \u65e7\u7684\u64cd\u4f5c int Get_Rank_By_Val(int x) { int ans=0,p=root; while (true) { if(x<t[p].val) { p=t[p].ch[0]; } else { ans+=t[t[p].ch[0]].size; if(x==t[p].val) { Splay(p); return ans+1; } ans+=t[p].cnt; p=t[p].ch[1]; } } } */","title":"\u666e\u901a\u5e73\u8861\u6811"},{"location":"old/%E8%87%AA%E5%88%B6Template/#_35","text":"\u60a8\u9700\u8981\u5199\u4e00\u79cd\u6570\u636e\u7ed3\u6784\uff08\u53ef\u53c2\u8003\u9898\u76ee\u6807\u9898\uff09\uff0c\u6765\u7ef4\u62a4\u4e00\u4e2a\u6709\u5e8f\u6570\u5217\u3002 \u5176\u4e2d\u9700\u8981\u63d0\u4f9b\u4ee5\u4e0b\u64cd\u4f5c\uff1a\u7ffb\u8f6c\u4e00\u4e2a\u533a\u95f4\uff0c\u4f8b\u5982\u539f\u6709\u5e8f\u5e8f\u5217\u662f 5 4 3 2 1\uff0c\u7ffb\u8f6c\u533a\u95f4\u662f [2,4][2,4] \u7684\u8bdd\uff0c\u7ed3\u679c\u662f 5 2 3 4 1\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 #include <iostream> using namespace std ; const int N = 114514 ; namespace SPLAY { const int N = 114514 ; using Ty = int ; const Ty Inf = 1 << 30 ; //Inf\uff1a\u8bb0\u5f97longlong\u7684\u8bdd\u8981\u6539\u8fd9\u91cc\uff01 //\u6ce8\u610f\uff1aInf\u4e0d\u5e94\u8be5\u4e0e\u4efb\u4f55\u53ef\u80fd\u7684\u503c\u76f8\u7b49\uff0c\u5426\u5219\u4f60\u9700\u8981\u8003\u8651\u522b\u7684\u65b9\u5f0f struct Splay { struct Node { int fa , ch [ 2 ]; Ty val ; //val\uff1a\u8981\u7ef4\u62a4\u7684\u503c Ty cnt , size ; //cnt\u3001size\uff1a\u56fa\u5b9a\uff0c\u6bcf\u4e2a\u8282\u70b9\u7684\u4e2a\u6570\u548c\u5b50\u6811\u5927\u5c0f int T ; //T:\u53cd\u8f6c\u6807\u8bb0 } t [ N ]; //root:\u6839\u8282\u70b9\u4e0b\u6807 //total:\u603b\u8282\u70b9\u6570 int root , total ; //\u66f4\u65b0\u8282\u70b9p\u7684\u4fe1\u606f void __upd ( int p ) { if ( p == 0 ) return ; t [ p ]. size = t [ t [ p ]. ch [ 0 ]]. size + t [ t [ p ]. ch [ 1 ]]. size + t [ p ]. cnt ; } //\u5224\u65adp\u662f\u5426\u662f\u5728\u53f3\u513f\u5b50\u4f4d\u7f6e judge whether p is father's R-child bool __get ( int p ) { return p == t [ t [ p ]. fa ]. ch [ 1 ]; } //\u5728\u5185\u5b58\u8282\u70b9\u6c60\u4e2d\u5206\u914d\u4e00\u4e2a\u65b0\u7684\u503c\uff0c\u5e76\u8fd4\u56de\u5b83\u7684\u4e0b\u6807 int __add ( Ty val ) { t [ ++ total ]. val = val ; t [ total ]. cnt = t [ total ]. size = 1 ; t [ total ]. fa = 0 ; t [ total ]. ch [ 0 ] = t [ total ]. ch [ 1 ] = 0 ; t [ total ]. T = 0 ; return total ; } void init () { root = 1 ; total = 0 ; __add ( - Inf ); //1 __add ( Inf ); //2 t [ 1 ]. ch [ 1 ] = 2 ; t [ 2 ]. fa = 1 ; __upd ( root ); } //\u4e0b\u4f20\u53cd\u8f6c\u6807\u8bb0 void __spread ( int p ) { if ( t [ p ]. T ) { swap ( t [ t [ p ]. ch [ 0 ]]. ch [ 0 ], t [ t [ p ]. ch [ 0 ]]. ch [ 1 ]); //LChild swap ( t [ t [ p ]. ch [ 1 ]]. ch [ 0 ], t [ t [ p ]. ch [ 1 ]]. ch [ 1 ]); //RChild t [ t [ p ]. ch [ 0 ]]. T ^= 1 ; t [ t [ p ]. ch [ 1 ]]. T ^= 1 ; t [ p ]. T = 0 ; } } //zip or zap (depending on [whether p is father's R-child]) void __rotate ( int p ) { __spread ( p ); // z->y->p int y = t [ p ]. fa , z = t [ y ]. fa , chk = __get ( p ); //!!!You must use previous version Get(p) if ( y == 0 || p == 0 ) return ; // Modify p's R(L)Child as y's L(R)Child t [ y ]. ch [ chk ] = t [ p ]. ch [ chk ^ 1 ]; if ( t [ p ]. ch [ chk ^ 1 ]) t [ t [ p ]. ch [ chk ^ 1 ]]. fa = y ; // Then change p's Child t [ p ]. ch [ chk ^ 1 ] = y ; t [ y ]. fa = p ; // Finally change p's father as z (which was y's father) t [ p ]. fa = z ; if ( z ) t [ z ]. ch [ y == t [ z ]. ch [ 1 ]] = p ; __upd ( y ); __upd ( p ); } //\u4f38\u5c55\u64cd\u4f5c : // \u5982\u679c p \u7684\u7236\u4eb2\u662f\u6839\u8282\u70b9\uff0c\u76f4\u63a5\u5c06 p \u5de6\u65cb\u6216\u53f3\u65cb // \u5982\u679c p \u7684\u7236\u4eb2\u4e0d\u662f\u6839\u8282\u70b9\uff0c\u4e14 p \u548c\u7236\u4eb2\u7684\u513f\u5b50\u7c7b\u578b\u76f8\u540c\uff0c\u9996\u5148\u5c06\u5176\u7236\u4eb2\u5de6\u65cb\u6216\u53f3\u65cb\uff0c\u7136\u540e\u5c06 p \u53f3\u65cb\u6216\u5de6\u65cb // \u5982\u679c p \u7684\u7236\u4eb2\u4e0d\u662f\u6839\u8282\u70b9\uff0c\u4e14 p \u548c\u7236\u4eb2\u7684\u513f\u5b50\u7c7b\u578b\u4e0d\u540c\uff0c\u5c06 p \u5de6\u65cb\u518d\u53f3\u65cb\u3001\u6216\u8005\u53f3\u65cb\u518d\u5de6\u65cb void __splay ( int p ) { __spread ( p ); for ( int f = t [ p ]. fa ; f = t [ p ]. fa ; __rotate ( p )) { if ( t [ f ]. fa ) __rotate ( __get ( p ) == __get ( f ) ? f : p ); //Case 3,4:(p,y,z at the same line) | 5,6:(else) } root = p ; } //\u5c06p\u4e0d\u65ad\u65cb\u8f6c\u5230\u6839\u524d\u4e3a\u6b62 void __splay2 ( int p ) { __spread ( p ); for ( int f = t [ p ]. fa ; f = t [ p ]. fa , f != root ; __rotate ( p )) { if ( t [ f ]. fa != root ) __rotate ( __get ( p ) == __get ( f ) ? f : p ); //Case 3,4:(p,y,z at the same line) | 5,6:(else) } } //\u63d2\u5165\u4e00\u4e2a\u503c\u4e3aval\u7684\u5143\u7d20 void insert ( Ty val ) { if ( root == 0 ) { root = __add ( val ); __upd ( root ); return ; } int p = root , f = 0 ; while ( true ) { if ( t [ p ]. val == val ) { t [ p ]. cnt ++ ; __upd ( p ); __upd ( f ); __splay ( p ); return ; } f = p ; //f!=0; p = t [ p ]. ch [ t [ p ]. val < val ]; if ( ! p ) //Child does not exist { t [ f ]. ch [ t [ f ]. val < val ] = __add ( val ); t [ total ]. fa = f ; __upd ( total ); __upd ( f ); __splay ( total ); return ; } } } //\u6839\u636e\u6392\u540d\uff08\u4ece1\u5f00\u59cb\uff09\u53d6\u5f97\u503c\u548c\u4e0b\u6807 //\u6ce8\u610f\u8fd9\u51e0\u4e2a\u64cd\u4f5c\u4f1a\u7acb\u5373\u4f7f\u5f97\u88ab\u627e\u5230\u7684\u8282\u70b9\u88absplay\u5230\u6839\u8282\u70b9\uff0c\u4e0d\u8fc7\u4e0b\u6807\u4ecd\u7136\u662f\u6709\u6548\u7684 pair < Ty , int > get_val_by_rank ( int rank , bool root_RChild_rotate ) { // *\u5982\u679c\u4e0d\u9009\u62e9\u5728init\u65f6\u63d2\u5165\u4e24\u4e2a\u521d\u59cb\u65e0\u7a77\u5927\u503c\uff0c\u5219\u8bf7\u5728\u8fd9\u91cc\u79fb\u9664\u8fd9\u6bb5\u4ee3\u7801 rank += 1 ; // *\u79fb\u9664\u4ee3\u7801\u6bb5\u7ed3\u675f int p = root ; while ( true ) { __spread ( p ); if ( t [ p ]. ch [ 0 ] && t [ t [ p ]. ch [ 0 ]]. size >= rank ) { p = t [ p ]. ch [ 0 ]; } else { rank -= t [ p ]. cnt + t [ t [ p ]. ch [ 0 ]]. size ; if ( rank <= 0 ) { if ( root_RChild_rotate ) __splay2 ( p ); else __splay ( p ); return { t [ p ]. val , p }; } p = t [ p ]. ch [ 1 ]; } } } void reverse ( int l , int r ) { get_val_by_rank ( l -1 , 0 ); //l-1 is root get_val_by_rank ( r + 1 , 1 ); //r+1 is rchild of l-1 now //now r+1's lchild is the range needed to be reversed. int p = root ; __spread ( p ); p = t [ p ]. ch [ 1 ]; __spread ( p ); p = t [ p ]. ch [ 0 ]; __spread ( p ); swap ( t [ p ]. ch [ 0 ], t [ p ]. ch [ 1 ]); t [ p ]. T ^= 1 ; } void output ( int p ) { __spread ( p ); if ( t [ p ]. ch [ 0 ]) { output ( t [ p ]. ch [ 0 ]); } if ( p && p != 1 && p != 2 ) { cout << t [ p ]. val << \" \" ; } if ( t [ p ]. ch [ 1 ]) { output ( t [ p ]. ch [ 1 ]); } } } splay_tree ; } int n , m ; int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); cin >> n >> m ; SPLAY :: splay_tree . init (); for ( int i = 1 ; i <= n ; i ++ ) { SPLAY :: splay_tree . insert ( i ); } for ( int i = 1 ; i <= m ; i ++ ) { int l , r ; cin >> l >> r ; SPLAY :: splay_tree . reverse ( l , r ); } SPLAY :: splay_tree . output ( SPLAY :: splay_tree . root ); return 0 ; }","title":"\u6587\u827a\u5e73\u8861\u6811"},{"location":"old/%E8%87%AA%E5%88%B6Template/#_36","text":"","title":"\u5409\u5982\u4e00\u7ebf\u6bb5\u6811"},{"location":"old/%E8%87%AA%E5%88%B6Template/#_37","text":"\uff08\u4eceOI-wiki\u6284\u7684\uff09 \u533a\u95f4\u53d6 min\uff0c\u610f\u5473\u7740\u53ea\u5bf9\u90a3\u4e9b\u5927\u4e8e \\(t\\) \u7684\u6570\u6709\u66f4\u6539\u3002\u56e0\u6b64\u8fd9\u4e2a\u64cd\u4f5c\u7684\u5bf9\u8c61\u4e0d\u518d\u662f\u6574\u4e2a\u533a\u95f4\uff0c\u800c\u662f\u201c\u8fd9\u4e2a\u533a\u95f4\u4e2d\u5927\u4e8e \\(t\\) \u7684\u6570\u201d\u3002\u4e8e\u662f\u6211\u4eec\u53ef\u4ee5\u6709\u8fd9\u6837\u7684\u601d\u8def\uff1a\u6bcf\u4e2a\u7ed3\u70b9\u7ef4\u62a4\u8be5\u533a\u95f4\u7684\u6700\u5927\u503c \\(Max\\) \u3001\u6b21\u5927\u503c \\(Se\\) \u3001\u533a\u95f4\u548c \\(Sum\\) \u4ee5\u53ca\u6700\u5927\u503c\u7684\u4e2a\u6570 \\(Cnt\\) \u3002\u63a5\u4e0b\u6765\u6211\u4eec\u8003\u8651\u533a\u95f4\u5bf9 \\(t\\) \u53d6 \\(\\min\\) \u7684\u64cd\u4f5c\u3002 \u5982\u679c \\(Max\\le t\\) \uff0c\u663e\u7136\u8fd9\u4e2a \\(t\\) \u662f\u6ca1\u6709\u610f\u4e49\u7684\uff0c\u76f4\u63a5\u8fd4\u56de\uff1b \u5982\u679c \\(Se<t\\le Max\\) \uff0c\u90a3\u4e48\u8fd9\u4e2a \\(t\\) \u5c31\u80fd\u66f4\u65b0\u5f53\u524d\u533a\u95f4\u4e2d\u7684\u6700\u5927\u503c\u3002\u4e8e\u662f\u6211\u4eec\u8ba9\u533a\u95f4\u548c\u52a0\u4e0a \\(Cnt(t-Max)\\) \uff0c\u7136\u540e\u66f4\u65b0 \\(Max\\) \u4e3a \\(t\\) \uff0c\u5e76\u6253\u4e00\u4e2a\u6807\u8bb0\u3002 \u5982\u679c \\(t\\le Se\\) \uff0c\u90a3\u4e48\u8fd9\u65f6\u4f60\u53d1\u73b0\u4f60\u4e0d\u77e5\u9053\u6709\u591a\u5c11\u4e2a\u6570\u6d89\u53ca\u5230\u66f4\u65b0\u7684\u95ee\u9898\u3002\u4e8e\u662f\u6211\u4eec\u7684\u7b56\u7565\u5c31\u662f\uff0c\u66b4\u529b\u9012\u5f52\u5411\u4e0b\u64cd\u4f5c\u3002\u7136\u540e\u4e0a\u4f20\u4fe1\u606f\u3002 \u8fd9\u4e2a\u7b97\u6cd5\u7684\u590d\u6742\u5ea6\u5982\u4f55\uff1f\u4f7f\u7528\u52bf\u80fd\u5206\u6790\u6cd5\u53ef\u4ee5\u5f97\u5230\u590d\u6742\u5ea6\u662f \\(O(m\\log n)\\) \u7684\u3002\u5177\u4f53\u5206\u6790\u8fc7\u7a0b\u89c1\u8bba\u6587\u3002 5306_Gorgeous_Sequence3_myfastio 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <cstdlib> #include <algorithm> #include <string> #include <vector> #include <map> #include <unordered_map> #include <set> #include <unordered_set> #include <queue> using namespace std ; typedef long long ll ; int T ; namespace JSJSEgmentTree { using Ty = ll ; const int MAXN = 2e6 + 10 ; const Ty Inf = 1e17 ; int n , m ; Ty a [ MAXN ]; struct JSJSegmentTree { struct Node { Ty maxval , sec_maxval , maxval_cnt ; Ty mintag ; Ty sum ; int l , r ; } t [ MAXN * 4 ]; void __upd ( int p ) { t [ p ]. sum = t [ p * 2 ]. sum + t [ p * 2 + 1 ]. sum ; if ( t [ p * 2 ]. maxval == t [ p * 2 + 1 ]. maxval ) { t [ p ]. maxval = t [ p * 2 ]. maxval ; t [ p ]. maxval_cnt = t [ p * 2 ]. maxval_cnt + t [ p * 2 + 1 ]. maxval_cnt ; t [ p ]. sec_maxval = max ( t [ p * 2 ]. sec_maxval , t [ p * 2 + 1 ]. sec_maxval ); } else if ( t [ p * 2 ]. maxval > t [ p * 2 + 1 ]. maxval ) { t [ p ]. maxval = t [ p * 2 ]. maxval ; t [ p ]. maxval_cnt = t [ p * 2 ]. maxval_cnt ; t [ p ]. sec_maxval = max ( t [ p * 2 ]. sec_maxval , t [ p * 2 + 1 ]. maxval ); } else { t [ p ]. maxval = t [ p * 2 + 1 ]. maxval ; t [ p ]. maxval_cnt = t [ p * 2 + 1 ]. maxval_cnt ; t [ p ]. sec_maxval = max ( t [ p * 2 ]. maxval , t [ p * 2 + 1 ]. sec_maxval ); } } void __tagpush ( int p , Ty mintag ) { if ( t [ p ]. maxval > mintag ) { t [ p ]. sum += ( mintag - t [ p ]. maxval ) * t [ p ]. maxval_cnt ; t [ p ]. maxval = mintag ; // mintag < t[p].maxval <= t[p].mintag always hold t [ p ]. mintag = mintag ; } } void __tagdown ( int p ) { if ( t [ p ]. mintag != Inf ) { __tagpush ( p * 2 , t [ p ]. mintag ); __tagpush ( p * 2 + 1 , t [ p ]. mintag ); t [ p ]. mintag = Inf ; } } void build_tree ( int p , int l , int r ) { t [ p ]. mintag = Inf ; t [ p ]. l = l ; t [ p ]. r = r ; if ( l == r ) { t [ p ]. sum = t [ p ]. maxval = a [ l ]; t [ p ]. maxval_cnt = 1 ; t [ p ]. sec_maxval = - Inf ; return ; } int mid = ( l + r ) / 2 ; build_tree ( p * 2 , l , mid ); build_tree ( p * 2 + 1 , mid + 1 , r ); __upd ( p ); } void modify_min ( int p , int L , int R , Ty val ) { if ( t [ p ]. maxval > val ) { if ( L <= t [ p ]. l && t [ p ]. r <= R && t [ p ]. sec_maxval < val ) { return __tagpush ( p , val ); } __tagdown ( p ); int mid = ( t [ p ]. l + t [ p ]. r ) / 2 ; if ( L <= mid ) { modify_min ( p * 2 , L , R , val ); } if ( mid < R ) { modify_min ( p * 2 + 1 , L , R , val ); } __upd ( p ); } } Ty query_sum ( int p , int L , int R ) { if ( L <= t [ p ]. l && t [ p ]. r <= R ) { return t [ p ]. sum ; } __tagdown ( p ); int mid = ( t [ p ]. l + t [ p ]. r ) / 2 ; Ty ans = 0 ; if ( L <= mid ) { ans += query_sum ( p * 2 , L , R ); } if ( mid < R ) { ans += query_sum ( p * 2 + 1 , L , R ); } return ans ; } Ty query_max ( int p , int L , int R ) { if ( L <= t [ p ]. l && t [ p ]. r <= R ) { return t [ p ]. maxval ; } __tagdown ( p ); int mid = ( t [ p ]. l + t [ p ]. r ) / 2 ; Ty ans =- Inf ; if ( L <= mid ) { ans = max ( query_max ( p * 2 , L , R ), ans ); } if ( mid < R ) { ans = max ( query_max ( p * 2 + 1 , L , R ), ans ); } return ans ; } }; } using namespace JSJSEgmentTree ; JSJSegmentTree t ; namespace Fast_IO { char __nc () { static char buf [ 1000000 ], * p = buf , * q = buf ; return p == q && ( q = ( p = buf ) + fread ( buf , 1 , 1000000 , stdin ), p == q ) ? EOF : * p ++ ; } template < typename T > inline void read ( T & x ) { char c ; int sgn = 1 ; x = 0 ; c = __nc (); while ( c > '9' || c < '0' ) { if ( c == '-' ) sgn = -1 ; c = __nc (); } while ( c <= '9' && c >= '0' ) { x = ( x << 3 ) + ( x << 1 ) + ( c - '0' ); c = __nc (); } x *= sgn ; } template < typename T > inline void print ( T x ) { if ( x < 0 ) { putchar ( '-' ); x = - x ; } if ( x > 9 ) { print ( x / 10 ); } putchar ( x % 10 + '0' ); } } // namespace Fast_IO using namespace Fast_IO ; int main () { read ( T ); for ( int _ = 1 ; _ <= T ; _ ++ ) { read ( n ); read ( m ); for ( int i = 1 ; i <= n ; i ++ ) { read ( a [ i ]); } t . build_tree ( 1 , 1 , n ); for ( int i = 1 ; i <= m ; i ++ ) { int op ; read ( op ); if ( op == 0 ) { int l , r ; ll val ; read ( l ); read ( r ); read ( val ); t . modify_min ( 1 , l , r , val ); } else if ( op == 1 ) //get maxval { int l , r ; read ( l ); read ( r ); printf ( \"%lld \\n \" , t . query_max ( 1 , l , r )); } else //op==2: get sum { int l , r ; read ( l ); read ( r ); printf ( \"%lld \\n \" , t . query_sum ( 1 , l , r )); } } } return 0 ; }","title":"\u533a\u95f4\u53d6\u6700\u5c0f\u503c+\u7ef4\u62a4\u533a\u95f4\u6700\u5927\u503c\u4e0e\u548c"},{"location":"old/%E8%87%AA%E5%88%B6Template/#bzoj4695","text":"\u957f\u5ea6\u4e3a \\(n\\) \u7684\u5e8f\u5217\uff0c\u652f\u6301\u533a\u95f4\u52a0 \\(x\\) /\u533a\u95f4\u5bf9 \\(x\\) \u53d6 \\(\\max\\) /\u533a\u95f4\u5bf9 \\(x\\) \u53d6 \\(\\min\\) /\u6c42\u533a\u95f4\u548c/\u6c42\u533a\u95f4\u6700\u5927\u503c/\u6c42\u533a\u95f4\u6700\u5c0f\u503c\u3002 \\(N,M\\le 5\\times 10^5,|A_i|\\le 10^8\\) \u3002 \u540c\u6837\u7684\u65b9\u6cd5\uff0c\u6211\u4eec\u7ef4\u62a4\u6700\u5927\u3001\u6b21\u5927\u3001\u6700\u5927\u4e2a\u6570\u3001\u6700\u5c0f\u3001\u6b21\u5c0f\u3001\u6700\u5c0f\u4e2a\u6570\u3001\u533a\u95f4\u548c\u3002\u9664\u4e86\u8fd9\u4e9b\u4fe1\u606f\uff0c\u6211\u4eec\u8fd8\u9700\u8981\u7ef4\u62a4\u533a\u95f4 \\(\\max\\) \u3001\u533a\u95f4 \\(\\min\\) \u3001\u533a\u95f4\u52a0\u7684\u6807\u8bb0\u3002\u76f8\u6bd4\u4e0a\u4e00\u9053\u9898\uff0c\u8fd9\u5c31\u6d89\u53ca\u5230\u6807\u8bb0\u4e0b\u4f20\u7684\u987a\u5e8f\u95ee\u9898\u4e86\u3002\u6211\u4eec\u91c7\u7528\u8fd9\u6837\u7684\u7b56\u7565\uff1a \u6211\u4eec\u8ba4\u4e3a\u533a\u95f4\u52a0\u7684\u6807\u8bb0\u662f\u6700\u4f18\u5148\u7684\uff0c\u5176\u4f59\u4e24\u79cd\u6807\u8bb0\u5730\u4f4d\u5e73\u7b49\u3002 \u5bf9\u4e00\u4e2a\u7ed3\u70b9\u52a0\u4e0a\u4e00\u4e2a \\(v\\) \u6807\u8bb0\uff0c\u9664\u4e86\u7528 \\(v\\) \u66f4\u65b0\u536b\u661f\u4fe1\u606f\u548c\u5f53\u524d\u7ed3\u70b9\u7684\u533a\u95f4\u52a0\u6807\u8bb0\u5916\uff0c\u6211\u4eec\u7528\u8fd9\u4e2a v \u66f4\u65b0\u533a\u95f4 \\(\\max\\) \u548c\u533a\u95f4 \\(\\min\\) \u7684\u6807\u8bb0\u3002 \u5bf9\u4e00\u4e2a\u7ed3\u70b9\u53d6 \\(v\\) \u7684 \\(\\min\\) \uff08\u8fd9\u91cc\u5ffd\u7565\u66b4\u641c\u7684\u8fc7\u7a0b\uff0c\u5047\u5b9a\u6807\u8bb0\u6ee1\u8db3\u6dfb\u52a0\u7684\u6761\u4ef6\uff09\uff0c\u9664\u4e86\u66f4\u65b0\u536b\u661f\u4fe1\u606f\uff0c\u6211\u4eec\u8981\u4e0e\u533a\u95f4 \\(\\max\\) \u7684\u6807\u8bb0\u505a\u6bd4\u8f83\u3002\u5982\u679c \\(v\\) \u5c0f\u4e8e\u533a\u95f4 \\(\\max\\) \u7684\u6807\u8bb0\uff0c\u5219\u6240\u6709\u7684\u6570\u6700\u540e\u90fd\u4f1a\u53d8\u6210 v\uff0c\u90a3\u4e48\u628a\u533a\u95f4 \\(\\max\\) \u7684\u6807\u8bb0\u4e5f\u53d8\u6210 \\(v\\) \u3002\u5426\u5219\u4e0d\u7ba1\u3002 \u533a\u95f4\u53d6 v \u7684 \\(\\max\\) \u540c\u7406\u3002 \u53e6\u5916\uff0cBZOJ \u8fd9\u9053\u9898\u5361\u5e38\u2026\u2026\u591a\u6570\u7ec4\u7ebf\u6bb5\u6811\u7684\u5e38\u6570\u6bd4\u7ed3\u6784\u4f53\u7ebf\u6bb5\u6811\u7684\u5e38\u6570\u5927\u2026\u2026\u5728\u7ef4\u62a4\u4fe1\u606f\u7684\u65f6\u4faf\uff0c\u5f53\u53ea\u6709\u4e00\u4e24\u4e2a\u6570\u7684\u65f6\u4faf\u53ef\u80fd\u53d1\u751f\u6570\u96c6\u91cd\u5408\uff0c\u6bd4\u5982\u4e00\u4e2a\u6570\u65e2\u662f\u6700\u5927\u503c\u53c8\u662f\u6b21\u5c0f\u503c\u3002\u8fd9\u79cd\u8981\u7279\u5224\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <cstdlib> #include <algorithm> #include <string> #include <vector> #include <map> #include <unordered_map> #include <set> #include <unordered_set> #include <queue> using namespace std ; typedef long long ll ; namespace JSJSEgmentTree { using Ty = ll ; const int MAXN = 5e5 + 10 ; const Ty Inf = 1e17 ; int n , m ; Ty a [ MAXN ]; struct JSJSegmentTree { struct Node { Ty maxval , sec_maxval , maxval_cnt ; Ty minval , sec_minval , minval_cnt ; Ty mintag , maxtag , addtag ; Ty sum ; int l , r ; } t [ MAXN * 4 ]; void __upd ( int p ) { t [ p ]. sum = t [ p * 2 ]. sum + t [ p * 2 + 1 ]. sum ; if ( t [ p * 2 ]. maxval == t [ p * 2 + 1 ]. maxval ) { t [ p ]. maxval = t [ p * 2 ]. maxval ; t [ p ]. maxval_cnt = t [ p * 2 ]. maxval_cnt + t [ p * 2 + 1 ]. maxval_cnt ; t [ p ]. sec_maxval = max ( t [ p * 2 ]. sec_maxval , t [ p * 2 + 1 ]. sec_maxval ); } else if ( t [ p * 2 ]. maxval > t [ p * 2 + 1 ]. maxval ) { t [ p ]. maxval = t [ p * 2 ]. maxval ; t [ p ]. maxval_cnt = t [ p * 2 ]. maxval_cnt ; t [ p ]. sec_maxval = max ( t [ p * 2 ]. sec_maxval , t [ p * 2 + 1 ]. maxval ); } else { t [ p ]. maxval = t [ p * 2 + 1 ]. maxval ; t [ p ]. maxval_cnt = t [ p * 2 + 1 ]. maxval_cnt ; t [ p ]. sec_maxval = max ( t [ p * 2 ]. maxval , t [ p * 2 + 1 ]. sec_maxval ); } if ( t [ p * 2 ]. minval == t [ p * 2 + 1 ]. minval ) { t [ p ]. minval = t [ p * 2 ]. minval ; t [ p ]. minval_cnt = t [ p * 2 ]. minval_cnt + t [ p * 2 + 1 ]. minval_cnt ; t [ p ]. sec_minval = min ( t [ p * 2 ]. sec_minval , t [ p * 2 + 1 ]. sec_minval ); } else if ( t [ p * 2 ]. minval < t [ p * 2 + 1 ]. minval ) { t [ p ]. minval = t [ p * 2 ]. minval ; t [ p ]. minval_cnt = t [ p * 2 ]. minval_cnt ; t [ p ]. sec_minval = min ( t [ p * 2 ]. sec_minval , t [ p * 2 + 1 ]. minval ); } else { t [ p ]. minval = t [ p * 2 + 1 ]. minval ; t [ p ]. minval_cnt = t [ p * 2 + 1 ]. minval_cnt ; t [ p ]. sec_minval = min ( t [ p * 2 ]. minval , t [ p * 2 + 1 ]. sec_minval ); } } void __tagpush_add ( int p , Ty val ) { t [ p ]. sum += ( t [ p ]. r - t [ p ]. l + 1l l ) * val ; t [ p ]. maxval += val ; t [ p ]. minval += val ; if ( t [ p ]. sec_maxval != - Inf ) t [ p ]. sec_maxval += val ; if ( t [ p ]. sec_minval != Inf ) t [ p ]. sec_minval += val ; if ( t [ p ]. maxtag != - Inf ) t [ p ]. maxtag += val ; if ( t [ p ]. mintag != Inf ) t [ p ]. mintag += val ; t [ p ]. addtag += val ; } void __tagpush_min ( int p , Ty val ) { if ( t [ p ]. maxval > val ) { t [ p ]. sum += ( 1l l * val - t [ p ]. maxval ) * t [ p ]. maxval_cnt ; if ( t [ p ]. sec_minval == t [ p ]. maxval ) t [ p ]. sec_minval = val ; if ( t [ p ]. minval == t [ p ]. maxval ) t [ p ]. minval = val ; if ( t [ p ]. maxtag > val ) t [ p ]. maxtag = val ; t [ p ]. maxval = t [ p ]. mintag = val ; } } void __tagpush_max ( int p , Ty val ) { if ( t [ p ]. minval < val ) { t [ p ]. sum += ( 1l l * val - t [ p ]. minval ) * t [ p ]. minval_cnt ; if ( t [ p ]. sec_maxval == t [ p ]. minval ) t [ p ]. sec_maxval = val ; if ( t [ p ]. maxval == t [ p ]. minval ) t [ p ]. maxval = val ; if ( t [ p ]. mintag < val ) t [ p ]. mintag = val ; t [ p ]. minval = t [ p ]. maxtag = val ; } } void __tagdown ( int p ) { if ( t [ p ]. addtag ) { __tagpush_add ( p * 2 , t [ p ]. addtag ); __tagpush_add ( p * 2 + 1 , t [ p ]. addtag ); t [ p ]. addtag = 0 ; } if ( t [ p ]. maxtag !=- Inf ) { __tagpush_max ( p * 2 , t [ p ]. maxtag ); __tagpush_max ( p * 2 + 1 , t [ p ]. maxtag ); t [ p ]. maxtag =- Inf ; } if ( t [ p ]. mintag != Inf ) { __tagpush_min ( p * 2 , t [ p ]. mintag ); __tagpush_min ( p * 2 + 1 , t [ p ]. mintag ); t [ p ]. mintag = Inf ; } } void build_tree ( int p , int l , int r ) { t [ p ]. mintag = Inf ; t [ p ]. maxtag =- Inf ; t [ p ]. l = l ; t [ p ]. r = r ; if ( l == r ) { t [ p ]. sum = t [ p ]. maxval = t [ p ]. minval = a [ l ]; t [ p ]. maxval_cnt = t [ p ]. minval_cnt = 1 ; t [ p ]. sec_maxval = - Inf ; t [ p ]. sec_minval = Inf ; return ; } int mid = ( l + r ) / 2 ; build_tree ( p * 2 , l , mid ); build_tree ( p * 2 + 1 , mid + 1 , r ); __upd ( p ); } void modify_add ( int p , int L , int R , Ty val ) { if ( L <= t [ p ]. l && t [ p ]. r <= R ) { return __tagpush_add ( p , val ); } __tagdown ( p ); int mid = ( t [ p ]. l + t [ p ]. r ) / 2 ; if ( L <= mid ) modify_add ( p * 2 , L , R , val ); if ( mid < R ) modify_add ( p * 2 + 1 , L , R , val ); __upd ( p ); } void modify_min ( int p , int L , int R , Ty val ) { if ( t [ p ]. maxval > val ) { if ( L <= t [ p ]. l && t [ p ]. r <= R && t [ p ]. sec_maxval < val ) { return __tagpush_min ( p , val ); } __tagdown ( p ); int mid = ( t [ p ]. l + t [ p ]. r ) / 2 ; if ( L <= mid ) { modify_min ( p * 2 , L , R , val ); } if ( mid < R ) { modify_min ( p * 2 + 1 , L , R , val ); } __upd ( p ); } } void modify_max ( int p , int L , int R , Ty val ) { if ( t [ p ]. minval < val ) { if ( L <= t [ p ]. l && t [ p ]. r <= R && t [ p ]. sec_minval > val ) { return __tagpush_max ( p , val ); } __tagdown ( p ); int mid = ( t [ p ]. l + t [ p ]. r ) / 2 ; if ( L <= mid ) { modify_max ( p * 2 , L , R , val ); } if ( mid < R ) { modify_max ( p * 2 + 1 , L , R , val ); } __upd ( p ); } } Ty query_sum ( int p , int L , int R ) { if ( L <= t [ p ]. l && t [ p ]. r <= R ) { return t [ p ]. sum ; } __tagdown ( p ); int mid = ( t [ p ]. l + t [ p ]. r ) / 2 ; Ty ans = 0 ; if ( L <= mid ) { ans += query_sum ( p * 2 , L , R ); } if ( mid < R ) { ans += query_sum ( p * 2 + 1 , L , R ); } return ans ; } Ty query_max ( int p , int L , int R ) { if ( L <= t [ p ]. l && t [ p ]. r <= R ) { return t [ p ]. maxval ; } __tagdown ( p ); int mid = ( t [ p ]. l + t [ p ]. r ) / 2 ; Ty ans =- Inf ; if ( L <= mid ) { ans = max ( query_max ( p * 2 , L , R ), ans ); } if ( mid < R ) { ans = max ( query_max ( p * 2 + 1 , L , R ), ans ); } return ans ; } Ty query_min ( int p , int L , int R ) { if ( L <= t [ p ]. l && t [ p ]. r <= R ) { return t [ p ]. minval ; } __tagdown ( p ); int mid = ( t [ p ]. l + t [ p ]. r ) / 2 ; Ty ans = Inf ; if ( L <= mid ) { ans = min ( query_min ( p * 2 , L , R ), ans ); } if ( mid < R ) { ans = min ( query_min ( p * 2 + 1 , L , R ), ans ); } return ans ; } }; } using namespace JSJSEgmentTree ; JSJSegmentTree t ; namespace Fast_IO { char __nc () { static char buf [ 1000000 ], * p = buf , * q = buf ; return p == q && ( q = ( p = buf ) + fread ( buf , 1 , 1000000 , stdin ), p == q ) ? EOF : * p ++ ; } template < typename T > inline void read ( T & x ) { char c ; int sgn = 1 ; x = 0 ; c = __nc (); while ( c > '9' || c < '0' ) { if ( c == '-' ) sgn = -1 ; c = __nc (); } while ( c <= '9' && c >= '0' ) { x = ( x << 3 ) + ( x << 1 ) + ( c - '0' ); c = __nc (); } x *= sgn ; } template < typename T > inline void print ( T x ) { if ( x < 0 ) { putchar ( '-' ); x = - x ; } if ( x > 9 ) { print ( x / 10 ); } putchar ( x % 10 + '0' ); } } // namespace Fast_IO using namespace Fast_IO ; int main () { read ( n ); for ( int i = 1 ; i <= n ; i ++ ) read ( a [ i ]); t . build_tree ( 1 , 1 , n ); read ( m ); for ( int i = 1 ; i <= m ; i ++ ) { int op , l , r ; ll val ; read ( op ), read ( l ), read ( r ); if ( op <= 3 ) read ( val ); if ( op == 1 ) //add { t . modify_add ( 1 , l , r , val ); } else if ( op == 2 ) //max { t . modify_max ( 1 , l , r , val ); } else if ( op == 3 ) //min { t . modify_min ( 1 , l , r , val ); } else if ( op == 4 ) //sum { print ( t . query_sum ( 1 , l , r )); putchar ( '\\n' ); } else if ( op == 5 ) //max { print ( t . query_max ( 1 , l , r )); putchar ( '\\n' ); } else //min { print ( t . query_min ( 1 , l , r )); putchar ( '\\n' ); } } return 0 ; }","title":"BZOJ4695 \u6700\u5047\u5973\u9009\u624b"},{"location":"old/%E8%87%AA%E5%88%B6Template/#_38","text":"","title":"\u56fe\u8bba"},{"location":"old/%E8%87%AA%E5%88%B6Template/#_39","text":"\u56fe\u8bba\u7b97\u6cd5\u7684\u5b9e\u73b0\u4e3b\u8981\u4f9d\u8d56\u4e8e\u6b64\u3002\u9664\u975e\u6709\u7279\u6b8a\u8bf4\u660e\uff0c\u5426\u5219\u5927\u90e8\u5206\u56fe\u8bba\u7b97\u6cd5\u7684\u9ed8\u8ba4\u8f93\u5165\u63a5\u53e3\u5305\u62ec\u6b64\u6bb5\u6240\u8ff0\u7684\u90bb\u63a5\u8868\u3002 \ud83d\udd25\uff1atotal\u3001head\u3002","title":"\u90bb\u63a5\u8868"},{"location":"old/%E8%87%AA%E5%88%B6Template/#_40","text":"Funs || Methods Reliance Time Complexity Inputs Outputs Description adde 1 x,y,w: x\u5230y\u7684\u8fb9\u6743\u4e3aw\u7684\u8fb9 edge, total \u6dfb\u52a0\u8fb9 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 namespace Edges { typedef int Ty ; const int N = 1e4 + 10 , M = 2e5 + 100 ; //public int n , m ; //n,m: \u70b9\u3001\u8fb9\u6570\u91cf struct E { int from , to , inext ; Ty w ; } edge [ M ]; int head [ N ], total ; void adde ( int x , int y , Ty w ) { edge [ ++ total ]. from = x ; edge [ total ]. to = y ; edge [ total ]. w = w ; edge [ total ]. inext = head [ x ]; head [ x ] = total ; } } using namespace Edges ;","title":"\u5e26\u8fb9\u6743\u7684\u7248\u672c"},{"location":"old/%E8%87%AA%E5%88%B6Template/#lca","text":"\u500d\u589e\u6cd5\u3002 \ud83d\udd25\uff1atotal\uff0chead\uff0cd\uff0cdist 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 #include <iostream> #include <cmath> // #include <memory.h> #include <queue> #include <cstdio> #include <cstring> using namespace std ; typedef long long ll ; int T ; namespace Edges { const int N = 20010 ; typedef long long Ty ; //public struct E { int to , inext ; Ty w ; } edge [ N * 2 ]; int head [ N ], total ; int n , m ; void adde ( int x , int y , Ty w ) { edge [ ++ total ]. to = y ; edge [ total ]. w = w ; edge [ total ]. inext = head [ x ]; head [ x ] = total ; } } using namespace Edges ; namespace LCA { //local int d [ N ], f [ N ][ 20 ], dist [ N ], t ; //d:\u6df1\u5ea6 //f\uff1a\u500d\u589e\u6570\u7ec4 //dist:\u6839\u5230\u7b2cx\u4e2a\u70b9\u7684\u5e26\u6743\u8ddd\u79bb //t: t=log2(n)+1 //bfs\u5e76\u9884\u5904\u7406\u500d\u589e\u6570\u7ec4f void bfs ( int rt = 1 ) //init { t = int ( log2 ( n )) + 1 ; queue < int > q ; q . push ( rt ); d [ rt ] = 1 ; while ( q . size ()) { int x = q . front (); q . pop (); for ( int i = head [ x ]; i ; i = edge [ i ]. inext ) { int y = edge [ i ]. to ; if ( d [ y ] == 0 ) { d [ y ] = d [ x ] + 1 ; dist [ y ] = dist [ x ] + edge [ i ]. w ; f [ y ][ 0 ] = x ; for ( int k = 1 ; k <= t ; k ++ ) { f [ y ][ k ] = f [ f [ y ][ k -1 ]][ k -1 ]; } q . push ( y ); } } } } //\u901a\u8fc7\u500d\u589e\u6570\u7ec4\u5f97\u5230LCA int lca ( int x , int y ) { if ( d [ x ] > d [ y ]) swap ( x , y ); //d[x]<=d[y] //make d[y]=d[x] for ( int k = t ; k >= 0 ; k -- ) { if ( d [ f [ y ][ k ]] >= d [ x ]) y = f [ y ][ k ]; } if ( x == y ) return x ; //then climb together for ( int k = t ; k >= 0 ; k -- ) { if ( f [ x ][ k ] != f [ y ][ k ]) x = f [ x ][ k ], y = f [ y ][ k ]; } return f [ x ][ 0 ]; } } using namespace LCA ; int indegree [ N ]; int main () { ios :: sync_with_stdio ( false ); // cin>>T; scanf ( \"%d\" , & T ); while ( T -- ) { total = 0 ; memset ( head , 0 , sizeof ( head )); memset ( d , 0 , sizeof ( d )); memset ( dist , 0 , sizeof ( dist )); memset ( f , 0 , sizeof ( f )); memset ( indegree , 0 , sizeof ( indegree )); // cin>>n>>m; scanf ( \"%d\" , & n ); // scanf(\"%d\",&m); t = int ( log2 ( n )) + 1 ; // t=(int)(log(n*1.0)/log(2.0))+1; for ( int i = 1 ; i <= n -1 ; i ++ ) { int x , y ; // cin>>x>>y; scanf ( \"%d\" , & x ); scanf ( \"%d\" , & y ); adde ( x , y , 0 ); indegree [ y ] ++ ; } for ( int i = 1 ; i <= n ; i ++ ) { if ( indegree [ i ] == 0 ) { bfs ( i ); break ; } } int x , y ; scanf ( \"%d\" , & x ); scanf ( \"%d\" , & y ); printf ( \"%d \\n \" , lca ( x , y )); } return 0 ; }","title":"LCA"},{"location":"old/%E8%87%AA%E5%88%B6Template/#hld","text":"\u901a\u8fc7\u4e24\u6b21dfs\u5b9e\u73b0\uff0c\u7b2c\u4e00\u6b21dfs\u6807\u8bb0\u91cd\u5b50\u8282\u70b9\u3001\u6df1\u5ea6\u3001\u7236\u4eb2\u3001\u5b50\u6811\u5927\u5c0f\uff1b\u7b2c\u4e8c\u6b21\u6807\u8bb0dfn\uff08\u91cd\u8fb9\u4f18\u5148\u904d\u5386\uff09\u3001rnk\uff08dfn\u7684\u53cd\u51fd\u6570\uff0c\u4e5f\u5373\u901a\u8fc7dfn\u83b7\u5f97\u8282\u70b9\u539f\u6807\u53f7\uff09\u3001top\uff08\u6240\u5728\u91cd\u94fe\u94fe\u9876\uff09\u3002\u4f7f\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u94fe\u4e0adfn\u4fe1\u606f\u3002 \u8def\u5f84\u4e0a\u7ef4\u62a4 \uff1a\u6bcf\u6b21\u9009\u62e9\u6df1\u5ea6\u8f83\u5927\u7684\u94fe\u5f80\u4e0a\u8df3\uff0c\u76f4\u5230\u4e24\u70b9\u5728\u540c\u4e00\u6761\u94fe\u4e0a\u3002 \u5b50\u6811\u7ef4\u62a4 \uff1a\u8bb0\u5f55\u6240\u5728\u5b50\u6811\u8fde\u7eed\u533a\u95f4\u672b\u7aef\u7684\u7ed3\u70b9\uff08\u4ed6\u55b5\u7684\u4e0d\u662f\u76f4\u63a5\u8bb0\u5f55\u5b50\u6811dfn\u6700\u5927\u662f\u8c01\u5c31\u884c\u4e86\u5417\uff08\uff09\uff09 LCA \uff1a\u548c\u8def\u5f84\u4e0a\u7ef4\u62a4\u76f8\u4f3c\uff0c\u4e0d\u8fc7\u5f53\u4e24\u4e2a\u8282\u70b9\u8df3\u5230\u540c\u4e00\u94fe\u65f6\uff0c\u53d6\u6df1\u5ea6\u8f83\u5c0f\u8282\u70b9\u4f5c\u4e3aLCA \ud83e\udd2b\uff1adfs\u3001dfs2\u3001init_wdfn\u3001build_tree \ud83d\udd25\uff1atotal\u3001head\u3001dfn\u3001node\u3001w_dfn \u6ce8\u610f\u7ebf\u6bb5\u6811\u4e0a\u53ef\u80fd\u4e5f\u8981\u6e05\u7a7a\uff081~4n\uff0c\u6211\u4e0d\u77e5\u9053\u662f\u4ec0\u4e48\u60c5\u51b5\u2026\u2026\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 //HLD [P2590 [ZJOI2008\\]\u6811\u7684\u7edf\u8ba1] #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <cstdlib> #include <algorithm> #include <string> #include <vector> #include <map> #include <unordered_map> #include <set> #include <unordered_set> #include <queue> using namespace std ; typedef long long ll ; namespace Edges { typedef int Ty ; const int N = 5e5 + 10 , M = 2e5 + 10 ; //public int n , m ; //n,m: \u70b9\u3001\u8fb9\u6570\u91cf struct E { int to , inext ; // Ty w; } edge [ M ]; int head [ N ], total ; void adde ( int x , int y ) { edge [ ++ total ]. to = y ; // edge[total].w = w; edge [ total ]. inext = head [ x ]; head [ x ] = total ; } } using namespace Edges ; namespace SEGMENT_TREE { typedef int Ty ; const Ty INF = 1145141919 ; Ty w_dfn [ N ]; //w_dfn: \u7531dfn\u5230\u6743\u503c\u7684\u6620\u5c04 //\u7ef4\u62a4dfn\u7528\u7684\u7ebf\u6bb5\u6811 struct Segment_tree { struct SEGMENT_TREE { Ty maxval , sum ; int l , r ; } t [ N * 4 ]; //\u7ef4\u62a4\u5173\u4e8edfn\u7684\u4fe1\u606f void __upd ( int p ) { t [ p ]. maxval = max ( t [ p * 2 ]. maxval , t [ p * 2 + 1 ]. maxval ); t [ p ]. sum = t [ p * 2 ]. sum + t [ p * 2 + 1 ]. sum ; } //\u5efa\u6811 void build_tree ( int p , int l , int r ) { t [ p ]. l = l ; t [ p ]. r = r ; if ( l == r ) { t [ p ]. maxval = t [ p ]. sum = w_dfn [ l ]; return ; } int mid = ( l + r ) / 2 ; build_tree ( p * 2 , l , mid ); build_tree ( p * 2 + 1 , mid + 1 , r ); __upd ( p ); } //\u5355\u70b9\u4fee\u6539 void singlechange ( int p , int pos , Ty val ) { if ( t [ p ]. l == t [ p ]. r ) { w_dfn [ t [ p ]. l ] = val ; t [ p ]. maxval = t [ p ]. sum = w_dfn [ t [ p ]. l ]; return ; } int mid = ( t [ p ]. l + t [ p ]. r ) / 2 ; if ( pos <= mid ) singlechange ( p * 2 , pos , val ); else singlechange ( p * 2 + 1 , pos , val ); __upd ( p ); } //\u8be2\u95ee\u533a\u95f4\u6700\u5927\u503c int ask_maxval ( int p , int l , int r ) { if ( l <= t [ p ]. l && t [ p ]. r <= r ) { return t [ p ]. maxval ; } Ty ans =- INF ; int mid = ( t [ p ]. l + t [ p ]. r ) / 2 ; if ( l <= mid ) ans = max ( ans , ask_maxval ( p * 2 , l , r )); if ( mid < r ) ans = max ( ans , ask_maxval ( p * 2 + 1 , l , r )); return ans ; } //\u8be2\u95ee\u533a\u95f4\u548c int ask_sum ( int p , int l , int r ) { if ( l <= t [ p ]. l && t [ p ]. r <= r ) { return t [ p ]. sum ; } Ty ans = 0 ; int mid = ( t [ p ]. l + t [ p ]. r ) / 2 ; if ( l <= mid ) ans += ask_sum ( p * 2 , l , r ); if ( mid < r ) ans += ask_sum ( p * 2 + 1 , l , r ); return ans ; } } tree ; } using namespace SEGMENT_TREE ; namespace HLD { typedef int Ty ; struct NODE { int fa , hson , top , size , depth , dfn ; Ty w ; } node [ N ]; //local int dfn = 0 ; //dfn:\u7b2c\u4e8c\u6b21dfs\u9700\u8981\u4f7f\u7528dfn //\u7b2c\u4e00\u6b21dfs\uff1a\u6807\u8bb0\u91cd\u5b50\u8282\u70b9\u3001\u6df1\u5ea6\u3001\u7236\u4eb2\u3001\u5b50\u6811\u5927\u5c0f void dfs ( int x , int depth ) { node [ x ]. depth = depth ; node [ x ]. hson = 0 ; node [ x ]. size = 1 ; for ( int e = head [ x ]; e ; e = edge [ e ]. inext ) { int y = edge [ e ]. to ; if ( y == node [ x ]. fa ) continue ; node [ y ]. fa = x ; dfs ( y , depth + 1 ); node [ x ]. size += node [ y ]. size ; if ( node [ x ]. hson == 0 || node [ node [ x ]. hson ]. size < node [ y ]. size ) { node [ x ]. hson = y ; } } } //\u7b2c\u4e8c\u6b21dfs\uff1a\u6807\u8bb0dfn\uff08\u91cd\u8fb9\u4f18\u5148\u904d\u5386\uff09\u3001rnk\uff08dfn\u7684\u53cd\u51fd\u6570\uff0c\u4e5f\u5373\u901a\u8fc7dfn\u83b7\u5f97\u8282\u70b9\u539f\u6807\u53f7\uff09\u3001top\uff08\u6240\u5728\u91cd\u94fe\u94fe\u9876\uff09 void dfs2 ( int x , int top ) { node [ x ]. top = top ; dfn ++ ; node [ x ]. dfn = dfn ; if ( node [ x ]. hson ) { dfs2 ( node [ x ]. hson , top ); for ( int e = head [ x ]; e ; e = edge [ e ]. inext ) { int y = edge [ e ]. to ; if ( y == node [ x ]. fa || y == node [ x ]. hson ) continue ; dfs2 ( y , y ); } } } //\u53d6\u5f97x\u3001y\u8def\u5f84\u4e0a\u7684\u548c Ty get_sum ( int x , int y ) { Ty ans = 0 ; while ( node [ x ]. top != node [ y ]. top ) { if ( node [ node [ x ]. top ]. depth < node [ node [ y ]. top ]. depth ) { swap ( x , y ); } ans += tree . ask_sum ( 1 , node [ node [ x ]. top ]. dfn , node [ x ]. dfn ); x = node [ node [ x ]. top ]. fa ; } if ( node [ x ]. depth < node [ y ]. depth ) swap ( x , y ); ans += tree . ask_sum ( 1 , node [ y ]. dfn , node [ x ]. dfn ); return ans ; } //\u53d6\u5f97x\u3001y\u8def\u5f84\u4e0a\u7684\u6700\u5927\u503c Ty get_max ( int x , int y ) { Ty ans =- INF ; while ( node [ x ]. top != node [ y ]. top ) { if ( node [ node [ x ]. top ]. depth < node [ node [ y ]. top ]. depth ) swap ( x , y ); ans = max ( tree . ask_maxval ( 1 , node [ node [ x ]. top ]. dfn , node [ x ]. dfn ), ans ); //!! x = node [ node [ x ]. top ]. fa ; } if ( node [ x ]. depth < node [ y ]. depth ) swap ( x , y ); ans = max ( tree . ask_maxval ( 1 , node [ y ]. dfn , node [ x ]. dfn ), ans ); return ans ; } //\u9884\u5b58\u70b9\u6743\u5230dfn\u6743\u4e0a void init_wdfn () { for ( int i = 1 ; i <= n ; i ++ ) { w_dfn [ node [ i ]. dfn ] = node [ i ]. w ; } // tree.build_tree(1,1,n); } } using namespace HLD ; int main () { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n -1 ; i ++ ) { int x , y ; scanf ( \"%d%d\" , & x , & y ); adde ( x , y ); adde ( y , x ); } dfs ( 1 , 1 ); dfs2 ( 1 , 1 ); for ( int i = 1 ; i <= n ; i ++ ) { //Ty scanf ( \"%d\" , & node [ i ]. w ); } init_wdfn (); tree . build_tree ( 1 , 1 , n ); int q ; scanf ( \"%d\" , & q ); for ( int i = 1 ; i <= q ; i ++ ) { char op [ 10 ]; int x , y ; scanf ( \"%s\" , op ); scanf ( \"%d%d\" , & x , & y ); if ( op [ 0 ] == 'C' ) { tree . singlechange ( 1 , node [ x ]. dfn , y ); } else if ( op [ 1 ] == 'M' ) { // cout<<get_max(x,y)<<endl; printf ( \"%d \\n \" , get_max ( x , y )); } else if ( op [ 1 ] == 'S' ) { // cout<<get_sum(x,y)<<endl; printf ( \"%d \\n \" , get_sum ( x , y )); } } return 0 ; }","title":"\u6811\u94fe\u5256\u5206HLD"},{"location":"old/%E8%87%AA%E5%88%B6Template/#edcc","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 //\u65e0\u5411\u56fe\u7684\u6865\u3001\u8fb9\u53cc\u8054\u901a\u5206\u91cf // POJ 3694 #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <cstdlib> #include <algorithm> #include <string> #include <vector> #include <map> #include <unordered_map> #include <set> #include <unordered_set> #include <queue> using namespace std ; typedef long long ll ; namespace Edges { typedef int Ty ; const int N = 1e5 + 10 , M = 4e5 + 10 ; //public int n , m ; //n,m: \u70b9\u3001\u8fb9\u6570\u91cf struct E { int to , inext ; bool is_cut ; // is_cut: \u662f\u5426\u4e3a\u5272\u8fb9 } edge [ M ]; int head [ N ], total = 1 ; //\u26a0\ufe0f\u6ce8\u610f\uff1a\u4ece1\u5f00\u59cb\u8ba1\u6570\uff01 //\u65b0\u56fe\u4e2d\u7684\u8fb9 E edge_c [ M ]; int head_c [ N ], total_c ; void adde ( int x , int y ) { edge [ ++ total ]. to = y ; edge [ total ]. is_cut = false ; edge [ total ]. inext = head [ x ]; head [ x ] = total ; } void adde_c ( int x , int y ) { edge_c [ ++ total_c ]. to = y ; edge_c [ total_c ]. inext = head_c [ x ]; head_c [ x ] = total_c ; } } using namespace Edges ; namespace EDCC { struct Node { int dfn , low , c ; //dfn,low\uff1adfn\u548c\u6700\u5c0f\u53ef\u8ffd\u6eaf\u503c //c: \u70b9\u6240\u5c5e\u7684edcc\u7f16\u53f7 } node [ N ]; //public int dfn = 0 ; int edcc_cnt = 0 ; //dfn:\u5168\u5c40dfn\u7f16\u53f7\u8ba1\u6570\u5668 //edcc_cnt\uff1a\u5728\u7b2c\u4e8c\u6b21dfs\u8fc7\u7a0b\u4e2d\u8ba1\u7b97edcc\u6570\u76ee //tarjan\u6c42\u51fa\u6865. in_edge:\u8fdb\u5165\u70b9x\u7684\u8fb9\u5728\u539f\u56fe\u4e2d\u7684\u4e0b\u6807\uff0c\u7528\u4e8e\u963b\u6b62\u904d\u5386\u53cd\u5411\u8fb9 void tarjan ( int x , int in_edge ) { node [ x ]. dfn = node [ x ]. low =++ dfn ; for ( int e = head [ x ]; e ; e = edge [ e ]. inext ) { int y = edge [ e ]. to ; if ( ! node [ y ]. dfn ) { tarjan ( y , e ); node [ x ]. low = min ( node [ x ]. low , node [ y ]. low ); if ( node [ y ]. low > node [ x ]. dfn ) { edge [ e ]. is_cut = edge [ e ^ 1 ]. is_cut = true ; } } else if ( e != ( in_edge ^ 1 )) { node [ x ]. low = min ( node [ x ]. low , node [ y ]. dfn ); } } } //\u5bf9\u6240\u6709\u70b9\u505a\u4e00\u6b21tarjan void tarjan_forall ( int n = n ) { for ( int i = 1 ; i <= n ; i ++ ) { if ( node [ i ]. dfn == 0 ) { tarjan ( i , -1 ); } } } //int edcc_cnt=0; //dfs\u6807\u8bb0\u5404\u70b9\u6240\u5c5e\u7684edcc void __edcc_dfs ( int x ) { node [ x ]. c = edcc_cnt ; for ( int e = head [ x ]; e ; e = edge [ e ]. inext ) { if ( edge [ e ]. is_cut ) continue ; int y = edge [ e ]. to ; if ( node [ y ]. c ) continue ; __edcc_dfs ( y ); } } //dfs\u6807\u8bb0\u5404\u70b9\u6240\u5c5e\u7684edcc\uff08\u5bf9\u6240\u6709\u70b9\uff09 void edcc_forall ( int n = n ) { for ( int i = 1 ; i <= n ; i ++ ) { if ( node [ i ]. c ) { edcc_cnt ++ ; __edcc_dfs ( i ); } } } //edcc\u7f29\u70b9\uff1a\u5728\u65b0\u56fe\u4e0a\u5efa\u56fe void edcc_suodian () { for ( int i = 2 ; i <= total ; i ++ ) //\u6ce8\u610f\u8fd9\u91cc\u904d\u5386\u7684\u662f\u8fb9 { int x = edge [ i ]. to , y = edge [ i ^ 1 ]. to ; if ( node [ x ]. c == node [ y ]. c ) continue ; adde_c ( node [ x ]. c , node [ y ]. c ); } } } using namespace EDCC ; int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ), cout . tie ( 0 ); return 0 ; }","title":"\u65e0\u5411\u56feEDCC"},{"location":"old/%E8%87%AA%E5%88%B6Template/#vdcc","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <cstdlib> #include <algorithm> #include <string> #include <vector> #include <map> #include <unordered_map> #include <set> #include <unordered_set> #include <queue> using namespace std ; typedef long long ll ; namespace Edges { typedef int Ty ; const int N = 6e5 + 10 , M = 6e5 + 10 ; //public int n , m ; //n,m: \u70b9\u3001\u8fb9\u6570\u91cf struct E { int to , inext ; } edge [ M ]; int head [ N ], total = 1 ; //\u26a0\ufe0f\u6ce8\u610f\uff1a\u4ece1\u5f00\u59cb\u8ba1\u6570\uff01 //\u65b0\u56fe\u4e2d\u7684\u8fb9 E edge_c [ M ]; int head_c [ N ], total_c ; void adde ( int x , int y ) { edge [ ++ total ]. to = y ; edge [ total ]. inext = head [ x ]; head [ x ] = total ; } void adde_c ( int x , int y ) { edge_c [ ++ total_c ]. to = y ; edge_c [ total_c ]. inext = head_c [ x ]; head_c [ x ] = total_c ; } } using namespace Edges ; namespace VDCC { struct Node { int dfn , low ; int c ; bool is_cutpoint ; //dfn,low\uff1adfn\u548c\u6700\u5c0f\u53ef\u8ffd\u6eaf\u503c //is_cutpoint: \u662f\u5272\u70b9\u6807\u8bb0 //c: \u4e00\u822c\u70b9\u6240\u5c5e\u7684edcc\u7f16\u53f7 / \u5272\u70b9\u5728\u65b0\u56fe\u4e2d\u6240\u5c5e\u7684\u70b9\u7684\u7f16\u53f7 } node [ N ]; //public int dfn = 0 ; int vdcc_cnt = 0 ; vector < int > vdcc [ N ]; //dfn:\u5168\u5c40dfn\u7f16\u53f7\u8ba1\u6570\u5668 //vdcc_cnt\uff1a\u5728\u7b2c\u4e8c\u6b21dfs\u8fc7\u7a0b\u4e2d\u8ba1\u7b97vdcc\u6570\u76ee //vdcc: \u4fdd\u5b58\u6240\u6709vdcc\u4e2d\u70b9\u7684\u7f16\u53f7\u7684vector\u96c6\u5408 //local int st [ N ], st_p ; //st:\u6808 //tarjan\u6c42\u51fa\u5272\u70b9\uff0c\u540c\u65f6\u987a\u5e26\u6c42\u51favdcc void tarjan ( int x , int root ) //for vdcc { node [ x ]. dfn = node [ x ]. low =++ dfn ; if ( x == root && head [ x ] == 0 ) { vdcc [ ++ vdcc_cnt ]. push_back ( x ); // single[x]=true; return ; } st [ ++ st_p ] = x ; int flag = 0 ; for ( int e = head [ x ]; e ; e = edge [ e ]. inext ) { int y = edge [ e ]. to ; if ( ! node [ y ]. dfn ) { tarjan ( y , root ); node [ x ]. low = min ( node [ x ]. low , node [ y ]. low ); if ( node [ x ]. dfn <= node [ y ]. low ) { flag ++ ; if ( x != root || flag > 1 ) node [ x ]. is_cutpoint = true ; vdcc_cnt ++ ; int z ; do { z = st [ st_p -- ]; vdcc [ vdcc_cnt ]. push_back ( z ); } while ( z != y ); vdcc [ vdcc_cnt ]. push_back ( x ); } } else node [ x ]. low = min ( node [ x ]. low , node [ y ]. dfn ); } } //\u4e00\u822c\u7684\u6c42\u5272\u70b9\uff0c\u4e0d\u6c42\u51favdcc void tarjan2 ( int x , int root , int in_edge = -1 ) { node [ x ]. dfn = node [ x ]. low =++ dfn ; int flag = 0 ; for ( int e = head [ x ]; e ; e = edge [ e ]. inext ) { int y = edge [ e ]. to ; if ( ! node [ y ]. dfn ) { tarjan2 ( y , root , in_edge ); node [ x ]. low = min ( node [ x ]. low , node [ y ]. low ); if ( node [ x ]. dfn <= node [ y ]. low ) { flag ++ ; if (( x == root && flag >= 2 ) || ( x != root )) { node [ x ]. is_cutpoint = true ; } } } else if ( e != ( in_edge ^ 1 )) //\u6216\u8005\u76f4\u63a5else node [ x ]. low = min ( node [ x ]. low , node [ y ]. dfn ); } } //tarjan\u6c42\u51fa\u5272\u70b9\u548cvdcc\uff08\u5bf9\u6240\u6709\u70b9\uff09 void tarjan_forall ( int n = n ) { for ( int i = 1 ; i <= n ; i ++ ) { if ( node [ i ]. dfn == 0 ) { tarjan ( i , i ); } } } //vdcc\u7f29\u70b9\uff1a\u5728\u65b0\u56fe\u4e0a\u5efa\u56fe //\u4e3a\u6240\u6709\u5272\u70b9\u7684c\u65b0\u5206\u914d\u7f16\u53f7(vdcc_cnt+1 ~ vdcc_cnt*2)\uff0c\u5176\u4ed6\u70b9\u7684c\u4fdd\u5b58\u81ea\u5df1\u6240\u5c5e\u7684vdcc\u7f16\u53f7 //\u65b0\u7684\u56fe\u4f1a\u662f\u4ee5\u5404\u4e2a\u5272\u70b9\u4e3a\u4e2d\u5fc3\u8fde\u63a5\u5230\u5404\u4e2avdcc\u7f29\u6210\u7684\u70b9\uff08\u7528vdcc\u7f16\u53f7\u8868\u793a\uff09\u7684\u56fe\u3002 void vdcc_suodian () { int num = vdcc_cnt ; for ( int i = 1 ; i <= n ; i ++ ) { if ( node [ i ]. is_cutpoint ) node [ i ]. c =++ num ; // node[i].new_id } total_c = 1 ; for ( int i = 1 ; i <= vdcc_cnt ; i ++ ) { for ( auto x : vdcc [ i ]) { if ( node [ x ]. is_cutpoint ) { adde_c ( i , node [ x ]. c ); adde_c ( node [ x ]. c , i ); } else node [ x ]. c = i ; } } } } using namespace VDCC ; int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ), cout . tie ( 0 ); return 0 ; }","title":"\u65e0\u5411\u56feVDCC\uff08\u70b9\u53cc\uff09"},{"location":"old/%E8%87%AA%E5%88%B6Template/#tarjan","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 // LUOGU 3387 \u7f29\u70b9 (\u6709\u5411\u56fetarjan\u7f29\u70b9) #include <iostream> #include <vector> #include <queue> using namespace std ; const int N = 2e4 + 5 , M = 2e5 + 5 ; struct E { int to , inext ; } edge [ M ], edge_c [ M ]; int head [ N ], total ; int head_c [ N ], total_c ; int n , m , a [ N ]; //vector<int> scc[N]; int st [ N ], st_p , cnt , c [ N ], sum [ N ]; //stack, scc_count, scc_sum int dfn [ N ], low [ N ], dfn_cnt ; bool inst [ N ]; //in stack int in_degree [ N ]; void adde ( int x , int y ) { edge [ ++ total ]. to = y ; edge [ total ]. inext = head [ x ]; head [ x ] = total ; } void adde_c ( int x , int y ) { edge_c [ ++ total_c ]. to = y ; edge_c [ total_c ]. inext = head_c [ x ]; head_c [ x ] = total_c ; } void tarjan ( int x ) { dfn [ x ] = low [ x ] =++ dfn_cnt ; st [ ++ st_p ] = x ; inst [ x ] = true ; for ( int e = head [ x ]; e ; e = edge [ e ]. inext ) { int y = edge [ e ]. to ; if ( ! dfn [ y ]) { tarjan ( y ); low [ x ] = min ( low [ x ], low [ y ]); } else if ( inst [ y ]) low [ x ] = min ( low [ x ], dfn [ y ]); } if ( dfn [ x ] == low [ x ]) //scc judge success { cnt ++ ; //scc_cnt++ while ( st [ st_p ] != x ) { int y = st [ st_p ]; //scc[cnt].emplace_back(y); inst [ y ] = false ; c [ y ] = cnt ; sum [ cnt ] += a [ y ]; st_p -- ; } //x //scc[cnt].emplace_back(x); inst [ x ] = false ; c [ x ] = cnt ; sum [ cnt ] += a [ x ]; st_p -- ; } } void creat_new_graph () { for ( int i = 1 ; i <= n ; i ++ ) { for ( int e = head [ i ]; e ; e = edge [ e ]. inext ) { int y = edge [ e ]. to ; if ( c [ i ] == c [ y ]) continue ; //same scc else { adde_c ( c [ i ], c [ y ]); in_degree [ c [ y ]] ++ ; } } } } int f [ N ], ans = 0 ; void topo () //for Graph2 { queue < int > q ; for ( int i = 1 ; i <= cnt ; i ++ ) { if ( ! in_degree [ i ]) { q . push ( i ); f [ i ] = sum [ i ]; ans = max ( ans , f [ i ]); } } while ( q . size ()) { int x = q . front (); q . pop (); for ( int e = head_c [ x ]; e ; e = edge_c [ e ]. inext ) { int y = edge_c [ e ]. to ; f [ y ] = max ( f [ y ], f [ x ] + sum [ y ]); ans = max ( ans , f [ y ]); in_degree [ y ] -- ; if ( ! in_degree [ y ]) q . push ( y ); } } } int main () { ios :: sync_with_stdio ( false ); cin >> n >> m ; for ( int i = 1 ; i <= n ; i ++ ) cin >> a [ i ]; for ( int i = 1 ; i <= m ; i ++ ) { int x , y ; cin >> x >> y ; adde ( x , y ); } for ( int i = 1 ; i <= n ; i ++ ) { if ( ! dfn [ i ]) tarjan ( i ); } creat_new_graph (); topo (); cout << ans << endl ; return 0 ; }","title":"\u6709\u5411\u56fetarjan\u7f29\u70b9"},{"location":"old/%E8%87%AA%E5%88%B6Template/#_41","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <cstdlib> #include <algorithm> #include <string> #include <vector> #include <map> #include <unordered_map> #include <set> #include <unordered_set> #include <queue> using namespace std ; typedef long long ll ; namespace Edges { typedef int Ty ; const int N = 1e4 + 10 , M = 2e5 + 100 ; //public int n , m ; //n,m: \u70b9\u3001\u8fb9\u6570\u91cf struct E { int to , inext ; Ty w ; } edge [ M ]; int head [ N ], total ; void adde ( int x , int y , Ty w ) { edge [ ++ total ]. to = y ; edge [ total ]. w = w ; edge [ total ]. inext = head [ x ]; head [ x ] = total ; } } using namespace Edges ; namespace Hungary { const int N = 1e4 + 10 ; //local bool vis [ N ]; int match [ N ]; //vis:\u5308\u7259\u5229\u7b97\u6cd5\u4e2d\u7528\u4e8e\u6807\u8bb0\u8282\u70b9\u662f\u5426\u8d70\u8fc7 //match:\u4e8c\u5206\u56fe\u7684\u53f3\u4fa7\u8282\u70b9\u5bf9\u5e94\u7684\u5de6\u4fa7\u8282\u70b9\u5339\u914d\u8c01\uff08\u5982\u679c\u662f\u5728\u540c\u4e00\u5f20\u56fe\u4e2d\u4f7f\u7528\u7edf\u4e00\u7f16\u53f7\u5219\u4e5f\u53ef\u4fdd\u5b58\u5de6\u4fa7\u70b9\u7684\u5339\u914d\u60c5\u51b5\uff09 //\u9644\u6ce8\uff1a\u539f\u7b97\u6cd5\u91cc\u9762\u5de6\u4fa7\u8282\u70b9\u7684\u7f16\u53f7\u548c\u53f3\u4fa7\u8282\u70b9\u7684\u6807\u53f7\u662f\u53ef\u4ee5\u76f8\u540c\u7684\u3002\u6362\u53e5\u8bdd\u8bf4\u628a\u5de6\u4fa7\u548c\u53f3\u4fa7\u770b\u6210\u4e86\u4e24\u4e2a\u4e0d\u540c\u7684\u56fe //\u5bfb\u627e\u4e00\u6761\u589e\u5e7f\u8def\u5e76\u6539\u53d8\u5339\u914d bool __dfs ( int x ) { for ( int e = head [ x ]; e ; e = edge [ e ]. inext ) { int y = edge [ e ]. to ; if ( ! vis [ y ]) { vis [ y ] = true ; if ( ! match [ y ] || __dfs ( match [ y ])) { match [ y ] = x ; // match[x]=y; //\u80fd\u4f7f\u7528\u5f53\u4e14\u4ec5\u5f53\u6240\u6709\u70b9\u7f16\u53f7\u552f\u4e00\uff08\u5de6\u4fa7\u70b9\u4e0e\u53f3\u4fa7\u70b9\u7f16\u53f7\u4e0d\u4f1a\u76f8\u540c\uff09 return true ; } } } return false ; } void __clear_visit ( int n = n ) { for ( int i = 1 ; i <= n * 2 ; i ++ ) vis [ i ] = false ; //\u6ce8\u610f\u8981\u6539\u8303\u56f4 } //\u4e8c\u5206\u56fe\u5339\u914d int do_Hungary () { int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) //\u4e8c\u5206\u56fe\u7684\u4e00\u4fa7\uff08\u5de6\u4fa7\uff09\u6709n\u4e2a\u70b9\uff0c\u7f16\u53f7\u4e3a1~n { __clear_visit (); if ( __dfs ( i )) ans ++ ; } return ans ; } } using namespace Hungary ; int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ), cout . tie ( 0 ); return 0 ; }","title":"\u5308\u7259\u5229"},{"location":"old/%E8%87%AA%E5%88%B6Template/#km-bfs","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 //2021\u725b\u5ba2\u591a\u68215 J Jewels #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <cstdlib> #include <algorithm> #include <string> #include <vector> #include <map> #include <unordered_map> #include <set> #include <unordered_set> #include <queue> using namespace std ; // typedef long long ll; using ll = long long ; // const int N=2e5+10; namespace KMKM { using Ty = ll ; const int N = 310 ; const Ty Inf = 1e18 ; int n ; Ty g [ N ][ N ]; //g\uff1a\u5e26\u6743\u5de6\u53f3\u5b50\u56fe\uff08\u4e8c\u5206\u56fe\uff0c\u5de6\u53f3\u4e24\u8fb9\u4e0b\u6807\u90fd\u662f\u4ece1\u5f00\u59cb\uff09 int matchx [ N ], matchy [ N ]; int pre [ N ]; bool visx [ N ], visy [ N ]; Ty lx [ N ], ly [ N ]; Ty slack [ N ]; //match:\u5339\u914d\u70b9\u6620\u5c04\u96c6\u5408\u3002\u8981\u6c42\u4e00\u5b9a\u662f\u5b8c\u7f8e\u5339\u914d\uff0c\u56e0\u6b64\u4e00\u5b9a\u5b58\u5728 //slack\uff1a\u677e\u5f1b\u6570\u7ec4\uff0c\u8bb0\u5f55\u4e86delta\u503c //lx\u3001ly\uff1a\u6807\u53f7\u6570\u7ec4\uff0c\u53c2\u89c1\u674e\u715c\u4e1c\u84dd\u4e66 //\u521d\u59cb\u5316\u6807\u53f7\u6570\u7ec4\u7684\u503c void __init ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { lx [ i ] = ly [ i ] = 0 ; for ( int j = 1 ; j <= n ; j ++ ) { lx [ i ] = max ( lx [ i ], g [ i ][ j ]); } } } bool __check ( int y , queue < int > & q ) { visy [ y ] = 1 ; if ( matchy [ y ] != 0 ) { q . push ( matchy [ y ]); visx [ matchy [ y ]] = 1 ; return false ; } while ( y != 0 ) { matchy [ y ] = pre [ y ]; swap ( y , matchx [ pre [ y ]]); } return true ; } void __bfs ( int u ) { queue < int > q ; q . push ( u ); visx [ u ] = 1 ; while ( true ) { while ( q . size ()) { int x = q . front (); q . pop (); for ( int y = 1 ; y <= n ; y ++ ) { if ( visy [ y ] == 0 ) { Ty delta = lx [ x ] + ly [ y ] - g [ x ][ y ]; if ( slack [ y ] >= delta ) { pre [ y ] = x ; if ( delta ) { slack [ y ] = delta ; } else if ( __check ( y , q )) { return ; } } } } } Ty delta = Inf ; for ( int j = 1 ; j <= n ; j ++ ) { if ( visy [ j ] == 0 ) { delta = min ( delta , slack [ j ]); } } for ( int j = 1 ; j <= n ; j ++ ) { if ( visx [ j ]) { lx [ j ] -= delta ; } if ( visy [ j ]) { ly [ j ] += delta ; } else { slack [ j ] -= delta ; } } for ( int j = 1 ; j <= n ; j ++ ) { if ( visy [ j ] == 0 && slack [ j ] == 0 && __check ( j , q )) { return ; } } } } //\u6700\u5927\u6743\u503c\u5339\u914d\u3002\u8981\u60f3\u53d6\u5f97\u6700\u5c0f\u6743\u503c\u5339\u914d\uff0c\u5c06\u6743\u503c\u53d6\u53cd\u3002 void KM () { __init ( n ); for ( int i = 1 ; i <= n ; i ++ ) { fill ( slack , slack + 1 + n , Inf ); fill ( visx , visx + 1 + n , 0 ); fill ( visy , visy + 1 + n , 0 ); __bfs ( i ); } } } using namespace KMKM ; struct J { ll x , y , z , v ; } a [ 310 ]; ll gw ( ll t , int i ) { return a [ i ]. v * a [ i ]. v * t * t + a [ i ]. z * 2 * a [ i ]. v * t ; } int main () { scanf ( \"%d\" , & n ); ll ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { // cin>>a[i].x scanf ( \"%lld\" , & a [ i ]. x ); scanf ( \"%lld\" , & a [ i ]. y ); scanf ( \"%lld\" , & a [ i ]. z ); scanf ( \"%lld\" , & a [ i ]. v ); ans += a [ i ]. x * a [ i ]. x ; ans += a [ i ]. y * a [ i ]. y ; ans += a [ i ]. z * a [ i ]. z ; } for ( int i = 1 ; i <= n ; i ++ ) //t=0~n-1 { ll t = i - 1 ; for ( int j = 1 ; j <= n ; j ++ ) { ll val = gw ( t , j ); g [ i ][ j ] =- val ; } } KM (); for ( int i = 1 ; i <= n ; i ++ ) { ans +=- g [ i ][ matchx [ i ]]; } printf ( \"%lld \\n \" , ans ); return 0 ; }","title":"KM-BFS"},{"location":"old/%E8%87%AA%E5%88%B6Template/#edmonds-karp","text":"Funs || Methods Reliance Time Complexity Inputs Outputs Description __bfs n Edges\uff1a\u6b8b\u5dee\u7f51\u7edc\u3002S\u3001T\uff1a\u6e90\u70b9\u548c\u6c47\u70b9 incf\uff1a\u6e90\u70b9\u5230\u70b9x\u7684\u6700\u5c0f\u5269\u4f59\u5bb9\u91cf\u3002pre\uff1a\u70b9x\u7684\u524d\u9a71\u6570\u7ec4 \u904d\u5386\u6b8b\u5dee\u7f51\u7edc\u627e\u5230\u6700\u957f\u589e\u5e7f\u8def\u3002 __update m Edges\uff1a\u6b8b\u5dee\u7f51\u7edc\uff1bincf\u3001pre\uff1a\u540c\u4e0a\u8f93\u51fa\u3002S\u3001T\uff1a\u6e90\u70b9\u548c\u6c47\u70b9 \u8fd4\u56de\u6b64\u6b21\u66f4\u65b0\u7684\u6d41\u91cf\u5927\u5c0f\u3002Edges\uff1a\u66f4\u65b0\u540e\u7684\u6b8b\u5dee\u7f51\u7edc\u3002 \u4ece\u6c47\u70b9t\u5f00\u59cb\u5012\u7740\u66f4\u65b0\u589e\u5e7f\u8def\u4ee5\u53ca\u53cd\u5411\u8fb9\u7684\u5269\u4f59\u5bb9\u91cf get_maxflow nm^2 s,t\uff1a\u6e90\u70b9\u4e0e\u6c47\u70b9 \u6700\u5927\u6d41\u5927\u5c0f \u53d6\u5f97\u6700\u5927\u6d41 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 //\u7f51\u7edc\u6d41\uff1aEdmonds_Karp\u7b97\u6cd5 #include <iostream> #include <queue> #include <memory.h> using namespace std ; typedef long long ll ; namespace Edges { typedef ll Ty ; const int N = 1e4 + 10 , M = 2e5 + 100 ; //public int n , m ; //n,m: \u70b9\u3001\u8fb9\u6570\u91cf //\u6b8b\u5dee\u7f51\u7edc\u7684\u8fb9 struct E { int from , to , inext ; Ty w ; } edge [ M ]; int head [ N ], total ; void adde ( int x , int y , Ty w ) { edge [ ++ total ]. from = x ; edge [ total ]. to = y ; edge [ total ]. w = w ; edge [ total ]. inext = head [ x ]; head [ x ] = total ; } } using namespace Edges ; namespace Edmonds_Karp { typedef ll Ty ; const int N = 1e4 + 10 ; //N\uff1a\u70b9\u4e2a\u6570 const Ty Inf = 1e18 ; //Inf\uff1a\u6d41\u91cf\u65e0\u7a77\u5927\u503c //public int S , T ; //S,T:\u6e90\u70b9\u548c\u6c47\u70b9 //local bool v [ N ]; //v:__bfs\u65f6\u4f7f\u7528\u7684\u6807\u8bb0\u904d\u5386\u6570\u7ec4 int pre [ N ]; //pre\uff1a__bfs\u65f6\u4f7f\u7528\u7684\u8bb0\u5f55\u74f6\u9888\u8def\u524d\u9a71\u8f6c\u79fb\u65b9\u5411\u7684\u6570\u7ec4 Ty incf [ N ]; //incf\uff1a\u589e\u5e7f\u8def //\u904d\u5386\u6b8b\u5dee\u7f51\u7edc\u627e\u5230\u6700\u957f\u589e\u5e7f\u8def\u3002\u4ece\u6c47\u70b9t\u5f00\u59cb\u5012\u7740\u66f4\u65b0\u589e\u5e7f\u8def\u4ee5\u53ca\u53cd\u5411\u8fb9\u7684\u5269\u4f59\u5bb9\u91cf bool __bfs ( int s , int t ) { memset ( v , 0 , sizeof ( v )); queue < int > q ; q . push ( s ); v [ s ] = 1 ; incf [ s ] = Inf ; while ( q . size ()) { int x = q . front (); q . pop (); for ( int e = head [ x ]; e ; e = edge [ e ]. inext ) { int y = edge [ e ]. to ; if ( edge [ e ]. w && ! v [ y ]) { incf [ y ] = min ( incf [ x ], edge [ e ]. w ); pre [ y ] = e ; v [ y ] = 1 ; q . push ( y ); if ( y == t ) return true ; } } } return false ; } //\u4ece\u6c47\u70b9t\u5f00\u59cb\u5012\u7740\u66f4\u65b0\u589e\u5e7f\u8def\u4ee5\u53ca\u53cd\u5411\u8fb9\u7684\u5269\u4f59\u5bb9\u91cf Ty __update ( int s , int t ) { int x = t ; while ( x != s ) { int e = pre [ x ]; edge [ e ]. w -= incf [ t ]; if ( e % 2 ) edge [ e + 1 ]. w += incf [ t ]; else edge [ e - 1 ]. w -= incf [ t ]; x = edge [ e ]. from ; } return incf [ t ]; } //\u53d6\u5f97\u6700\u5927\u6d41 Ty get_maxflow ( int s = S , int t = T ) { Ty maxflow = 0 ; while ( __bfs ( s , t )) maxflow += __update ( s , t ); return maxflow ; } } using namespace Edmonds_Karp ; int main () { ios :: sync_with_stdio ( false ); cin >> n >> m >> S >> T ; for ( int i = 1 ; i <= m ; i ++ ) { int x , y , w ; cin >> x >> y >> w ; adde ( x , y , w ); adde ( y , x , 0 ); } ll maxflow = get_maxflow ( S , T ); cout << maxflow << endl ; return 0 ; }","title":"\u7f51\u7edc\u6d41\uff1aEdmonds Karp"},{"location":"old/%E8%87%AA%E5%88%B6Template/#dinic","text":"\u522b\u5fd8\u4e86\u52a0\u8fb9\u7684\u65f6\u5019\u52a0\u53cd\u5411\u8fb9\u3002 10.12\u66f4\u65b0\uff1a\u73b0\u5728\u66f4\u65b0\u4e3a\u5e26\u5f53\u524d\u5f27\u4f18\u5316\u7684\u7248\u672c\uff0c\u53c2\u89c1\u6ce8\u91ca \uff08\u2b50\uff1a\u8fd9\u73a9\u610f\u8fd8\u6709\u4e2a\u6700\u77ed\u5f27\u4f18\u5316\u6211\u6ca1\u6574\u2026\u2026\u6709\u5f85\u8fdb\u4e00\u6b65\u6539\u8fdb\uff09 Funs || Methods Reliance Time Complexity Inputs Outputs Description __bfs n Edges\uff1a\u6b8b\u5dee\u7f51\u7edc\u3002S\u3001T\uff1a\u6e90\u70b9\u548c\u6c47\u70b9 d\uff1a\u5c42\u6b21\u6570\u7ec4 \u53d6\u5f97\u5f53\u524d\u6b8b\u5dee\u7f51\u7edc\u4eces\u89e6\u53d1\u7684\u5404\u4e2a\u70b9\u7684\u5c42\u6b21 __dinic n Edges\uff1a\u6b8b\u5dee\u7f51\u7edc\u3002d\uff1a\u5c42\u6b21\u6570\u7ec4\u3002S\u3001T\uff1a\u6e90\u70b9\u548c\u6c47\u70b9\u3002 \u8fd4\u56de\u6b64\u6b21\u66f4\u65b0\u7684\u6d41\u91cf\u5927\u5c0f\u3002Edges\uff1a\u66f4\u65b0\u540e\u7684\u6b8b\u5dee\u7f51\u7edc\u3002 \u5728\u5206\u5c42\u56fe\u4e0a\u66f4\u65b0\u6700\u5927\u6d41\u5e76\u8fd4\u56de\u66f4\u65b0\u503c get_maxflow (n^2)*m s,t\uff1a\u6e90\u70b9\u4e0e\u6c47\u70b9\u3002 \u6700\u5927\u6d41\u5927\u5c0f \u53d6\u5f97\u6700\u5927\u6d41 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 //\u7f51\u7edc\u6d41\uff1aDinic\u7b97\u6cd5 //\u5e26\u5f53\u524d\u5f27\u4f18\u5316 #include <iostream> #include <memory.h> #include <queue> using namespace std ; typedef long long ll ; namespace Edges { typedef ll Ty ; const int N = 1e4 + 10 , M = 2e5 + 100 ; //public int n , m ; //n,m: \u70b9\u3001\u8fb9\u6570\u91cf //\u6b8b\u5dee\u7f51\u7edc\u7684\u8fb9 struct E { int from , to , inext ; Ty w ; } edge [ M ]; int head [ N ], total ; void adde ( int x , int y , Ty w ) { edge [ ++ total ]. from = x ; edge [ total ]. to = y ; edge [ total ]. w = w ; edge [ total ]. inext = head [ x ]; head [ x ] = total ; } } using namespace Edges ; namespace Dinic { typedef ll Ty ; const int N = 1e4 + 10 ; //N\uff1a\u70b9\u4e2a\u6570 const Ty Inf = 1e18 ; //Inf\uff1a\u6d41\u91cf\u65e0\u7a77\u5927\u503c //public int S , T ; //S,T:\u6e90\u70b9\u548c\u6c47\u70b9 //local int d [ N ]; //d\uff1a\u5c42\u6b21\u6570\u7ec4 int cur_head [ N ]; // cur_head: \u7528\u4e8e\u5f53\u524d\u5f27\u4f18\u5316 //\u53d6\u5f97\u5f53\u524d\u6b8b\u5dee\u7f51\u7edc\u4eces\u89e6\u53d1\u7684\u5404\u4e2a\u70b9\u7684\u5c42\u6b21 bool __bfs ( int s , int t ) { memset ( d , 0 , sizeof ( d )); memcpy ( cur_head , head , sizeof ( head )); //\u7528\u4e8e\u5f53\u524d\u5f27\u4f18\u5316 queue < int > q ; q . push ( s ); d [ s ] = 1 ; while ( q . size ()) { int x = q . front (); q . pop (); // for (int e = head[x]; e; e = edge[e].inext) for ( int e = cur_head [ x ]; e ; e = edge [ e ]. inext ) { cur_head [ x ] = e ; //\u66f4\u65b0\u5f53\u524d\u5f27\uff1a\u539f\u56e0\u662f\u4e00\u6761\u8fb9\u589e\u5e7f\u4e00\u6b21\u540e\u5c31\u4e0d\u4f1a\u518d\u6b21\u589e\u5e7f\u4e86\uff0c\u6240\u4ee5\u4e0b\u6b21\u589e\u5e7f\u65f6\u4e0d\u9700\u8981\u518d\u8003\u8651\u8fd9\u6761\u8fb9\u3002 int y = edge [ e ]. to ; if ( edge [ e ]. w && ! d [ y ]) { q . push ( y ); d [ y ] = d [ x ] + 1 ; if ( y == t ) return true ; } } } return false ; } // \u5728\u5206\u5c42\u56fe\u4e0a\u66f4\u65b0\u6700\u5927\u6d41\u5e76\u8fd4\u56de\u66f4\u65b0\u503c Ty __dinic ( int x , Ty flow , int t ) { if ( x == t ) return flow ; Ty rest = flow , delta ; for ( int e = head [ x ]; e ; e = edge [ e ]. inext ) { if ( rest == 0 ) return flow ; //!!! if ( edge [ e ]. w && d [ edge [ e ]. to ] == d [ x ] + 1 ) { delta = __dinic ( edge [ e ]. to , min ( edge [ e ]. w , rest ), t ); if ( ! delta ) d [ edge [ e ]. to ] = 0 ; //pruning edge [ e ]. w -= delta ; if ( e % 2 ) edge [ e + 1 ]. w += delta ; else edge [ e - 1 ]. w += delta ; //+= ? rest -= delta ; } } return flow - rest ; } // \u53d6\u5f97\u6700\u5927\u6d41 Ty get_maxflow ( int s = S , int t = T ) { Ty maxflow = 0 ; while ( __bfs ( s , t )) { Ty flow ; while ( flow = __dinic ( s , Inf , t )) maxflow += flow ; } return maxflow ; } } using namespace Dinic ; int main () { ios :: sync_with_stdio ( false ); cin >> n >> m >> S >> T ; for ( int i = 1 ; i <= m ; i ++ ) { int x , y , w ; cin >> x >> y >> w ; adde ( x , y , w ); //\u522b\u5fd8\u4e86\u52a0\u53cd\u5411\u8fb9\uff01 adde ( y , x , 0 ); } ll maxflow = get_maxflow ( S , T ); cout << maxflow << endl ; return 0 ; }","title":"\u7f51\u7edc\u6d41\uff1aDinic"},{"location":"old/%E8%87%AA%E5%88%B6Template/#hlpp","text":"\u26a0\ufe0f\u6ce8\u610f\uff1a\u9700\u8981\u5c06total\u521d\u59cb\u5316\u4e3a1\u3002 Funs || Methods Reliance Time Complexity Inputs Outputs Description __ht_init n Edges\uff1a\u6b8b\u5dee\u7f51\u7edc\uff1bs\u3001t\uff1a\u6e90\u70b9\u548c\u6c47\u70b9 \u8fd4\u56de\u503c\u8868\u793as\u3001t\u662f\u5426\u8fde\u901a\u3002ht\uff1a\u9ad8\u5ea6\u6570\u7ec4\u3002 \u4ecet\u5f00\u59cb\u8ba1\u7b97\u5404\u70b9\u9ad8\u5ea6\u3002\u8fd4\u56de\u503c\u8868\u793as\u3001t\u662f\u5426\u8fde\u901a __gap_init n ht\uff1a\u9ad8\u5ea6\u6570\u7ec4\uff1bs\u3001t\uff1a\u6e90\u70b9\u548c\u6c47\u70b9 gap\uff1a\u7edf\u8ba1\u5bf9\u5e94\u9ad8\u5ea6\u4e2a\u6570\u7684\u70b9\u6570\u7684\u6570\u7ec4 \u7edf\u8ba1\u5bf9\u5e94\u9ad8\u5ea6\u4e2a\u6570\u7684\u70b9\u6570 __s_init s\u76f8\u90bb\u70b9\u6570 Edges\uff1a\u6b8b\u5dee\u7f51\u7edc\uff1bs\u3001t\uff1a\u6e90\u70b9\u548c\u6c47\u70b9 pq\uff1a\u6700\u9ad8\u6807\u53f7\u4f18\u5148\u961f\u5217\u3002vis\uff1a\u8bbf\u95ee\u6570\u7ec4\u3002 \u7528\u6e90\u70b9s\u76f8\u90bb\u7684\u70b9\u521d\u59cb\u5316\u4f18\u5148\u961f\u5217 __push u\u76f8\u90bb\u70b9\u6570 Edges\uff1a\u6b8b\u5dee\u7f51\u7edc\uff1bs\u3001t\uff1a\u6e90\u70b9\u548c\u6c47\u70b9\u3002u\uff1a\u8282\u70b9\u6807\u53f7\u3002 ex\uff1a\u8d85\u989d\u6d41\u6570\u7ec4\u3002vis\uff1a\u8bbf\u95ee\u6570\u7ec4\uff08\u662f\u5426\u5728\u4f18\u5148\u961f\u5217\u4e2d\uff09\u3002Edges\uff1a\u6b8b\u5dee\u7f51\u7edc\u3002 \u5c06\u70b9u\u5411\u7740\u76f8\u90bb\u70b9\u63a8\u9001\u8d85\u989d\u6d41 __relabel u\u76f8\u90bb\u70b9\u6570 Edges\uff1a\u6b8b\u5dee\u7f51\u7edc\uff1bht\uff1a\u9ad8\u5ea6\u6570\u7ec4\uff1bu\uff1a\u8282\u70b9\u6807\u53f7\u3002 ht\uff1a\u9ad8\u5ea6\u6570\u7ec4 \u4e3a\u70b9u\u91cd\u8d34\u9ad8\u5ea6\u6807\u7b7e get_maxflow n^2*sqrt(m) s,t\uff1a\u6e90\u70b9\u4e0e\u6c47\u70b9 \u6700\u5927\u6d41\u5927\u5c0f \u53d6\u5f97\u6700\u5927\u6d41 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 #include <iostream> #include <memory.h> #include <queue> using namespace std ; typedef long long ll ; namespace Edges { typedef ll Ty ; const int N = 2e4 + 10 , M = 4e5 + 100 ; //public int n , m ; //n,m: \u70b9\u3001\u8fb9\u6570\u91cf //\u6b8b\u5dee\u7f51\u7edc\u7684\u8fb9 struct E { int from , to , inext ; Ty w ; } edge [ M ]; int head [ N ], total = 1 ; //total\uff1a\u5e94\u5f53\u521d\u59cb\u5316\u4e3a1 void adde ( int x , int y , Ty w ) { edge [ ++ total ]. from = x ; edge [ total ]. to = y ; edge [ total ]. w = w ; edge [ total ]. inext = head [ x ]; head [ x ] = total ; } } using namespace Edges ; namespace HLPP { typedef ll Ty ; const int N = 2e4 + 10 ; //N\uff1a\u70b9\u4e2a\u6570 const int Inf2 = 0x3f3f3f3f ; //inf2\uff1a\u9ad8\u5ea6\u65e0\u7a77\u5927\u503c const Ty Inf = 1e18 ; //Inf\uff1a\u6d41\u91cf\u65e0\u7a77\u5927\u503c //public int S , T ; //S,T:\u6e90\u70b9\u548c\u6c47\u70b9 //local int ht [ N ], gap [ N ]; //ht, gap\uff1a\u9ad8\u5ea6\u548c\u7edf\u8ba1\u5bf9\u5e94\u9ad8\u5ea6\u6709\u591a\u5c11\u4e2a\u6570\u7684gap\u6570\u7ec4 Ty ex [ N ]; //ex\uff1a\u8d85\u989d\u6d41 bool vis [ N ]; //vis\uff1a\u6807\u8bb0\u67d0\u70b9\u662f\u5426\u88ab\u904d\u5386 struct __cmp { bool operator ()( int a , int b ) const { return ht [ a ] < ht [ b ]; } }; //\u4f2a\u88c5\u6bd4\u8f83\u51fd\u6570\u7c7b priority_queue < int , vector < int > , __cmp > pq ; //pq\uff1a\u4f18\u5148\u961f\u5217\uff0c\u7528\u4e8e\u53d6\u51fa\u6700\u5927\u6807\u53f7\u7684\u70b9 //\u4ecet\u5f00\u59cb\u8ba1\u7b97\u5404\u70b9\u9ad8\u5ea6\u3002\u8fd4\u56de\u503c\u8868\u793as\u3001t\u662f\u5426\u8fde\u901a bool __ht_init ( int s = S , int t = T ) { memset ( ht , 0x3f , sizeof ( ht )); queue < int > q ; q . push ( t ); ht [ t ] = 0 ; while ( q . size ()) { int u = q . front (); q . pop (); for ( int e = head [ u ]; e ; e = edge [ e ]. inext ) { int y = edge [ e ]. to ; if ( edge [ e ^ 1 ]. to && ht [ y ] > ht [ u ] + 1 ) { ht [ y ] = ht [ u ] + 1 ; q . push ( y ); } } } return ht [ s ] != Inf2 ; } //\u7edf\u8ba1\u5bf9\u5e94\u9ad8\u5ea6\u4e2a\u6570\u7684\u70b9\u6570 void __gap_init () { memset ( gap , 0 , sizeof ( gap )); for ( int i = 1 ; i <= n ; i ++ ) { if ( ht [ i ] != Inf2 ) { gap [ ht [ i ]] ++ ; } } } //\u7528\u6e90\u70b9s\u76f8\u90bb\u7684\u70b9\u521d\u59cb\u5316\u4f18\u5148\u961f\u5217 void __s_init ( int s = S , int t = T ) { memset ( ex , 0 , sizeof ( ex )); for ( int e = head [ s ]; e ; e = edge [ e ]. inext ) { int y = edge [ e ]. to ; Ty w = edge [ e ]. w ; if ( w == 0 ) continue ; ex [ s ] -= w ; ex [ y ] += w ; edge [ e ]. w -= w ; edge [ e ^ 1 ]. w += w ; if ( y != s && y != t && vis [ y ] == 0 ) { pq . push ( y ); vis [ y ] = true ; } } } //\u5c06\u70b9u\u5411\u7740\u76f8\u90bb\u70b9\u63a8\u9001\u8d85\u989d\u6d41 bool __push ( int u , int s = S , int t = T ) { for ( int e = head [ u ]; e ; e = edge [ e ]. inext ) { int y = edge [ e ]. to ; Ty w = edge [ e ]. w ; if ( w == 0 || ht [ u ] != ht [ y ] + 1 ) continue ; Ty k = min ( w , ex [ u ]); ex [ u ] -= k ; ex [ y ] += k ; edge [ e ]. w -= k ; edge [ e ^ 1 ]. w += k ; if ( y != s && y != t && vis [ y ] == 0 ) { pq . push ( y ); vis [ y ] = true ; } if ( ex [ u ] == 0 ) { return false ; } } return true ; } // \u4e3a\u70b9u\u91cd\u8d34\u9ad8\u5ea6\u6807\u7b7e void __relabel ( int u ) { ht [ u ] = Inf2 ; for ( int e = head [ u ]; e ; e = edge [ e ]. inext ) { int y = edge [ e ]. to ; Ty w = edge [ e ]. w ; if ( w ) { ht [ u ] = min ( ht [ u ], ht [ y ] + 1 ); } } //ht[u]++; } //\u53d6\u5f97\u6700\u5927\u6d41 Ty get_maxflow ( int s = S , int t = T ) { if ( __ht_init ( s , t ) == 0 ) // \u56fe\u4e0d\u8fde\u901a return 0 ; ht [ s ] = n ; //\u521d\u59cb\u5316s\u7684\u9ad8\u5ea6 while ( pq . size ()) { //\u6e05\u7a7a\u961f\u5217 pq . pop (); } __gap_init (); __s_init ( s , t ); while ( pq . size ()) { int u = pq . top (); pq . pop (); vis [ u ] = 0 ; while ( __push ( u , s , t )) { if ( -- gap [ ht [ u ]] == 0 ) { for ( int i = 1 ; i <= n ; i ++ ) { //gap optimization //\u5728\u7b97\u6cd5\u7684\u67d0\u4e00\u65f6\u523b\uff0ch(u)=t \u7684\u7ed3\u70b9\u4e2a\u6570\u4e3a0\uff0c\u90a3\u4e48\u5bf9\u4e8eh(i)>t\u7684\u7ed3\u70b9i\u5c31\u6c38\u8fdc\u65e0\u6cd5\u63a8\u9001\u8d85\u989d\u6d41\u5230t\uff0c\u56e0\u6b64\u53ea\u80fd\u9001\u56des\uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u5728\u8fd9\u65f6\u76f4\u63a5\u8ba9\u4ed6\u4eec\u7684\u9ad8\u5ea6\u53d8\u6210n+1\uff0c\u4ee5\u5c3d\u5feb\u63a8\u9001\u56des\uff0c\u51cf\u5c11\u91cd\u8d34\u6807\u7b7e\u7684\u64cd\u4f5c\u3002 if ( i != s && i != t && ht [ i ] > ht [ u ] && ht [ i ] < n + 1 ) { ht [ i ] = n + 1 ; } } } __relabel ( u ); gap [ ht [ u ]] ++ ; } } return ex [ t ]; } } int main () { ios :: sync_with_stdio ( false ); cin >> n >> m >> HLPP :: S >> HLPP :: T ; for ( int i = 1 ; i <= m ; i ++ ) { int x , y ; ll w ; cin >> x >> y >> w ; adde ( x , y , w ); //\u522b\u5fd8\u4e86\u52a0\u53cd\u5411\u8fb9\uff01 adde ( y , x , 0 ); } ll maxflow = HLPP :: get_maxflow ( HLPP :: S , HLPP :: T ); cout << maxflow << endl ; return 0 ; }","title":"\u7f51\u7edc\u6d41\uff1aHLPP\uff08\u6700\u9ad8\u6807\u53f7\u9884\u6d41\u63a8\u8fdb\u7b97\u6cd5\uff09"},{"location":"old/%E8%87%AA%E5%88%B6Template/#mcmfek","text":"\u26a0\ufe0f\u6ce8\u610f\uff1a\u8fd9\u73a9\u610f\u4e0d\u80fd\u76f4\u63a5\u7528\u4e8e\u6709\u8d1f\u73af\uff08\u8d39\u7528\u8d1f\u73af\uff09\u7684\u56fe\u4e2d\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 //\u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41 #include <iostream> #include <memory.h> #include <queue> #include <utility> using namespace std ; typedef long long ll ; namespace Edges { typedef int Ty ; const int N = 5e3 + 10 , M = 1.2e5 + 100 ; //public int n , m ; //n,m: \u70b9\u3001\u8fb9\u6570\u91cf //\u6b8b\u5dee\u7f51\u7edc\u7684\u8fb9 struct E { int from , to , inext ; Ty w , c ; //w:\u6d41\u91cf, c: \u5355\u4f4d\u8d39\u7528 } edge [ M ]; int head [ N ], total ; void adde ( int x , int y , Ty w , Ty c ) { edge [ ++ total ]. from = x ; edge [ total ]. to = y ; edge [ total ]. w = w ; edge [ total ]. c = c ; edge [ total ]. inext = head [ x ]; head [ x ] = total ; } } using namespace Edges ; namespace MCMF_EK { typedef int Ty ; const int N = 5e3 + 10 ; //N\uff1a\u70b9\u4e2a\u6570 const Ty Inf = 0x3f3f3f3f ; //Inf\uff1a\u6d41\u91cf\u65e0\u7a77\u5927\u503c // const int Inf2=0x3f3f3f3f; //inf2\uff1a\u5c42\u6b21\u65e0\u7a77\u5927\u503c //public int S , T ; //S,T: \u6e90\u70b9\u3001\u6c47\u70b9 //local bool v [ N ]; int pre [ N ]; Ty incf [ N ], d [ N ]; //incf\uff1a\u589e\u5e7f\u8def, //v:__spfa\u65f6\u4f7f\u7528\u7684\u6807\u8bb0\u5728\u961f\u5217\u4e2d\u6570\u7ec4, //pre\uff1a__bfs\u65f6\u4f7f\u7528\u7684\u8bb0\u5f55\u74f6\u9888\u8def\u524d\u9a71\u8f6c\u79fb\u65b9\u5411\u7684\u6570\u7ec4, //d: spfa\u6700\u77ed\u8def bool __spfa ( int s = S , int t = T ) { queue < int > q ; // memset(d,0x3f,sizeof(d)); //c //memset(v,0,sizeof(v)); for ( int i = 1 ; i <= n ; i ++ ) //\u6ce8\u610f\u8fd9\u4e2a\u5730\u65b9\u7684n\u53ef\u80fd\u8981\u6539 { d [ i ] = Inf ; //\u6ce8\u610f\u8fd9\u4e2a\u6e05\u7a7a\u4e0d\u80fd\u4f7f\u7528Inf2\uff0c\u56e0\u4e3ad\u7684\u503c\u4e0d\u518d\u662f\u5c42\u6b21\u800c\u662f\u8d39\u7528\u6700\u77ed\u8def\u957f\u5ea6\u4e86 v [ i ] = 0 ; } q . push ( s ); d [ s ] = 0 ; v [ s ] = 1 ; incf [ s ] = Inf ; while ( q . size ()) { int x = q . front (); q . pop (); v [ x ] = 0 ; for ( int e = head [ x ]; e ; e = edge [ e ]. inext ) { int y = edge [ e ]. to ; if ( edge [ e ]. w && d [ y ] > d [ x ] + edge [ e ]. c ) { d [ y ] = d [ x ] + edge [ e ]. c ; incf [ y ] = min ( incf [ x ], edge [ e ]. w ); pre [ y ] = e ; if ( ! v [ y ]) { v [ y ] = 1 ; q . push ( y ); } } } } if ( d [ t ] == Inf ) return false ; //no connect return true ; } Ty __update ( Ty & maxflow , int s = S , int t = T ) { int x = t ; while ( x != s ) { int e = pre [ x ]; edge [ e ]. w -= incf [ t ]; if ( e % 2 ) edge [ e + 1 ]. w += incf [ t ]; else edge [ e -1 ]. w += incf [ t ]; x = edge [ e ]. from ; } maxflow += incf [ t ]; return incf [ t ] * d [ t ]; } auto get_mcmf ( int s = S , int t = T ) { Ty maxflow = 0 , cost = 0 ; while ( __spfa ( s , t )) { cost += __update ( maxflow , s , t ); } return make_pair ( maxflow , cost ); } } int main () { ios :: sync_with_stdio ( false ); cin >> n >> m >> MCMF_EK :: S >> MCMF_EK :: T ; for ( int i = 1 ; i <= m ; i ++ ) { int x , y ; ll w , c ; cin >> x >> y >> w >> c ; adde ( x , y , w , c ); //! adde ( y , x , 0 , - c ); //! } auto ans = MCMF_EK :: get_mcmf (); cout << ans . first << \" \" << ans . second << endl ; return 0 ; }","title":"\u2b50\u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41\uff08MCMF\uff09\uff1aEK"},{"location":"old/%E8%87%AA%E5%88%B6Template/#zkw","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <cstdlib> #include <algorithm> #include <string> #include <vector> #include <map> #include <unordered_map> #include <set> #include <unordered_set> #include <queue> using namespace std ; typedef long long ll ; namespace Edges { typedef int Ty ; const int N = 5e3 + 10 , M = 1.2e5 + 10 ; //public int n , m ; //n,m: \u70b9\u3001\u8fb9\u6570\u91cf //\u6b8b\u5dee\u7f51\u7edc\u7684\u8fb9 struct E { int from , to , inext ; Ty w , c ; } edge [ M ]; int head [ N ], total ; void adde ( int x , int y , Ty w , Ty c ) { edge [ ++ total ]. from = x ; edge [ total ]. to = y ; edge [ total ]. w = w ; edge [ total ]. c = c ; edge [ total ]. inext = head [ x ]; head [ x ] = total ; } } using namespace Edges ; namespace MCMF_ZKW { typedef int Ty ; const int N = 5e3 + 10 ; //N\uff1a\u70b9\u4e2a\u6570 const Ty Inf = 0x3f3f3f3f ; //Inf\uff1a\u6d41\u91cf\u65e0\u7a77\u5927\u503c // const int Inf2=0x3f3f3f3f; //inf2\uff1a\u5c42\u6b21\u65e0\u7a77\u5927\u503c //public int S , T ; //S,T: \u6e90\u70b9\u3001\u6c47\u70b9 //local bool v [ N ]; Ty d [ N ]; //incf\uff1a\u589e\u5e7f\u8def //d: spfa\u6700\u77ed\u8def //\u4f7f\u7528SLF\u4f18\u5316\u7684spfa\u5bfb\u627e\u5206\u5c42\u56fe bool __spfa ( int s = S , int t = T ) { deque < int > q ; // memset(d,0x3f,sizeof(d)); //c //memset(v,0,sizeof(v)); for ( int i = 1 ; i <= n ; i ++ ) { d [ i ] = Inf ; //\u6ce8\u610f\u8fd9\u4e2a\u6e05\u7a7a\u4e0d\u80fd\u4f7f\u7528Inf2\uff0c\u56e0\u4e3ad\u7684\u503c\u4e0d\u518d\u662f\u5c42\u6b21\u800c\u662f\u8d39\u7528\u6700\u77ed\u8def\u957f\u5ea6\u4e86 v [ i ] = 0 ; } q . push_back ( s ); d [ s ] = 0 ; v [ s ] = 1 ; while ( q . size ()) { int x = q . front (); q . pop_front (); v [ x ] = 0 ; for ( int e = head [ x ]; e ; e = edge [ e ]. inext ) { int y = edge [ e ]. to ; if ( edge [ e ]. w > 0 && d [ y ] > d [ x ] + edge [ e ]. c ) { d [ y ] = d [ x ] + edge [ e ]. c ; if ( ! v [ y ]) { v [ y ] = 1 ; if ( q . size () && d [ y ] < d [ q . front ()]) { q . push_front ( y ); } else q . push_back ( y ); } } } } //no connect return d [ t ] < Inf ; } //\u4f7f\u7528dinic\u7b97\u6cd5\u63a8\u9001\u6d41\u3002\u8fd4\u56de\u7684\u662f\u6d41\u7684\u6539\u53d8\u91cf\u3002 Ty __dinic ( int x , int t , Ty flow , Ty & maxflow , Ty & cost ) { if ( x == t ) { maxflow += flow ; return flow ; } Ty rest = flow , delta ; v [ x ] = true ; for ( int e = head [ x ]; e ; e = edge [ e ]. inext ) { if ( rest == 0 ) return flow ; //!!! int y = edge [ e ]. to ; if ( v [ y ]) continue ; if ( edge [ e ]. w > 0 && d [ y ] == d [ x ] + edge [ e ]. c ) { delta = __dinic ( y , t , min ( edge [ e ]. w , rest ), maxflow , cost ); if ( ! delta ) d [ y ] = 0 ; //pruning edge [ e ]. w -= delta ; if ( e % 2 ) edge [ e + 1 ]. w += delta ; else edge [ e - 1 ]. w += delta ; //+= ? cost += delta * edge [ e ]. c ; //\u66f4\u65b0\u8d39\u7528 rest -= delta ; } } return flow - rest ; } //\u53d6\u5f97\u6700\u5927\u6d41\u6700\u5c0f\u8d39\u7528 auto get_mcmf ( int s = S , int t = T ) { Ty maxflow = 0 , cost = 0 ; while ( __spfa ( s , t )) { // cost+=__update(maxflow,s,t); __dinic ( s , t , Inf , maxflow , cost ); } return make_pair ( maxflow , cost ); } } int main () { ios :: sync_with_stdio ( false ); cin >> n >> m >> MCMF_ZKW :: S >> MCMF_ZKW :: T ; for ( int i = 1 ; i <= m ; i ++ ) { int x , y ; ll w , c ; cin >> x >> y >> w >> c ; adde ( x , y , w , c ); //! adde ( y , x , 0 , - c ); //! } auto ans = MCMF_ZKW :: get_mcmf (); cout << ans . first << \" \" << ans . second << endl ; return 0 ; }","title":"ZKW \u8d39\u7528\u6d41"},{"location":"old/%E8%87%AA%E5%88%B6Template/#vector","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <cstdlib> #include <algorithm> #include <string> #include <vector> #include <map> #include <unordered_map> #include <set> #include <unordered_set> #include <queue> using namespace std ; typedef long long ll ; namespace Edges { typedef ll Ty ; const int N = 5e5 + 10 , M = 1e6 + 10 ; //public int n , m ; //n,m: \u70b9\u3001\u8fb9\u6570\u91cf //\u6b8b\u5dee\u7f51\u7edc\u7684\u8fb9 struct E { int from , to ; Ty w , c ; int dualedge_num ; }; // int head[N], total; int total ; vector < E > head [ N ]; int adde ( int x , int y , Ty w , Ty c ) { ++ total ; // edge[++total].from = x; // edge[total].to = y; // edge[total].w = w; // edge[total].c=c; // edge[total].inext = head[x]; // head[x] = total; // head[x].emplace_back(x,y,w,c); head [ x ]. push_back ({ x , y , w , c }); return head [ x ]. size () -1 ; } void adde2 ( int x , int y , Ty w , Ty c ) { int dual1 = adde ( x , y , w , c ); int dual2 = adde ( y , x , 0 , - c ); head [ x ]. back (). dualedge_num = dual2 ; head [ y ]. back (). dualedge_num = dual1 ; } } using namespace Edges ; #include <bitset> namespace MCMF_ZKW { typedef ll Ty ; const int N = 5e5 + 10 ; //N\uff1a\u70b9\u4e2a\u6570 const Ty Inf = 1e18 ; //Inf\uff1a\u6d41\u91cf\u65e0\u7a77\u5927\u503c // const int Inf2=0x3f3f3f3f; //inf2\uff1a\u5c42\u6b21\u65e0\u7a77\u5927\u503c //public int S , T ; //S,T: \u6e90\u70b9\u3001\u6c47\u70b9 //local // bool v[N]; bitset < N > v ; Ty d [ N ]; //incf\uff1a\u589e\u5e7f\u8def //d: spfa\u6700\u77ed\u8def //\u4f7f\u7528SLF\u4f18\u5316\u7684spfa\u5bfb\u627e\u5206\u5c42\u56fe bool __spfa ( int s = S , int t = T ) { queue < int > q ; // memset(d,0x3f,sizeof(d)); //c //memset(v,0,sizeof(v)); fill ( d + 1 , d + 1 + n , Inf ); // fill(v+1,v+1+n,0); for ( int i = 1 ; i <= n ; i ++ ) { // d[i]=Inf; //\u6ce8\u610f\u8fd9\u4e2a\u6e05\u7a7a\u4e0d\u80fd\u4f7f\u7528Inf2\uff0c\u56e0\u4e3ad\u7684\u503c\u4e0d\u518d\u662f\u5c42\u6b21\u800c\u662f\u8d39\u7528\u6700\u77ed\u8def\u957f\u5ea6\u4e86 v [ i ] = 0 ; } q . push ( s ); d [ s ] = 0 ; v [ s ] = 1 ; while ( q . size ()) { int x = q . front (); q . pop (); v [ x ] = 0 ; // for(int e=head[x];e;e=edge[e].inext) for ( auto & e : head [ x ]) { // int y=edge[e].to; int y = e . to ; // if(edge[e].w>0 && d[y]>d[x]+edge[e].c) if ( e . w > 0 && d [ y ] > d [ x ] + e . c ) { // d[y]=d[x]+edge[e].c; d [ y ] = d [ x ] + e . c ; if ( ! v [ y ]) { v [ y ] = 1 ; // if(q.size() && d[y]<d[q.front()]) // { // q.push_front(y); // } // else q . push ( y ); } } } } //no connect return d [ t ] < Inf ; } //\u4f7f\u7528dinic\u7b97\u6cd5\u63a8\u9001\u6d41\u3002\u8fd4\u56de\u7684\u662f\u6d41\u7684\u6539\u53d8\u91cf\u3002 Ty __dinic ( int x , int t , Ty flow , Ty & maxflow , Ty & cost ) { if ( x == t ) { maxflow += flow ; return flow ; } Ty rest = flow , delta ; v [ x ] = true ; // for (int e = head[x]; e; e = edge[e].inext) for ( auto & e : head [ x ]) { if ( rest == 0 ) return flow ; //!!! // int y=edge[e].to; int y = e . to ; if ( v [ y ]) continue ; // if (edge[e].w>0 && d[y] == d[x] + edge[e].c) if ( e . w > 0 && d [ y ] == d [ x ] + e . c ) { // delta = __dinic(y, t, min(edge[e].w, rest), maxflow, cost); delta = __dinic ( y , t , min ( e . w , rest ), maxflow , cost ); if ( ! delta ) d [ y ] = 0 ; //pruning // edge[e].w -= delta; e . w -= delta ; // if (e % 2) // edge[e + 1].w += delta; // else // edge[e - 1].w += delta; //+= ? head [ y ][ e . dualedge_num ]. w += delta ; // cost+= delta*edge[e].c; //\u66f4\u65b0\u8d39\u7528 cost += delta * e . c ; rest -= delta ; } } return flow - rest ; } //\u53d6\u5f97\u6700\u5927\u6d41\u6700\u5c0f\u8d39\u7528 auto get_mcmf ( int s = S , int t = T ) { Ty maxflow = 0 , cost = 0 ; while ( __spfa ( s , t )) { // cost+=__update(maxflow,s,t); __dinic ( s , t , Inf , maxflow , cost ); } return make_pair ( maxflow , cost ); } } ll nn , a , b , c ; namespace Fast_IO { char __nc () { static char buf [ 1000000 ], * p = buf , * q = buf ; return p == q && ( q = ( p = buf ) + fread ( buf , 1 , 1000000 , stdin ), p == q ) ? EOF : * p ++ ; } template < typename T > inline void read ( T & x ) { char c ; int sgn = 1 ; x = 0 ; c = __nc (); while ( c > '9' || c < '0' ) { if ( c == '-' ) sgn = -1 ; c = __nc (); } while ( c <= '9' && c >= '0' ) { x = ( x << 3 ) + ( x << 1 ) + ( c - '0' ); c = __nc (); } x *= sgn ; } template < typename T > inline void print ( T x ) { if ( x < 0 ) { putchar ( '-' ); x = - x ; } if ( x > 9 ) { print ( x / 10 ); } putchar ( x % 10 + '0' ); } void readstr ( char * a ) { char c ; c = __nc (); while ( ! ( c <= 'z' && c >= 'a' )) c = __nc (); while ( c <= 'z' && c >= 'a' ) { * a = c ; a ++ ; c = __nc (); } } } // namespace Fast_IO using namespace Fast_IO ; int main () { // ios::sync_with_stdio(false); // cin.tie(0); // cout.tie(0); // cin>>nn>>a>>b>>c; read ( nn ); read ( a ); read ( b ); read ( c ); MCMF_ZKW :: S = nn + 2 ; MCMF_ZKW :: T = nn + 1 ; n = nn + 5 ; for ( int i = 1 ; i <= nn ; i ++ ) { ll ai , bi , ci ; // cin>>ai>>bi>>ci; read ( ai ); read ( bi ); read ( ci ); // adde2(nn+1,i,1,0); adde2 ( i , nn + 1 , 1 , 0 ); adde2 ( nn + 3 , i , 1 , - ai ); adde2 ( nn + 4 , i , 1 , - bi ); adde2 ( nn + 5 , i , 1 , - ci ); } adde2 ( nn + 2 , nn + 3 , a , 0 ); adde2 ( nn + 2 , nn + 4 , b , 0 ); adde2 ( nn + 2 , nn + 5 , c , 0 ); auto ans = MCMF_ZKW :: get_mcmf (); // cout<<-ans.second<<endl; print ( - ans . second ); // cin>>n>>m>>MCMF_ZKW::S>>MCMF_ZKW::T; // for(int i=1;i<=m;i++) // { // int x,y; // ll w,c; // cin>>x>>y>>w>>c; // adde(x,y,w,c); //! // adde(y,x,0,-c); //! // } // auto ans=MCMF_ZKW::get_mcmf(); // cout<<ans.first<<\" \"<<ans.second<<endl; return 0 ; }","title":"\u4f7f\u7528vector\u7684\u7248\u672c\uff0c\u5e38\u6570\u662f\u524d\u8005\u7684\u4e00\u534a\u5de6\u53f3"},{"location":"old/%E8%87%AA%E5%88%B6Template/#_42","text":"\u7b80\u8981\u539f\u7406\uff1a\u4ece\u6bcf\u4e2a\u5c1a\u672a\u5339\u914d\u7684\u70b9\u51fa\u53d1\u53bb\u5bfb\u627e\u589e\u5e7f\u8def\uff0c\u5982\u679c\u627e\u5230\u4e86\u5c31\u53cd\u8f6c\u3002\u4ea4\u66ff\u5730\u628a\u5339\u914d\u8fb9\u7684\u4e24\u7aef\u7684\u70b9\u6807\u8bb0\u6210o\u3001i\uff0c\u4eceo\u6807\u8bb0\u51fa\u53d1\u7684\u5982\u679c\u9047\u5230\u4e86o\uff0c\u8868\u660e\u9047\u5230\u4e86\u5947\u73af\uff0c\u5219\u6267\u884c\u7f29\u82b1\u64cd\u4f5c\uff1alca\u627e\u6839\uff0c\u7136\u540e\u6807\u8bb0\u6240\u6709\u73af\u4e0a\u7684\u70b9\u5bf9\u5e94\u7684\u82b1\u6839\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 // luogu 6113 #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <cstdlib> #include <algorithm> #include <string> #include <vector> #include <map> #include <unordered_map> #include <set> #include <unordered_set> #include <queue> #include <cassert> #include <random> #include <chrono> using namespace std ; typedef long long ll ; // graph namespace Blossom_Algorithm { template < typename T > class graph { public : struct edge { int from ; int to ; T cost ; }; vector < edge > edges ; vector < vector < int >> g ; int n ; graph ( int _n ) : n ( _n ) { g . resize ( n ); } virtual int add ( int from , int to , T cost ) = 0 ; }; // undirectedgraph template < typename T > class undirectedgraph : public graph < T > { public : using graph < T >:: edges ; //edges\uff1a\u8fb9\u8868 using graph < T >:: g ; //g\uff1a\u90bb\u63a5\u8868\uff0c\u4fdd\u5b58\u7684\u662f\u8fb9\u7684\u6807\u53f7 using graph < T >:: n ; undirectedgraph ( int _n ) : graph < T > ( _n ) {} int add ( int from , int to , T cost = 1 ) { assert ( 0 <= from && from < n && 0 <= to && to < n ); //\u6807\u53f7\u8303\u56f4\uff1a0~n-1 int id = ( int ) edges . size (); g [ from ]. push_back ( id ); g [ to ]. push_back ( id ); edges . push_back ({ from , to , cost }); return id ; } }; // blossom / find_max_unweighted_matching template < typename T > vector < int > find_max_unweighted_matching ( const undirectedgraph < T > & g ) { std :: mt19937 rng ( chrono :: steady_clock :: now (). time_since_epoch (). count ()); vector < int > match ( g . n , -1 ); // match\uff1a\u5339\u914d vector < int > aux ( g . n , -1 ); // aux\uff1a\u65f6\u95f4\u6233\u8bb0 vector < int > label ( g . n ); // label\uff1a\"o\" or \"i\"\uff0c\u7528\u4e8e\u5728\u627e\u589e\u5e7f\u8def\u65f6\u786e\u8ba4\u5947\u73af vector < int > orig ( g . n ); // orig\uff1a\u82b1\u6839 vector < int > parent ( g . n , -1 ); // parent\uff1a\u7236\u8282\u70b9 queue < int > q ; int aux_time = -1 ; //\u5bfb\u627e\uff08\u5df2\u7ecf\u6709\u7f29\u82b1\uff09\u56fe\u7684\u4e24\u4e2a\u82b1\u6839\u7684LCA auto lca = [ & ]( int v , int u ) { aux_time ++ ; //\u6bcf\u6b21\u8c03\u7528\u65f6\u90fd\u4ee3\u8868\u5b58\u5728\u4e00\u4e2a\u80fd\u7f29\u7684\u82b1\uff0c\u56e0\u6b64\u76f8\u5f53\u4e8e\u82b1\u7684\u7f16\u53f7\u4e86 //\u4e24\u4e2a\u70b9\u8f6e\u6d41\u4ea4\u66ff\u5411\u524d\u8df3\uff0c\u649e\u5230\u8bbf\u95ee\u8fc7\u7684\u70b9\u5c31\u8868\u660e\u662flca\u4e86 while ( true ) { if ( v != -1 ) { if ( aux [ v ] == aux_time ) { // \u627e\u5230\u62dc\u8bbf\u8fc7\u7684\u70b9 \u4e5f\u5c31\u662fLCA return v ; } aux [ v ] = aux_time ; if ( match [ v ] == -1 ) { v = -1 ; } else { v = orig [ parent [ match [ v ]]]; // \u4ee5\u5339\u914d\u70b9\u7684\u7236\u8282\u70b9\u7ee7\u7eed\u5bfb\u627e } } swap ( v , u ); } }; // lca //\u4ee5a\u4e3a\u6839\u7684\u82b1\u8fdb\u884c\u7f29\u82b1\uff08\u6ce8\u610f\u8fd9\u4e24\u4e2a\u70b9u\u3001v\u90fd\u662fo\u578b\u70b9\uff09 auto blossom = [ & ]( int v , int u , int a ) { while ( orig [ v ] != a ) { parent [ v ] = u ; u = match [ v ]; if ( label [ u ] == 1 ) { // \u521d\u59cb\u70b9\u8bbe\u4e3a\"o\" \u627e\u589e\u5e7f\u8def\uff08\u76f8\u5f53\u4e8e\u7f29\u82b1\u540e\u5c31\u65e0\u89c6\u4e86\u4ed6\u672c\u6765\u7684oi\u6807\u8bb0\u4e86\uff0ci\u578b\u70b9\u4e5f\u5168\u90e8\u6539\u6210o\u578b\u70b9\uff09 label [ u ] = 0 ; q . push ( u ); } orig [ v ] = orig [ u ] = a ; // \u7f29\u82b1 v = parent [ u ]; } }; // blossom //\u5f97\u5230\u4e86\u589e\u5e7f\u8def\u5e76\u53cd\u8f6c auto augment = [ & ]( int v ) { while ( v != -1 ) { int pv = parent [ v ]; int next_v = match [ pv ]; match [ v ] = pv ; match [ pv ] = v ; v = next_v ; } }; // augment //bfs\u6765\u5bfb\u627e\u589e\u5e7f\u8def\u5e76\u53cd\u8f6c\u4e4b\u4ee5\u5b9e\u73b0\u5339\u914d auto bfs = [ & ]( int root ) { fill ( label . begin (), label . end (), -1 ); iota ( orig . begin (), orig . end (), 0 ); while ( ! q . empty ()) { q . pop (); } q . push ( root ); // \u521d\u59cb\u70b9\u8bbe\u4e3a \"o\", \u8fd9\u91cc\u4ee5\"0\"\u4ee3\u66ff\"o\", \"1\"\u4ee3\u66ff\"i\" label [ root ] = 0 ; while ( ! q . empty ()) { int v = q . front (); q . pop (); for ( int id : g . g [ v ]) { auto & e = g . edges [ id ]; int u = e . from ^ e . to ^ v ; //e.from == v\uff0c\u6240\u4ee5\u5f02\u6216\u51fa\u6765\u5e94\u8be5\u4e00\u5b9a\u662fe.to\uff0c\u4e0d\u77e5\u9053\u4e3a\u4ec0\u4e48\u8981\u8fd9\u4e48\u5199\u2026\u2026 if ( label [ u ] == -1 ) { // \u627e\u5230\u672a\u62dc\u8bbf\u70b9 label [ u ] = 1 ; // \u6807\u8bb0 \"i\" parent [ u ] = v ; //\u5bf9\u6807\u8bb0\u4e3ai\u7684\u70b9\u4fdd\u5b58parent\uff08\u76f8\u5f53\u4e8e\u672a\u5339\u914d\u8fb9\u7684\u53cd\u5411\u8fde\u63a5\uff09 if ( match [ u ] == -1 ) { // \u627e\u5230\u672a\u5339\u914d\u70b9 augment ( u ); // \u5bfb\u627e\u589e\u5e7f\u8def\u5f84 return true ; } // \u627e\u5230\u5df2\u5339\u914d\u70b9 \u5c06\u4e0e\u5979\u5339\u914d\u7684\u70b9\u4e22\u5165queue \u5ef6\u4f38\u4ea4\u9519\u6811 label [ match [ u ]] = 0 ; q . push ( match [ u ]); continue ; } else if ( label [ u ] == 0 && orig [ v ] != orig [ u ]) { // \u627e\u5230\u5df2\u62dc\u8bbf\u70b9 \u4e14\u6807\u8bb0\u540c\u4e3a\"o\" \u4ee3\u8868\u627e\u5230\"\u82b1\" int a = lca ( orig [ v ], orig [ u ]); // \u627eLCA \u7136\u540e\u7f29\u82b1 blossom ( u , v , a ); blossom ( v , u , a ); } } } return false ; }; // bfs //\u968f\u673a\u6253\u4e71\u5e76\u5339\u914d auto greedy = [ & ]() { vector < int > order ( g . n ); // \u968f\u673a\u6253\u4e71 order iota ( order . begin (), order . end (), 0 ); shuffle ( order . begin (), order . end (), rng ); // \u5c06\u53ef\u4ee5\u5339\u914d\u7684\u70b9\u5339\u914d for ( int i : order ) { if ( match [ i ] == -1 ) { for ( auto id : g . g [ i ]) { auto & e = g . edges [ id ]; int to = e . from ^ e . to ^ i ; //\uff1f\uff1f\uff1f if ( match [ to ] == -1 ) { match [ i ] = to ; match [ to ] = i ; break ; } } } } }; // greedy // \u4e00\u5f00\u59cb\u5148\u968f\u673a\u5339\u914d greedy (); // \u5bf9\u672a\u5339\u914d\u70b9\u627e\u589e\u5e7f\u8def for ( int i = 0 ; i < g . n ; i ++ ) { if ( match [ i ] == -1 ) { bfs ( i ); } } return match ; } } using namespace Blossom_Algorithm ; int n , m ; int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ), cout . tie ( 0 ); cin >> n >> m ; undirectedgraph < int > G ( n ); for ( int i = 1 ; i <= m ; i ++ ) { int x , y ; cin >> x >> y ; G . add ( x -1 , y -1 ); //\u65e0\u5411\u8fb9\uff0c\u4e0d\u9700\u8981\u52a0\u4e24\u6b21 } auto res = find_max_unweighted_matching ( G ); int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( res [ i ] != -1 ) { ans ++ ; } } cout << ans / 2 << '\\n' ; for ( int i = 0 ; i < n ; i ++ ) { cout << (( res [ i ] == -1 ) ? 0 : ( res [ i ] + 1 )) << ' ' ; } return 0 ; }","title":"\u5e26\u82b1\u6811\u5339\u914d"},{"location":"old/%E8%87%AA%E5%88%B6Template/#_43","text":"","title":"\u6742\u9879"},{"location":"old/%E8%87%AA%E5%88%B6Template/#_44","text":"Funs || Methods Reliance Time Complexity Inputs Outputs Description copy_to_b N a\uff1a\u6570\u7ec4 b \u590d\u5236a\u5230b sort_and_unique copy_to_b nlogn n\uff1a\u957f\u5ea6\uff1bb\uff1a\u79bb\u6563\u5316\u540e\u6570\u7ec4 dlen\uff1a\u53bb\u91cd\u540e\u7684\u6570\u7ec4\u957f\u5ea6 \u5bf9b\u6392\u5e8f\u3001\u53bb\u91cd\uff0c\u8fd4\u56de\u53bb\u91cd\u540e\u7684\u6570\u7ec4\u957f\u5ea6 get_id sort_and_unique logn x:\u67e5\u627e\u503c\uff1bb\uff1a\u79bb\u6563\u5316\u540e\u6570\u7ec4\uff1b \u8fd4\u56de\u79bb\u6563\u5316\u540e\u7684\u503c \u8fd4\u56de\u79bb\u6563\u5316\u540e\u7684\u503c\uff081\u5f00\u59cb\u8ba1\u6570\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 typedef long long ll ; namespace Discretization { const int N = 1e6 + 10 ; typedef ll Ty ; //public Ty a [ N ], b [ N ]; int dlen ; // \u590d\u5236a\u5230b void copy_to_b () { memcpy ( b , a , sizeof ( a )); } // \u5bf9b\u6392\u5e8f\u3001\u53bb\u91cd\uff0c\u8fd4\u56de\u53bb\u91cd\u540e\u7684\u6570\u7ec4\u957f\u5ea6 int sort_and_unique ( int n ) { sort ( b + 1 , b + 1 + n ); return dlen = unique ( b + 1 , b + 1 + n ) - b -1 ; } // \u8fd4\u56de\u79bb\u6563\u5316\u540e\u7684\u503c\uff081\u5f00\u59cb\u8ba1\u6570\uff09 inline int get_id ( Ty x ) { return lower_bound ( b + 1 , b + 1 + dlen , x ) - b ; } } using namespace Discretization ;","title":"\u79bb\u6563\u5316"},{"location":"old/%E8%87%AA%E5%88%B6Template/#_45","text":"\u6ce8\u610f\uff1a\u7528\u5feb\u8bfb\u7684\u65f6\u5019\u52a1\u5fc5\u8981\u628a ios::sync_with_stdio(false); \u6ce8\u91ca\u6389\uff01 Funs || Methods Reliance Time Complexity Inputs Outputs Description read 1 \u6574\u6570\u53d8\u91cfx \u8bfb\u5165x \u8bfb\u5165x print 1 \u6574\u6570\u53d8\u91cfx \u8f93\u51fax\uff08\u4e0d\u5305\u62ec\u6362\u884c\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 #include <cstdio> #include <iostream> using namespace std ; namespace Fast_IO { char __nc () { static char buf [ 1000000 ], * p = buf , * q = buf ; return p == q && ( q = ( p = buf ) + fread ( buf , 1 , 1000000 , stdin ), p == q ) ? EOF : * p ++ ; } template < typename T > inline void read ( T & x ) { char c ; int sgn = 1 ; x = 0 ; c = __nc (); while ( c > '9' || c < '0' ) { if ( c == '-' ) sgn = -1 ; c = __nc (); } while ( c <= '9' && c >= '0' ) { x = ( x << 3 ) + ( x << 1 ) + ( c - '0' ); c = __nc (); } x *= sgn ; } template < typename T > inline void print ( T x ) { if ( x < 0 ) { putchar ( '-' ); x = - x ; } if ( x > 9 ) { print ( x / 10 ); } putchar ( x % 10 + '0' ); } void readstr ( char * a ) { char c ; c = __nc (); while ( ! ( c <= 'z' && c >= 'a' )) c = __nc (); while ( c <= 'z' && c >= 'a' ) { * a = c ; a ++ ; c = __nc (); } } } // namespace Fast_IO using namespace Fast_IO ; int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ), cout . tie ( 0 ); long long x ; read ( x ); print ( x ); putchar ( '\\n' ); print ( - x ); putchar ( '\\n' ); print ( 0 ); putchar ( '\\n' ); return 0 ; }","title":"\u5feb\u8bfb"},{"location":"old/%E8%87%AA%E5%88%B6Template/#nth_element","text":"1 nth_element ( a + 1 , a + k , a + n + 1 ); #include <algorithm> \u5185\u7f6e\u51fd\u6570\u3002\u7b2ck\u540d\u5c06\u5728a[k]\u5904\uff0c\u6bd4\u5b83\u5c0f\u7684\u6240\u6709\u5143\u7d20\u5728\u5de6\u4fa7\uff0c\u6bd4\u4ed6\u5927\u7684\u6240\u6709\u5143\u7d20\u5728\u53f3\u4fa7\u3002","title":"nth_element"},{"location":"old/%E8%87%AA%E5%88%B6Template/#_46","text":"\u53ea\u662f\u8bb0\u4e00\u4e0b\uff0c\u4e00\u822c\u4e0d\u4f1a\u771f\u7684\u624b\u5199\u3002\u5305\u62ec\u4e00\u822c\u7684lowerbound\u548c\u53cd\u8fc7\u6765\u7248\u672c\u7684lowerbound\u3002\u6539\u6210upperbound\uff0c\u5219\u53ea\u9700\u8981\u6539\u4e00\u4e0b\u5224\u65ad\u5408\u6cd5\u6027\u7684\u6761\u4ef6\u3002\u8bf7\u52a1\u5fc5\u4fdd\u8bc1\u7b54\u6848\u5728l\u3001r\u5185\u5b58\u5728\u3002 \u53e3\u8bc0\uff1a\u4ee5o\u4e3a\u6b63\u65b9\u5411\uff0c\u53cd\u5411\u53d6\u6574\uff0c\u201c\u5426\u5219\u201d\u53cd\u5411+\u8d21\u732e\uff0c\u201c\u8d21\u732e\u201d\u6b63\u5411\u3002 Funs || Methods Reliance Time Complexity Inputs Outputs Description bs_lowerbound logn L\u3001R\uff1a\u641c\u7d22\u4e0b\u6807\u8303\u56f4\uff0ca\uff1a\u641c\u7d22\u5e8f\u5217\uff0cx\uff1a\u6bd4\u8f83\u503c \u540c\u63cf\u8ff0 \u627e\u5230\u5e8f\u5217a\u4e2d\u5728\u8303\u56f4\u5185\u7684>=x\u6700\u5c0f\u7684\u4e00\u4e2a\uff0c\u5e76\u8fd4\u56de\u5176\u503c bs_lowerbound2 logn L\u3001R\uff1a\u641c\u7d22\u4e0b\u6807\u8303\u56f4\uff0ca\uff1a\u641c\u7d22\u5e8f\u5217\uff0cx\uff1a\u6bd4\u8f83\u503c \u540c\u63cf\u8ff0 \u627e\u5230\u5e8f\u5217a\u4e2d\u5728\u8303\u56f4\u5185\u7684<= x\u6700\u5927\u7684\u4e00\u4e2a\uff0c\u5e76\u8fd4\u56de\u5176\u503c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 namespace BS { //\u627e\u5230>=x\u4e2d\u6700\u5c0f\u7684\u4e00\u4e2a template < typename T > T bs_lowerbound ( T L , T R , T a [], T x ) { T l = L , r = R ; //\u5de6x\u53f3o\uff1a\u5411\u4e0b\u53d6\u6574\uff0c\u201c\u5426\u5219\u201d\u4e3a\u5de6\uff0c+1\uff08\u5411\u53f3\uff09 while ( l < r ) { T mid = ( l + r ) >> 1 ; //\u6ce8\u610f\u8fd9\u6837\u5199\u662f\u5411\u4e0b\u53d6\u6574\uff0c\u7528\u9664\u6cd5\u662f\u54110\u53d6\u6574\uff0cl\u548cr\u4e3a\u8d1f\u6570\u65f6\u53ef\u80fd\u6709\u5f71\u54cd if ( a [ mid ] >= x ) r = mid ; else l = mid + 1 ; } return a [ l ]; } //\u627e\u5230<=x\u4e2d\u6700\u5927\u7684\u4e00\u4e2a template < typename T > T bs_lowerbound2 ( T L , T R , T a [], T x ) { T l = L , r = R ; while ( l < r ) { T mid = ( l + r + 1 ) >> 1 ; //\u6ce8\u610f\u8fd9\u6837\u5199\u662f\u5411\u4e0b\u53d6\u6574\uff0c\u7528\u9664\u6cd5\u662f\u54110\u53d6\u6574\uff0cl\u548cr\u4e3a\u8d1f\u6570\u65f6\u53ef\u80fd\u6709\u5f71\u54cd if ( a [ mid ] <= x ) l = mid ; else r = mid -1 ; } return a [ l ]; } }","title":"\u4e8c\u5206"},{"location":"old/%E8%87%AA%E5%88%B6Template/#_47","text":"\u8fd9\u662f\u627e\u6700\u5c0f\u503c\u7684\u8fde\u7eed\u503c\u57df\u4e09\u5206\u3002\u5207\u8bb0\u4e0d\u80fd\u76f4\u63a5\u7528\u4e8e\u79bb\u6563\u503c\uff01\uff08\u9664\u975e\u9898\u76ee\u6709\u4efb\u4f55\u6027\u8d28\u4fdd\u8bc1\u4e86\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 namespace TS { template < typename T = double > T ts_findmin ( T l , T r , T ( * f )( T ), T eps = 1e-9 ) { //r>l T param = 0.01 ; while ( r - l >= eps ) { T mid = ( l + r ) / 2 ; T lmid = mid - ( r - l ) * param , rmid = mid + ( r - l ) * param ; if ( f ( lmid ) > f ( rmid )) { l = lmid ; } else r = rmid ; } return f ( r ); } } double f ( double x ) { return x * x ; } int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ), cout . tie ( 0 ); cout << TS :: ts_findmin ( -2.0 , 5.0 , f ) << endl ; return 0 ; }","title":"\u4e09\u5206"},{"location":"old/%E8%87%AA%E5%88%B6Template/#int128","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include <iostream> #include <cstdio> using namespace std ; void scan ( __int128_t & x ) //\u8f93\u5165 { x = 0 ; int f = 1 ; char ch ; if (( ch = getchar ()) == '-' ) f = - f ; else x = x * 10 + ch - '0' ; while (( ch = getchar ()) >= '0' && ch <= '9' ) x = x * 10 + ch - '0' ; x *= f ; } void print ( __int128_t x ) { if ( x < 0 ) { x = - x ; putchar ( '-' ); } if ( x > 9 ) print ( x / 10 ); putchar ( x % 10 + '0' ); } int main () { ios :: sync_with_stdio ( false ); __int128_t a , b ; scan ( a ); scan ( b ); print ( a + b ); return 0 ; }","title":"int128"},{"location":"old/%E8%87%AA%E5%88%B6Template/#_48","text":"\u6ce8\u610f\u8fd9\u4e2a\u9b3c\u4e1c\u897f\u5728\u5bf90\u7684\u5224\u65ad\u4e0a\u53ef\u80fd\u6709\u70b9\u95ee\u9898 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 ll gcd ( ll a , ll b ) { return b ? gcd ( b , a % b ) : a ; } struct Fr { ll x , y ; Fr ( ll xx , ll yy ) { if ( yy == 0 ) { x = xx ; y = yy ; return ; } ll g = gcd ( xx , yy ); x = xx / g ; y = yy / g ; } Fr () : x ( 0 ), y ( 1 ) {} Fr ( ll x ) : x ( x ), y ( 1 ) {} bool operator < ( const Fr & a ) const { if ( a == Fr ( 0 , 0 )) { if ( x == 0 && y == 0 ) return false ; return true ; } if ( x == 0 && y == 0 ) { return false ; } return x * a . y < y * a . x ; } bool operator > ( const Fr & a ) const { if ( a == Fr ( 0 , 0 )) { //if(x==0 && y==0) return false; return false ; } if ( x == 0 && y == 0 ) { return true ; } return x * a . y > y * a . x ; } bool operator == ( const Fr & a ) const { if ( a . x == 0 && a . y == 0 ) { if ( x == 0 && y == 0 ) return true ; return false ; } if ( x == 0 && y == 0 ) { if ( a . x == 0 && a . y == 0 ) return true ; return false ; } return x * a . y == y * a . x ; } Fr operator + ( const Fr & a ) const { return Fr ( x * a . y + y * a . x , y * a . y ); } Fr operator - ( const Fr & a ) const { return Fr ( x * a . y - y * a . x , y * a . y ); } Fr operator * ( const Fr & a ) const { return Fr ( x * a . x , y * a . y ); } Fr operator / ( const Fr & a ) const { return Fr ( x * a . y , y * a . x ); } bool is_frac () const { if ( y == 0 ) return false ; return x % y != 0 ; } };","title":"\u2b50\u5206\u6570\u7c7b"},{"location":"old/%E8%87%AA%E5%88%B6Template/#_49","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <cstdlib> #include <algorithm> #include <string> #include <vector> #include <map> #include <unordered_map> #include <set> #include <unordered_set> #include <queue> using namespace std ; typedef long long ll ; const int N = 2e5 + 10 ; int T ; int m ; ll a1 [ N ], a2 [ N ], b [ N ]; pair < double , double > get_kb ( ll a [], ll b [], ll n ) { ll x = 0 , y = 0 , xy = 0 , x2 = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { x += a [ i ]; y += b [ i ]; xy += a [ i ] * b [ i ]; x2 += a [ i ] * a [ i ]; } double k = ( n * xy - x * y ) / ( n * x2 - x * x ); double bb = ( y * x2 - x * xy ) / ( n * x2 - x * x ); return { k , bb }; } int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ), cout . tie ( 0 ); cin >> T ; for ( int _ = 1 ; _ <= T ; _ ++ ) { scanf ( \"%d\" , & m ); for ( int i = 1 ; i <= m ; i ++ ) { scanf ( \"%lld\" , & a1 [ i ]); } for ( int i = 1 ; i <= m ; i ++ ) { scanf ( \"%lld\" , & a2 [ i ]); } for ( int i = 1 ; i <= m ; i ++ ) { scanf ( \"%lld\" , & b [ i ]); } double k1 , b1 , k2 , b2 ; tie ( k1 , b1 ) = get_kb ( a1 , b , m ); tie ( k2 , b2 ) = get_kb ( a2 , b , m ); double ans1 = 0 , ans2 = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { ans1 += fabs ( b [ i ] - ( k1 * a1 [ i ] + b1 )); ans2 += fabs ( b [ i ] - ( k2 * a2 [ i ] + b2 )); } if ( ans1 > ans2 ) { printf ( \"2 \\n \" ); } else printf ( \"1 \\n \" ); } return 0 ; }","title":"\u6700\u5c0f\u4e8c\u4e58\u6cd5"},{"location":"old/%E8%87%AA%E5%88%B6Template/#gospers_hack","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <cstdlib> #include <algorithm> #include <string> #include <vector> #include <map> #include <unordered_map> #include <set> #include <unordered_set> #include <queue> using namespace std ; typedef long long ll ; const int N = 2e5 + 10 ; //\u904d\u5386n\u4e2d\u9009k\u4e2a\u7684\u6240\u6709\u96c6\u5408 //GH(3,5): 00111,01011,...,11100 auto GospersHack ( int k , int n ) { int cur = ( 1 << k ) - 1 ; int limit = ( 1 << n ); vector < int > res ; while ( cur < limit ) { res . push_back ( cur ); // do something int lb = cur & - cur ; int r = cur + lb ; cur = (( r ^ cur ) >> __builtin_ctz ( lb ) + 2 ) | r ; // \u6216\uff1acur = (((r ^ cur) >> 2) / lb) | r; } return res ; } //\u679a\u4e3e\u5b50\u96c6 void it_subset ( int sta ) { for ( int sub = sta ; sub > 0 ; sub = ( sub - 1 ) & sta ) { //do something... } //bit:sta\u7684\u4e8c\u8fdb\u5236\u4e0b\u4f4d\u6570-1\uff0c\u76f8\u5f53\u4e8e\u5bf92\u53d6log int bit = 31 - __builtin_clz ( sta ); //\u53d6\u5f97\u5b50\u96c6\u548c\uff08\u4e0b\u6807\u4ece0\u5f00\u59cb\u8ba1\u6570\uff09\uff1a\u4f8b\u59821101\u8868\u793a\u4e0b\u6807\u4e3a0\u30012\u30013\u7684\u5143\u7d20\u7684\u548c for ( int sta = 1 ; sta < ( 1 << n ); ++ sta ) { //__builtin_clz : \u4e8c\u8fdb\u5236\u524d\u5bfc\u96f6\u4e2a\u6570 //bit\uff1a\u5728\u8fd9\u91cc\u662f\u76f8\u5f53\u4e8e\u5bf92\u53d6log\u7684\u7ed3\u679c int bit = 31 - __builtin_clz ( sta ); f [ sta ] = add ( f [ sta ^ ( 1 << bit )], a [ bit ]); } } // \u2022int __builtin_ffs (unsigned int x) // \u8fd4\u56dex\u7684\u6700\u540e\u4e00\u4f4d1\u7684\u662f\u4ece\u540e\u5411\u524d\u7b2c\u51e0\u4f4d\uff0c\u6bd4\u59827368\uff081110011001000\uff09\u8fd4\u56de4\u3002 // \u2022int __builtin_clz (unsigned int x) // \u8fd4\u56de\u524d\u5bfc\u76840\u7684\u4e2a\u6570\u3002\uff08int 1\u7684\u8fd4\u56de\u503c\u662f31\uff0c2\u30013\u662f30\uff0c4~7\u662f29\uff09 // \u2022int __builtin_ctz (unsigned int x) // \u8fd4\u56de\u540e\u9762\u76840\u4e2a\u4e2a\u6570\uff0c\u548c__builtin_clz\u76f8\u5bf9\u3002 // \u2022int __builtin_popcount (unsigned int x) // \u8fd4\u56de\u4e8c\u8fdb\u5236\u8868\u793a\u4e2d1\u7684\u4e2a\u6570\u3002 // \u2022int __builtin_parity (unsigned int x) // \u8fd4\u56dex\u7684\u5947\u5076\u6821\u9a8c\u4f4d\uff0c\u4e5f\u5c31\u662fx\u76841\u7684\u4e2a\u6570\u6a212\u7684\u7ed3\u679c\u3002 // \u6b64\u5916\uff0c\u8fd9\u4e9b\u51fd\u6570\u90fd\u6709\u76f8\u5e94\u7684usigned long\u548cusigned long long\u7248\u672c\uff0c\u53ea\u9700\u8981\u5728\u51fd\u6570\u540d\u540e\u9762\u52a0\u4e0al\u6216ll\u5c31\u53ef\u4ee5\u4e86\uff0c\u6bd4\u5982int __builtin_clzll\u3002 int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ), cout . tie ( 0 ); auto res = GospersHack ( 3 , 5 ); for ( auto v : res ) cout << v << \" \" ; return 0 ; }","title":"\u5b50\u96c6\u679a\u4e3e\u4e0egospers_hack"},{"location":"old/%E8%87%AA%E5%88%B6Template/#_50","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 import os import random as rd import sys import time def generate_one_case () : n = rd . randint ( 1 , 30 ) k = rd . randint ( 1 , n ) print ( n , k ) for i in range ( n ) : val = rd . randint ( 1 , 50 ) print ( val , end = ' ' ) print () def generate_multi_case () : T = rd . randint ( 1 , 10 ) print ( T ) for i in range ( T ) : generate_one_case () print ( flush = True ) namae = \"k\" for _ in range ( 10000 ) : sys . stdout = open ( f \"{namae}_in.txt\" , \"w\" ) generate_multi_case () t1 = time . perf_counter () os . system ( f \"{namae}.exe < {namae}_in.txt >{namae}_out.txt\" ) t2 = time . perf_counter () print (( t2 - t1 ) * 1000 , file = sys . stderr ) t1 = time . perf_counter () os . system ( f \"{namae}_std.exe < {namae}_in.txt >{namae}2_out.txt\" ) t2 = time . perf_counter () print (( t2 - t1 ) * 1000 , file = sys . stderr ) if os . system ( f \"fc {namae}_out.txt {namae}2_out.txt\" ) : print ( \"WA\" , file = sys . stderr ) exit ( 0 ) print ( \"AC\" , file = sys . stderr )","title":"\u5bf9\u62cd"},{"location":"old/%E8%87%AA%E5%88%B6Template/#_51","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 //P1337 [JSOI2004]\u5e73\u8861\u70b9 / \u540a\u6253XXX // \u6c42n\u4e2a\u70b9\u7684\u5e26\u6743\u91cd\u5fc3\uff0c\u7b49\u4ef7\u4e8e\u6700\u5c0f\u5316\u67d0\u4e2a\u51fd\u6570\u503c #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <cstdlib> #include <algorithm> #include <string> #include <vector> #include <map> #include <unordered_map> #include <set> #include <unordered_set> #include <queue> #include <ctime> #include <random> #include <iomanip> using namespace std ; typedef long long ll ; const int N = 2e5 + 10 ; using ll = long long ; using ld = long double ; int n ; struct Point { ld x , y , w ; } a [ N ]; namespace Anneal { //do something... //public ld ansx , ansy , ansval ; ld nowx , nowy , nowval ; //ansx,ansy,ansval:\u5f53\u524d\u7ef4\u62a4\u7684\u6700\u597d\u7b54\u6848\uff0c\u56e0\u9898\u800c\u5f02 //nowx,nowy,nowval\uff1a\u5f53\u524d\u7684\u7b54\u6848\uff0c\u540c\u4e0a\uff0c\u56e0\u9898\u800c\u5f02 //do something end. //local ld t , tt ; ld D ; ld eps ; mt19937 rnd ( time ( 0 )); //t\uff1a\u6e29\u5ea6 //d\uff1a\u5355\u6b21\u964d\u6e29\u6bd4\u4f8b //eps\uff1a\u6700\u5927\u7cbe\u5ea6\u8bef\u5dee //rnd\uff1a\u968f\u673a\u6570\u751f\u6210\u5668 //\u751f\u6210\u968f\u673a\u6d6e\u70b9\u6570 inline ld __Rand () { return ( ld ) rand () / RAND_MAX ; } //\u751f\u6210\u968f\u673a\u6574\u6570 inline int __randint ( int r ) { return rnd () % r + 1 ; } //\u8ba1\u7b97\u8861\u91cf\u7528\u51fd\u6570\u503c ld calval ( ld x , ld y ) { //do something... ld ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { ld dx = a [ i ]. x - x , dy = a [ i ]. y - y ; ans += a [ i ]. w * sqrt ( dx * dx + dy * dy ); } return ans ; //do something end. } //\u968f\u673a\u6539\u53d8\u503c void rand_change () { //do something... ld nextx = nowx + t * ( __Rand () * 2-1 ); ld nexty = nowy + t * ( __Rand () * 2-1 ); ld delta = calval ( nextx , nexty ) - nowval ; //\u80fd\u91cf\u5dee\u503c //\u91cd\u8981\u516c\u5f0f\uff1a\u53d1\u751f\u8f6c\u79fb\u7684\u51e0\u7387P(delta E)=e^(-delta E/T) \uff08\u65b0\u72b6\u6001\u66f4\u52a3\u65f6\uff09 if ( delta < 0 || exp ( - delta / t ) > __Rand ()) // if( exp(-delta/t) > __Rand()) { ld tmp = nowval + delta ; tie ( nowx , nowy , nowval ) = tie ( nextx , nexty , tmp ); } if ( nowval < ansval ) { tie ( ansx , ansy , ansval ) = tie ( nowx , nowy , nowval ); } //do something end. } int __cnt = 0 ; auto anneal () { //init tt = t = 100000 ; D = 0.97 ; eps = 0.001 ; srand ( time ( 0 )); //do something... //init2 ansx = nowx = ansy = nowy = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { ansx += a [ i ]. x ; ansy += a [ i ]. y ; } ansx /= n ; ansy /= n ; // ansx=0.577; // ansy=1.000; ansval = calval ( ansx , ansy ); nowx = ansx ; nowy = ansy ; nowval = ansval ; // cerr<<\"init_ansx:\"<<ansx<<endl; // cerr<<\"init_ansy:\"<<ansy<<endl; // cerr<<\"init_ansval:\"<<ansval<<endl; while ( t >= eps ) { rand_change (); t *= D ; __cnt ++ ; } //do something end. // cerr<<\"__cnt:\"<<__cnt<<endl; // cerr<<\"nowval:\"<<nowval<<endl; // cerr<<\"ansval:\"<<ansval<<endl; //\u7ec6\u5316\u7cbe\u5ea6\uff0c\u5bf9\u4e8e\u8fd9\u9898\u6765\u8bf4\u662f\u5fc5\u8981\u7684 for ( int i = 1 ; i <= 3000 ; i ++ ) { ld nextx = ansx + t * ( __Rand () * 2-1 ); ld nexty = ansy + t * ( __Rand () * 2-1 ); ld delta = calval ( nextx , nexty ) - ansval ; //\u80fd\u91cf\u5dee\u503c if ( delta < 0 ) { ld tmp = ansval + delta ; tie ( ansx , ansy , ansval ) = tie ( nextx , nexty , tmp ); } } return make_pair ( ansx , ansy ); } } using namespace Anneal ; int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ), cout . tie ( 0 ); cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> a [ i ]. x >> a [ i ]. y >> a [ i ]. w ; } anneal (); cout << fixed << setprecision ( 3 ) << ansx << \" \" << ansy << endl ; // cout<<ansx<<\" \"<<ansy<<endl; return 0 ; }","title":"\u6a21\u62df\u9000\u706b"},{"location":"old/%E8%87%AA%E5%88%B6Template/#in-c","text":"\u81e8\u6642\u5f9e Algorithm_Design_and_other/pattern_recognition/classify.cpp\u88e1\u9762\u6284\u7684 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 //\u5b9e\u7528\u7c7b\u51fd\u6570 namespace __Utility { //\u975e\u6570\u636e\u7279\u5f81\u540d unordered_set < string > No_data_strings_name { \"Id\" , \"Species\" }; //\u975e\u6570\u636e\u7279\u5f81\u4f4d\u7f6e\u5bf9\u5e94\u7684\u540d\u5b57 unordered_map < int , string > No_data_strings { { 0 , \"Id\" }, { 5 , \"Species\" } }; //\u5206\u5272\u5b57\u7b26\u4e32 auto split_str ( const string & s , char split_char = ',' ) { vector < string > res ; //lambda auto string_find_first_not = []( const string & s , size_t pos = 0 , char split_char = ',' ) { for ( size_t i = pos ; i < s . size (); i ++ ) { if ( s [ i ] != split_char && s [ i ] != ' ' && s [ i ] != '\\t' ) return i ; } return string :: npos ; }; size_t begin_pos = string_find_first_not ( s , 0 , split_char ); size_t end_pos = s . find ( split_char , begin_pos ); while ( begin_pos != string :: npos ) { size_t end_pos2 = end_pos -1 ; while ( begin_pos < end_pos2 && ( s [ end_pos2 ] == '\\t' || s [ end_pos2 ] == ' ' )) { end_pos2 -- ; } res . emplace_back ( s . substr ( begin_pos , end_pos2 + 1 - begin_pos )); begin_pos = string_find_first_not ( s , end_pos , split_char ); end_pos = s . find ( split_char , begin_pos ); } return res ; } //\u5b57\u7b26\u4e32\u8f6cdouble double str_to_double ( const string & s ) { return atof ( s . c_str ()); } //\u5b57\u7b26\u4e32\u8f6cint int str_to_int ( const string & s ) { return atoi ( s . c_str ()); } } // namespace __Utility","title":"\u2b50\u5206\u9694\u5b57\u7b26\u4e32 in C++"},{"location":"old/%E8%87%AA%E5%88%B6Template/#_52","text":"Luogu 1484 \u79cd\u6811 \u9898\u610f\uff1a\u6709N\u4e2a\u5751\uff0c\u6bcf\u4e2a\u5751\u53ef\u4ee5\u79cd\u6811\uff0c\u4e14\u83b7\u5229a[i]\uff08\u53ef\u4ee5\u4e3a\u8d1f\uff09\u3002\u4efb\u4f55\u76f8\u90bb\u4e24\u4e2a\u5751\u91cc\u4e0d\u80fd\u90fd\u79cd\u6811\uff0c\u95ee\u5728\u6700\u591a\u79cdK\u68f5\u6811\u7684\u524d\u63d0\u4e0b\u7684\u6700\u5927\u83b7\u5229 \u505a\u6cd5\uff1a\u6bcf\u4e2a\u8282\u70b9\u5f00\u4e2a\u94fe\u8868\uff0c\u79cd\u6811\u4ee5\u540e\u5408\u5e76\u94fe\u8868\u4e24\u7aef\u8282\u70b9\uff0c\u7136\u540e\u63d2\u5165\u4f18\u5148\u961f\u5217\u4e2d\u7ef4\u62a4\u3002\u6bcf\u6b21\u8981\u79cd\u54ea\u68f5\u6811\u7531\u4f18\u5148\u961f\u5217\u4e2d\u7684\u961f\u5934\u8282\u70b9\u786e\u5b9a\u3002 \u8fd9\u4e48\u505a\u53ef\u4ee5\u4fdd\u8bc1\u6bcf\u6b21\u90fd\u53ea\u591a\u79cd\u4e00\u68f5\u6811\uff08\u76f8\u5f53\u4e8e\u53ea\u82b1\u8d391\u7684\u4ee3\u4ef7\uff09\uff0c\u5e76\u4e14\u5f97\u5230\u7684\u8d21\u732e\u5c31\u662f\u4e2d\u5bf9\u5e94\u8fd9\u4e48\u591a\u6570\u7684\u6700\u5927\u503c\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <cstdlib> #include <algorithm> #include <queue> using namespace std ; typedef long long ll ; const int N = 2e6 + 10 ; int T ; ll n , k ; struct Node { ll val ; ll lc , rc , ct ; //ct: center bool operator < ( const Node & b ) const { return val < b . val ; } } nd [ N ]; bool vis [ N ]; void dpdp () { priority_queue < Node > q ; for ( int i = 1 ; i <= n ; i ++ ) { q . push ( nd [ i ]); } ll ans = 0 ; bool flag = true ; while ( k -- ) { while ( vis [ q . top (). ct ]) { q . pop (); } auto u = q . top (); auto index = u . ct ; if ( u . val <= 0 ) { flag = false ; break ;} //\u5982\u679c\u662f\u4e00\u5b9a\u8981\u79cd\u90a3\u4e48\u591a\u6570\u5c31\u8bf7\u53bb\u6389\u8fd9\u4e2a ans += u . val ; q . pop (); // merge node nd [ index ]. val = nd [ nd [ index ]. lc ]. val + nd [ nd [ index ]. rc ]. val - nd [ index ]. val ; //list merge vis [ nd [ index ]. lc ] = vis [ nd [ index ]. rc ] = 1 ; nd [ index ]. lc = nd [ nd [ index ]. lc ]. lc ; nd [ nd [ index ]. lc ]. rc = index ; nd [ index ]. rc = nd [ nd [ index ]. rc ]. rc ; nd [ nd [ index ]. rc ]. lc = index ; q . push ( nd [ index ]); } if ( true ) { cout << ans << endl ; } else { cout << \"Error!\" << endl ; } } int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ), cout . tie ( 0 ); cin >> n >> k ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> nd [ i ]. val ; nd [ i ]. lc = i -1 ; nd [ i ]. rc = i + 1 ; nd [ i ]. ct = i ; vis [ i ] = 0 ; } // nd[1].lc=n; \u6709\u73af\u7684\u60c5\u51b5\uff08\u5bf9\u5e94luogu 1792\uff09 // nd[n].rc=1; dpdp (); return 0 ; }","title":"\u53ef\u53cd\u6094\u8d2a\u5fc3"},{"location":"old/%E8%87%AA%E5%88%B6Template/#2021icpc","text":"\u95ee\u9898\uff1an\u4e2a\u6709\u5e8f\u5bf9ai,bi\uff0c\u5bf9\u4e8e\u6bcf\u4e2a\u6709\u5e8f\u5bf9\uff0c\u9009\u62e9\u5c06ai\u52a0\u5165set A\u6216\u8005\u5c06bi\u52a0\u5165set B\uff0c\u6700\u5c0f\u5316max(A)+max(B)\uff0c\uff08\u7a7a\u96c6\u65f6\u4e3a0\uff09 \u89e3\u6cd5\uff1a \u5148\u5c06\u6709\u5e8f\u5bf9\u6309ai\u4e3a\u7b2c\u4e00\u5173\u952e\u5b57\u6392\u5e8f\u3002\u7531\u4e8eai<=aj && bi<=bj\u65f6\uff0c \u53ef\u4ee5\u820d\u5f03ai,bi\uff08\u8fd9\u662f\u56e0\u4e3a\u8f83\u5927\u7684\u90a3\u4e2a\u5728\u6700\u4f18\u89e3\u4e2d\u4e00\u5b9a\u4f1a\u5728aj,bj\u4e2d\u9009\u4e00\u4e2a\uff0c\u800c\u6b64\u65f6ai,bi\u7684\u9009\u6cd5\u53ea\u8981\u8ddfaj,bj\u7684\u9009\u6cd5\u5c31\u4e00\u5b9a\u4e0d\u4f1a\u4f7f\u5f97\u7b54\u6848\u589e\u5927\uff09\uff0c\u56e0\u6b64\u9700\u8981\u4fdd\u8bc1\u5904\u7406\u540e\u7684\u5e8f\u5217\u4e2d\uff0cbi\u968fi\u5355\u8c03\u9012\u51cf\uff0c\u56e0\u6b64\u5012\u7740\u626b\u4e00\u904d\u5220\u9664\u7834\u574fbi\u5355\u8c03\u6027\u7684\u5143\u7d20\u5373\u53ef\u3002\u5177\u4f53\u5b9e\u73b0\u65f6\u4e0d\u662f\u771f\u7684\u5220\u9664\u800c\u662f\u65b0\u5f00\u4e00\u4e2a\u5217\u8868\u505a\u8fd9\u4e2a\u64cd\u4f5c\u3002 \u4e4b\u540e\uff0c\u5bf9\u4e8e\u67d0\u4e2aaj\uff0c\u53ea\u8981\u786e\u5b9a\u9009\u4e86j\uff0c\u90a3\u4e48\u6240\u6709\u6bd4j\u5927\u7684i\u90fd\u53ef\u4ee5\u5728\u4e0d\u589e\u52a0\u7b54\u6848\u7684\u524d\u63d0\u4e0b\u9009\u62e9ai\uff0cbj\u540c\u7406\u53ef\u4ee5\u5728\u4e0d\u589e\u52a0\u7b54\u6848\u7684\u524d\u63d0\u4e0b\u9009\u62e9\u6bd4j\u5c0f\u7684i\uff0c\u56e0\u6b64\u6700\u7ec8\u7b54\u6848\u51fa\u73b0\u5728 a1, a2+b1, a3+b2, ... , an+b_{n-1}, bn\u4e2d\u3002\u626b\u63cf\u4e00\u904d\u5373\u53ef\u5f97\u7b54\u6848\u3002","title":"\u7ecf\u5178\u4e8c\u9009\u4e00\u95ee\u9898\uff082021icpc\u4e0a\u6d77\u7684\u67d0\u9898\uff09"},{"location":"old/%E8%87%AA%E5%88%B6Template/#cf1408-d-searchlights","text":"\u9898\u610f\uff1a\u6709\u82e5\u5e72\u4e2a\u5f3a\u76d7\u548c\u63a2\u7167\u706f\uff0c\u7ed9\u51fa\u4ed6\u4eec\u7684\u5750\u6807\uff080\u52301e6\u8303\u56f4\u5185\uff09\uff0c\u706f\u80fd\u770b\u5230\u5f3a\u76d7\u5f53\u4e14\u4ec5\u5f53\u706f\u4e0d\u4e25\u683c\u5728\u5f3a\u76d7\u7684\u53f3\u4e0a\u65b9\u3002\u73b0\u5728\u80fd\u4e00\u6b21\u6027\u79fb\u52a8\u6240\u6709\u7684\u5f3a\u76d7\u5411\u4e0a\u6216\u5411\u53f3\u4e00\u6b65\uff0c\u95ee\u6700\u5c11\u9700\u8981\u591a\u5c11\u6b65\u6570\u624d\u80fd\u628a\u5f3a\u76d7\u5168\u90e8\u79fb\u51fa\u53bb\u3002 \u89e3\u6cd5\uff1a\u7b97\u51fa\u6bcf\u4e2a\u5f3a\u76d7\u5411\u4e0a\u548c\u5411\u53f3\u8d70\u6240\u9700\u7684\u6b65\u6570\u3002\u9898\u76ee\u5c31\u53d8\u6210\u4e86\u6700\u5c0f\u5316\u6700\u5927\u503c\u3002\u5957\u7528\u5373\u53ef\u3002 \uff08\u4e0a\u6d77\u7684H\u9898\u7684\u505a\u6cd5\u53c2\u8003oi\u505a\u9898\u8bb0\u5f55\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 #include <iostream> #include <cstdio> #include <algorithm> #include <memory.h> using namespace std ; int T ; int n , k ; const int N = 2e5 + 10 ; int a [ N ], b [ N ]; pair < int , int > li [ N ], li2 [ N ]; int li_p , li_p2 ; long long upd ( int n ) { li_p2 = 0 ; sort ( li + 1 , li + 1 + n ); pair < int , int > last = li [ n ]; li2 [ ++ li_p2 ] = last ; for ( int i = n -1 ; i >= 1 ; i -- ) { if ( li [ i ]. second > last . second ) { li2 [ ++ li_p2 ] = li [ i ]; last = li [ i ]; } } long long ans = min ( li2 [ 1 ]. first , li2 [ li_p2 ]. second ); for ( int i = 2 ; i <= li_p2 ; i ++ ) { ans = min ( ans ,( long long ) li2 [ i ]. first + li2 [ i -1 ]. second ); } return ans ; } int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); cin >> T ; while ( T -- ) { cin >> n >> k ; for ( int i = 1 ; i <= k ; i ++ ) { cin >> a [ i ]; } for ( int i = 1 ; i <= k ; i ++ ) { cin >> b [ i ]; } sort ( a + 1 , a + 1 + k ); sort ( b + 1 , b + 1 + k ); long long ans = 1e18 ; for ( int i = 1 ; i <= k ; i ++ ) //enumerate first match who; { li_p = 0 ; for ( int j = 1 ; j <= k ; j ++ ) //match { int L , R ; //L L = (( b [( j + i -2 ) % k + 1 ] - a [ j ]) % n + n ) % n ; //\u6ce8\u610f\u4e0b\u6807\u8d8a\u754c R = (( a [ j ] - b [( j + i -2 ) % k + 1 ]) % n + n ) % n ; li [ ++ li_p ] = { 2 * L , R }; } ans = min ( ans , upd ( li_p )); li_p = 0 ; for ( int j = 1 ; j <= k ; j ++ ) //match { int L , R ; //L L = (( b [( j + i -2 ) % k + 1 ] - a [ j ]) % n + n ) % n ; R = (( a [ j ] - b [( j + i -2 ) % k + 1 ]) % n + n ) % n ; li [ ++ li_p ] = { L , R * 2 }; } ans = min ( ans , upd ( li_p )); } cout << ans << endl ; } return 0 ; }","title":"cf1408 D Searchlights"}]}